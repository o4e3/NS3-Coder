{
  "repo_name": "ERIGrid/ns3-fmi-export",
  "github_url": "https://github.com/ERIGrid/ns3-fmi-export",
  "readme": "[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.1934876.svg)](https://doi.org/10.5281/zenodo.1934876)\n\n# The ns-3 FMI Export Module\n\n## About\n\nModule **fmi-export** enables the FMI-compliant simulation coupling with ns-3 scripts, i.e., ns-3 script are launched and executed through an FMI-compliant co-simulation interface.\nIn terms of FMI terminology, ns-3 is the slave application, and generated FMUs launch ns-3 and synchronize its execution during runtime (tool coupling).\n\nModule **fmu-examples** provides examples for using the **fmi-export** module.\nThe module comprises dedicated models (clients and servers), helpers and simulation scripts implementing example applications, whose functionality is then exported as FMU for Co-Simulation.\nFurthermore, test applications (written in Python) show how the resulting FMUs can be used in a simulation.\n\n## Prerequisites and installation on Ubuntu 20.04\n\nFollow these instructions to install the **fmi-export** module:\n\n1. Install required dependencies:\n   ```\n   sudo apt install build-essential\n   sudo apt install cmake\n   sudo apt install unzip\n   sudo apt install libboost1.71-all-dev\n   ```\n\n2. This module relies on a lot of functionality provided by the FMI++ library.\n   Hence, in order to install this module, the latest version of the FMI++ library (commit [10b4dbe](https://github.com/fmipp/fmipp/tree/10b4dbe5162f37440b1c2b59aab080db92b6a7db)) should be cloned from its repository:\n   ```\n   git clone https://github.com/fmipp/fmipp.git\n   cd fmipp\n   git checkout 10b4dbe\n   cd ..\n   ```\n\n3. Get the [source code from GitHub](https://github.com/ERIGrid/ns3-fmi-export).\n   ```\n   git clone https://github.com/ERIGrid/ns3-fmi-export.git\n   ```\n\n4. Get the [ns-3 code](https://gitlab.com/nsnam/ns-3-dev) (tested with release version *ns-3.33*).\n   ```\n   git clone https://gitlab.com/nsnam/ns-3-dev.git\n   cd ns-3-dev\n   git checkout ns-3.33\n   ```\n\n5. From the source code, copy the *fmi-export* directory (and the *fmu-examples* directory if you want to include examples) to the *src* subdirectory of ns-3, i.e., the directory with all the other ns-3 modules.\n   ```\n   cp -R /path/to/cloned/ns3-fmi-export/fmi-export/ src/\n   cp -R /path/to/cloned/ns3-fmi-export/fmu-examples/ src/\n   ```\n\n6. Configure `waf` with the *--with-fmi-export* flag set to the previously cloned FMI++ library:\n   ```\n   ./waf configure --with-fmi-export=/path/to/cloned/fmipp\n   ```\n\n7. Build the module using `waf`:\n   ```\n   ./waf\n   ```\n\n8. If you want to run all the examples (see below for more information), you can run script ``run-tests.sh``:\n   ```\n   cd src/fmu-examples/examples\n   chmod +x run-tests.sh\n   ./run-tests.sh\n   ```\n\n## Prerequisites and installation in a Cygwin environment (Windows)\n\nns-3 is mainly developed for Linux, but it can also be installed on Windows in a 32-bit Cygwin environment.\nPlease refer to commit [122190b](https://github.com/ERIGrid/ns3-fmi-export/tree/122190be8c0f7915966bc7adf2ca8bcab4d73ca4) for details.\n\n## FMI-compliant ns-3 scripts\n\nns-3 scripts have to implement the abstract class *SimpleEventQueueFMUBase*.\nThis class provides a simple event queue that can be synchronized via an FMI-compliant interface.\nIncoming/outgoing messages are *associated with input/output variables*.\nWhenever a message is sent from a network node, the associated input variable is set to a non-zero integer value, referred to as *message ID*.\nWhen the same message is received at another network node, the associated output variable is set to the same message ID.\nThe sending/receiving of messages is simulated with individual ns-3 simulation runs, whose results are stored as events in the queue.\n\nTo define an FMI-compliant ns-3 script, a new class inheriting from *SimpleEventQueueFMUBase* has to be implemented, which provides the following two methods:\n\n* Method *initializeSimulation()*:\n  This method allows to define simulation variables (typically member variables of the inheriting class) as inputs/outputs/parameters of the ns-3 simulation.\n\n* Method *runSimulation( const double& sync_time )*:\n  This method is called whenever a new ns-3 simulation has to be run.\n  Most of the code it contains is what you would typically find in an ns-3 script.\n  Results of such a simulation can be added to the event queue via method *addNewEventForMessage( evt_time, msg_id, output_var )*.\n\nAfter the definition of the class, the macro *CREATE_NS3_FMU_BACKEND* has to be used.\nThis macro replaces the typical main methods of ns-3 scripts.\n\n\n## FMU generation using Python scripts\n\nFMUs can be generated using the Python script `ns3_fmu_create.py`.\nThe FMU is created by executing the Python script from the command line:\n```\n     ns3_fmu_create.py [-h] [-v] -m <model_id> -s <ns3_script> \\\n        [-f <fmi_version>] [<additional_file_1> ... <additional_file_N>] \\\n        [var1=start_val1 ... varN=start_valN]\n```\nOptional arguments are enclosed by squared brackets [...].\n\n### Mandatory input arguments\n\n* *-m, --model-id*: Specify the FMU model identifier. *Attention*: The FMU model identifier must fulfill the restrictions for C function names!\n* *-s, --script*: Path to ns-3 script (absolute or relative).\n\n### Optional input arguments\n\n* *-h, --help*: Display the help screen.\n* *-v, --verbose*: Turn on log messages.\n* *-l, --litter*: Do not clean-up intermediate files (e.g., log file with debug messages from compilation).\n* *-f, --fmi-version*: Specify FMI version (1 or 2, default is 2)\n\nAdditional files may be specified (e.g., CSV input lists) that will be automatically copied to the FMU.\nThe specified files paths may be absolute or relative.\n\nStart values for variables and parameters may be defined.\nFor instance, to set variable with name *var1* to value *12.34*, specify *var1=12.34* in the command line as optional argument.\n\n\n## Using an FMU generated for ns-3\n\nDuring simulation, interaction with the FMU is basically limited to the use of three (types of) functions:\n\n* *Setter functions*: Set the value (message ID) of input variables. This corresponds to sending a message. 0 means no input.\n\n* *Getter functions*: Retrieve the value (message ID) of output variables. This corresponds to receiving a message. 0 means no output.\n\n* *Synchronization*: An FMU for co-simulation is synchronized from one synchronization point to the next by calling the *doStep( ..., com_point, step_size, ...)* function, where *com_point* is the time of the last successful FMU synchronization and *step_size* is the length of the next simulation step.\n  In the case of FMUs for ns-3, which internally implement an event queue, there are three distinct ways of calling this function:\n\n  1. *Time advance*: When doStep(...) is called with step_size > 0, then the FMU tries to advance its internal simulation time accordingly.\n\n  2. *Receiving messages*: When calling doStep(...) with step_step = 0 (an FMU iteration) at a time corresponding to an internal event, the value(s) of the associated output variable(s) will be set to the according message ID.\n     To retrieve the actual message ID, call the getter function *after* the FMU iteration.\n\n  3. *Sending messages*: When calling doStep(...) with step_size = 0 (an FMU iteration) even though there is no internal event scheduled at this time, then the FMU assumes that one or more new messages have been sent and a new ns-3 simulation should be run.\n     To trigger an ns-3 simulation, provide new message IDs via the setter functions directly before the FMU iteration (but after a time advance).\n\n\n## Examples\n\nThe example applications are test cases from the [ERIGrid](https://erigrid.eu/) project:\n\n* *SimpleFMU*:\n  A very simple test case where a client sends data to a server.\n\n* *TC3*:\n  This test case comprises two smart meters sending data to a voltage controller, which sends data to actuate the tap position of an OLTC transformer.\n  This test case is described in detail in ERIGrid deliverable D-JRA2.2.\n\n* *LSS2*:\n  This test case also looks on the data transmission of smart meters to a controller, focusing on the effect of co-channel interference of Wi-Fi networks.\n  This test case is described in detail in ERIGrid deliverable D-JRA2.3.\n\nModule **fmu-examples** provides the models for these test cases.\nThese models implement dedicated clients and servers, which provide the functionality to extract the end-to-end delay of message transmissions.\nBased on these end-to-end delays, the ns-3 simulation scripts add events to the event queue of the FMU.\n\nThe classes *ClientBase* and *ServerBase* are the bases classes for all the clients and servers implemented for the example applications.\nThe implemented clients and servers are examples of how callback functions can be used to calculate end-to-end delays.\nHelpers for including the clients and servers into simulations scripts are provided.\nAll helpers are specializations of the template base classes *ClientHelperBase* and *ServerHelperBase*.\n\n\nThe examples are implemented in dedicated ns-3 scripts, which can be found in the module's subdirectory *examples/scratch*.\nThe scripts can be translated to FMUs for Co-Simulations using Python script `ns3_fmu_create.py` (from module *fmi-export*).\nTest applications (written in Python) using these FMUs can be found in module's subdirectory *examples/test*.\n\nTo build the examples, copy directory *fmu-examples* to ns-3's *src* directory (i.e., the directory with all the other ns-3 modules).\nThen change into the ns-3 root directory and build the module using `waf`.\n\n\n### Example SimpleFMU\n\n#### Overview\n\nThe ns-3 script of the simple example can be found (``SimpleFMU.cc``).\nIt implements a simple simulation in which one node (A) send messages to another node (B).\n\nThe script defines class *SimpleFMU*, which inherits from class *SimpleEventQueueFMUBase*:\n* The class defines three class member variables:\n\n  1. Variable *nodeA_send* is of type fmippInteger and will be used as input variable for the final FMU\n  2. Variable *nodeB_receive* is of type fmippInteger and will be used as output variable for the final FMU\n  3. Variable *channel_delay* is of type fmippReal and will be used as parameter for the final FMU\n\n* Function *initializeSimulation()*:\n  This function uses the macros *addIntegerInput(...)*, *addIntegerOutput(...)* and *addRealParameter(...)* to define the class member variables as input, output and parameter, respectively.\n  This definition is sufficient to create later on the FMU with an input, output and parameter with exactly the same names as the corresponding variables in the script.\n\n* Function *runSimulation( const double& sync_time )*:\n  This function runs an ns-3 simulation every time new inputs are set to the FMU (and the FMU is iterated, see above).\n  Most of the code is just like for normal ns-3 scripts, there are a few differences however:\n\n  * At the beginning of the function, variable *nodeA_send* is checked to be equal to zero, in order to know if indeed a message has been sent (i.e., a message ID is available as input).\n  * At the end of the simulation, the end-to-end delay of the message is retrieved.\n  * Finally, the event queue is updated with a new event using function *addNewEventForMessage(...)*.\n    The inputs are the time at which the message is received (i.e., the time of the FMU synchronization plus the end-to-end delay), the message ID and the pointer to the corresponding output variable.\n\n* At the very end of the script, macro *CREATE_NS3_FMU_BACKEND* is used with the name of the new class (SimpleFMU).\n  This macro is basically a replacement for a main function.\n\n\n#### Creating the FMU\n\nCreate the FMU with the help of Python script `ns3_fmu_create.py`.\nIn the command line, go to the example directory *src/fmu-examples/examples* and issue the following command:\n```\n  $ ./../../fmi-export/ns3_fmu_create.py -v -m SimpleFMU -s scratch/SimpleFMU.cc -f 1 channel_delay=0.2\n```\n\nThis command does the following:\n\n* It defines the FMU's model identifier as *SimpleFMU*.\n  This means that the resulting FMU will be called *SimpleFMU.fmu*.\n\n* It defines *scratch/SimpleFMU.cc* as the ns-3 script to be used for the simulation.\n\n* The parameter *channel_delay* is set to 0.3.\n\n\nThe output of the script in the command line should be something along the following lines. (Note that `waf` is called twice during the process.)\n```\n    [DEBUG] Using FMI version 1\n    [DEBUG] Found start value:  channel_delay = 0.2\n    Waf: Entering directory `/cygdrive/c/Development/erigrid/ns-3-allinone/ns-3-dev/build'\n    Waf: Leaving directory `/cygdrive/c/Development/erigrid/ns-3-allinone/ns-3-dev/build'\n    Build commands will be stored in build/compile_commands.json\n    'build' finished successfully (1.363s)\n\n    Modules built:\n    antenna\t\t\taodv\t\t\t\t\tapplications\n    bridge\t\t\t\tbuildings\t\t\t\tconfig-store\n    core\t\t\t\tcsma\t\t\t\t\tcsma-layout\n    dsdv\t\t\t\tdsr\t\t\t\t\tenergy\n    flow-monitor\t\t\tfmi-export (no Python)\tfmu-examples (no Python)\n    internet\t\t\tinternet-apps\t\t\tlr-wpan\n    lte\t\t\t\t\tmesh\t\t\t\tmobility\n    mpi\t\t\t\tnetanim (no Python)\t\tnetwork\n    nix-vector-routing\t\tolsr\t\t\t\t\tpoint-to-point\n    point-to-point-layout\tpropagation\t\t\tsixlowpan\n    spectrum\t\t\tstats\t\t\t\t\ttest (no Python)\n    topology-read\t\ttraffic-control\t\t\tuan\n    virtual-net-device\t\twave\t\t\t\t\twifi\n    wimax\n\n    Modules not built (see ns-3 tutorial for explanation):\n    brite\t\t\t\t\tclick\t\t\t\t\tfd-net-device\n    openflow\t\t\t\ttap-bridge\t\t\t\tvisualizer\n\n    [DEBUG] successfully compiled ns-3 script\n    Waf: Entering directory `/cygdrive/c/Development/erigrid/ns-3-allinone/ns-3-dev/build'\n    Waf: Leaving directory `/cygdrive/c/Development/erigrid/ns-3-allinone/ns-3-dev/build'\n    Build commands will be stored in build/compile_commands.json\n    'build' finished successfully (1.349s)\n    [DEBUG] successfully created JSON script\n    [DEBUG] FMI model identifier:  SimpleFMU\n    [DEBUG] ns-3 script:  scratch/SimpleFMU.cc\n    [DEBUG] ns-3 install directory:  /cygdrive/c/Development/erigrid/ns-3-allinone/ns-3-dev\n    [DEBUG] Aditional files:\n    [DEBUG] Added start value to model description:  channel_delay = 0.2\n    [DEBUG] FMU created successfully: SimpleFMU.fmu\n```\n\n#### Using the FMU in a simulation\n\nPython script `testSimpleFMU.py` uses the generated FMU in a simulation.\nIt can be found in the module's subdirectory *examples/test*.\nWhen running the simulation script, the output should be similar to the following:\n```\n    [test_sim_ict] WARNING: The path specified for the FMU's entry point does not exist: \"\"\n    Use directory of main application as working directory instead.\n    [test_sim_ict] MIME-TYPE: Wrong MIME type: application/x-waf --- expected:\n    Waf: Entering directory `/cygdrive/c/Development/erigrid/ns-3-allinone/ns-3-dev/build'\n    Waf: Leaving directory `/cygdrive/c/Development/erigrid/ns-3-allinone/ns-3-dev/build'\n    Build commands will be stored in build/compile_commands.json\n    'build' finished successfully (1.406s)\n    ================================================\n    simulation time : 0.0\n    next event time : 0.0\n    next send time : 1.0\n    ================================================\n    simulation time : 1.0\n    next event time : no next event specified\n    next send time : 1.0\n    At time 1.00000: SEND message with ID = 1\n    ================================================\n    simulation time : 1.301686399\n    next event time : 1.301686399\n    next send time : 2.0\n    At time 1.30169: RECEIVE message with ID = 1\n    ================================================\n    simulation time : 2.0\n    next event time : no next event specified\n    next send time : 2.0\n    At time 2.00000: SEND message with ID = 2\n    ================================================\n    simulation time : 2.301686399\n    next event time : 2.301686399\n    next send time : 3.0\n    At time 2.30169: RECEIVE message with ID = 2\n    ================================================\n    simulation time : 3.0\n    next event time : no next event specified\n    next send time : 3.0\n    At time 3.00000: SEND message with ID = 3\n    ================================================\n    simulation time : 3.301686399\n    next event time : 3.301686399\n    next send time : 4.0\n    At time 3.30169: RECEIVE message with ID = 3\n    ================================================\n```\n\n### Example TC3\n\n#### Creating the FMU\n\nCreate the FMU with the help of Python script `ns3_fmu_create.py`.\nIn the command line, go to the example directory *src/fmu-examples/examples* and issue the following command:\n```\n     $ ./../../fmi-export/ns3_fmu_create.py -v -m TC3 -s scratch/TC3.cc -f 1\n```\n\n#### Using the FMU in a simulation\n\nPython script `testTC3.py` uses the generated FMU in a simulation.\nIt can be found in the module's subdirectory *examples/test*.\nWhen running the simulation script, the output should be similar to the following:\n```\n    [test_sim_ict] WARNING: The path specified for the FMU's entry point does not exist: \"\"\n    Use directory of main application as working directory instead.\n    [test_sim_ict] MIME-TYPE: Wrong MIME type: application/x-waf --- expected:\n    Waf: Entering directory `/cygdrive/c/Development/erigrid/ns-3-allinone/ns-3-dev/build'\n    Waf: Leaving directory `/cygdrive/c/Development/erigrid/ns-3-allinone/ns-3-dev/build'\n    Build commands will be stored in build/compile_commands.json\n    'build' finished successfully (1.415s)\n    ==========================================\n    simulation time : 0.0\n    next event time : 0.0\n    next send time : 1.0\n    ctrl_msg_id = 0\n    ==========================================\n    simulation time : 1.0\n    next event time : 1.0\n    next send time : 1.0\n    At time 1.00000: SEND messages to controller with ID = 1 and  ID = -1\n    ctrl_msg_id = 0\n    ==========================================\n    simulation time : 1.039132019\n    next event time : 1.039132019\n    next send time : 2.0\n    ctrl_msg_id = 1\n    At time 1.03913: RECEIVE message at controller with ID = 1\n    At time 1.03913: SEND message from controller with ID = 10\n    ==========================================\n    simulation time : 1.049157658\n    next event time : 1.049157658\n    next send time : 2.0\n    ctrl_msg_id = -1\n    At time 1.04916: RECEIVE message at controller with ID = -1\n    At time 1.04916: SEND message from controller with ID = -10\n    ==========================================\n    simulation time : 1.079941038\n    next event time : 1.079941038\n    next send time : 2.0\n    ctrl_msg_id = 0\n    At time 1.07994: RECEIVE message at transformer with ID = 10\n    ==========================================\n    simulation time : 1.089867677\n    next event time : 1.089867677\n    next send time : 2.0\n    ctrl_msg_id = 0\n    At time 1.08987: RECEIVE message at transformer with ID = -10\n    ==========================================\n    simulation time : 2.0\n    next event time : 2.0\n    next send time : 2.0\n    At time 2.00000: SEND messages to controller with ID = 2 and  ID = -2\n    ctrl_msg_id = 0\n    ==========================================\n    simulation time : 2.039015019\n    next event time : 2.039015019\n    next send time : 3.0\n    ctrl_msg_id = 2\n    At time 2.03902: RECEIVE message at controller with ID = 2\n    At time 2.03902: SEND message from controller with ID = 20\n    ==========================================\n    simulation time : 2.049040658\n    next event time : 2.049040658\n    next send time : 3.0\n    ctrl_msg_id = -2\n    At time 2.04904: RECEIVE message at controller with ID = -2\n    At time 2.04904: SEND message from controller with ID = -20\n    ==========================================\n    simulation time : 2.076761038\n    next event time : 2.076761038\n    next send time : 3.0\n    ctrl_msg_id = 0\n    At time 2.07676: RECEIVE message at transformer with ID = 20\n    ==========================================\n    simulation time : 2.090786677\n    next event time : 2.090786677\n    next send time : 3.0\n    ctrl_msg_id = 0\n    At time 2.09079: RECEIVE message at transformer with ID = -20\n    ==========================================\n    simulation time : 3.0\n    next event time : 3.0\n    next send time : 3.0\n    At time 3.00000: SEND messages to controller with ID = 3 and  ID = -3\n    ctrl_msg_id = 0\n    ==========================================\n    simulation time : 3.041898019\n    next event time : 3.041898019\n    next send time : 4.0\n    ctrl_msg_id = -3\n    At time 3.04190: RECEIVE message at controller with ID = -3\n    At time 3.04190: SEND message from controller with ID = -30\n    ==========================================\n    simulation time : 3.052203658\n    next event time : 3.052203658\n    next send time : 4.0\n    ctrl_msg_id = 3\n    At time 3.05220: RECEIVE message at controller with ID = 3\n    At time 3.05220: SEND message from controller with ID = 30\n    ==========================================\n    simulation time : 3.079644038\n    next event time : 3.079644038\n    next send time : 4.0\n    ctrl_msg_id = 0\n    At time 3.07964: RECEIVE message at transformer with ID = -30\n    ==========================================\n    simulation time : 3.096913677\n    next event time : 3.096913677\n    next send time : 4.0\n    ctrl_msg_id = 0\n    At time 3.09691: RECEIVE message at transformer with ID = 30\n    ==========================================\n```\n",
  "examples": []
}