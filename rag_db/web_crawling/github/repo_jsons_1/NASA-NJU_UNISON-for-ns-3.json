{
  "repo_name": "NASA-NJU/UNISON-for-ns-3",
  "github_url": "https://github.com/NASA-NJU/UNISON-for-ns-3",
  "readme": "# Unison for ns-3\n\n[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.10077300.svg)](https://doi.org/10.5281/zenodo.10077300)\n[![CI](https://github.com/NASA-NJU/UNISON-for-ns-3/actions/workflows/per_commit.yml/badge.svg)](https://github.com/NASA-NJU/UNISON-for-ns-3/actions/workflows/per_commit.yml)\n\nA fast and user-transparent parallel simulator implementation for ns-3.\n\nWith fine-grained partition and load-adaptive scheduling, Unison allows users to easily simulate models with multithreaded parallelization without further configurations.\nMeanwhile, cache misses are reduced by fine-grained partition, and the mutual waiting time among threads is minimized by load-adaptive scheduling, resulting in efficient parallelization.\nMore information about Unison can be found in our [EuroSys '24 paper](https://dl.acm.org/doi/10.1145/3627703.3629574).\n\nSupported ns-3 version: >= 3.36.1.\nWe are trying to keep Unison updated with the latest version of ns-3.\nYou can find each unison-enabled ns-3 version via `unison-*` tags.\n\n## Getting Started\n\nThe quickest way to get started is to type the command\n\n```shell\n./ns3 configure --enable-mtp --enable-examples\n```\n\n> The build profile is set to default (which uses `-O2 -g` compiler flags) in this case.\n> If you want to get `-O3` optimized build and discard all log outputs, please add `-d optimized` arguments.\n\nThe `--enable-mtp` option will enable multi-threaded parallelization.\nYou can verify Unison is enabled by checking whether `Multithreaded Simulation : ON` appears in the optional feature list.\n\nNow, let's build and run a DCTCP example with default sequential simulation and parallel simulation (using 4 threads) respectively:\n\n```shell\n./ns3 build dctcp-example dctcp-example-mtp\ntime ./ns3 run dctcp-example\ntime ./ns3 run dctcp-example-mtp\n```\n\nThe simulation should finish in 4-5 minutes for `dctcp-example` and 1-2 minutes for `dctcp-example-mtp`, depending on your hardware and your build profile.\nThe output in `*.dat` should be in accordance with the comments in the source file.\n\nThe speedup of Unison is more significant for larger topologies and traffic volumes.\nIf you are interested in using it to simulate topologies like fat-tree, BCube and 2D-torus, please refer to [Running Evaluations](#running-evaluations).\n\n## Speedup Your Existing Code\n\nTo understand how Unison affects your model code, let's find the differences between two versions of the source files of the above example:\n\n```shell\ndiff examples/tcp/dctcp-example.cc examples/mtp/dctcp-example-mtp.cc\n```\n\nIt turns out that to bring Unison to the existing model code, all you need to do is to include the `ns3/mtp-interface.h` header file and add the following line at the beginning of the `main` function:\n\n```c++\nMtpInterface::Enable(numberOfThreads);\n```\n\nThe parameter `numberOfThreads` is optional.\nIf it is omitted, the number of threads is automatically chosen and will not exceed the maximum number of available hardware threads on your system.\nIf you want to enable Unison for distributed simulation on existing MPI programs for further speedup, place the above line before MPI initialization and do not explicitly specify the simulator implementation in your code.\nFor such hybrid simulation with MPI, the `--enable-mpi` option is also required when configuring ns-3.\n\nUnison resolved a lot of thread-safety issues with ns-3's architecture.\nYou don't need to consider these issues on your own for most of the time, except if you have custom global statistics other than the built-in flow-monitor.\nIn the latter case, if multiple nodes can access your global statistics, you can replace them with atomic variables via `std::atomic<>`.\nWhen collecting tracing data such as Pcap, it is strongly recommended to create separate output files for each node instead of a single trace file.\nFor complex custom data structures, you can create critical sections by adding\n\n```c++\nMtpInterface::CriticalSection cs;\n```\n\nat the beginning of your methods.\n\n## Examples\n\nIn addition to the DCTCP example, you can find other adapted examples in `examples/mtp`.\nMeanwhile, Unison also supports manual partition, and you can find a minimal example in `src/mtp/examples/simple-mtp.cc`\nFor hybrid simulation with MPI, you can find a minimal example in `src/mpi/examples/simple-hybrid.cc`.\n\nWe also provide three detailed fat-tree examples for Unison, traditional MPI parallel simulation and hybrid simulation:\n\n| Name | Location | Required configuration flags | Running commands |\n| - | - | - | - |\n| fat-tree-mtp | src/mtp/examples/fat-tree-mtp.cc | `--enable-mtp --enable-exaples` without `--enable-mpi` | `./ns3 run \"fat-tree-mtp --thread=4\"` |\n| fat-tree-mpi | src/mpi/examples/fat-tree-mpi.cc | `--enable-mpi --enable-exaples` without `--enable-mtp` | `./ns3 run fat-tree-mpi --command-template \"mpirun -np 4 %s\"` |\n| fat-tree-hybrid | src/mpi/examples/fat-tree-hybrid.cc | `--enable-mtp --enable-mpi --enable-exaples` | `./ns3 run fat-tree-hybrid --command-template \"mpirun -np 2 %s --thread=2\"` |\n\nFeel free to explore these examples, compare code changes and adjust the `-np` and `--thread` arguments.\n\n## Running Evaluations\n\nTo evaluate Unison, please switch to [unison-evaluations](https://github.com/NASA-NJU/Unison-for-ns-3/tree/unison-evaluations) branch, which is based on ns-3.36.1.\nIn this branch, you can find various topology models in the `scratch` folder.\nThere are a lot of parameters you can set for each topology.\nWe provided a utility script `exp.py` to compare these simulators and parameters.\nWe also provided `process.py` to convert these raw experiment data to CSV files suitable for plotting.\nPlease see the [README in that branch](https://github.com/NASA-NJU/Unison-for-ns-3/tree/unison-evaluations) for more details.\n\nThe evaluated artifact (based on ns-3.36.1) is persistently indexed by DOI [10.5281/zenodo.10077300](https://doi.org/10.5281/zenodo.10077300).\n\n## Module Documentation\n\n### 1. Overview\n\nUnison for ns-3 is mainly implemented in the `mtp` module (located at `src/mtp/*`), which stands for multi-threaded parallelization.\nThis module contains three parts: A parallel simulator implementation `multithreaded-simulator-impl`, an interface to users `mtp-interface`, and `logical-process` to represent LPs in terms of parallel simulation.\n\nAll LPs and threads are stored in the `mtp-interface`.\nIt controls the simulation progress, schedules LPs to threads and manages the lifecycles of LPs and threads.\nThe interface also provides some methods and options for users to tweak the simulation.\n\nEach LP's logic is implemented in `logical-process`. It contains most of the methods of the default sequential simulator plus some auxiliary methods for parallel simulation.\n\nThe simulator implementation `multithreaded-simulator-impl` is a derived class from the base simulator.\nIt converts calls to the base simulator into calls to logical processes based on the context of the current thread.\nIt also provides a partition method for automatic fine-grained topology partition.\n\nFor distributed simulation with MPI, we added `hybrid-simulator-impl` in the `mpi` module (located at `src/mpi/model/hybrid-simulator-impl*`).\nThis simulator uses both `mtp-interface` and `mpi-interface` to coordinate local LPs and global MPI communications.\nWe also modified the module to make it locally thread-safe.\n\n### 2. Modifications to ns-3 Architecture\n\nIn addition to the `mtp` and `mpi` modules, we also modified the following part of the ns-3 architecture to make it thread-safe, also with some bug fixing for ns-3.\nYou can find the modifications to each unison-enabled ns-3 version via `git diff unison-* ns-*`.\n\nModifications to the build system to provide `--enable-mtp` option to enable/disable Unison:\n\n```\nns3                                                |    2 +\nCMakeLists.txt                                     |    1 +\nbuild-support/custom-modules/ns3-configtable.cmake |    3 +\nbuild-support/macros-and-definitions.cmake         |   10 +\n```\n\nModifications to the `core` module to make reference counting thread-safe:\n\n```\nsrc/core/CMakeLists.txt                            |    1 +\nsrc/core/model/atomic-counter.h                    |   50 +\nsrc/core/model/hash.h                              |   16 +\nsrc/core/model/object.cc                           |    2 +\nsrc/core/model/simple-ref-count.h                  |   11 +-\n```\n\nModifications to the `network` module to make packets thread-safe:\n\n```\nsrc/network/model/buffer.cc                        |   15 +-\nsrc/network/model/buffer.h                         |    7 +\nsrc/network/model/byte-tag-list.cc                 |   14 +-\nsrc/network/model/node.cc                          |    7 +\nsrc/network/model/node.h                           |    7 +\nsrc/network/model/packet-metadata.cc               |   26 +-\nsrc/network/model/packet-metadata.h                |   14 +-\nsrc/network/model/packet-tag-list.h                |   11 +-\nsrc/network/model/socket.cc                        |    6 +\n```\n\nModifications to the `internet` module to make it thread-safe and add per-flow ECMP routing:\n\n```\nsrc/internet/model/global-route-manager-impl.cc    |    2 +\nsrc/internet/model/ipv4-global-routing.cc          |   32 +-\nsrc/internet/model/ipv4-global-routing.h           |    8 +-\nsrc/internet/model/ipv4-packet-info-tag.cc         |    2 +\nsrc/internet/model/ipv6-packet-info-tag.cc         |    2 +\nsrc/internet/model/tcp-option.cc                   |    2 +-\n```\n\nModifications to the `flow-monitor` module to make it thread-safe:\n\n```\nsrc/flow-monitor/model/flow-monitor.cc             |   48 +\nsrc/flow-monitor/model/flow-monitor.h              |    4 +\nsrc/flow-monitor/model/ipv4-flow-classifier.cc     |   12 +\nsrc/flow-monitor/model/ipv4-flow-classifier.h      |    5 +\nsrc/flow-monitor/model/ipv4-flow-probe.cc          |    2 +\nsrc/flow-monitor/model/ipv6-flow-classifier.cc     |   12 +\nsrc/flow-monitor/model/ipv6-flow-classifier.h      |    5 +\nsrc/flow-monitor/model/ipv6-flow-probe.cc          |    2 +\n```\n\nModifications to the `nix-vector-routing` module to make it thread-safe:\n\n```\nsrc/nix-vector-routing/model/nix-vector-routing.cc |   92 ++\nsrc/nix-vector-routing/model/nix-vector-routing.h  |    8 +\n```\n\nModifications to the `mpi` module to make it thread-safe with the hybrid simulator:\n\n```\nsrc/mpi/model/granted-time-window-mpi-interface.cc |   25 +\nsrc/mpi/model/granted-time-window-mpi-interface.h  |    7 +\nsrc/mpi/model/mpi-interface.cc                     |    3 +-\n```\n\n### 3. Logging\n\nThe reason behind Unison's fast speed is that it divides the network into multiple logical processes (LPs) with fine granularity and schedules them dynamically.\nTo get to know more details of such workflow, you can enable the following log component:\n\n```c++\nLogComponentEnable(\"LogicalProcess\", LOG_LEVEL_INFO);\nLogComponentEnable(\"MultithreadedSimulatorImpl\", LOG_LEVEL_INFO);\n```\n\n### 4. Advanced Options\n\nThese options can be modified at the beginning of the `main` function using the native config syntax of ns-3.\n\nYou can also change the default maximum number of threads by setting\n\n```c++\nConfig::SetDefault(\"ns3::MultithreadedSimulatorImpl::MaxThreads\", UintegerValue(8));\nConfig::SetDefault(\"ns3::HybridSimulatorImpl::MaxThreads\", UintegerValue(8));\n```\n\nThe automatic partition will cut off stateless links whose delay is above the threshold.\nThe threshold is automatically calculated based on the delay of every link.\nIf you are not satisfied with the partition results, you can set a custom threshold by setting\n\n```c++\nConfig::SetDefault(\"ns3::MultithreadedSimulatorImpl::MinLookahead\", TimeValue(NanoSeconds(500));\nConfig::SetDefault(\"ns3::HybridSimulatorImpl::MinLookahead\", TimeValue(NanoSeconds(500));\n```\n\nThe scheduling method determines the priority (estimated completion time of the next round) of each logical process.\nThere are five available options:\n\n- `ByExecutionTime`: LPs with a higher execution time of the last round will have higher priority.\n- `ByPendingEventCount`: LPs with more pending events of this round will have higher priority.\n- `ByEventCount`: LPs with more pending events of this round will have higher priority.\n- `BySimulationTime`: LPs with larger current clock time will have higher priority.\n- `None`: Do not schedule. The partition's priority is based on their ID.\n\nMany experiments show that the first one usually leads to better performance.\nHowever, you can still choose one according to your taste by setting\n\n```c++\nGlobalValue::Bind(\"PartitionSchedulingMethod\", StringValue(\"ByExecutionTime\"));\n```\n\nBy default, the scheduling period is 2 when the number of partitions is less than 16, 3 when it is less than 256, 4 when it is less than 4096, etc.\nSince more partitions lead to more scheduling costs.\nYou can also set how frequently scheduling occurs by setting\n\n```c++\nGlobalValue::Bind(\"PartitionSchedulingPeriod\", UintegerValue(4));\n```\n\n## Links\n\nIf you find the code useful, please consider citing [our paper](https://dl.acm.org/doi/10.1145/3627703.3629574).\n\n```bibtex\n@inproceedings{10.1145/3627703.3629574,\nauthor = {Bai, Songyuan and Zheng, Hao and Tian, Chen and Wang, Xiaoliang and Liu, Chang and Jin, Xin and Xiao, Fu and Xiang, Qiao and Dou, Wanchun and Chen, Guihai},\ntitle = {Unison: A Parallel-Efficient and User-Transparent Network Simulation Kernel},\nyear = {2024},\nisbn = {9798400704376},\npublisher = {Association for Computing Machinery},\naddress = {New York, NY, USA},\nurl = {https://doi.org/10.1145/3627703.3629574},\ndoi = {10.1145/3627703.3629574},\nabstract = {Discrete-event simulation (DES) is a prevalent tool for evaluating network designs. Although DES offers full fidelity and generality, its slow performance limits its application. To speed up DES, many network simulators employ parallel discrete-event simulation (PDES). However, adapting existing network simulation models to PDES requires complex reconfigurations and often yields limited performance improvement. In this paper, we address this gap by proposing a parallel-efficient and user-transparent network simulation kernel, Unison, that adopts fine-grained partition and load-adaptive scheduling optimized for network scenarios. We prototype Unison based on ns-3. Existing network simulation models of ns-3 can be seamlessly transitioned to Unison. Testbed experiments on commodity servers demonstrate that Unison can achieve a 40\\texttimes{} speedup over DES using 24 CPU cores, and a 10\\texttimes{} speedup compared with existing PDES algorithms under the same CPU cores.},\nbooktitle = {Proceedings of the Nineteenth European Conference on Computer Systems},\npages = {115\u2013131},\nnumpages = {17},\nkeywords = {Data center networks, Network simulation, Parallel discrete-event simulation},\nlocation = {<conf-loc>, <city>Athens</city>, <country>Greece</country>, </conf-loc>},\nseries = {EuroSys '24}\n}\n```\n\nBelow are some links that may also be helpful to you:\n\n- [ns-3 Tutorial](https://www.nsnam.org/docs/tutorial/html/index.html)\n- [ns-3 Model Library](https://www.nsnam.org/docs/models/html/index.html)\n- [ns-3 Manual](https://www.nsnam.org/docs/manual/html/index.html)\n",
  "examples": []
}