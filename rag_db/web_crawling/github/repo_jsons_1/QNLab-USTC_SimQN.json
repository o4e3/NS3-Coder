{
  "repo_name": "QNLab-USTC/SimQN",
  "github_url": "https://github.com/QNLab-USTC/SimQN",
  "readme": "# SimQN\n\n- [SimQN](#simqn)\n  - [Overview](#overview)\n  - [Roadmap](#roadmap)\n  - [Why choose SimQN?](#why-choose-simqn)\n  - [Installation](#installation)\n  - [First sight of SimQN](#first-sight-of-simqn)\n  - [Get Help](#get-help)\n  - [Release History](#release-history)\n  - [How to contribute?](#how-to-contribute)\n  - [License and Authors](#license-and-authors)\n  - [Ciatation](#ciatation)\n\n## Overview\n\n[![Pytest](https://github.com/QNLab-USTC/SimQN/actions/workflows/pytest.yml/badge.svg?branch=main)](https://github.com/QNLab-USTC/SimQN/actions/workflows/pytest.yml)\n![Flake8](https://github.com/QNLab-USTC/SimQN/actions/workflows/flake8.yml/badge.svg)\n\n**[Attention]** Most of existing&future studies in [QNLab](https://qnlab-ustc.com/) are evaluated on SimQN platform, if you would like to follow our work or seek for an easy-to-use quantum network simulator, you cannot miss SimQN! Please check out the following publication for details. **([Link](https://ieeexplore.ieee.org/abstract/document/10024900/) and [PDF](https://infonetlijian.github.io/homepage/PDF_files/2023-%E3%80%90IEEE%20Network%E3%80%91-SimQN_a_Network-layer_Simulator_for_the_Quantum_Network_Investigation.pdf)).**  \n\nWelcome to SimQN's documentation. SimQN is a discrete-event-based network simulation platform for quantum networks.\nSimQN enables large-scale investigations, including QKD protocols, entanglement distributions protocols, and routing algorithms, resource allocation schemas in quantum networks. For example, users can use SimQN to design routing algorithms for better QKD performance. For more information, please refer to the [Documents](https://qnlab-ustc.github.io/SimQN/).\n\nSimQN is a Python3 library for quantum networking simulation. It is designed to be general purpose. It means that SimQN can be used for both QKD network, entanglement distribution networks, and other kinds of quantum networks' evaluation. The core idea is that SimQN makes no architecture assumption. Since there is currently no recognized network architecture in quantum network investigations, SimQN stays flexible in this aspect.\n\nSimQN provides high performance for large-scale network simulation. SimQN uses [Cython](https://cython.org/) to compile critical codes in C/C++ libraries to boost the evaluation. Also, along with the commonly used quantum state-based physical models, SimQN provides a higher-layer fidelity-based entanglement physical model to reduce the computation overhead and brings convenience for users in evaluation. Last but not least, SimQN provides several network auxiliary models for easily building network topologies, producing routing tables and managing multiple session requests.\n\n## Roadmap\n\n![Roadmap](https://github.com/QNLab-USTC/QuantumNetworkWebsite/blob/main/static/images/simqn_roadmap.png)\n\n- Currently, we are foucsing on developing the 0.2.x version of SimQN, which will include:\n  - Useful network utilities, such as more random topology generators, routing algorithms, and session request generators, real topology adaptors, and Multi-path routing algorithms.\n  - Representative quantum network protocols, such as Q-CAST routing protocol, PS/PU routing protocol, REPS routing protocol for quantum information networks, and CASCADE error correction protocol for QKD networks.\n\n- The follwing functions will be included in the future versions:\n  - Practical quantum network entities, such as quantum repeaters, quantum switches, and quantum benchmarking devices.\n  - Useful network utilities, such as random request traffic generators.\n  - Support for Quantum network stack protocols, incluing KM protocols, routing protocols in QKD networks, and entanglement distribution protocols in quantum information networks.\n  - Realization of easy-to-use GUI for SimQN.\n  \n## Why choose SimQN?\n\nSimQN is designed as a functional and easy-to-use simulator, like [NS3](https://www.nsnam.org/) in classic networks, it provides numerous functions for anyone who wants to simulate a QKD network or entanglement-based network. \n\nCompared with the existing quantum network simulators, the developers pay more attention to simulation in the network area. Currently, a network simulation can be complicated, as users may have to implement routing algorithms and multiply protocols in different layers to complete a simulation. SimQN aims to break down this problem by providing a modulized quantum node and reusable algorithms and protocols. As a result, users can focus on what they study and reuse other built-in modules. The developers believe this will significantly reduce the burden on our users. As for the physics area, SimQN can also simulate quantum noise, fidelity, and more. Thus, if you focus on the research of the quantum network area, SimQN can be a competitive choice.  \n\n**The main advantages of SimQN can be summarized as follows.**\n- Easy-to-use with Python\n- High-efficiency simulator core\n- Customizable qubit model\n- Built-in quantum internet protocol stack\n- Mainstream quantum applications support, e.g., QKD, quantum networking, and distributed quantum computing (incoming)\n- Periodical updates for academia-related functions and state-of-the-art solutions in the community  (you are welcome to highlight your work and contribute your code on SimQN)\n- ...\n\n\n## Installation\n\nInstall and update using `pip`:\n```\npip3 install -U qns\n```\n\n## First sight of SimQN\n\nHere is an example of using SimQN.\n\n``` Python\n\n    from qns.simulator.simulator import Simulator\n    from qns.network.topology import RandomTopology\n    from qns.network.protocol.entanglement_distribution import EntanglementDistributionApp\n    from qns.network import QuantumNetwork\n    from qns.network.route.dijkstra import DijkstraRouteAlgorithm\n    from qns.network.topology.topo import ClassicTopology\n    import qns.utils.log as log\n    import logging\n\n    init_fidelity = 0.99   # the initial entanglement's fidelity\n    nodes_number = 150     # the number of nodes\n    lines_number = 450     # the number of quantum channels\n    qchannel_delay = 0.05  # the delay of quantum channels\n    cchannel_delay = 0.05  # the delay of classic channels\n    memory_capacity = 50   # the size of quantum memories\n    send_rate = 10         # the send rate\n    requests_number = 10   # the number of sessions (SD-pairs)\n\n    # generate the simulator\n    s = Simulator(0, 10, accuracy=1000000)\n\n    # set the log's level\n    log.logger.setLevel(logging.INFO)\n    log.install(s)\n\n    # generate a random topology using the parameters above\n    # each node will install EntanglementDistributionApp for hop-by-hop entanglement distribution\n    topo = RandomTopology(nodes_number=nodes_number,\n                          lines_number=lines_number,\n                          qchannel_args={\"delay\": qchannel_delay},\n                          cchannel_args={\"delay\": cchannel_delay},\n                          memory_args=[{\"capacity\": memory_capacity}],\n                          nodes_apps=[EntanglementDistributionApp(init_fidelity=init_fidelity)])\n\n    # build the network, with Dijkstra's routing algorithm\n    net = QuantumNetwork(topo=topo, classic_topo=ClassicTopology.All, route=DijkstraRouteAlgorithm())\n\n    # build the routing table\n    net.build_route()\n\n    # randomly select multiple sessions (SD-pars)\n    net.random_requests(requests_number, attr={\"send_rate\": send_rate})\n\n    # all entities in the network will install the simulator and do initiate works.\n    net.install(s)\n\n    # run simulation\n    s.run()\n```\n\n## Get Help\n\n- This [documentation](https://qnlab-ustc.github.io/SimQN/) may answer most questions.\n    - The [tutorial](https://qnlab-ustc.github.io/SimQN/tutorials.html) here presents how to use SimQN.\n    - The [API manual](https://qnlab-ustc.github.io/SimQN/modules.html) shows more detailed information.\n- Welcome to report bugs at [Github](https://github.com/QNLab-USTC/SimQN).\n\n## Release History\n\n- v0.2.1(Released 2025.04)\n  - *New functions!!!*\n  - Network Utilities: Add Random Topology Generator, including ER model, BA model, and dual-BA model.\n  - Applications: Add CASCADE Error Correction and Privacy Amplification Process for BB84 Protocol.\n\n- v0.1.5(Released 2022.09)\n  - *New functions!!!*\n  - Simulator Core: Cython Optimization, Multi-process Support.\n  - Quantum Entitise: Quantum Memory, Delay Model.\n  - Tools: Monitor Tools.\n\n- v0.1.4(Released 2022.03)\n  - *New functions!!!*\n  - Simulator Core: Priority Queue Based Event Scheduler.\n  - Physical Backends: Qubit Model, EPR Model, Quantum Gates.\n  - Quantum Entitise: Quantum Node, Quantum Channel.\n  - Network Utilities: Topology Generator, Routing Utility.\n  - Applications: BB84 Protocol, Entanglement Swapping Protocol.\n  - Tools: Rnd Tools.\n\n## How to contribute?\nWelcome to contribute through Github Issue or Pull Requests. Please refer to the [develop guide](https://qnlab-ustc.github.io/SimQN/develop.html). If you have any questions, you are welcome to contact the developers via e-mail.\n\n## License and Authors\n\nSimQN is an open-source project under [GPLv3](/LICENSE) license. The authors of the paper includes:\n* Lutong Chen (ertuil), School of Cyber Science and Technology, University of Science and Technology of China, China. elliot.98@outlook.com\n* Jian Li(infonetlijian), School of Cyber Science and Technology, University of Science and Technology of China, China. \n* Kaiping Xue (kaipingxue), School of Cyber Science and Technology, University of Science and Technology of China, China. xue.kaiping@gmail.com\n* Nenghai Yu, School of Cyber Science and Technology, University of Science and Technology of China, China.\n* Ruidong Li, Institute of Science and Engineering, Kanazawa University, Japan.\n* Qibin Sun, School of Cyber Science and Technology, University of Science and Technology of China, China.\n* Jun Lu, School of Cyber Science and Technology, University of Science and Technology of China, China.\n\nOther contributors includes:\n* Zirui Xiao, School of Cyber Science and Technology, University of Science and Technology of China, China.\n* Yuqi Yang, School of Cyber Science and Technology, University of Science and Technology of China, China.\n* Bing Yang, School of Cyber Science and Technology, University of Science and Technology of China, China.\n* Xumin Gao, School of Cyber Science and Technology, University of Science and Technology of China, China.\n\n## Citation\n\nPlease cite this publication if you use SimQN in your research.\n\n```Bibtex\n@article{chen2023simqn,\n  title={SimQN: A network-layer simulator for the quantum network investigation},\n  author={Chen, Lutong and Xue, Kaiping and Li, Jian and Yu, Nenghai and Li, Ruidong and Sun, Qibin and Lu, Jun},\n  journal={IEEE Network},\n  volume={37},\n  number={5},\n  pages={182--189},\n  year={2023},\n  publisher={IEEE},\n  doi={10.1109/MNET.130.2200481}\n}\n```\n",
  "examples": [
    {
      "file_path": "examples/DEJMPS.py",
      "code": "from qns.models.epr.mixed import MixedStateEntanglement\nfrom qns.models.qubit.gate import RX, CNOT\nimport numpy as np\n\n\ndef DEJMPS(q1, q2, q3, q4):\n    \"\"\"\n    The BEJMPS distillation protocol\n    \"\"\"\n    RX(q1, np.pi/2)\n    RX(q2, np.pi/2)\n    RX(q3, -np.pi/2)\n    RX(q4, -np.pi/2)\n\n    CNOT(q1, q2)\n    CNOT(q3, q4)\n    c2 = q2.measure()\n    c4 = q4.measure()\n    if c2 == c4:\n        return True, q1, q3\n    return False, None, None\n\n\ndef main():\n    fail_count = 0\n    succ_count = 0\n    fidelity = None\n    for _ in range(1000):\n        e1 = MixedStateEntanglement(fidelity=0.8)\n        e2 = MixedStateEntanglement(fidelity=0.8)\n\n        q1, q3 = e1.to_qubits()\n        print(q1.state.state)\n        q2, q4 = e2.to_qubits()\n\n        ret, q1, q3 = DEJMPS(q1, q2, q3, q4)\n        if ret:\n            succ_count += 1\n            rho = q1.state.rho\n            phi_p: np.ndarray = 1/np.sqrt(2) * np.array([[1, 0, 0, 1]])\n            fidelity = np.dot(phi_p, rho)\n            fidelity = np.dot(fidelity, phi_p.T.conj())\n        else:\n            fail_count += 1\n    print(succ_count, fail_count, rho, fidelity)\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "file_path": "examples/classic_communication.py",
      "code": "\nfrom qns.simulator.simulator import Simulator\nfrom qns.simulator.event import Event\nfrom qns.entity.node.app import Application\nfrom qns.entity.node.node import QNode\nfrom qns.entity.cchannel.cchannel import ClassicChannel, ClassicPacket, RecvClassicPacket\nfrom qns.simulator import func_to_event\n\n\n# the send application\nclass SendApp(Application):\n    def __init__(self, dest: QNode, cchannel: ClassicChannel, send_rate=1):\n        super().__init__()\n        self.dest = dest\n        self.cchannel = cchannel\n        self.send_rate = send_rate\n\n    # initiate: generate the first send event\n    def install(self, node: QNode, simulator: Simulator):\n        super().install(node, simulator)\n\n        # get start time\n\n        t = simulator.ts\n        event = func_to_event(t, self.send_packet, by=self)\n        self._simulator.add_event(event)\n\n    def send_packet(self):\n        # generate a packet\n        packet = ClassicPacket(msg=\"Hello,world\", src=self.get_node(), dest=self.dest)\n\n        # send the classic packet\n        self.cchannel.send(packet=packet, next_hop=self.dest)\n\n        # calculate the next sending time\n        t = self._simulator.current_time + \\\n            self._simulator.time(sec=1 / self.send_rate)\n\n        # insert the next send event to the simulator\n        event = func_to_event(t, self.send_packet, by=self)\n        self._simulator.add_event(event)\n\n\nclass RecvApp(Application):\n    def __init__(self):\n        super().__init__()\n        self.add_handler(self.handleClassicPacket, [RecvClassicPacket], [])\n\n    def handleClassicPacket(self, node: QNode, event: Event):\n        if isinstance(event, RecvClassicPacket):\n            packet = event.packet\n\n            # get the packet message\n            msg = packet.get()\n\n            # handling the receiving packet\n            # ...\n            print(msg)\n\n\n# generate quantum nodes\nn1 = QNode(\"n1\")\nn2 = QNode(\"n2\")\n\n# generate a classic channel\nl1 = ClassicChannel(name=\"l1\")\nn1.add_cchannel(l1)\nn2.add_cchannel(l1)\n\n# add apps\nn1.add_apps(SendApp(dest=n2, cchannel=l1))\nn2.add_apps(RecvApp())\n\n\ns = Simulator(0, 10, 10000)\nn1.install(s)\nn2.install(s)\n\n# run the simulation\ns.run()\n"
    },
    {
      "file_path": "examples/classic_packet_forward.py",
      "code": "from qns.entity.cchannel.cchannel import ClassicChannel, ClassicPacket, RecvClassicPacket\nfrom qns.entity.node.app import Application\nfrom qns.entity.node.node import QNode\nfrom qns.network.network import QuantumNetwork\nfrom qns.network.protocol.classicforward import ClassicPacketForwardApp\nfrom qns.network.route.dijkstra import DijkstraRouteAlgorithm\nfrom qns.network.route.route import RouteImpl\nfrom qns.network.topology.linetopo import LineTopology\nfrom qns.network.topology.topo import ClassicTopology\nfrom qns.simulator.event import Event, func_to_event\nfrom qns.simulator.simulator import Simulator\n\n\nclass SendApp(Application):\n    def __init__(self, dest: QNode, route: RouteImpl, send_rate=1):\n        super().__init__()\n        self.dest = dest\n        self.route = route\n        self.send_rate = send_rate\n\n    def install(self, node: QNode, simulator: Simulator):\n        super().install(node, simulator)\n        t = simulator.ts\n        event = func_to_event(t, self.send_packet, by=self)\n        self._simulator.add_event(event)\n\n    def send_packet(self):\n        packet = ClassicPacket(msg=f\"Hello,world from {self.get_node()}\", src=self.get_node(), dest=self.dest)\n\n        route_result = self.route.query(self.get_node(), self.dest)\n        if len(route_result) <= 0 or len(route_result[0]) <= 1:\n            print(\"not found next hop\")\n        next_hop = route_result[0][1]\n        cchannel: ClassicChannel = self.get_node().get_cchannel(next_hop)\n        if cchannel is None:\n            print(\"not found next channel\")\n\n        # send the classic packet\n        cchannel.send(packet=packet, next_hop=next_hop)\n\n        # calculate the next sending time\n        t = self._simulator.current_time + \\\n            self._simulator.time(sec=1 / self.send_rate)\n\n        # insert the next send event to the simulator\n        event = func_to_event(t, self.send_packet, by=self)\n        self._simulator.add_event(event)\n\n\n# the receiving application\nclass RecvApp(Application):\n    def __init__(self):\n        super().__init__()\n        self.add_handler(self.ClassicPacketHandler, [RecvClassicPacket], [])\n\n    def ClassicPacketHandler(self, node: QNode, event: Event):\n        packet = event.packet\n        msg = packet.get()\n        print(f\"{node} recv packet: {msg} from {packet.src}->{packet.dest}\")\n\n\ndef main():\n    s = Simulator(0, 10, accuracy=10000000)\n\n    topo = LineTopology(nodes_number=10,\n                        qchannel_args={\"delay\": 0.1},\n                        cchannel_args={\"delay\": 0.1})\n\n    net = QuantumNetwork(topo=topo, classic_topo=ClassicTopology.Follow)\n\n    # build quantum routing table\n    net.build_route()\n\n    classic_route = DijkstraRouteAlgorithm(name=\"classic route\")\n\n    # build classic routing table\n    classic_route.build(net.nodes, net.cchannels)\n    print(classic_route.route_table)\n\n    for n in net.nodes:\n        n.add_apps(ClassicPacketForwardApp(classic_route))\n        n.add_apps(RecvApp())\n\n    n1 = net.get_node(\"n1\")\n    n10 = net.get_node(\"n10\")\n\n    n1.add_apps(SendApp(n10, classic_route))\n\n    net.install(s)\n    s.run()\n\n\nif __name__ == \"__main__\":\n    main()\n"
    },
    {
      "file_path": "examples/entanglement_distribution_line_topo.py",
      "code": "import logging\n\nfrom qns.network.route.dijkstra import DijkstraRouteAlgorithm\nfrom qns.network.topology.topo import ClassicTopology\nfrom qns.simulator.simulator import Simulator\nfrom qns.network import QuantumNetwork\nfrom qns.network.topology import LineTopology\nimport qns.utils.log as log\nfrom qns.network.protocol.entanglement_distribution import EntanglementDistributionApp\n\n\nlog.logger.setLevel(logging.INFO)\n\n# constrains\ninit_fidelity = 0.99\nnodes_number = 20\nlines_number = 19\nqchannel_delay = 0.05\ncchannel_delay = 0.05\nmemory_capacity = 50\nsend_rate = 10\n\nnodes_number = 10\nfor nodes_number in range(2, 21):\n    result = []\n    for delay in [0.1, 0.07, 0.05, 0.03]:\n        s = Simulator(0, 30, accuracy=10000000)\n        log.install(s)\n        topo = LineTopology(nodes_number=nodes_number,\n                            qchannel_args={\"delay\": delay},\n                            cchannel_args={\"delay\": delay},\n                            memory_args=[{\n                                \"capacity\": memory_capacity,\n                                \"decoherence_rate\": 0.2}],\n                            nodes_apps=[EntanglementDistributionApp(init_fidelity=init_fidelity)])\n\n        net = QuantumNetwork(\n            topo=topo, classic_topo=ClassicTopology.All, route=DijkstraRouteAlgorithm())\n        net.build_route()\n\n        src = net.get_node(\"n1\")\n        dst = net.get_node(f\"n{nodes_number}\")\n        net.add_request(src=src, dest=dst, attr={\"send_rate\": send_rate})\n        net.install(s)\n        s.run()\n        result.append(dst.apps[-1].success[0].fidelity)\n    log.monitor(f\"{nodes_number} {result[0]} {result[1]} {result[2]} {result[3]}\")\n"
    },
    {
      "file_path": "examples/entanglement_distribution_random_topo.py",
      "code": "import logging\n\nfrom qns.network.route.dijkstra import DijkstraRouteAlgorithm\nfrom qns.network.topology.topo import ClassicTopology\nfrom qns.simulator.simulator import Simulator\nfrom qns.network import QuantumNetwork\nfrom qns.network.topology import RandomTopology\nimport qns.utils.log as log\nfrom qns.utils.rnd import set_seed\nfrom qns.network.protocol.entanglement_distribution import EntanglementDistributionApp\n\n# constrains\ninit_fidelity = 0.99\nnodes_number = 150\nlines_number = 450\nqchannel_delay = 0.05\ncchannel_delay = 0.05\nmemory_capacity = 50\nsend_rate = 10\nrequests_number = 10\n\nlog.logger.setLevel(logging.INFO)\n\nfor requests_number in [10, 20, 30, 40]:\n    for nodes_number in range(20, 201, 10):\n        lines_number = 3 * nodes_number\n        # set a fixed random seed\n        set_seed(100)\n        s = Simulator(0, 10, accuracy=1000000)\n        log.install(s)\n\n        topo = RandomTopology(nodes_number=nodes_number,\n                              lines_number=lines_number,\n                              qchannel_args={\"delay\": qchannel_delay},\n                              cchannel_args={\"delay\": cchannel_delay},\n                              memory_args=[{\"capacity\": memory_capacity}],\n                              nodes_apps=[EntanglementDistributionApp(init_fidelity=init_fidelity)])\n\n        net = QuantumNetwork(\n            topo=topo, classic_topo=ClassicTopology.All, route=DijkstraRouteAlgorithm())\n\n        net.build_route()\n        try:\n            net.random_requests(requests_number, attr={\"send_rate\": send_rate})\n        except Exception:\n            continue\n        net.install(s)\n\n        s.run()\n        results = []\n        for req in net.requests:\n            src = req.src\n            results.append(src.apps[0].success_count)\n        fair = sum(results)**2 / (len(results) * sum([r**2 for r in results]))\n        log.monitor(requests_number, nodes_number, s.time_spend, sep=\" \")\n"
    },
    {
      "file_path": "examples/entanglement_swapping.py",
      "code": "from qns.models.qubit.qubit import Qubit\nfrom qns.models.qubit.gate import H, CNOT, X, Z\nfrom qns.models.qubit.const import QUBIT_STATE_0\n\nq0 = Qubit(state=QUBIT_STATE_0, name=\"q0\")\nq1 = Qubit(state=QUBIT_STATE_0, name=\"q1\")\n\nq2 = Qubit(state=QUBIT_STATE_0, name=\"q2\")\nq3 = Qubit(state=QUBIT_STATE_0, name=\"q3\")\n\n# entangle q0 and q1\nH(q0)\nCNOT(q0, q1)\n\n# entangle q2 and q3\nH(q2)\nCNOT(q2, q3)\n\n# entanglement swapping\nCNOT(q1, q2)\nH(q1)\n\n# measure q2 and q1\nc0 = q2.measure()\nc1 = q1.measure()\n\nif c0 == 1 and c1 == 0:\n    X(q3)\nelif c0 == 0 and c1 == 1:\n    Z(q3)\nelif c0 == 1 and c1 == 1:\n    X(q3)\n    Z(q3)\n\n# now q0 and q3 are entangled\nassert (q0.measure() == q3.measure())\n"
    },
    {
      "file_path": "examples/parallel_experiments.py",
      "code": "from qns.utils.multiprocess import MPSimulations\nfrom qns.network.route.dijkstra import DijkstraRouteAlgorithm\nfrom qns.network.topology.topo import ClassicTopology\nfrom qns.simulator.simulator import Simulator\nfrom qns.network import QuantumNetwork\nfrom qns.network.topology import LineTopology\nfrom qns.network.protocol.entanglement_distribution import EntanglementDistributionApp\n\n\nclass EPRDistributionSimulation(MPSimulations):\n    def run(self, setting):\n        nodes_number = setting[\"nodes_number\"]\n        delay = setting[\"delay\"]\n        memory_capacity = setting[\"memory_capacity\"]\n        send_rate = setting[\"send_rate\"]\n        s = Simulator(0, 10, accuracy=10000000)\n        topo = LineTopology(nodes_number=nodes_number,\n                            qchannel_args={\"delay\": delay, \"drop_rate\": 0.3},\n                            cchannel_args={\"delay\": delay},\n                            memory_args={\n                                \"capacity\": memory_capacity,\n                                \"store_error_model_args\": {\"a\": 0.2}},\n                            nodes_apps=[EntanglementDistributionApp(init_fidelity=0.99)])\n\n        net = QuantumNetwork(\n            topo=topo, classic_topo=ClassicTopology.All, route=DijkstraRouteAlgorithm())\n        net.build_route()\n\n        src = net.get_node(\"n1\")\n        dst = net.get_node(f\"n{nodes_number}\")\n        net.add_request(src=src, dest=dst, attr={\"send_rate\": send_rate})\n        net.install(s)\n        s.run()\n        return {\"count\": src.apps[0].success_count}\n\n\nif __name__ == \"__main__\":\n    ss = EPRDistributionSimulation(settings={\n        \"nodes_number\": [5, 10, 15, 20, 25, 30],\n        \"delay\": [0.05],\n        \"memory_capacity\": [10, 20, 30],\n        \"send_rate\": [1000, 2000]\n    }, aggregate=True, iter_count=10, cores=20)\n    ss.start()\n    print(ss.get_data())\n"
    },
    {
      "file_path": "examples/simple_bb84.py",
      "code": "from qns.entity.cchannel.cchannel import ClassicChannel\nfrom qns.entity.qchannel.qchannel import QuantumChannel\nfrom qns.entity import QNode\nfrom qns.simulator.simulator import Simulator\nfrom qns.network.protocol.bb84 import BB84RecvApp, BB84SendApp, KEY_BLOCK_SIZE\nimport numpy as np\n\nlight_speed = 299791458\n\n\ndef drop_rate(length):\n    # drop 0.2 db/KM\n    return 1 - np.exp(- length / 50000)\n\n\nfor length in [1000, 5000, 10000, 50000, 100000, 150000]:\n    results = []\n    for i in range(10):\n        s = Simulator(0, 10, accuracy=10000000000)\n        n1 = QNode(name=\"n1\")\n        n2 = QNode(name=\"n2\")\n\n        qlink = QuantumChannel(name=\"l1\", delay=length / light_speed,\n                               drop_rate=drop_rate(length))\n\n        clink = ClassicChannel(name=\"c1\", delay=length / light_speed)\n\n        n1.add_cchannel(clink)\n        n2.add_cchannel(clink)\n        n1.add_qchannel(qlink)\n        n2.add_qchannel(qlink)\n\n        sp = BB84SendApp(n2, qlink, clink, send_rate=1000)\n        rp = BB84RecvApp(n1, qlink, clink)\n        n1.add_apps(sp)\n        n2.add_apps(rp)\n\n        n1.install(s)\n        n2.install(s)\n\n        s.run()\n        results.append(len(sp.key_pool)*KEY_BLOCK_SIZE / 10)\n        print(\"length\", length, \"sp key block num\", len(sp.key_pool))\n        print(\"length\", length, \"rp key block num\", len(rp.key_pool))\n    print(length, np.mean(results), np.std(results))\n"
    },
    {
      "file_path": "examples/trusted_relay_bb84.py",
      "code": "from qns.network.topology.topo import ClassicTopology\nfrom qns.simulator.simulator import Simulator\nfrom qns.network import QuantumNetwork\nfrom qns.network.topology import LineTopology\nfrom qns.network.protocol.bb84 import BB84RecvApp, BB84SendApp\n\nimport numpy as np\n\nlight_speed = 299791458\ntotal_length = 100000\n\n\ndef drop_rate(length):\n    # drop 0.2 db/KM\n    return 1 - np.exp(- length / 50000)\n\n\nfor num in [2, 3, 4, 5, 6]:\n    results = []\n    for i in range(10):\n        length = total_length / (num - 1)\n        s = Simulator(0, 10, accuracy=10000000000)\n\n        topo = LineTopology(num, nodes_apps=[], qchannel_args={\n                            \"delay\": length / light_speed,\n                            \"drop_rate\": drop_rate(length)},\n                            cchannel_args={\"delay\": length / light_speed})\n\n        net = QuantumNetwork(topo=topo, classic_topo=ClassicTopology.Follow)\n\n        rps = []\n        for qchannel in net.qchannels:\n            (src, dst) = qchannel.node_list\n            cchannel = None\n            for c in net.cchannels:\n                if c.name == f\"c-{qchannel.name}\":\n                    cchannel = c\n            assert (cchannel is not None)\n\n            sp = BB84SendApp(dst, qchannel, cchannel, send_rate=1000)\n            rp = BB84RecvApp(src, qchannel, cchannel)\n            src.add_apps(sp)\n            dst.add_apps(rp)\n            rps.append(rp)\n\n        for n in net.nodes:\n            n.install(s)\n        s.run()\n        rets = [len(rp.succ_key_pool) / 10 for rp in rps]\n        results.append(min(rets))\n    print(num, np.mean(results), np.std(results))\n"
    }
  ]
}