{
  "repo_name": "QiuYukang/5G-LENA",
  "github_url": "https://github.com/QiuYukang/5G-LENA",
  "readme": "<!--\nCopyright (c) 2022 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n\nSPDX-License-Identifier: GPL-2.0-only\n-->\n\n[![REUSE status](https://api.reuse.software/badge/gitlab.com/cttc-lena/nr)](https://api.reuse.software/info/gitlab.com/cttc-lena/nr)\n[![DOI](https://zenodo.org/badge/DOI/10.5281/zenodo.7780747.svg)](https://doi.org/10.5281/zenodo.7780747)\n\n# 3GPP NR ns-3 module #\n\nThis is an [ns-3](https://www.nsnam.org \"ns-3 Website\") NR module for the\nsimulation of 3GPP NR non-standalone cellular networks. ns-3 is used as a base\nsimulator, on top of which can be added our NR module as plug-in.\n\n## ns-3 + NR prerequisites\n\n### ns-3 prerequisites:\n\nMake sure to install all [ns-3 preresquisites](https://www.nsnam.org/wiki/Installation#Prerequisites).\n\n### NR prerequisites:\n\nInstall libc6-dev (it provides `semaphore.h` header file):\n\n```\nsudo apt-get install libc6-dev\n```\n\nInstall sqlite:\n\n```\napt-get install sqlite sqlite3 libsqlite3-dev\n```\n\nNotice that ns-3 and nr prerequisites are required (otherwise you will get an error, e.g: `fatal error: ns3/sqlite-output.h`).\n\n## ns-3 + nr installation\n\n###  Download ns-3:\n\n```\ngit clone https://gitlab.com/nsnam/ns-3-dev.git\ncd ns-3-dev\n```\n\n### Download the NR module:\n\n```\ncd contrib\ngit clone https://gitlab.com/cttc-lena/nr.git\n```\n\nNotice that since these are two independent git repositories, when you run\n`git status` inside of the ns-3, you will notice that the contrib/nr\ndirectory will be listed as \"Untracked files\". This is normal.\n\n### Switch to the latest NR release branch:\n\nCheckout the latest NR release branch (usually the branch with the highest version\nnumber, to list git branches run `git branch -r`). For example, for NR Release v2.2 run:\n\n```\ncd nr\ngit checkout 5g-lena-v2.5.y\n```\n\n### Switch to the recommended ns-3 release branch:\n\nCheck in the [NR RELEASE_NOTES.md Supported platforms](https://gitlab.com/cttc-lena/nr/-/blob/master/RELEASE_NOTES.md#supported-platforms) which is the recommended ns-3 release, and then check out the corresponding ns-3 release branch.\nFor example, if the NR RELEASE_NOTES.md indicates that the recommended ns-3 release is \".39\" you can run:\n\n```\ncd ../..\ngit checkout ns-3.38\n```\n\nFor a quicker reference we provide a table with the supported versions of ns-3-dev\nfor each NR release.\n\n| NR version     | ns-3 version | Build system  |\n| :------------: | :-----------:| :-----------: |\n| 5g-lena-v2.5.y | ns-3.39      | cmake         |\n| 5g-lena-v2.4.y | ns-3.38      | cmake         |\n| 5g-lena-v2.3.y | ns-3.37      | cmake         |\n| 5g-lena-v2.2.y | ns-3.36.1    | cmake         |\n| 5g-lena-v2.1.y | ns-3.36      | cmake         |\n| 5g-lena-v2.0.y | ns-3.36      | cmake         |\n| 5g-lena-v1.3.y | ns-3.35      | waf           |\n\n\n### Test ns-3 + nr installation:\n\nLet's configure the ns-3 + NR project:\n\n```\n./ns3 configure --enable-examples --enable-tests\n```\n\nIn the output you should see: `SQLite support: ON`.\n\nIf that is not the case, return to \"ns-3 and NR prerequisites\" section, and install all prerequisites. After the installation of the missing packages run again `./ns3 configure --enable-tests --enable-examples`.\n\nTo compile the ns-3 with NR you can run the following command:\n\n```\n./ns3\n```\n\nIf the NR module is recognized correctly, you should see \"nr\" in the list of\nbuilt modules. If that is the case, _Welcome to the NR world !_\n\nFurther instructions on how to run the examples are given in the [Getting Started instructions](https://cttc-lena.gitlab.io/nr/html/getting-started.html).\n\n## Upgrading 5G-LENA\n\nWe assume that your work lives in a separate branch, and that the 'master'\nbranch of the NR repository is left untouched as the first time you downloaded\nit. If it is not the case, then please move all your work in a separate branch.\n\nA vanilla 'master' branch can be updated by simply running:\n\n```\ncd ns-3-dev/contrib/nr    # or src/nr if the module lives under src/\ngit checkout master\ngit pull\n```\n\n## Documentation\n\nWe maintain two sources of documentation:\n\n1. [The user manual](https://cttc-lena.gitlab.io/nr/nrmodule.pdf) describes the models and their assumptions; as\nwe developed the module while the 3GPP standard was not fully available, some parts\nare not modeling precisely the procedures as indicated by the standard.\n\n2. [The Doxygen](https://cttc-lena.gitlab.io/nr/html/), you will find details about design\nand user usage of any class of the module, as well as description and\nimages for the examples and the tests.\n\n\n\n### Building documentation\n\nIf you would like to build the documentation on your own, you can follow the\ninstructions from this section.\n\n- To build the user manual, navigate to the nr folder and then:\n\n```\ncd doc\nmake latexpdf\n```\n\nAnd you will find the PDF user manual in the directory build/latex. Please note\nthat you may have to install some requirements to build the documentation; you\ncan find the list of packages for any Ubuntu-based distribution in the file\n`.gitlab-ci.yml`.\n\n- To build the doxygen documentation, please do from the nr folder:\n\n```\ngit submodule sync --recursive\ngit submodule update --init --recursive\npython3 doc/m.css/documentation/doxygen.py doc/doxygen-mcss.conf --debug\n```\n\nYou will find the doxygen documentation inside `doc/doc/html/`.\nPlease note that you may need to initialize the m.css submodule, and\nto install some packages like python3.\n\n## Contributions are welcome!\n\nAs you may know, to fund, design, develop and then maintain an\nopen source software for a novel communication technology is a\nchallenging and time expensive task. For this, we would like to\nfoster collaborations with researchers and companies around the globe:\n\n- If you identify a bug, please let us know through the Gitlab issue page;\n- If you have a development plan that you can share, please get in touch with us.\nWe may be able to provide useful suggestions with your design and then maybe your\ncontribution can be more integrated more efficiently and be useful to let the project grow;\n- If you plan to share your code, as the GPLv2 permits, please help us to\nintegrate it so that the work you have done does not become outdated\nand then impossible to merge;\n- The more we are, the better we can do!\n\n## Features\n\nTo see the features, please go to the [official webpage](https://cttc-lena.gitlab.io/5g-lena-website/features/).\n\n## Papers\n\nAn updated list of published papers that are based on the outcome of this\nmodule is available\n[here](https://cttc-lena.gitlab.io/5g-lena-website/papers/).\n\n## About\n\nThe [OpenSim](https://www.cttc.cat/open-simulations-opensim/) research group in CTTC is a group of highly skilled researchers, with expertise in the area of cellular networks, O-RAN, radio resource management, ML/AI based network management, with a focus on the following research lines:\n\n- Developing models, algorithms, and architectures for next-generation virtualized open radio access networks\n- Designing, implementing, validating, and evaluating 5G and beyond extensions in ns-3, including licensed/unlicensed/shared-based access and vehicular communications\n- Deriving 3GPP/IEEE technologies coexistence and spectrum sharing strategies\n- Designing radio resource, interference, and spectrum management techniques.\n\n## Collaborations\n\nContact us if you think that we could collaborate! We are interested in research projects with companies or other research institutions. Our [OpenSim](https://www.cttc.cat/open-simulations-opensim/) research group has gained a vast experience in industrial research projects through many successful projects with some of the top companies in the telecom industry. We also organize secondments for excellent and motivated MSc/PhD students. We can organize tutorials for the academy or industry.\n\n## Authors ##\n\nIn alphabetical order:\n\n- Zoraze Ali\n- Biljana Bojovic\n- Lorenza Giupponi\n- Katerina Koutlia\n- Sandra Lagen\n- Natale Patriciello\n\nInspired by [mmWave module by NYU/UniPD](https://github.com/nyuwireless-unipd/ns3-mmwave)\n\n## License ##\n\nThis software is licensed under the terms of the GNU GPLv2, as like as ns-3.\nSee the LICENSE file for more details.\n",
  "examples": [
    {
      "file_path": "examples/cttc-3gpp-channel-example.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2019 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n/**\n * \\file cttc-3gpp-channel-example.cc\n * \\ingroup examples\n * \\brief Channel Example\n *\n * This example describes how to setup a simulation using the 3GPP channel model\n * from TR 38.900. Topology consists by default of 2 UEs and 2 gNbs, and can be\n * configured to be either mobile or static scenario.\n *\n * The output of this example are default NR trace files that can be found in\n * the root ns-3 project folder.\n */\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-helper.h\"\n#include \"ns3/nr-mac-scheduler-tdma-rr.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/nr-point-to-point-epc-helper.h\"\n#include \"ns3/point-to-point-helper.h\"\n#include <ns3/antenna-module.h>\n#include <ns3/buildings-helper.h>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    std::string scenario = \"UMa\"; // scenario\n    double frequency = 28e9;      // central frequency\n    double bandwidth = 100e6;     // bandwidth\n    double mobility = false;      // whether to enable mobility\n    double simTime = 1;           // in second\n    double speed = 1;             // in m/s for walking UT.\n    bool logging = true; // whether to enable logging from the simulation, another option is by\n                         // exporting the NS_LOG environment variable\n    double hBS;          // base station antenna height in meters\n    double hUT;          // user antenna height in meters\n    double txPower = 40; // txPower\n    enum BandwidthPartInfo::Scenario scenarioEnum = BandwidthPartInfo::UMa;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"scenario\",\n                 \"The scenario for the simulation. Choose among 'RMa', 'UMa', 'UMi-StreetCanyon', \"\n                 \"'InH-OfficeMixed', 'InH-OfficeOpen'.\",\n                 scenario);\n    cmd.AddValue(\"frequency\", \"The central carrier frequency in Hz.\", frequency);\n    cmd.AddValue(\"mobility\",\n                 \"If set to 1 UEs will be mobile, when set to 0 UE will be static. By default, \"\n                 \"they are mobile.\",\n                 mobility);\n    cmd.AddValue(\"logging\", \"If set to 0, log components will be disabled.\", logging);\n    cmd.Parse(argc, argv);\n\n    // enable logging\n    if (logging)\n    {\n        // LogComponentEnable (\"ThreeGppSpectrumPropagationLossModel\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"ThreeGppPropagationLossModel\", LOG_LEVEL_ALL);\n        // LogComponentEnable (\"ThreeGppChannelModel\", LOG_LEVEL_ALL);\n        // LogComponentEnable (\"ChannelConditionModel\", LOG_LEVEL_ALL);\n        // LogComponentEnable (\"UdpClient\", LOG_LEVEL_INFO);\n        // LogComponentEnable (\"UdpServer\", LOG_LEVEL_INFO);\n        // LogComponentEnable (\"LteRlcUm\", LOG_LEVEL_LOGIC);\n        // LogComponentEnable (\"LtePdcp\", LOG_LEVEL_INFO);\n    }\n\n    /*\n     * Default values for the simulation. We are progressively removing all\n     * the instances of SetDefault, but we need it for legacy code (LTE)\n     */\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n\n    // set mobile device and base station antenna heights in meters, according to the chosen\n    // scenario\n    if (scenario == \"RMa\")\n    {\n        hBS = 35;\n        hUT = 1.5;\n        scenarioEnum = BandwidthPartInfo::RMa;\n    }\n    else if (scenario == \"UMa\")\n    {\n        hBS = 25;\n        hUT = 1.5;\n        scenarioEnum = BandwidthPartInfo::UMa;\n    }\n    else if (scenario == \"UMi-StreetCanyon\")\n    {\n        hBS = 10;\n        hUT = 1.5;\n        scenarioEnum = BandwidthPartInfo::UMi_StreetCanyon;\n    }\n    else if (scenario == \"InH-OfficeMixed\")\n    {\n        hBS = 3;\n        hUT = 1;\n        scenarioEnum = BandwidthPartInfo::InH_OfficeMixed;\n    }\n    else if (scenario == \"InH-OfficeOpen\")\n    {\n        hBS = 3;\n        hUT = 1;\n        scenarioEnum = BandwidthPartInfo::InH_OfficeOpen;\n    }\n    else\n    {\n        NS_ABORT_MSG(\"Scenario not supported. Choose among 'RMa', 'UMa', 'UMi-StreetCanyon', \"\n                     \"'InH-OfficeMixed', and 'InH-OfficeOpen'.\");\n    }\n\n    // create base stations and mobile terminals\n    NodeContainer enbNodes;\n    NodeContainer ueNodes;\n    enbNodes.Create(2);\n    ueNodes.Create(2);\n\n    // position the base stations\n    Ptr<ListPositionAllocator> enbPositionAlloc = CreateObject<ListPositionAllocator>();\n    enbPositionAlloc->Add(Vector(0.0, 0.0, hBS));\n    enbPositionAlloc->Add(Vector(0.0, 80.0, hBS));\n    MobilityHelper enbmobility;\n    enbmobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    enbmobility.SetPositionAllocator(enbPositionAlloc);\n    enbmobility.Install(enbNodes);\n\n    // position the mobile terminals and enable the mobility\n    MobilityHelper uemobility;\n    uemobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    uemobility.Install(ueNodes);\n\n    if (mobility)\n    {\n        ueNodes.Get(0)->GetObject<MobilityModel>()->SetPosition(\n            Vector(90, 15, hUT)); // (x, y, z) in m\n        ueNodes.Get(0)->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(\n            Vector(0, speed, 0)); // move UE1 along the y axis\n\n        ueNodes.Get(1)->GetObject<MobilityModel>()->SetPosition(\n            Vector(30, 50.0, hUT)); // (x, y, z) in m\n        ueNodes.Get(1)->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(\n            Vector(-speed, 0, 0)); // move UE2 along the x axis\n    }\n    else\n    {\n        ueNodes.Get(0)->GetObject<MobilityModel>()->SetPosition(Vector(90, 15, hUT));\n        ueNodes.Get(0)->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(0, 0, 0));\n\n        ueNodes.Get(1)->GetObject<MobilityModel>()->SetPosition(Vector(30, 50.0, hUT));\n        ueNodes.Get(1)->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(0, 0, 0));\n    }\n\n    /*\n     * Create NR simulation helpers\n     */\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    /*\n     * Spectrum configuration. We create a single operational band and configure the scenario.\n     */\n    BandwidthPartInfoPtrVector allBwps;\n    CcBwpCreator ccBwpCreator;\n    const uint8_t numCcPerBand = 1; // in this example we have a single band, and that band is\n                                    // composed of a single component carrier\n\n    /* Create the configuration for the CcBwpHelper. SimpleOperationBandConf creates\n     * a single BWP per CC and a single BWP in CC.\n     *\n     * Hence, the configured spectrum is:\n     *\n     * |---------------Band---------------|\n     * |---------------CC-----------------|\n     * |---------------BWP----------------|\n     */\n    CcBwpCreator::SimpleOperationBandConf bandConf(frequency,\n                                                   bandwidth,\n                                                   numCcPerBand,\n                                                   scenarioEnum);\n    OperationBandInfo band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);\n    // Initialize channel and pathloss, plus other things inside band.\n    nrHelper->InitializeOperationBand(&band);\n    allBwps = CcBwpCreator::GetAllBwps({band});\n\n    // Configure ideal beamforming method\n    idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));\n\n    // Configure scheduler\n    nrHelper->SetSchedulerTypeId(NrMacSchedulerTdmaRR::GetTypeId());\n\n    // Antennas for the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(2));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(4));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Antennas for the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(8));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(8));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // install nr net devices\n    NetDeviceContainer enbNetDev = nrHelper->InstallGnbDevice(enbNodes, allBwps);\n    NetDeviceContainer ueNetDev = nrHelper->InstallUeDevice(ueNodes, allBwps);\n\n    int64_t randomStream = 1;\n    randomStream += nrHelper->AssignStreams(enbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);\n\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)->SetTxPower(txPower);\n    nrHelper->GetGnbPhy(enbNetDev.Get(1), 0)->SetTxPower(txPower);\n\n    // When all the configuration is done, explicitly call UpdateConfig ()\n    for (auto it = enbNetDev.Begin(); it != enbNetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.010)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(ueNodes);\n\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));\n\n    // assign IP address to UEs, and install UDP downlink applications\n    uint16_t dlPort = 1234;\n    ApplicationContainer clientApps;\n    ApplicationContainer serverApps;\n    for (uint32_t u = 0; u < ueNodes.GetN(); ++u)\n    {\n        Ptr<Node> ueNode = ueNodes.Get(u);\n        // Set the default gateway for the UE\n        Ptr<Ipv4StaticRouting> ueStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(ueNode->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n\n        UdpServerHelper dlPacketSinkHelper(dlPort);\n        serverApps.Add(dlPacketSinkHelper.Install(ueNodes.Get(u)));\n\n        UdpClientHelper dlClient(ueIpIface.GetAddress(u), dlPort);\n        dlClient.SetAttribute(\"Interval\", TimeValue(MicroSeconds(1)));\n        // dlClient.SetAttribute (\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n        dlClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n        dlClient.SetAttribute(\"PacketSize\", UintegerValue(1500));\n        clientApps.Add(dlClient.Install(remoteHost));\n    }\n\n    // attach UEs to the closest eNB\n    nrHelper->AttachToClosestEnb(ueNetDev, enbNetDev);\n\n    // start server and client apps\n    serverApps.Start(Seconds(0.4));\n    clientApps.Start(Seconds(0.4));\n    serverApps.Stop(Seconds(simTime));\n    clientApps.Stop(Seconds(simTime - 0.2));\n\n    // enable the traces provided by the nr module\n    nrHelper->EnableTraces();\n\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n\n    Ptr<UdpServer> serverApp = serverApps.Get(0)->GetObject<UdpServer>();\n    uint64_t receivedPackets = serverApp->GetReceived();\n\n    Simulator::Destroy();\n\n    if (receivedPackets == 10)\n    {\n        return EXIT_SUCCESS;\n    }\n    else\n    {\n        return EXIT_FAILURE;\n    }\n}\n"
    },
    {
      "file_path": "examples/cttc-3gpp-channel-nums-fdm.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2019 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n/**\n *\n * \\file cttc-3gpp-channel-nums-fdm.cc\n * \\ingroup examples\n * \\brief Frequency division multiplexing example, with TDD and FDD\n *\n * The example is showing how to configure multiple bandwidth parts, in which\n * some of them form a FDD configuration, while others uses TDD. The user\n * can configure the bandwidth and the frequency of these BWPs. Three types\n * of traffic are available: two are DL (video and voice) while one is\n * UL (gaming). Each traffic will be routed to different BWP. Voice will go\n * in the TDD BWP, while video will go in the FDD-DL one, and gaming in the\n * FDD-UL one.\n *\n * The configured spectrum division is the following:\n\\verbatim\n    |------------BandTdd--------------|--------------BandFdd---------------|\n    |------------CC0------------------|--------------CC1-------------------|\n    |------------BWP0-----------------|------BWP1-------|-------BWP2-------|\n\\endverbatim\n * We will configure BWP0 as TDD, BWP1 as FDD-DL, BWP2 as FDD-UL.\n */\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/config-store.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"3gppChannelNumsFdm\");\n\nint\nmain(int argc, char* argv[])\n{\n    uint16_t gNbNum = 4;\n    uint16_t ueNum = 4;\n\n    uint32_t udpPacketSizeVideo = 100;\n    uint32_t udpPacketSizeVoice = 1252;\n    uint32_t udpPacketSizeGaming = 500;\n    uint32_t lambdaVideo = 50;\n    uint32_t lambdaVoice = 100;\n    uint32_t lambdaGaming = 250;\n\n    uint32_t simTimeMs = 1400;\n    uint32_t udpAppStartTimeMs = 400;\n\n    double centralFrequencyBand1 = 28e9;\n    double bandwidthBand1 = 100e6;\n    double centralFrequencyBand2 = 28.2e9;\n    double bandwidthBand2 = 100e6;\n    double totalTxPower = 4;\n    std::string simTag = \"default\";\n    std::string outputDir = \"./\";\n    bool enableVideo = true;\n    bool enableVoice = true;\n    bool enableGaming = true;\n\n    CommandLine cmd(__FILE__);\n\n    cmd.AddValue(\"packetSizeVideo\",\n                 \"packet size in bytes to be used by video traffic\",\n                 udpPacketSizeVideo);\n    cmd.AddValue(\"packetSizeVoice\",\n                 \"packet size in bytes to be used by voice traffic\",\n                 udpPacketSizeVoice);\n    cmd.AddValue(\"packetSizeGaming\",\n                 \"packet size in bytes to be used by gaming traffic\",\n                 udpPacketSizeGaming);\n    cmd.AddValue(\"lambdaVideo\",\n                 \"Number of UDP packets in one second for video traffic\",\n                 lambdaVideo);\n    cmd.AddValue(\"lambdaVoice\",\n                 \"Number of UDP packets in one second for voice traffic\",\n                 lambdaVoice);\n    cmd.AddValue(\"lambdaGaming\",\n                 \"Number of UDP packets in one second for gaming traffic\",\n                 lambdaGaming);\n    cmd.AddValue(\"enableVideo\", \"If true, enables video traffic transmission (DL)\", enableVideo);\n    cmd.AddValue(\"enableVoice\", \"If true, enables voice traffic transmission (DL)\", enableVoice);\n    cmd.AddValue(\"enableGaming\", \"If true, enables gaming traffic transmission (UL)\", enableGaming);\n    cmd.AddValue(\"simTimeMs\", \"Simulation time\", simTimeMs);\n    cmd.AddValue(\"centralFrequencyBand1\",\n                 \"The system frequency to be used in band 1\",\n                 centralFrequencyBand1);\n    cmd.AddValue(\"bandwidthBand1\", \"The system bandwidth to be used in band 1\", bandwidthBand1);\n    cmd.AddValue(\"centralFrequencyBand2\",\n                 \"The system frequency to be used in band 2\",\n                 centralFrequencyBand2);\n    cmd.AddValue(\"bandwidthBand2\", \"The system bandwidth to be used in band 2\", bandwidthBand2);\n    cmd.AddValue(\"totalTxPower\",\n                 \"total tx power that will be proportionally assigned to\"\n                 \" bands, CCs and bandwidth parts depending on each BWP bandwidth \",\n                 totalTxPower);\n    cmd.AddValue(\"simTag\",\n                 \"tag to be appended to output filenames to distinguish simulation campaigns\",\n                 simTag);\n    cmd.AddValue(\"outputDir\", \"directory where to store simulation results\", outputDir);\n\n    cmd.Parse(argc, argv);\n\n    NS_ABORT_IF(centralFrequencyBand1 > 100e9);\n    NS_ABORT_IF(centralFrequencyBand2 > 100e9);\n\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n\n    int64_t randomStream = 1;\n\n    GridScenarioHelper gridScenario;\n    gridScenario.SetRows(gNbNum / 2);\n    gridScenario.SetColumns(gNbNum);\n    gridScenario.SetHorizontalBsDistance(5.0);\n    gridScenario.SetBsHeight(10.0);\n    gridScenario.SetUtHeight(1.5);\n    // must be set before BS number\n    gridScenario.SetSectorization(GridScenarioHelper::SINGLE);\n    gridScenario.SetBsNumber(gNbNum);\n    gridScenario.SetUtNumber(ueNum);\n    gridScenario.SetScenarioHeight(3); // Create a 3x3 scenario where the UE will\n    gridScenario.SetScenarioLength(3); // be distribuited.\n    randomStream += gridScenario.AssignStreams(randomStream);\n    gridScenario.CreateScenario();\n\n    /*\n     * TODO: Add a print, or a plot, that shows the scenario.\n     */\n\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n\n    // Put the pointers inside nrHelper\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    BandwidthPartInfoPtrVector allBwps;\n    CcBwpCreator ccBwpCreator;\n    const uint8_t numCcPerBand = 1; // in this example, both bands have a single CC\n\n    CcBwpCreator::SimpleOperationBandConf bandConfTdd(centralFrequencyBand1,\n                                                      bandwidthBand1,\n                                                      numCcPerBand,\n                                                      BandwidthPartInfo::UMi_StreetCanyon);\n    CcBwpCreator::SimpleOperationBandConf bandConfFdd(centralFrequencyBand2,\n                                                      bandwidthBand2,\n                                                      numCcPerBand,\n                                                      BandwidthPartInfo::UMi_StreetCanyon);\n\n    bandConfFdd.m_numBwp = 2; // Here, bandFdd will have 2 BWPs\n\n    // By using the configuration created, it is time to make the operation bands\n    OperationBandInfo bandTdd = ccBwpCreator.CreateOperationBandContiguousCc(bandConfTdd);\n    OperationBandInfo bandFdd = ccBwpCreator.CreateOperationBandContiguousCc(bandConfFdd);\n\n    /*\n     * The configured spectrum division is:\n     * |------------BandTdd--------------|--------------BandFdd---------------|\n     * |------------CC0------------------|--------------CC1-------------------|\n     * |------------BWP0-----------------|------BWP1-------|-------BWP2-------|\n     *\n     * We will configure BWP0 as TDD, BWP1 as FDD-DL, BWP2 as FDD-UL.\n     */\n\n    /*\n     * Attributes of ThreeGppChannelModel still cannot be set in our way.\n     * TODO: Coordinate with Tommaso\n     */\n    Config::SetDefault(\"ns3::ThreeGppChannelModel::UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetChannelConditionModelAttribute(\"UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n\n    nrHelper->InitializeOperationBand(&bandTdd);\n    nrHelper->InitializeOperationBand(&bandFdd);\n    allBwps = CcBwpCreator::GetAllBwps({bandTdd, bandFdd});\n\n    // Beamforming method\n    idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));\n\n    // Core latency\n    epcHelper->SetAttribute(\"S1uLinkDelay\", TimeValue(MilliSeconds(0)));\n\n    // Antennas for all the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(2));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(4));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Antennas for all the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(4));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(8));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    nrHelper->SetGnbPhyAttribute(\"TxPower\", DoubleValue(4.0));\n\n    uint32_t bwpIdForVoice = 0;\n    uint32_t bwpIdForVideo = 1;\n    uint32_t bwpIdForGaming = 2;\n\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"GBR_CONV_VOICE\", UintegerValue(bwpIdForVoice));\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"GBR_CONV_VIDEO\", UintegerValue(bwpIdForVideo));\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"GBR_GAMING\", UintegerValue(bwpIdForGaming));\n\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"GBR_CONV_VOICE\", UintegerValue(bwpIdForVoice));\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"GBR_CONV_VIDEO\", UintegerValue(bwpIdForVideo));\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"GBR_GAMING\", UintegerValue(bwpIdForGaming));\n\n    NetDeviceContainer enbNetDev =\n        nrHelper->InstallGnbDevice(gridScenario.GetBaseStations(), allBwps);\n    NetDeviceContainer ueNetDev =\n        nrHelper->InstallUeDevice(gridScenario.GetUserTerminals(), allBwps);\n\n    randomStream += nrHelper->AssignStreams(enbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);\n\n    NS_ASSERT(enbNetDev.GetN() == 4);\n\n    // -------------- First GNB:\n\n    // BWP0, the TDD one\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)->SetAttribute(\"Numerology\", UintegerValue(0));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)\n        ->SetAttribute(\"Pattern\", StringValue(\"F|F|F|F|F|F|F|F|F|F|\"));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)->SetAttribute(\"TxPower\", DoubleValue(4.0));\n\n    // BWP1, FDD-DL\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)->SetAttribute(\"Numerology\", UintegerValue(0));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)\n        ->SetAttribute(\"Pattern\", StringValue(\"DL|DL|DL|DL|DL|DL|DL|DL|DL|DL|\"));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)->SetAttribute(\"TxPower\", DoubleValue(4.0));\n\n    // BWP2, FDD-UL\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)->SetAttribute(\"Numerology\", UintegerValue(0));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)\n        ->SetAttribute(\"Pattern\", StringValue(\"UL|UL|UL|UL|UL|UL|UL|UL|UL|UL|\"));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)->SetAttribute(\"TxPower\", DoubleValue(0.0));\n\n    // Link the two FDD BWP:\n    nrHelper->GetBwpManagerGnb(enbNetDev.Get(0))->SetOutputLink(2, 1);\n\n    // -------------- Second GNB:\n\n    // BWP0, the TDD one\n    nrHelper->GetGnbPhy(enbNetDev.Get(1), 0)->SetAttribute(\"Numerology\", UintegerValue(1));\n    nrHelper->GetGnbPhy(enbNetDev.Get(1), 0)\n        ->SetAttribute(\"Pattern\", StringValue(\"F|F|F|F|F|F|F|F|F|F|\"));\n    nrHelper->GetGnbPhy(enbNetDev.Get(1), 0)->SetAttribute(\"TxPower\", DoubleValue(4.0));\n\n    // BWP1, FDD-DL\n    nrHelper->GetGnbPhy(enbNetDev.Get(1), 1)->SetAttribute(\"Numerology\", UintegerValue(1));\n    nrHelper->GetGnbPhy(enbNetDev.Get(1), 1)\n        ->SetAttribute(\"Pattern\", StringValue(\"DL|DL|DL|DL|DL|DL|DL|DL|DL|DL|\"));\n    nrHelper->GetGnbPhy(enbNetDev.Get(1), 1)->SetAttribute(\"TxPower\", DoubleValue(4.0));\n\n    // BWP2, FDD-UL\n    nrHelper->GetGnbPhy(enbNetDev.Get(1), 2)->SetAttribute(\"Numerology\", UintegerValue(1));\n    nrHelper->GetGnbPhy(enbNetDev.Get(1), 2)\n        ->SetAttribute(\"Pattern\", StringValue(\"UL|UL|UL|UL|UL|UL|UL|UL|UL|UL|\"));\n    nrHelper->GetGnbPhy(enbNetDev.Get(1), 2)->SetAttribute(\"TxPower\", DoubleValue(0.0));\n\n    // Link the two FDD BWP:\n    nrHelper->GetBwpManagerGnb(enbNetDev.Get(1))->SetOutputLink(2, 1);\n\n    // -------------- Third GNB:\n\n    // BWP0, the TDD one\n    nrHelper->GetGnbPhy(enbNetDev.Get(2), 0)->SetAttribute(\"Numerology\", UintegerValue(2));\n    nrHelper->GetGnbPhy(enbNetDev.Get(2), 0)\n        ->SetAttribute(\"Pattern\", StringValue(\"F|F|F|F|F|F|F|F|F|F|\"));\n    nrHelper->GetGnbPhy(enbNetDev.Get(2), 0)->SetAttribute(\"TxPower\", DoubleValue(4.0));\n\n    // BWP1, FDD-DL\n    nrHelper->GetGnbPhy(enbNetDev.Get(2), 1)->SetAttribute(\"Numerology\", UintegerValue(2));\n    nrHelper->GetGnbPhy(enbNetDev.Get(2), 1)\n        ->SetAttribute(\"Pattern\", StringValue(\"DL|DL|DL|DL|DL|DL|DL|DL|DL|DL|\"));\n    nrHelper->GetGnbPhy(enbNetDev.Get(2), 1)->SetAttribute(\"TxPower\", DoubleValue(4.0));\n\n    // BWP2, FDD-UL\n    nrHelper->GetGnbPhy(enbNetDev.Get(2), 2)->SetAttribute(\"Numerology\", UintegerValue(2));\n    nrHelper->GetGnbPhy(enbNetDev.Get(2), 2)\n        ->SetAttribute(\"Pattern\", StringValue(\"UL|UL|UL|UL|UL|UL|UL|UL|UL|UL|\"));\n    nrHelper->GetGnbPhy(enbNetDev.Get(2), 2)->SetAttribute(\"TxPower\", DoubleValue(0.0));\n\n    // Link the two FDD BWP:\n    nrHelper->GetBwpManagerGnb(enbNetDev.Get(2))->SetOutputLink(2, 1);\n\n    // -------------- Fourth GNB:\n\n    // BWP0, the TDD one\n    nrHelper->GetGnbPhy(enbNetDev.Get(3), 0)->SetAttribute(\"Numerology\", UintegerValue(3));\n    nrHelper->GetGnbPhy(enbNetDev.Get(3), 0)\n        ->SetAttribute(\"Pattern\", StringValue(\"F|F|F|F|F|F|F|F|F|F|\"));\n    nrHelper->GetGnbPhy(enbNetDev.Get(3), 0)->SetAttribute(\"TxPower\", DoubleValue(4.0));\n\n    // BWP1, FDD-DL\n    nrHelper->GetGnbPhy(enbNetDev.Get(3), 1)->SetAttribute(\"Numerology\", UintegerValue(3));\n    nrHelper->GetGnbPhy(enbNetDev.Get(3), 1)\n        ->SetAttribute(\"Pattern\", StringValue(\"DL|DL|DL|DL|DL|DL|DL|DL|DL|DL|\"));\n    nrHelper->GetGnbPhy(enbNetDev.Get(3), 1)->SetAttribute(\"TxPower\", DoubleValue(4.0));\n\n    // BWP2, FDD-UL\n    nrHelper->GetGnbPhy(enbNetDev.Get(3), 2)->SetAttribute(\"Numerology\", UintegerValue(3));\n    nrHelper->GetGnbPhy(enbNetDev.Get(3), 2)\n        ->SetAttribute(\"Pattern\", StringValue(\"UL|UL|UL|UL|UL|UL|UL|UL|UL|UL|\"));\n    nrHelper->GetGnbPhy(enbNetDev.Get(3), 2)->SetAttribute(\"TxPower\", DoubleValue(0.0));\n\n    // Link the two FDD BWP:\n    nrHelper->GetBwpManagerGnb(enbNetDev.Get(3))->SetOutputLink(2, 1);\n\n    // Set the UE routing:\n\n    for (uint32_t i = 0; i < ueNetDev.GetN(); i++)\n    {\n        nrHelper->GetBwpManagerUe(ueNetDev.Get(i))->SetOutputLink(1, 2);\n    }\n\n    // When all the configuration is done, explicitly call UpdateConfig ()\n\n    for (auto it = enbNetDev.Begin(); it != enbNetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    // From here, it is standard NS3. In the future, we will create helpers\n    // for this part as well.\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.000)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(gridScenario.GetUserTerminals());\n\n    Ipv4InterfaceContainer ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));\n\n    // Set the default gateway for the UEs\n    for (uint32_t j = 0; j < gridScenario.GetUserTerminals().GetN(); ++j)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting = ipv4RoutingHelper.GetStaticRouting(\n            gridScenario.GetUserTerminals().Get(j)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // Fix the attachment of the UEs: UE_i attached to GNB_i\n    for (uint32_t i = 0; i < ueNetDev.GetN(); ++i)\n    {\n        auto enbDev = DynamicCast<NrGnbNetDevice>(enbNetDev.Get(i));\n        auto ueDev = DynamicCast<NrUeNetDevice>(ueNetDev.Get(i));\n        NS_ASSERT(enbDev != nullptr);\n        NS_ASSERT(ueDev != nullptr);\n        nrHelper->AttachToEnb(ueDev, enbDev);\n    }\n\n    /*\n     * Traffic part. Install two kind of traffic: low-latency and voice, each\n     * identified by a particular source port.\n     */\n    uint16_t dlPortVideo = 1234;\n    uint16_t dlPortVoice = 1235;\n    uint16_t ulPortGaming = 1236;\n\n    ApplicationContainer serverApps;\n\n    // The sink will always listen to the specified ports\n    UdpServerHelper dlPacketSinkVideo(dlPortVideo);\n    UdpServerHelper dlPacketSinkVoice(dlPortVoice);\n    UdpServerHelper ulPacketSinkVoice(ulPortGaming);\n\n    // The server, that is the application which is listening, is installed in the UE\n    // for the DL traffic, and in the remote host for the UL traffic\n    serverApps.Add(dlPacketSinkVideo.Install(gridScenario.GetUserTerminals()));\n    serverApps.Add(dlPacketSinkVoice.Install(gridScenario.GetUserTerminals()));\n    serverApps.Add(ulPacketSinkVoice.Install(remoteHost));\n\n    /*\n     * Configure attributes for the different generators, using user-provided\n     * parameters for generating a CBR traffic\n     *\n     * Low-Latency configuration and object creation:\n     */\n    UdpClientHelper dlClientVideo;\n    dlClientVideo.SetAttribute(\"RemotePort\", UintegerValue(dlPortVideo));\n    dlClientVideo.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    dlClientVideo.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSizeVideo));\n    dlClientVideo.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambdaVideo)));\n\n    // The bearer that will carry low latency traffic\n    EpsBearer videoBearer(EpsBearer::GBR_CONV_VIDEO);\n\n    // The filter for the low-latency traffic\n    Ptr<EpcTft> videoTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfVideo;\n    dlpfVideo.localPortStart = dlPortVideo;\n    dlpfVideo.localPortEnd = dlPortVideo;\n    videoTft->Add(dlpfVideo);\n\n    // Voice configuration and object creation:\n    UdpClientHelper dlClientVoice;\n    dlClientVoice.SetAttribute(\"RemotePort\", UintegerValue(dlPortVoice));\n    dlClientVoice.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    dlClientVoice.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSizeVoice));\n    dlClientVoice.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambdaVoice)));\n\n    // The bearer that will carry voice traffic\n    EpsBearer voiceBearer(EpsBearer::GBR_CONV_VOICE);\n\n    // The filter for the voice traffic\n    Ptr<EpcTft> voiceTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfVoice;\n    dlpfVoice.localPortStart = dlPortVoice;\n    dlpfVoice.localPortEnd = dlPortVoice;\n    voiceTft->Add(dlpfVoice);\n\n    // Gaming configuration and object creation:\n    UdpClientHelper ulClientGaming;\n    ulClientGaming.SetAttribute(\"RemotePort\", UintegerValue(ulPortGaming));\n    ulClientGaming.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    ulClientGaming.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSizeGaming));\n    ulClientGaming.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambdaGaming)));\n\n    // The bearer that will carry gaming traffic\n    EpsBearer gamingBearer(EpsBearer::GBR_GAMING);\n\n    // The filter for the gaming traffic\n    Ptr<EpcTft> gamingTft = Create<EpcTft>();\n    EpcTft::PacketFilter ulpfGaming;\n    ulpfGaming.remotePortStart = ulPortGaming;\n    ulpfGaming.remotePortEnd = ulPortGaming;\n    ulpfGaming.direction = EpcTft::UPLINK;\n    gamingTft->Add(ulpfGaming);\n\n    /*\n     * Let's install the applications!\n     */\n    ApplicationContainer clientApps;\n\n    for (uint32_t i = 0; i < gridScenario.GetUserTerminals().GetN(); ++i)\n    {\n        Ptr<Node> ue = gridScenario.GetUserTerminals().Get(i);\n        Ptr<NetDevice> ueDevice = ueNetDev.Get(i);\n        Address ueAddress = ueIpIface.GetAddress(i);\n\n        // The client, who is transmitting, is installed in the remote host,\n        // with destination address set to the address of the UE\n        if (enableVoice)\n        {\n            dlClientVoice.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n            clientApps.Add(dlClientVoice.Install(remoteHost));\n\n            nrHelper->ActivateDedicatedEpsBearer(ueDevice, voiceBearer, voiceTft);\n        }\n\n        if (enableVideo)\n        {\n            dlClientVideo.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n            clientApps.Add(dlClientVideo.Install(remoteHost));\n\n            nrHelper->ActivateDedicatedEpsBearer(ueDevice, videoBearer, videoTft);\n        }\n\n        // For the uplink, the installation happens in the UE, and the remote address\n        // is the one of the remote host\n\n        if (enableGaming)\n        {\n            ulClientGaming.SetAttribute(\"RemoteAddress\",\n                                        AddressValue(internetIpIfaces.GetAddress(1)));\n            clientApps.Add(ulClientGaming.Install(ue));\n\n            nrHelper->ActivateDedicatedEpsBearer(ueDevice, gamingBearer, gamingTft);\n        }\n    }\n\n    // start UDP server and client apps\n    serverApps.Start(MilliSeconds(udpAppStartTimeMs));\n    clientApps.Start(MilliSeconds(udpAppStartTimeMs));\n    serverApps.Stop(MilliSeconds(simTimeMs));\n    clientApps.Stop(MilliSeconds(simTimeMs));\n\n    // enable the traces provided by the nr module\n    // nrHelper->EnableTraces();\n\n    FlowMonitorHelper flowmonHelper;\n    NodeContainer endpointNodes;\n    endpointNodes.Add(remoteHost);\n    endpointNodes.Add(gridScenario.GetUserTerminals());\n\n    Ptr<ns3::FlowMonitor> monitor = flowmonHelper.Install(endpointNodes);\n    monitor->SetAttribute(\"DelayBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"JitterBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"PacketSizeBinWidth\", DoubleValue(20));\n\n    Simulator::Stop(MilliSeconds(simTimeMs));\n    Simulator::Run();\n\n    /*\n     * To check what was installed in the memory, i.e., BWPs of eNb Device, and its configuration.\n     * Example is: Node 1 -> Device 0 -> BandwidthPartMap -> {0,1} BWPs -> NrGnbPhy -> Numerology,\n    GtkConfigStore config;\n    config.ConfigureAttributes ();\n    */\n\n    // Print per-flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier =\n        DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n\n    double averageFlowThroughput = 0.0;\n    double averageFlowDelay = 0.0;\n\n    std::ofstream outFile;\n    std::string filename = outputDir + \"/\" + simTag;\n    outFile.open(filename.c_str(), std::ofstream::out | std::ofstream::trunc);\n    if (!outFile.is_open())\n    {\n        std::cerr << \"Can't open file \" << filename << std::endl;\n        return 1;\n    }\n\n    outFile.setf(std::ios_base::fixed);\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin();\n         i != stats.end();\n         ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        std::stringstream protoStream;\n        protoStream << (uint16_t)t.protocol;\n        if (t.protocol == 6)\n        {\n            protoStream.str(\"TCP\");\n        }\n        if (t.protocol == 17)\n        {\n            protoStream.str(\"UDP\");\n        }\n        outFile << \"Flow \" << i->first << \" (\" << t.sourceAddress << \":\" << t.sourcePort << \" -> \"\n                << t.destinationAddress << \":\" << t.destinationPort << \") proto \"\n                << protoStream.str() << \"\\n\";\n        outFile << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n        outFile << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n        outFile << \"  TxOffered:  \"\n                << i->second.txBytes * 8.0 / ((simTimeMs - udpAppStartTimeMs) / 1000.0) / 1000.0 /\n                       1000.0\n                << \" Mbps\\n\";\n        outFile << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n        if (i->second.rxPackets > 0)\n        {\n            // Measure the duration of the flow from receiver's perspective\n            // double rxDuration = i->second.timeLastRxPacket.GetSeconds () -\n            // i->second.timeFirstTxPacket.GetSeconds ();\n            double rxDuration = (simTimeMs - udpAppStartTimeMs) / 1000.0;\n\n            averageFlowThroughput += i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000;\n            averageFlowDelay += 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;\n\n            outFile << \"  Throughput: \" << i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000\n                    << \" Mbps\\n\";\n            outFile << \"  Mean delay:  \"\n                    << 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n            // outFile << \"  Mean upt:  \" << i->second.uptSum / i->second.rxPackets / 1000/1000 << \"\n            // Mbps \\n\";\n            outFile << \"  Mean jitter:  \"\n                    << 1000 * i->second.jitterSum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n        }\n        else\n        {\n            outFile << \"  Throughput:  0 Mbps\\n\";\n            outFile << \"  Mean delay:  0 ms\\n\";\n            outFile << \"  Mean jitter: 0 ms\\n\";\n        }\n        outFile << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n    }\n\n    double meanFlowThroughput = averageFlowThroughput / stats.size();\n    double meanFlowDelay = averageFlowDelay / stats.size();\n    double throughputTolerance = meanFlowThroughput * 0.001;\n\n    outFile << \"\\n\\n  Mean flow throughput: \" << meanFlowThroughput << \"\\n\";\n    outFile << \"  Mean flow delay: \" << meanFlowDelay << \"\\n\";\n\n    outFile.close();\n\n    std::ifstream f(filename.c_str());\n\n    if (f.is_open())\n    {\n        std::cout << f.rdbuf();\n    }\n\n    Simulator::Destroy();\n\n    // called from examples-to-run.py with all default parameters\n    if (argc == 0 && (meanFlowThroughput < 0.709696 - throughputTolerance ||\n                      meanFlowThroughput > 0.709696 + throughputTolerance))\n    {\n        return EXIT_FAILURE;\n    }\n    else\n    {\n        return EXIT_SUCCESS;\n    }\n}\n"
    },
    {
      "file_path": "examples/cttc-3gpp-channel-nums.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2017 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/config-store.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/point-to-point-module.h\"\n/**\n * \\file cttc-3gpp-channel-nums.cc\n * \\ingroup examples\n * \\brief Simple topology numerologies example.\n *\n * This example allows users to configure the numerology and test the end-to-end\n * performance for different numerologies. In the following figure we illustrate\n * the simulation setup.\n *\n * For example, UDP packet generation rate can be configured by setting\n * \"--lambda=1000\". The numerology can be toggled by the argument,\n * e.g. \"--numerology=1\". Additionally, in this example two arguments\n * are added \"bandwidth\" and \"frequency\", both in Hz units. The modulation\n * scheme of this example is in test mode, and it is fixed to 28.\n *\n * By default, the program uses the 3GPP channel model, without shadowing and with\n * line of sight ('l') option. The program runs for 0.4 seconds and one single\n * packet is to be transmitted. The packet size can be configured by using the\n * following parameter: \"--packetSize=1000\".\n *\n * This simulation prints the output to the terminal and also to the file which\n * is named by default \"cttc-3gpp-channel-nums-fdm-output\" and which is by\n * default placed in the root directory of the project.\n *\n * To run the simulation with the default configuration one shall run the\n * following in the command line:\n *\n * ./ns3 run cttc-3gpp-channel-nums\n *\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"3gppChannelNumerologiesExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // enable logging or not\n    bool logging = false;\n    if (logging)\n    {\n        LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"LtePdcp\", LOG_LEVEL_INFO);\n    }\n\n    // set simulation time and mobility\n    double simTime = 1;           // seconds\n    double udpAppStartTime = 0.4; // seconds\n\n    // other simulation parameters default values\n    uint16_t numerology = 0;\n\n    uint16_t gNbNum = 1;\n    uint16_t ueNumPergNb = 1;\n\n    double centralFrequency = 7e9;\n    double bandwidth = 100e6;\n    double txPower = 14;\n    double lambda = 1000;\n    uint32_t udpPacketSize = 1000;\n    bool udpFullBuffer = true;\n    uint8_t fixedMcs = 28;\n    bool useFixedMcs = true;\n    bool singleUeTopology = true;\n    // Where we will store the output files.\n    std::string simTag = \"default\";\n    std::string outputDir = \"./\";\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"gNbNum\", \"The number of gNbs in multiple-ue topology\", gNbNum);\n    cmd.AddValue(\"ueNumPergNb\", \"The number of UE per gNb in multiple-ue topology\", ueNumPergNb);\n    cmd.AddValue(\"numerology\", \"The numerology to be used.\", numerology);\n    cmd.AddValue(\"txPower\", \"Tx power to be configured to gNB\", txPower);\n    cmd.AddValue(\"simTag\",\n                 \"tag to be appended to output filenames to distinguish simulation campaigns\",\n                 simTag);\n    cmd.AddValue(\"outputDir\", \"directory where to store simulation results\", outputDir);\n    cmd.AddValue(\"frequency\", \"The system frequency\", centralFrequency);\n    cmd.AddValue(\"bandwidth\", \"The system bandwidth\", bandwidth);\n    cmd.AddValue(\"udpPacketSize\", \"UDP packet size in bytes\", udpPacketSize);\n    cmd.AddValue(\"lambda\", \"Number of UDP packets per second\", lambda);\n    cmd.AddValue(\"udpFullBuffer\",\n                 \"Whether to set the full buffer traffic; if this parameter is set then the \"\n                 \"udpInterval parameter\"\n                 \"will be neglected\",\n                 udpFullBuffer);\n    cmd.AddValue(\n        \"fixedMcs\",\n        \"The fixed MCS that will be used in this example if useFixedMcs is configured to true (1).\",\n        fixedMcs);\n    cmd.AddValue(\"useFixedMcs\",\n                 \"Whether to use fixed mcs, normally used for testing purposes\",\n                 useFixedMcs);\n    cmd.AddValue(\"singleUeTopology\",\n                 \"If true, the example uses a predefined topology with one UE and one gNB; \"\n                 \"if false, the example creates a grid of gNBs with a number of UEs attached\",\n                 singleUeTopology);\n\n    cmd.Parse(argc, argv);\n\n    NS_ASSERT(ueNumPergNb > 0);\n\n    // setup the nr simulation\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n\n    /*\n     * Spectrum division. We create one operation band with one component carrier\n     * (CC) which occupies the whole operation band bandwidth. The CC contains a\n     * single Bandwidth Part (BWP). This BWP occupies the whole CC band.\n     * Both operational bands will use the StreetCanyon channel modeling.\n     */\n    CcBwpCreator ccBwpCreator;\n    const uint8_t numCcPerBand = 1; // in this example, both bands have a single CC\n    BandwidthPartInfo::Scenario scenario = BandwidthPartInfo::RMa_LoS;\n    if (ueNumPergNb > 1)\n    {\n        scenario = BandwidthPartInfo::InH_OfficeOpen;\n    }\n\n    // Create the configuration for the CcBwpHelper. SimpleOperationBandConf creates\n    // a single BWP per CC\n    CcBwpCreator::SimpleOperationBandConf bandConf(centralFrequency,\n                                                   bandwidth,\n                                                   numCcPerBand,\n                                                   scenario);\n\n    // By using the configuration created, it is time to make the operation bands\n    OperationBandInfo band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);\n\n    /*\n     * Initialize channel and pathloss, plus other things inside band1. If needed,\n     * the band configuration can be done manually, but we leave it for more\n     * sophisticated examples. For the moment, this method will take care\n     * of all the spectrum initialization needs.\n     */\n    nrHelper->InitializeOperationBand(&band);\n\n    BandwidthPartInfoPtrVector allBwps = CcBwpCreator::GetAllBwps({band});\n\n    /*\n     * Continue setting the parameters which are common to all the nodes, like the\n     * gNB transmit power or numerology.\n     */\n    nrHelper->SetGnbPhyAttribute(\"TxPower\", DoubleValue(txPower));\n    nrHelper->SetGnbPhyAttribute(\"Numerology\", UintegerValue(numerology));\n\n    // Scheduler\n    nrHelper->SetSchedulerTypeId(TypeId::LookupByName(\"ns3::NrMacSchedulerTdmaRR\"));\n    nrHelper->SetSchedulerAttribute(\"FixedMcsDl\", BooleanValue(useFixedMcs));\n    nrHelper->SetSchedulerAttribute(\"FixedMcsUl\", BooleanValue(useFixedMcs));\n\n    if (useFixedMcs == true)\n    {\n        nrHelper->SetSchedulerAttribute(\"StartingMcsDl\", UintegerValue(fixedMcs));\n        nrHelper->SetSchedulerAttribute(\"StartingMcsUl\", UintegerValue(fixedMcs));\n    }\n\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n\n    // Antennas for all the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(2));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(4));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Antennas for all the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(4));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(8));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<ThreeGppAntennaModel>()));\n\n    // Beamforming method\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n\n    Config::SetDefault(\"ns3::ThreeGppChannelModel::UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    //  nrHelper->SetChannelConditionModelAttribute (\"UpdatePeriod\", TimeValue (MilliSeconds (0)));\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n\n    // Error Model: UE and GNB with same spectrum error model.\n    nrHelper->SetUlErrorModel(\"ns3::NrEesmIrT1\");\n    nrHelper->SetDlErrorModel(\"ns3::NrEesmIrT1\");\n\n    // Both DL and UL AMC will have the same model behind.\n    nrHelper->SetGnbDlAmcAttribute(\n        \"AmcModel\",\n        EnumValue(NrAmc::ErrorModel)); // NrAmc::ShannonModel or NrAmc::ErrorModel\n    nrHelper->SetGnbUlAmcAttribute(\n        \"AmcModel\",\n        EnumValue(NrAmc::ErrorModel)); // NrAmc::ShannonModel or NrAmc::ErrorModel\n\n    // Create EPC helper\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    nrHelper->SetEpcHelper(epcHelper);\n    // Core latency\n    epcHelper->SetAttribute(\"S1uLinkDelay\", TimeValue(MilliSeconds(0)));\n\n    // gNb routing between Bearer and bandwidh part\n    uint32_t bwpIdForBearer = 0;\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"GBR_CONV_VOICE\", UintegerValue(bwpIdForBearer));\n\n    // Initialize nrHelper\n    nrHelper->Initialize();\n\n    /*\n     *  Create the gNB and UE nodes according to the network topology\n     */\n    NodeContainer gNbNodes;\n    NodeContainer ueNodes;\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    Ptr<ListPositionAllocator> bsPositionAlloc = CreateObject<ListPositionAllocator>();\n    Ptr<ListPositionAllocator> utPositionAlloc = CreateObject<ListPositionAllocator>();\n\n    const double gNbHeight = 10;\n    const double ueHeight = 1.5;\n\n    if (singleUeTopology)\n    {\n        gNbNodes.Create(1);\n        ueNodes.Create(1);\n        gNbNum = 1;\n        ueNumPergNb = 1;\n\n        mobility.Install(gNbNodes);\n        mobility.Install(ueNodes);\n        bsPositionAlloc->Add(Vector(0.0, 0.0, gNbHeight));\n        utPositionAlloc->Add(Vector(0.0, 30.0, ueHeight));\n    }\n    else\n    {\n        gNbNodes.Create(gNbNum);\n        ueNodes.Create(ueNumPergNb * gNbNum);\n\n        int32_t yValue = 0.0;\n        for (uint32_t i = 1; i <= gNbNodes.GetN(); ++i)\n        {\n            // 2.0, -2.0, 6.0, -6.0, 10.0, -10.0, ....\n            if (i % 2 != 0)\n            {\n                yValue = static_cast<int>(i) * 30;\n            }\n            else\n            {\n                yValue = -yValue;\n            }\n\n            bsPositionAlloc->Add(Vector(0.0, yValue, gNbHeight));\n\n            // 1.0, -1.0, 3.0, -3.0, 5.0, -5.0, ...\n            double xValue = 0.0;\n            for (uint16_t j = 1; j <= ueNumPergNb; ++j)\n            {\n                if (j % 2 != 0)\n                {\n                    xValue = j;\n                }\n                else\n                {\n                    xValue = -xValue;\n                }\n\n                if (yValue > 0)\n                {\n                    utPositionAlloc->Add(Vector(xValue, 1, ueHeight));\n                }\n                else\n                {\n                    utPositionAlloc->Add(Vector(xValue, -1, ueHeight));\n                }\n            }\n        }\n    }\n    mobility.SetPositionAllocator(bsPositionAlloc);\n    mobility.Install(gNbNodes);\n\n    mobility.SetPositionAllocator(utPositionAlloc);\n    mobility.Install(ueNodes);\n\n    // Install nr net devices\n    NetDeviceContainer gNbNetDev = nrHelper->InstallGnbDevice(gNbNodes, allBwps);\n\n    NetDeviceContainer ueNetDev = nrHelper->InstallUeDevice(ueNodes, allBwps);\n\n    int64_t randomStream = 1;\n    randomStream += nrHelper->AssignStreams(gNbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);\n\n    // When all the configuration is done, explicitly call UpdateConfig ()\n\n    for (auto it = gNbNetDev.Begin(); it != gNbNetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.000)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(ueNodes);\n\n    Ipv4InterfaceContainer ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));\n\n    // Set the default gateway for the UEs\n    for (uint32_t j = 0; j < ueNodes.GetN(); ++j)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(ueNodes.Get(j)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // attach UEs to the closest eNB\n    nrHelper->AttachToClosestEnb(ueNetDev, gNbNetDev);\n\n    // assign IP address to UEs, and install UDP downlink applications\n    uint16_t dlPort = 1234;\n\n    ApplicationContainer serverApps;\n\n    // The sink will always listen to the specified ports\n    UdpServerHelper dlPacketSinkHelper(dlPort);\n    serverApps.Add(dlPacketSinkHelper.Install(ueNodes.Get(0)));\n\n    UdpClientHelper dlClient;\n    dlClient.SetAttribute(\"RemotePort\", UintegerValue(dlPort));\n    dlClient.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSize));\n    dlClient.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    if (udpFullBuffer)\n    {\n        double bitRate = 75000000; // 75 Mbps will saturate the NR system of 20 MHz with the\n                                   // NrEesmIrT1 error model\n        bitRate /= ueNumPergNb;    // Divide the cell capacity among UEs\n        if (bandwidth > 20e6)\n        {\n            bitRate *= bandwidth / 20e6;\n        }\n        lambda = bitRate / static_cast<double>(udpPacketSize * 8);\n    }\n    dlClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambda)));\n\n    // The bearer that will carry low latency traffic\n    EpsBearer bearer(EpsBearer::GBR_CONV_VOICE);\n\n    Ptr<EpcTft> tft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpf;\n    dlpf.localPortStart = dlPort;\n    dlpf.localPortEnd = dlPort;\n    tft->Add(dlpf);\n\n    /*\n     * Let's install the applications!\n     */\n    ApplicationContainer clientApps;\n\n    for (uint32_t i = 0; i < ueNodes.GetN(); ++i)\n    {\n        Ptr<Node> ue = ueNodes.Get(i);\n        Ptr<NetDevice> ueDevice = ueNetDev.Get(i);\n        Address ueAddress = ueIpIface.GetAddress(i);\n\n        // The client, who is transmitting, is installed in the remote host,\n        // with destination address set to the address of the UE\n        dlClient.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n        clientApps.Add(dlClient.Install(remoteHost));\n\n        // Activate a dedicated bearer for the traffic type\n        nrHelper->ActivateDedicatedEpsBearer(ueDevice, bearer, tft);\n    }\n\n    // start server and client apps\n    serverApps.Start(Seconds(udpAppStartTime));\n    clientApps.Start(Seconds(udpAppStartTime));\n    serverApps.Stop(Seconds(simTime));\n    clientApps.Stop(Seconds(simTime));\n\n    // enable the traces provided by the nr module\n    // nrHelper->EnableTraces();\n\n    FlowMonitorHelper flowmonHelper;\n    NodeContainer endpointNodes;\n    endpointNodes.Add(remoteHost);\n    endpointNodes.Add(ueNodes);\n\n    Ptr<ns3::FlowMonitor> monitor = flowmonHelper.Install(endpointNodes);\n    monitor->SetAttribute(\"DelayBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"JitterBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"PacketSizeBinWidth\", DoubleValue(20));\n\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n\n    // Print per-flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier =\n        DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n\n    double averageFlowThroughput = 0.0;\n    double averageFlowDelay = 0.0;\n\n    std::ofstream outFile;\n    std::string filename = outputDir + \"/\" + simTag;\n    outFile.open(filename.c_str(), std::ofstream::out | std::ofstream::trunc);\n    if (!outFile.is_open())\n    {\n        NS_LOG_ERROR(\"Can't open file \" << filename);\n        return 1;\n    }\n    outFile.setf(std::ios_base::fixed);\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin();\n         i != stats.end();\n         ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        std::stringstream protoStream;\n        protoStream << (uint16_t)t.protocol;\n        if (t.protocol == 6)\n        {\n            protoStream.str(\"TCP\");\n        }\n        if (t.protocol == 17)\n        {\n            protoStream.str(\"UDP\");\n        }\n        outFile << \"Flow \" << i->first << \" (\" << t.sourceAddress << \":\" << t.sourcePort << \" -> \"\n                << t.destinationAddress << \":\" << t.destinationPort << \") proto \"\n                << protoStream.str() << \"\\n\";\n        outFile << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n        outFile << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n        outFile << \"  TxOffered:  \"\n                << i->second.txBytes * 8.0 / (simTime - udpAppStartTime) / 1000 / 1000 << \" Mbps\\n\";\n        outFile << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n        if (i->second.rxPackets > 0)\n        {\n            // Measure the duration of the flow from receiver's perspective\n            double rxDuration =\n                i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds();\n\n            averageFlowThroughput += i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000;\n            averageFlowDelay += 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;\n\n            outFile << \"  Throughput: \" << i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000\n                    << \" Mbps\\n\";\n            outFile << \"  Mean delay:  \"\n                    << 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n            // outFile << \"  Mean upt:  \" << i->second.uptSum / i->second.rxPackets / 1000/1000 << \"\n            // Mbps \\n\";\n            outFile << \"  Mean jitter:  \"\n                    << 1000 * i->second.jitterSum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n        }\n        else\n        {\n            outFile << \"  Throughput:  0 Mbps\\n\";\n            outFile << \"  Mean delay:  0 ms\\n\";\n            outFile << \"  Mean upt:  0  Mbps \\n\";\n            outFile << \"  Mean jitter: 0 ms\\n\";\n        }\n        outFile << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n    }\n\n    double meanFlowThroughput = averageFlowThroughput / stats.size();\n    double meanFlowDelay = averageFlowDelay / stats.size();\n    Ptr<UdpServer> serverApp = serverApps.Get(0)->GetObject<UdpServer>();\n    double totalUdpThroughput =\n        ((serverApp->GetReceived() * udpPacketSize * 8) / (simTime - udpAppStartTime)) * 1e-6;\n\n    outFile << \"\\n\\n  Mean flow throughput: \" << meanFlowThroughput << \"\\n\";\n    outFile << \"  Mean flow delay: \" << meanFlowDelay << \"\\n\";\n    outFile << \"\\n UDP throughput (bps) for UE with node ID 0:\" << totalUdpThroughput << std::endl;\n\n    outFile.close();\n\n    std::ifstream f(filename.c_str());\n\n    if (f.is_open())\n    {\n        std::cout << f.rdbuf();\n    }\n\n    Simulator::Destroy();\n\n    double toleranceMeanFlowThroughput = 383.557857 * 0.0001;\n    double toleranceMeanFlowDelay = 3.533664 * 0.0001;\n    double toleranceUdpThroughput = 372.5066667 * 0.0001;\n\n    // called from examples-to-run.py with all default parameters\n    if (argc == 0 && (meanFlowThroughput < 383.557857 - toleranceMeanFlowThroughput ||\n                      meanFlowThroughput > 383.557857 + toleranceMeanFlowThroughput ||\n                      meanFlowDelay < 3.533664 - toleranceMeanFlowDelay ||\n                      meanFlowDelay > 3.533664 + toleranceMeanFlowDelay ||\n                      totalUdpThroughput < 372.5066667 - toleranceUdpThroughput ||\n                      totalUdpThroughput > 372.5066667 + toleranceUdpThroughput))\n    {\n        return EXIT_FAILURE;\n    }\n    else\n    {\n        return EXIT_SUCCESS;\n    }\n}\n"
    },
    {
      "file_path": "examples/cttc-3gpp-channel-simple-fdm.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2020 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n/**\n *\n * \\file cttc-3gpp-channel-simple-fdm.cc\n * \\ingroup examples\n * \\brief Simple frequency division multiplexing example.\n *\n * This example describes how to setup a simple simulation with the frequency\n * division multiplexing. Simulation example allows configuration of the two\n * bandwidth parts where each is dedicated to different traffic type.\n * The topology is a simple topology that consists of 1 UE and 1 eNB. There\n * is one data bearer active and it will be multiplexed over a one of\n * the two bandwidth parts depending on whether the traffic is configured to\n * be low latency or not. By default the traffic is low latency. So,\n * the example can be run from the command line in the following way:\n *\n * ./ns3 run cttc-3gpp-channel-simple-fdm\n *\n * or to configure flow as not ultra low latency:\n *\n * ./ns3 run 'cttc-3gpp-channel-simple-fdm --isUll=0'\n *\n * Variables that are accessible through the command line (e.g. numerology of\n * BWP 1 can be configured by using --numerologyBwp1=4, so if the user would\n * like to specify this parameter the program can be run in the following way:\n *\n * ./ns3 run \"cttc-3gpp-channel-simple-fdm --numerologyBwp1=4\"\n *\n *\n *\n * The configured spectrum division is as follows:\n *\n * -----------------------------Band 1---------------------------------\n * -----------------------------CC1------------------------------------\n * ------------BWP1---------------|--------------BWP2------------------\n *\n */\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/config-store.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/eps-bearer-tag.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-helper.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/nr-point-to-point-epc-helper.h\"\n#include \"ns3/three-gpp-spectrum-propagation-loss-model.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Cttc3gppChannelSimpleFdm\");\n\nstatic int g_rlcTraceCallbackCalled =\n    false; //!< Global variable used to check if the callback function for RLC is called and thus to\n           //!< determine if the example is run correctly or not\nstatic int g_pdcpTraceCallbackCalled =\n    false; //!< Global variable used to check if the callback function for PDCP is called and thus\n           //!< to determine if the example is run correctly or not\n\n/**\n * Function creates a single packet and directly calls the function send\n * of a device to send the packet to the destination address.\n * @param device Device that will send the packet to the destination address.\n * @param addr Destination address for a packet.\n * @param packetSize The packet size.\n */\nstatic void\nSendPacket(Ptr<NetDevice> device, Address& addr, uint32_t packetSize)\n{\n    Ptr<Packet> pkt = Create<Packet>(packetSize);\n    // Adding empty IPV4 header after adding the IPV6 support for NR module.\n    // NrNetDevice::Receive need to peek the header to know the IP protocol.\n    // Since, there are no apps install in this test, this packet will be\n    // dropped in Ipv4L3Protocol::Receive method upon not finding the route.\n    Ipv4Header ipHeader;\n    pkt->AddHeader(ipHeader);\n\n    // the dedicated bearer that we activate in the simulation\n    // will have bearerId = 2\n    EpsBearerTag tag(1, 2);\n    pkt->AddPacketTag(tag);\n    device->Send(pkt, addr, Ipv4L3Protocol::PROT_NUMBER);\n}\n\n/**\n * Function that prints out PDCP delay. This function is designed as a callback\n * for PDCP trace source.\n * @param path The path that matches the trace source\n * @param rnti RNTI of UE\n * @param lcid logical channel id\n * @param bytes PDCP PDU size in bytes\n * @param pdcpDelay PDCP delay\n */\nvoid\nRxPdcpPDU(std::string path, uint16_t rnti, uint8_t lcid, uint32_t bytes, uint64_t pdcpDelay)\n{\n    std::cout << \"\\n Packet PDCP delay:\" << pdcpDelay << \"\\n\";\n    g_pdcpTraceCallbackCalled = true;\n}\n\n/**\n * Function that prints out RLC statistics, such as RNTI, lcId, RLC PDU size,\n * delay. This function is designed as a callback\n * for RLC trace source.\n * @param path The path that matches the trace source\n * @param rnti RNTI of UE\n * @param lcid logical channel id\n * @param bytes RLC PDU size in bytes\n * @param rlcDelay RLC PDU delay\n */\nvoid\nRxRlcPDU(std::string path, uint16_t rnti, uint8_t lcid, uint32_t bytes, uint64_t rlcDelay)\n{\n    std::cout << \"\\n\\n Data received by UE RLC at:\" << Simulator::Now() << std::endl;\n    std::cout << \"\\n rnti:\" << rnti << std::endl;\n    std::cout << \"\\n lcid:\" << (unsigned)lcid << std::endl;\n    std::cout << \"\\n bytes :\" << bytes << std::endl;\n    std::cout << \"\\n delay :\" << rlcDelay << std::endl;\n    g_rlcTraceCallbackCalled = true;\n}\n\n/**\n * Function that connects PDCP and RLC traces to the corresponding trace sources.\n */\nvoid\nConnectPdcpRlcTraces()\n{\n    // after recent changes in the EPC UE node ID has changed to 3\n    // dedicated bearer that we have activated has bearer id 2\n    Config::Connect(\"/NodeList/*/DeviceList/*/LteUeRrc/DataRadioBearerMap/*/LtePdcp/RxPDU\",\n                    MakeCallback(&RxPdcpPDU));\n    // after recent changes in the EPC UE node ID has changed to 3\n    // dedicated bearer that we have activated has bearer id 2\n    Config::Connect(\"/NodeList/*/DeviceList/*/LteUeRrc/DataRadioBearerMap/*/LteRlc/RxPDU\",\n                    MakeCallback(&RxRlcPDU));\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint16_t gNbNum = 1;\n    uint16_t ueNumPergNb = 1;\n    uint16_t numerologyBwp1 = 4;\n    uint16_t numerologyBwp2 = 2;\n    double centralFrequencyBand = 28.1e9;\n    double bandwidthBand = 200e6;\n    double txPowerPerBwp = 4;\n    uint32_t packetSize = 1000;\n    bool isUll = true; // Whether the flow is a low latency type of traffic.\n\n    Time sendPacketTime = Seconds(0.4);\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"gNbNum\", \"The number of gNbs in multiple-ue topology\", gNbNum);\n    cmd.AddValue(\"ueNumPergNb\", \"The number of UE per gNb in multiple-ue topology\", ueNumPergNb);\n    cmd.AddValue(\"numerologyBwp1\", \"The numerology to be used in bandwidth part 1\", numerologyBwp1);\n    cmd.AddValue(\"numerologyBwp2\", \"The numerology to be used in bandwidth part 2\", numerologyBwp2);\n    cmd.AddValue(\"frequency\", \"The system frequency\", centralFrequencyBand);\n    cmd.AddValue(\"bandwidthBand\", \"The system bandwidth\", bandwidthBand);\n    cmd.AddValue(\"packetSize\", \"packet size in bytes\", packetSize);\n    cmd.AddValue(\"isUll\", \"Enable Uplink\", isUll);\n    cmd.Parse(argc, argv);\n\n    int64_t randomStream = 1;\n    // Create the scenario\n    GridScenarioHelper gridScenario;\n    gridScenario.SetRows(1);\n    gridScenario.SetColumns(gNbNum);\n    gridScenario.SetHorizontalBsDistance(5.0);\n    gridScenario.SetBsHeight(10.0);\n    gridScenario.SetUtHeight(1.5);\n    // must be set before BS number\n    gridScenario.SetSectorization(GridScenarioHelper::SINGLE);\n    gridScenario.SetBsNumber(gNbNum);\n    gridScenario.SetUtNumber(ueNumPergNb * gNbNum);\n    gridScenario.SetScenarioHeight(3); // Create a 3x3 scenario where the UE will\n    gridScenario.SetScenarioLength(3); // be distributed.\n    randomStream += gridScenario.AssignStreams(randomStream);\n    gridScenario.CreateScenario();\n\n    Config::SetDefault(\"ns3::EpsBearer::Release\", UintegerValue(15));\n\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    // Create one operational band containing one CC with 2 bandwidth parts\n    BandwidthPartInfoPtrVector allBwps;\n    CcBwpCreator ccBwpCreator;\n    const uint8_t numCcPerBand = 1; // one CC per Band\n\n    // Create the configuration for the CcBwpHelper\n    CcBwpCreator::SimpleOperationBandConf bandConf(centralFrequencyBand,\n                                                   bandwidthBand,\n                                                   numCcPerBand,\n                                                   BandwidthPartInfo::UMi_StreetCanyon_LoS);\n    bandConf.m_numBwp = 2; // two BWPs per CC\n\n    // By using the configuration created, it is time to make the operation band\n    OperationBandInfo band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);\n\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n\n    nrHelper->InitializeOperationBand(&band);\n    allBwps = CcBwpCreator::GetAllBwps({band});\n\n    // Beamforming method\n    idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));\n\n    // Antennas for all the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(2));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(4));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Antennas for all the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(4));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(8));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    uint32_t bwpIdForLowLat = 0;\n    uint32_t bwpIdForVoice = 1;\n\n    // gNb routing between Bearer and bandwidh part\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\",\n                                                 UintegerValue(bwpIdForLowLat));\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"GBR_CONV_VOICE\", UintegerValue(bwpIdForVoice));\n\n    // Ue routing between Bearer and bandwidth part\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\", UintegerValue(bwpIdForLowLat));\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"GBR_CONV_VOICE\", UintegerValue(bwpIdForVoice));\n\n    // Install and get the pointers to the NetDevices\n    NetDeviceContainer enbNetDev =\n        nrHelper->InstallGnbDevice(gridScenario.GetBaseStations(), allBwps);\n    NetDeviceContainer ueNetDev =\n        nrHelper->InstallUeDevice(gridScenario.GetUserTerminals(), allBwps);\n\n    randomStream += nrHelper->AssignStreams(enbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);\n\n    // Set the attribute of the netdevice (enbNetDev.Get (0)) and bandwidth part (0)/(1)\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)\n        ->SetAttribute(\"Numerology\", UintegerValue(numerologyBwp1));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)\n        ->SetAttribute(\"Numerology\", UintegerValue(numerologyBwp2));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)->SetTxPower(txPowerPerBwp);\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)->SetTxPower(txPowerPerBwp);\n\n    for (auto it = enbNetDev.Begin(); it != enbNetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    InternetStackHelper internet;\n    internet.Install(gridScenario.GetUserTerminals());\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));\n\n    Simulator::Schedule(sendPacketTime,\n                        &SendPacket,\n                        enbNetDev.Get(0),\n                        ueNetDev.Get(0)->GetAddress(),\n                        packetSize);\n\n    // attach UEs to the closest eNB\n    nrHelper->AttachToClosestEnb(ueNetDev, enbNetDev);\n\n    Ptr<EpcTft> tft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpf;\n    dlpf.localPortStart = 1234;\n    dlpf.localPortEnd = 1235;\n    tft->Add(dlpf);\n    enum EpsBearer::Qci q;\n\n    if (isUll)\n    {\n        q = EpsBearer::NGBR_LOW_LAT_EMBB;\n    }\n    else\n    {\n        q = EpsBearer::GBR_CONV_VOICE;\n    }\n\n    EpsBearer bearer(q);\n    nrHelper->ActivateDedicatedEpsBearer(ueNetDev, bearer, tft);\n\n    Simulator::Schedule(Seconds(0.2), &ConnectPdcpRlcTraces);\n\n    nrHelper->EnableTraces();\n\n    Simulator::Stop(Seconds(1));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    if (g_rlcTraceCallbackCalled && g_pdcpTraceCallbackCalled)\n    {\n        return EXIT_SUCCESS;\n    }\n    else\n    {\n        return EXIT_FAILURE;\n    }\n}\n"
    },
    {
      "file_path": "examples/cttc-3gpp-channel-simple-ran.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2020 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n/**\n * \\ingroup examples\n * \\file cttc-3gpp-channel-simple-ran.cc\n * \\brief Simple RAN\n *\n * This example describes how to setup a simulation using the 3GPP channel model\n * from TR 38.900. This example consists of a simple topology of 1 UE and 1 gNb,\n * and only NR RAN part is simulated. One Bandwidth part and one CC are defined.\n * A packet is created and directly sent to gNb device by SendPacket function.\n * Then several functions are connected to PDCP and RLC traces and the delay is\n * printed.\n */\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/config-store.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/eps-bearer-tag.h\"\n#include \"ns3/grid-scenario-helper.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-helper.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/nr-point-to-point-epc-helper.h\"\n\nusing namespace ns3;\n\n/*\n * Enable the logs of the file by enabling the component \"Cttc3gppChannelSimpleRan\",\n * in this way:\n * $ export NS_LOG=\"Cttc3gppChannelSimpleRan=level_info|prefix_func|prefix_time\"\n */\nNS_LOG_COMPONENT_DEFINE(\"Cttc3gppChannelSimpleRan\");\n\nstatic bool g_rxPdcpCallbackCalled = false;\nstatic bool g_rxRxRlcPDUCallbackCalled = false;\n\n/**\n * Function creates a single packet and directly calls the function send\n * of a device to send the packet to the destination address.\n * @param device Device that will send the packet to the destination address.\n * @param addr Destination address for a packet.\n * @param packetSize The packet size.\n */\nstatic void\nSendPacket(Ptr<NetDevice> device, Address& addr, uint32_t packetSize)\n{\n    Ptr<Packet> pkt = Create<Packet>(packetSize);\n    Ipv4Header ipv4Header;\n    ipv4Header.SetProtocol(UdpL4Protocol::PROT_NUMBER);\n    pkt->AddHeader(ipv4Header);\n    EpsBearerTag tag(1, 1);\n    pkt->AddPacketTag(tag);\n    device->Send(pkt, addr, Ipv4L3Protocol::PROT_NUMBER);\n}\n\n/**\n * Function that prints out PDCP delay. This function is designed as a callback\n * for PDCP trace source.\n * @param path The path that matches the trace source\n * @param rnti RNTI of UE\n * @param lcid logical channel id\n * @param bytes PDCP PDU size in bytes\n * @param pdcpDelay PDCP delay\n */\nvoid\nRxPdcpPDU(std::string path, uint16_t rnti, uint8_t lcid, uint32_t bytes, uint64_t pdcpDelay)\n{\n    std::cout << \"\\n Packet PDCP delay:\" << pdcpDelay << \"\\n\";\n    g_rxPdcpCallbackCalled = true;\n}\n\n/**\n * Function that prints out RLC statistics, such as RNTI, lcId, RLC PDU size,\n * delay. This function is designed as a callback\n * for RLC trace source.\n * @param path The path that matches the trace source\n * @param rnti RNTI of UE\n * @param lcid logical channel id\n * @param bytes RLC PDU size in bytes\n * @param rlcDelay RLC PDU delay\n */\nvoid\nRxRlcPDU(std::string path, uint16_t rnti, uint8_t lcid, uint32_t bytes, uint64_t rlcDelay)\n{\n    std::cout << \"\\n\\n Data received at RLC layer at:\" << Simulator::Now() << std::endl;\n    std::cout << \"\\n rnti:\" << rnti << std::endl;\n    std::cout << \"\\n lcid:\" << (unsigned)lcid << std::endl;\n    std::cout << \"\\n bytes :\" << bytes << std::endl;\n    std::cout << \"\\n delay :\" << rlcDelay << std::endl;\n    g_rxRxRlcPDUCallbackCalled = true;\n}\n\n/**\n * Function that connects PDCP and RLC traces to the corresponding trace sources.\n */\nvoid\nConnectPdcpRlcTraces()\n{\n    Config::Connect(\"/NodeList/*/DeviceList/*/LteUeRrc/DataRadioBearerMap/1/LtePdcp/RxPDU\",\n                    MakeCallback(&RxPdcpPDU));\n\n    Config::Connect(\"/NodeList/*/DeviceList/*/LteUeRrc/DataRadioBearerMap/1/LteRlc/RxPDU\",\n                    MakeCallback(&RxRlcPDU));\n}\n\n/**\n * Function that connects UL PDCP and RLC traces to the corresponding trace sources.\n */\nvoid\nConnectUlPdcpRlcTraces()\n{\n    Config::Connect(\"/NodeList/*/DeviceList/*/LteEnbRrc/UeMap/*/DataRadioBearerMap/*/LtePdcp/RxPDU\",\n                    MakeCallback(&RxPdcpPDU));\n\n    Config::Connect(\"/NodeList/*/DeviceList/*/LteEnbRrc/UeMap/*/DataRadioBearerMap/*/LteRlc/RxPDU\",\n                    MakeCallback(&RxRlcPDU));\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint16_t numerologyBwp1 = 0;\n    uint32_t udpPacketSize = 1000;\n    double centralFrequencyBand1 = 28e9;\n    double bandwidthBand1 = 400e6;\n    uint16_t gNbNum = 1;\n    uint16_t ueNumPergNb = 1;\n    bool enableUl = false;\n\n    Time sendPacketTime = Seconds(0.4);\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"numerologyBwp1\", \"The numerology to be used in bandwidth part 1\", numerologyBwp1);\n    cmd.AddValue(\"centralFrequencyBand1\",\n                 \"The system frequency to be used in band 1\",\n                 centralFrequencyBand1);\n    cmd.AddValue(\"bandwidthBand1\", \"The system bandwidth to be used in band 1\", bandwidthBand1);\n    cmd.AddValue(\"packetSize\", \"packet size in bytes\", udpPacketSize);\n    cmd.AddValue(\"enableUl\", \"Enable Uplink\", enableUl);\n    cmd.Parse(argc, argv);\n\n    int64_t randomStream = 1;\n    // Create the scenario\n    GridScenarioHelper gridScenario;\n    gridScenario.SetRows(1);\n    gridScenario.SetColumns(gNbNum);\n    gridScenario.SetHorizontalBsDistance(5.0);\n    gridScenario.SetBsHeight(10.0);\n    gridScenario.SetUtHeight(1.5);\n    // must be set before BS number\n    gridScenario.SetSectorization(GridScenarioHelper::SINGLE);\n    gridScenario.SetBsNumber(gNbNum);\n    gridScenario.SetUtNumber(ueNumPergNb * gNbNum);\n    gridScenario.SetScenarioHeight(3); // Create a 3x3 scenario where the UE will\n    gridScenario.SetScenarioLength(3); // be distribuited.\n    randomStream += gridScenario.AssignStreams(randomStream);\n    gridScenario.CreateScenario();\n\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    // Create one operational band containing one CC with one bandwidth part\n    BandwidthPartInfoPtrVector allBwps;\n    CcBwpCreator ccBwpCreator;\n    const uint8_t numCcPerBand = 1;\n\n    // Create the configuration for the CcBwpHelper\n    CcBwpCreator::SimpleOperationBandConf bandConf1(centralFrequencyBand1,\n                                                    bandwidthBand1,\n                                                    numCcPerBand,\n                                                    BandwidthPartInfo::UMi_StreetCanyon_LoS);\n\n    // By using the configuration created, it is time to make the operation band\n    OperationBandInfo band1 = ccBwpCreator.CreateOperationBandContiguousCc(bandConf1);\n\n    Config::SetDefault(\"ns3::ThreeGppChannelModel::UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetSchedulerAttribute(\"FixedMcsDl\", BooleanValue(true));\n    nrHelper->SetSchedulerAttribute(\"StartingMcsDl\", UintegerValue(28));\n    nrHelper->SetChannelConditionModelAttribute(\"UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n\n    nrHelper->InitializeOperationBand(&band1);\n    allBwps = CcBwpCreator::GetAllBwps({band1});\n\n    // Beamforming method\n    idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));\n\n    // Antennas for all the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(2));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(4));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Antennas for all the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(4));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(8));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Install and get the pointers to the NetDevices\n    NetDeviceContainer enbNetDev =\n        nrHelper->InstallGnbDevice(gridScenario.GetBaseStations(), allBwps);\n    NetDeviceContainer ueNetDev =\n        nrHelper->InstallUeDevice(gridScenario.GetUserTerminals(), allBwps);\n\n    randomStream += nrHelper->AssignStreams(enbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);\n\n    // Set the attribute of the netdevice (enbNetDev.Get (0)) and bandwidth part (0)\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)\n        ->SetAttribute(\"Numerology\", UintegerValue(numerologyBwp1));\n\n    for (auto it = enbNetDev.Begin(); it != enbNetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    InternetStackHelper internet;\n    internet.Install(gridScenario.GetUserTerminals());\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));\n\n    if (enableUl)\n    {\n        Simulator::Schedule(sendPacketTime,\n                            &SendPacket,\n                            ueNetDev.Get(0),\n                            enbNetDev.Get(0)->GetAddress(),\n                            udpPacketSize);\n    }\n    else\n    {\n        Simulator::Schedule(sendPacketTime,\n                            &SendPacket,\n                            enbNetDev.Get(0),\n                            ueNetDev.Get(0)->GetAddress(),\n                            udpPacketSize);\n    }\n\n    // attach UEs to the closest eNB\n    nrHelper->AttachToClosestEnb(ueNetDev, enbNetDev);\n\n    if (enableUl)\n    {\n        std::cout << \"\\n Sending data in uplink.\" << std::endl;\n        Simulator::Schedule(Seconds(0.2), &ConnectUlPdcpRlcTraces);\n    }\n    else\n    {\n        std::cout << \"\\n Sending data in downlink.\" << std::endl;\n        Simulator::Schedule(Seconds(0.2), &ConnectPdcpRlcTraces);\n    }\n\n    nrHelper->EnableTraces();\n\n    Simulator::Stop(Seconds(1));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    if (g_rxPdcpCallbackCalled && g_rxRxRlcPDUCallbackCalled)\n    {\n        return EXIT_SUCCESS;\n    }\n    else\n    {\n        return EXIT_FAILURE;\n    }\n}\n"
    },
    {
      "file_path": "examples/cttc-3gpp-indoor-calibration.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2020 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/eps-bearer-tag.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/point-to-point-helper.h\"\n\nusing namespace ns3;\n\n/**\n * \\ingroup examples\n * \\file cttc-3gpp-indoor-calibration.cc\n * \\brief Simulation script for the NR-MIMO Phase 1 system-level calibration\n *\n * The scenario implemented in the present simulation script is according to\n * the topology described in 3GPP TR 38.900 V15.0.0 (2018-06) Figure 7.2-1:\n * \"Layout of indoor office scenarios\".\n *\n * The simulation assumptions and the configuration parameters follow\n * the evaluation assumptions agreed at 3GPP TSG RAN WG1 meeting #88,\n * and which are summarised in R1-1703534 Table 1.\n * In the following Figure is illustrated the scenario with the gNB positions\n * which are represented with \"x\". The UE nodes are randomly uniformly dropped\n * in the area. There are 10 UEs per gNB.\n *\n * <pre>\n *   +----------------------120 m------------------ +\n *   |                                              |\n *   |                                              |\n *   |      x      x      x      x      x-20m-x     |\n *   |                                        |     |\n *   50m                                     20m    |\n     |                                        |     |\n *   |      x      x      x      x      x     x     |\n *   |                                              |\n *   |                                              |\n *   +----------------------------------------------+\n * </pre>\n * The results of the simulation are files containing data that is being\n * collected over the course of the simulation execution:\n *\n * - SINR values for all the 120 UEs\n * - SNR values for all the 120 UEs\n * - RSSI values for all the 120 UEs\n *\n * Additionally there are files that contain:\n *\n * - UE positions\n * - gNB positions\n * - distances of UEs from the gNBs to which they are attached\n *\n * The file names are created by default in the root project directory if not\n * configured differently by setting resultsDirPath parameter of the Run()\n * function.\n *\n * The file names by default start with the prefixes such as \"sinrs\", \"snrs\",\n * \"rssi\", \"gnb-positions,\", \"ue-positions\" which are followed by the\n * string that briefly describes the configuration parameters that are being\n * set in the specific simulation execution.\n */\n\nNS_LOG_COMPONENT_DEFINE(\"Nr3gppIndoorCalibration\");\n\n/**\n * \\brief Main class\n */\nclass Nr3gppIndoorCalibration\n{\n  public:\n    /**\n     * \\brief This function converts a linear SINR value that is encapsulated in\n     * params structure to dBs, and then it prints the dB value to an output file\n     * containing SINR values.\n     * @param params RxPacketTraceParams structure that contains different\n     * attributes that define the reception of the packet\n     *\n     */\n    void UeReception(RxPacketTraceParams params);\n\n    /**\n     * \\brief This function converts a linear SNR value to dBs and prints it to\n     * the output file containing SNR values.\n     * @param snr SNR value in linear units\n     */\n    void UeSnrPerProcessedChunk(double snr);\n\n    /**\n     * \\brief This function prints out the RSSI value in dBm to file.\n     * @param rssidBm RSSI value in dBm\n     */\n    void UeRssiPerProcessedChunk(double rssidBm);\n\n    /**\n     * Function that will actually configure all the simulation parameters,\n     * topology and run the simulation by using the parameters that are being\n     * configured for the specific run.\n     *\n     * @param centralFrequencyBand The band central frequency\n     * @param bandwidthBand The band bandwidth\n     * @param numerology The numerology\n     * @param totalTxPower The gNB power\n     * @param gNbAntennaModel antenna model to be used by gNB device, can be ISO\n     * directional 3GPP\n     * @param ueAntennaModel antenna model to be used by gNB device, can be ISO\n     * directional 3GPP\n     * @param indoorScenario defines the indoor scenario to be used in the simulation\n     * campaign, currently the two different indoor scenarios are considered:\n     * InH-OfficeOpen and InH-OfficeMixed\n     * @param speed the speed of UEs in km/h\n     * @param resultsDirPath results directory path\n     * @param tag A tag that contains some simulation run specific values in order\n     * to be able to distinguish the results file for different runs for different\n     * parameters configuration\n     * @param duration The duration of the simulation\n     */\n    void Run(double centralFrequencyBand,\n             double bandwidthBand,\n             uint16_t numerology,\n             double totalTxPower,\n             bool cellScan,\n             double beamSearchAngleStep,\n             bool gNbAntennaModel,\n             bool ueAntennaModel,\n             std::string indoorScenario,\n             double speed,\n             std::string resultsDirPath,\n             std::string tag,\n             uint32_t duration);\n    /**\n     * \\brief Destructor that closes the output file stream and finished the\n     * writing into the files.\n     */\n    ~Nr3gppIndoorCalibration();\n\n    /**\n     * \\brief Function selects UE nodes that are placed with a minimum\n     * distance from its closest gNB.\n     * \\param ueNodes - container of UE nodes\n     * \\param gnbNodes - container of gNB nodes\n     * \\param min3DDistance - the minimum that shall be between UE and gNB\n     * \\param numberOfUesToBeSelected - the number of UE nodes to be selected\n     * from the original container\n     */\n    NodeContainer SelectWellPlacedUes(const NodeContainer ueNodes,\n                                      const NodeContainer gnbNodes,\n                                      double min3DDistance,\n                                      uint32_t numberOfUesToBeSelected);\n\n  private:\n    std::ofstream m_outSinrFile;         //!< the output file stream for the SINR file\n    std::ofstream m_outSnrFile;          //!< the output file stream for the SNR file\n    std::ofstream m_outRssiFile;         //!< the output file stream for the RSSI file\n    std::ofstream m_outUePositionsFile;  //!< the output file stream for the UE positions file\n    std::ofstream m_outGnbPositionsFile; //!< the output file stream for the gNB positions file\n    std::ofstream m_outDistancesFile;    //!< the output file stream for the distances file\n};\n\n/**\n * Function that creates the output file name for the results.\n * @param directoryName Directory name\n * @param filePrefix The prefix for the file name, e.g. sinr, snr,..\n * @param tag A tag that contains some simulation run specific values in order to be\n * able to distinguish the results file for different runs for different parameters\n * configuration\n * @return returns The full path file name string\n */\nstd::string\nBuildFileNameString(std::string directoryName, std::string filePrefix, std::string tag)\n{\n    std::ostringstream oss;\n    oss << directoryName << filePrefix << tag;\n    return oss.str();\n}\n\n/**\n * Creates a string tag that contains some simulation run specific values in\n * order to be able to distinguish the results files for different runs for\n * different parameters.\n * @param gNbAntennaModel gNb antenna model\n * @param ueAntennaModel UE antenna model\n * @param scenario The indoor scenario to be used\n * @param speed The speed of UEs in km/h\n * @return the parameter specific simulation name\n */\nstd::string\nBuildTag(bool gNbAntennaModel, bool ueAntennaModel, std::string scenario, double speed)\n{\n    std::ostringstream oss;\n    std::string ao;\n\n    std::string gnbAm;\n    if (gNbAntennaModel)\n    {\n        gnbAm = \"ISO\";\n    }\n    else\n    {\n        gnbAm = \"3GPP\";\n    }\n\n    std::string ueAm;\n    if (ueAntennaModel)\n    {\n        ueAm = \"ISO\";\n    }\n    else\n    {\n        ueAm = \"3GPP\";\n    }\n\n    std::string gm = \"\";\n    oss << \"-ao\" << ao << \"-amGnb\" << gnbAm << \"-amUE\" << ueAm << \"-sc\" << scenario << \"-sp\"\n        << speed << \"-gm\" << gm;\n\n    return oss.str();\n}\n\n/**\n * A callback function that redirects a call to the scenario instance.\n * @param scenario A pointer to a simulation instance\n * @param params RxPacketTraceParams structure containing RX parameters\n */\nvoid\nUeReceptionTrace(Nr3gppIndoorCalibration* scenario, RxPacketTraceParams params)\n{\n    scenario->UeReception(params);\n}\n\n/**\n * A callback function that redirects a call to the scenario instance.\n * @param scenario A pointer to a simulation instance\n * @param snr SNR value\n */\nvoid\nUeSnrPerProcessedChunkTrace(Nr3gppIndoorCalibration* scenario, double snr)\n{\n    scenario->UeSnrPerProcessedChunk(snr);\n}\n\n/**\n * A callback function that redirects a call to the scenario instance.\n * @param scenario A pointer to a simulation instance\n * @param rssidBm rssidBm RSSI value in dBm\n */\nvoid\nUeRssiPerProcessedChunkTrace(Nr3gppIndoorCalibration* scenario, double rssidBm)\n{\n    scenario->UeRssiPerProcessedChunk(rssidBm);\n}\n\nvoid\nNr3gppIndoorCalibration::UeReception(RxPacketTraceParams params)\n{\n    m_outSinrFile << params.m_cellId << params.m_rnti << \"\\t\" << 10 * log10(params.m_sinr)\n                  << std::endl;\n}\n\nvoid\nNr3gppIndoorCalibration::UeSnrPerProcessedChunk(double snr)\n{\n    m_outSnrFile << 10 * log10(snr) << std::endl;\n}\n\nvoid\nNr3gppIndoorCalibration::UeRssiPerProcessedChunk(double rssidBm)\n{\n    m_outRssiFile << rssidBm << std::endl;\n}\n\nNr3gppIndoorCalibration::~Nr3gppIndoorCalibration()\n{\n    m_outSinrFile.close();\n    m_outSnrFile.close();\n    m_outRssiFile.close();\n}\n\nNodeContainer\nNr3gppIndoorCalibration::SelectWellPlacedUes(const NodeContainer ueNodes,\n                                             const NodeContainer gnbNodes,\n                                             double minDistance,\n                                             uint32_t numberOfUesToBeSelected)\n{\n    NodeContainer ueNodesFiltered;\n    bool correctDistance = true;\n\n    for (NodeContainer::Iterator itUe = ueNodes.Begin(); itUe != ueNodes.End(); itUe++)\n    {\n        correctDistance = true;\n        Ptr<MobilityModel> ueMm = (*itUe)->GetObject<MobilityModel>();\n        Vector uePos = ueMm->GetPosition();\n\n        for (NodeContainer::Iterator itGnb = gnbNodes.Begin(); itGnb != gnbNodes.End(); itGnb++)\n        {\n            Ptr<MobilityModel> gnbMm = (*itGnb)->GetObject<MobilityModel>();\n            Vector gnbPos = gnbMm->GetPosition();\n            double x = uePos.x - gnbPos.x;\n            double y = uePos.y - gnbPos.y;\n            double distance = sqrt(x * x + y * y);\n\n            if (distance < minDistance)\n            {\n                correctDistance = false;\n                // NS_LOG(\"The UE node \"<<(*itUe)->GetId() << \" has wrong position, discarded.\");\n                break;\n            }\n            else\n            {\n                m_outDistancesFile << distance << std::endl;\n            }\n        }\n\n        if (correctDistance)\n        {\n            ueNodesFiltered.Add(*itUe);\n        }\n        if (ueNodesFiltered.GetN() >= numberOfUesToBeSelected)\n        {\n            // there are enough candidate UE nodes\n            break;\n        }\n    }\n    return ueNodesFiltered;\n}\n\nvoid\nNr3gppIndoorCalibration::Run(double centralFrequencyBand,\n                             double bandwidthBand,\n                             uint16_t numerology,\n                             double totalTxPower,\n                             bool cellScan,\n                             double beamSearchAngleStep,\n                             bool gNbAntennaModel,\n                             bool ueAntennaModel,\n                             std::string indoorScenario,\n                             double speed,\n                             std::string resultsDirPath,\n                             std::string tag,\n                             uint32_t duration)\n{\n    Time simTime = MilliSeconds(duration);\n    Time udpAppStartTimeDl = MilliSeconds(100);\n    Time udpAppStopTimeDl = MilliSeconds(duration);\n    uint32_t packetSize = 1000;\n    DataRate udpRate = DataRate(\"0.1kbps\");\n    // initially created 240 UE nodes, out of which will be selected 120 UEs that\n    // are well placed respecting the minimum distance parameter that is configured\n    uint16_t ueCount = 240;\n    // the minimum distance parameter\n    double minDistance = 0;\n    // BS atnenna height is 3 meters\n    double gNbHeight = 3;\n    // UE antenna height is 1.5 meters\n    double ueHeight = 1.5;\n\n    BandwidthPartInfo::Scenario scenario;\n    if (indoorScenario == \"InH-OfficeMixed\")\n    {\n        scenario = BandwidthPartInfo::InH_OfficeMixed;\n    }\n    else if (indoorScenario == \"InH-OfficeOpen\")\n    {\n        scenario = BandwidthPartInfo::InH_OfficeOpen;\n    }\n    else\n    {\n        NS_ABORT_MSG(\"Unsupported scenario\");\n    }\n\n    // if simulation tag is not provided create one\n    if (tag == \"\")\n    {\n        tag = BuildTag(gNbAntennaModel, ueAntennaModel, indoorScenario, speed);\n    }\n    std::string filenameSinr = BuildFileNameString(resultsDirPath, \"sinrs\", tag);\n    std::string filenameSnr = BuildFileNameString(resultsDirPath, \"snrs\", tag);\n    std::string filenameRssi = BuildFileNameString(resultsDirPath, \"rssi\", tag);\n    std::string filenameUePositions = BuildFileNameString(resultsDirPath, \"ue-positions\", tag);\n    std::string filenameGnbPositions = BuildFileNameString(resultsDirPath, \"gnb-positions\", tag);\n    std::string filenameDistances = BuildFileNameString(resultsDirPath, \"distances\", tag);\n\n    m_outSinrFile.open(filenameSinr.c_str());\n    m_outSinrFile.setf(std::ios_base::fixed);\n\n    if (!m_outSinrFile.is_open())\n    {\n        NS_ABORT_MSG(\"Can't open file \" << filenameSinr);\n    }\n\n    m_outSnrFile.open(filenameSnr.c_str());\n    m_outSnrFile.setf(std::ios_base::fixed);\n\n    if (!m_outSnrFile.is_open())\n    {\n        NS_ABORT_MSG(\"Can't open file \" << filenameSnr);\n    }\n\n    m_outRssiFile.open(filenameRssi.c_str());\n    m_outRssiFile.setf(std::ios_base::fixed);\n\n    if (!m_outRssiFile.is_open())\n    {\n        NS_ABORT_MSG(\"Can't open file \" << filenameRssi);\n    }\n\n    m_outUePositionsFile.open(filenameUePositions.c_str());\n    m_outUePositionsFile.setf(std::ios_base::fixed);\n\n    if (!m_outUePositionsFile.is_open())\n    {\n        NS_ABORT_MSG(\"Can't open file \" << filenameUePositions);\n    }\n\n    m_outGnbPositionsFile.open(filenameGnbPositions.c_str());\n    m_outGnbPositionsFile.setf(std::ios_base::fixed);\n\n    if (!m_outGnbPositionsFile.is_open())\n    {\n        NS_ABORT_MSG(\"Can't open file \" << filenameGnbPositions);\n    }\n\n    m_outDistancesFile.open(filenameDistances.c_str());\n    m_outDistancesFile.setf(std::ios_base::fixed);\n\n    if (!m_outDistancesFile.is_open())\n    {\n        NS_ABORT_MSG(\"Can't open file \" << filenameDistances);\n    }\n\n    // create base stations and mobile terminals\n    NodeContainer gNbNodes;\n    NodeContainer ueNodes;\n    MobilityHelper mobility;\n\n    gNbNodes.Create(12);\n    ueNodes.Create(ueCount);\n\n    // Creating positions of the gNB according to the 3gpp TR 38.900 Figure 7.2.-1\n    Ptr<ListPositionAllocator> gNbPositionAlloc = CreateObject<ListPositionAllocator>();\n\n    for (uint8_t j = 0; j < 2; j++)\n    {\n        for (uint8_t i = 0; i < 6; i++)\n        {\n            gNbPositionAlloc->Add(Vector(i * 20, j * 20, gNbHeight));\n        }\n    }\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(gNbPositionAlloc);\n    mobility.Install(gNbNodes);\n\n    double minBigBoxX = -10.0;\n    double minBigBoxY = -15.0;\n    double maxBigBoxX = 110.0;\n    double maxBigBoxY = 35.0;\n\n    // Creating positions of the UEs according to the 3gpp TR 38.900 and\n    // R11700144, uniformly randombly distributed in the rectangular area\n\n    NodeContainer selectedUeNodes;\n    for (uint8_t j = 0; j < 2; j++)\n    {\n        double minSmallBoxY = minBigBoxY + j * (maxBigBoxY - minBigBoxY) / 2;\n\n        for (uint8_t i = 0; i < 6; i++)\n        {\n            double minSmallBoxX = minBigBoxX + i * (maxBigBoxX - minBigBoxX) / 6;\n            Ptr<UniformRandomVariable> ueRandomVarX = CreateObject<UniformRandomVariable>();\n\n            double minX = minSmallBoxX;\n            double maxX = minSmallBoxX + (maxBigBoxX - minBigBoxX) / 6 - 0.0001;\n            double minY = minSmallBoxY;\n            double maxY = minSmallBoxY + (maxBigBoxY - minBigBoxY) / 2 - 0.0001;\n\n            Ptr<RandomBoxPositionAllocator> ueRandomRectPosAlloc =\n                CreateObject<RandomBoxPositionAllocator>();\n            ueRandomVarX->SetAttribute(\"Min\", DoubleValue(minX));\n            ueRandomVarX->SetAttribute(\"Max\", DoubleValue(maxX));\n            ueRandomRectPosAlloc->SetX(ueRandomVarX);\n            Ptr<UniformRandomVariable> ueRandomVarY = CreateObject<UniformRandomVariable>();\n            ueRandomVarY->SetAttribute(\"Min\", DoubleValue(minY));\n            ueRandomVarY->SetAttribute(\"Max\", DoubleValue(maxY));\n            ueRandomRectPosAlloc->SetY(ueRandomVarY);\n            Ptr<ConstantRandomVariable> ueRandomVarZ = CreateObject<ConstantRandomVariable>();\n            ueRandomVarZ->SetAttribute(\"Constant\", DoubleValue(ueHeight));\n            ueRandomRectPosAlloc->SetZ(ueRandomVarZ);\n\n            uint8_t smallBoxIndex = j * 6 + i;\n\n            NodeContainer smallBoxCandidateNodes;\n            NodeContainer smallBoxGnbNode;\n\n            smallBoxGnbNode.Add(gNbNodes.Get(smallBoxIndex));\n\n            for (uint32_t n = smallBoxIndex * ueCount / 12;\n                 n < smallBoxIndex * static_cast<uint32_t>(ueCount / 12) +\n                         static_cast<uint32_t>(ueCount / 12);\n                 n++)\n            {\n                smallBoxCandidateNodes.Add(ueNodes.Get(n));\n            }\n            mobility.SetPositionAllocator(ueRandomRectPosAlloc);\n            mobility.Install(smallBoxCandidateNodes);\n            NodeContainer sn =\n                SelectWellPlacedUes(smallBoxCandidateNodes, smallBoxGnbNode, minDistance, 10);\n            selectedUeNodes.Add(sn);\n        }\n    }\n\n    for (uint32_t j = 0; j < selectedUeNodes.GetN(); j++)\n    {\n        Vector v = selectedUeNodes.Get(j)->GetObject<MobilityModel>()->GetPosition();\n        m_outUePositionsFile << j << \"\\t\" << v.x << \"\\t\" << v.y << \"\\t\" << v.z << \" \" << std::endl;\n    }\n\n    for (uint32_t j = 0; j < gNbNodes.GetN(); j++)\n    {\n        Vector v = gNbNodes.Get(j)->GetObject<MobilityModel>()->GetPosition();\n        m_outGnbPositionsFile << j << \"\\t\" << v.x << \"\\t\" << v.y << \"\\t\" << v.z << \" \" << std::endl;\n    }\n\n    m_outUePositionsFile.close();\n    m_outGnbPositionsFile.close();\n    m_outDistancesFile.close();\n\n    // setup the nr simulation\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    /*\n     * Spectrum division. We create one operational band, containing one\n     * component carrier, which in turn contains a single bandwidth part\n     * centered at the frequency specified by the input parameters.\n     *\n     * The configured spectrum division is:\n     * |------------------------Band-------------------------|\n     * |-------------------------CC--------------------------|\n     * |-------------------------BWP-------------------------|\n     *\n     * Each spectrum part length is, as well, specified by the input parameters.\n     * The band will use the indoor channel modeling specified by scenario.\n     */\n    BandwidthPartInfoPtrVector allBwps;\n    CcBwpCreator ccBwpCreator;\n    const uint8_t numCcPerBand = 1;\n\n    // Create the configuration for the CcBwpHelper. SimpleOperationBandConf creates\n    // a single BWP per CC\n    CcBwpCreator::SimpleOperationBandConf bandConf(centralFrequencyBand,\n                                                   bandwidthBand,\n                                                   numCcPerBand,\n                                                   scenario);\n\n    // By using the configuration created, make the operation band\n    OperationBandInfo band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);\n\n    nrHelper->InitializeOperationBand(&band);\n    allBwps = CcBwpCreator::GetAllBwps({band});\n\n    // Disable channel matrix update to speed up the simulation execution\n    // Config::SetDefault (\"ns3::Nr3gppChannel::UpdatePeriod\", TimeValue (MilliSeconds(0)));\n    // Config::SetDefault (\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n    // Config::SetDefault (\"ns3::LteRlcUmLowLat::MaxTxBufferSize\", UintegerValue(999999999));\n    Config::SetDefault(\"ns3::LteEnbRrc::SrsPeriodicity\", UintegerValue(320));\n\n    if (cellScan)\n    {\n        idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                             TypeIdValue(CellScanBeamforming::GetTypeId()));\n        idealBeamformingHelper->SetBeamformingAlgorithmAttribute(\"BeamSearchAngleStep\",\n                                                                 DoubleValue(beamSearchAngleStep));\n    }\n    else\n    {\n        idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                             TypeIdValue(DirectPathBeamforming::GetTypeId()));\n    }\n\n    nrHelper->SetSchedulerTypeId(TypeId::LookupByName(\"ns3::NrMacSchedulerTdmaPF\"));\n\n    // Antennas for all the UEs - Should be 2x4 = 8 antenna elements\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(2));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(4));\n    // Antenna element type for UEs\n    if (ueAntennaModel)\n    {\n        nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                        PointerValue(CreateObject<IsotropicAntennaModel>()));\n    }\n    else\n    {\n        nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                        PointerValue(CreateObject<ThreeGppAntennaModel>()));\n    }\n    // Antennas for all the gNbs - Should be 4x8 = 32 antenna elements\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(4));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(8));\n    // Antenna element type for gNBs\n    if (gNbAntennaModel)\n    {\n        nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                         PointerValue(CreateObject<IsotropicAntennaModel>()));\n    }\n    else\n    {\n        nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                         PointerValue(CreateObject<ThreeGppAntennaModel>()));\n    }\n\n    // mobility.SetPositionAllocator (ueRandomRectPosAlloc);\n    // install nr net devices\n    NetDeviceContainer gNbDevs = nrHelper->InstallGnbDevice(gNbNodes, allBwps);\n    NetDeviceContainer ueNetDevs = nrHelper->InstallUeDevice(selectedUeNodes, allBwps);\n\n    int64_t randomStream = 1;\n    randomStream += nrHelper->AssignStreams(gNbDevs, randomStream);\n    randomStream += nrHelper->AssignStreams(ueNetDevs, randomStream);\n\n    for (uint32_t i = 0; i < gNbDevs.GetN(); i++)\n    {\n        nrHelper->GetGnbPhy(gNbDevs.Get(i), 0)\n            ->SetAttribute(\"Numerology\", UintegerValue(numerology));\n        nrHelper->GetGnbPhy(gNbDevs.Get(i), 0)\n            ->SetAttribute(\"TxPower\", DoubleValue(10 * log10(totalTxPower)));\n        // gNB noise figure shall be set to 7 dB\n        nrHelper->GetGnbPhy(gNbDevs.Get(i), 0)->SetAttribute(\"NoiseFigure\", DoubleValue(7));\n    }\n    for (uint32_t j = 0; j < ueNetDevs.GetN(); j++)\n    {\n        // UE noise figure shall be set to 10 dB\n        nrHelper->GetUePhy(ueNetDevs.Get(j), 0)->SetAttribute(\"NoiseFigure\", DoubleValue(10));\n    }\n\n    for (auto it = gNbDevs.Begin(); it != gNbDevs.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueNetDevs.Begin(); it != ueNetDevs.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.000)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    // in this container, interface 0 is the pgw, 1 is the remoteHost\n    // Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress (1);\n\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDevs));\n\n    // Set the default gateway for the UEs\n    for (uint32_t j = 0; j < ueNodes.GetN(); ++j)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(ueNodes.Get(j)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // attach UEs to the closest eNB\n    nrHelper->AttachToClosestEnb(ueNetDevs, gNbDevs);\n\n    // assign IP address to UEs, and install UDP downlink applications\n    uint16_t dlPort = 1234;\n    ApplicationContainer clientAppsDl;\n    ApplicationContainer serverAppsDl;\n\n    Time udpInterval =\n        Time::FromDouble((packetSize * 8) / static_cast<double>(udpRate.GetBitRate()), Time::S);\n\n    UdpServerHelper dlPacketSinkHelper(dlPort);\n    serverAppsDl.Add(dlPacketSinkHelper.Install(ueNodes));\n\n    // configure UDP downlink traffic\n    for (uint32_t i = 0; i < ueNetDevs.GetN(); i++)\n    {\n        UdpClientHelper dlClient(ueIpIface.GetAddress(i), dlPort);\n        dlClient.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n        dlClient.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n        dlClient.SetAttribute(\n            \"Interval\",\n            TimeValue(udpInterval)); // we try to saturate, we just need to measure during a short\n                                     // time, how much traffic can handle each BWP\n        clientAppsDl.Add(dlClient.Install(remoteHost));\n    }\n\n    // start UDP server and client apps\n    serverAppsDl.Start(udpAppStartTimeDl);\n    clientAppsDl.Start(udpAppStartTimeDl);\n\n    serverAppsDl.Stop(udpAppStopTimeDl);\n    clientAppsDl.Stop(udpAppStopTimeDl);\n\n    for (uint32_t i = 0; i < ueNetDevs.GetN(); i++)\n    {\n        Ptr<NrSpectrumPhy> ue1SpectrumPhy =\n            DynamicCast<NrUeNetDevice>(ueNetDevs.Get(i))->GetPhy(0)->GetSpectrumPhy();\n        ue1SpectrumPhy->TraceConnectWithoutContext(\"RxPacketTraceUe\",\n                                                   MakeBoundCallback(&UeReceptionTrace, this));\n        Ptr<NrInterference> ue1SpectrumPhyInterference = ue1SpectrumPhy->GetNrInterference();\n        NS_ABORT_IF(!ue1SpectrumPhyInterference);\n        ue1SpectrumPhyInterference->TraceConnectWithoutContext(\n            \"SnrPerProcessedChunk\",\n            MakeBoundCallback(&UeSnrPerProcessedChunkTrace, this));\n        ue1SpectrumPhyInterference->TraceConnectWithoutContext(\n            \"RssiPerProcessedChunk\",\n            MakeBoundCallback(&UeRssiPerProcessedChunkTrace, this));\n    }\n\n    Simulator::Stop(simTime);\n    Simulator::Run();\n    Simulator::Destroy();\n}\n\nint\nmain(int argc, char* argv[])\n{\n    // Parameters according to R1-1703534 3GPP TSG RAN WG1 Meetging #88, 2017\n    // Evaluation assumptions for Phase 1 NR MIMO system level calibration,\n    double centralFrequencyBand = 30e9;\n    double bandwidthBand = 40e6;\n    uint16_t numerology = 2;\n    double totalTxPower = 23;\n\n    uint32_t duration = 150;\n    bool cellScan = false;\n    double beamSearchAngleStep = 10.0;\n    bool enableGnbIso = true;\n    bool enableUeIso = true;\n    std::string indoorScenario = \"InH-OfficeOpen\";\n    double speed = 3.00;\n    std::string resultsDir = \"./\";\n    std::string simTag = \"\";\n\n    CommandLine cmd(__FILE__);\n\n    cmd.AddValue(\"duration\",\n                 \"Simulation duration in ms, should be greater than 100 ms to allow the collection \"\n                 \"of traces\",\n                 duration);\n    cmd.AddValue(\"cellScan\",\n                 \"Use beam search method to determine beamforming vector,\"\n                 \"true to use cell scanning method\",\n                 cellScan);\n    cmd.AddValue(\"beamSearchAngleStep\",\n                 \"Beam search angle step for beam search method\",\n                 beamSearchAngleStep);\n    cmd.AddValue(\"enableGnbIso\", \"Enable Isotropic antenna for the gNB\", enableGnbIso);\n    cmd.AddValue(\"enableGnbIso\", \"Enable Isotropic antenna for the UE\", enableUeIso);\n    cmd.AddValue(\"indoorScenario\",\n                 \"The indoor scenario to be used can be: InH-OfficeMixed or InH-OfficeOpen\",\n                 indoorScenario);\n    cmd.AddValue(\"speed\", \"UE speed in km/h\", speed);\n    cmd.AddValue(\"resultsDir\", \"directory where to store the simulation results\", resultsDir);\n    cmd.AddValue(\"simTag\",\n                 \"tag to be appended to output filenames to distinguish simulation campaigns\",\n                 simTag);\n\n    cmd.Parse(argc, argv);\n\n    ConfigStore inputConfig;\n    inputConfig.ConfigureDefaults();\n\n    Nr3gppIndoorCalibration phase1CalibrationScenario;\n    phase1CalibrationScenario.Run(centralFrequencyBand,\n                                  bandwidthBand,\n                                  numerology,\n                                  totalTxPower,\n                                  cellScan,\n                                  beamSearchAngleStep,\n                                  enableGnbIso,\n                                  enableUeIso,\n                                  indoorScenario,\n                                  speed,\n                                  resultsDir,\n                                  simTag,\n                                  duration);\n\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/cttc-channel-randomness.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2020 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n/**\n * \\ingroup examples\n * \\file cttc-channel-randomness.cc\n *\n * This example is intended to test the randmness of the channel in order to see\n * if we can reproduce the same channel realization within the same simulation run.\n *\n * This example is needed for the RemHelper generation task in order to decide\n * how to handle the randomness and how to calculate different RemPoints without\n * having these calculations correlate.\n *\n * \\code{.unparsed}\n$ ./ns3 run \"cttc-channel-randomness --PrintHelp\"\n    \\endcode\n *\n */\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/config-store.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/nr-spectrum-value-helper.h\"\n#include \"ns3/simple-net-device.h\"\n#include \"ns3/three-gpp-channel-model.h\"\n#include \"ns3/three-gpp-propagation-loss-model.h\"\n#include \"ns3/three-gpp-spectrum-propagation-loss-model.h\"\n#include <ns3/spectrum-model.h>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CttcChannelRandomness\");\n\n/**\n * Perform the beamforming using the DFT beamforming method\n * \\param thisDevice the device performing the beamforming\n * \\param thisAntenna the antenna object associated to thisDevice\n * \\param otherDevice the device towards which point the beam\n */\nstatic void\nDoBeamforming(Ptr<NetDevice> thisDevice,\n              Ptr<UniformPlanarArray> thisAntenna,\n              Ptr<NetDevice> otherDevice)\n{\n    // retrieve the position of the two devices\n    Vector aPos = thisDevice->GetNode()->GetObject<MobilityModel>()->GetPosition();\n    Vector bPos = otherDevice->GetNode()->GetObject<MobilityModel>()->GetPosition();\n\n    // compute the azimuth and the elevation angles\n    Angles completeAngle(bPos, aPos);\n\n    double posX = bPos.x - aPos.x;\n    double phiAngle = atan((bPos.y - aPos.y) / posX);\n\n    if (posX < 0)\n    {\n        phiAngle = phiAngle + M_PI;\n    }\n    if (phiAngle < 0)\n    {\n        phiAngle = phiAngle + 2 * M_PI;\n    }\n\n    double hAngleRadian = fmod((phiAngle + M_PI), 2 * M_PI - M_PI); // the azimuth angle\n    double vAngleRadian = completeAngle.GetInclination();           // the elevation angle\n\n    // retrieve the number of antenna elements\n    unsigned int totNoArrayElements = thisAntenna->GetNumberOfElements();\n\n    // the total power is divided equally among the antenna elements\n    double power = 1 / sqrt(totNoArrayElements);\n\n    UniformPlanarArray::ComplexVector antennaWeights(totNoArrayElements);\n    // compute the antenna weights\n    for (unsigned int ind = 0; ind < totNoArrayElements; ind++)\n    {\n        Vector loc = thisAntenna->GetElementLocation(ind);\n        double phase = -2 * M_PI *\n                       (sin(vAngleRadian) * cos(hAngleRadian) * loc.x +\n                        sin(vAngleRadian) * sin(hAngleRadian) * loc.y + cos(vAngleRadian) * loc.z);\n        antennaWeights[ind] = exp(std::complex<double>(0, phase)) * power;\n    }\n\n    // store the antenna weights\n    thisAntenna->SetBeamformingVector(antennaWeights);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double frequency = 28.0e9;\n    uint32_t rbNum = 555; // bandwidth in number of RBs, for numerology 0 is equivalent to 555 RBs\n    double subcarrierSpacing = 15000; // subcarrier spacing for numerology 0\n\n    double txPower = 40;\n    double distance = 10.0;\n    std::string scenario = \"UMa\"; // 3GPP propagation scenario\n\n    uint32_t simTimeMs = 1000;\n    bool logging = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"frequency\",\n                 \"The operating frequency in Hz (2125.0e6 corresponds to EARFCN 2100)\",\n                 frequency);\n    cmd.AddValue(\"rbNum\", \"The system BW in number of resource blocks\", rbNum);\n    cmd.AddValue(\"subcarrierSpacing\", \"The subcarrier spacing\", subcarrierSpacing);\n    cmd.AddValue(\"txPower\", \"The transmission power in dBm\", txPower);\n    cmd.AddValue(\"distance\", \"The distance between tx and rx nodes in meters\", distance);\n    cmd.AddValue(\"scenario\",\n                 \"The 3GPP propagation scenario for the simulation.\"\n                 \"Choose among 'UMa'and 'UMi-StreetCanyon'\",\n                 scenario);\n    cmd.AddValue(\"simTimeMs\", \"Simulation time in ms\", simTimeMs);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.Parse(argc, argv);\n\n    Config::SetDefault(\"ns3::ThreeGppChannelModel::UpdatePeriod\",\n                       TimeValue(MilliSeconds(0))); // update the channel at each iteration\n    Config::SetDefault(\"ns3::ThreeGppChannelConditionModel::UpdatePeriod\",\n                       TimeValue(MilliSeconds(0.0))); // do not update the channel condition\n\n    // create the tx and rx nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // create the tx and rx devices\n    Ptr<SimpleNetDevice> txDev = CreateObject<SimpleNetDevice>();\n    Ptr<SimpleNetDevice> rxDev = CreateObject<SimpleNetDevice>();\n\n    // associate the nodes and the devices\n    nodes.Get(0)->AddDevice(txDev);\n    txDev->SetNode(nodes.Get(0));\n    nodes.Get(1)->AddDevice(rxDev);\n    rxDev->SetNode(nodes.Get(1));\n\n    // create the tx and rx mobility models, set the positions\n    Ptr<MobilityModel> txMob = CreateObject<ConstantPositionMobilityModel>();\n    txMob->SetPosition(Vector(0.0, 0.0, 10.0));\n    Ptr<MobilityModel> rxMob = CreateObject<ConstantPositionMobilityModel>();\n    rxMob->SetPosition(Vector(distance, 0.0, 1.6));\n\n    // assign the mobility models to the nodes\n    nodes.Get(0)->AggregateObject(txMob);\n    nodes.Get(1)->AggregateObject(rxMob);\n\n    RngSeedManager::SetSeed(1);\n    RngSeedManager::SetRun(1);\n\n    int64_t stream = 1;\n\n    Ptr<ThreeGppPropagationLossModel> m_propagationLossModel; //!< the PropagationLossModel object\n    Ptr<ThreeGppSpectrumPropagationLossModel>\n        m_spectrumLossModel; //!< the SpectrumPropagationLossModel object\n\n    // create and configure the factories for the channel condition and propagation loss models\n    ObjectFactory propagationLossModelFactory;\n    ObjectFactory channelConditionModelFactory;\n\n    if (scenario == \"UMa\")\n    {\n        propagationLossModelFactory.SetTypeId(ThreeGppUmaPropagationLossModel::GetTypeId());\n        channelConditionModelFactory.SetTypeId(AlwaysLosChannelConditionModel::GetTypeId());\n    }\n    else if (scenario == \"UMi-StreetCanyon\")\n    {\n        propagationLossModelFactory.SetTypeId(\n            ThreeGppUmiStreetCanyonPropagationLossModel::GetTypeId());\n        channelConditionModelFactory.SetTypeId(AlwaysLosChannelConditionModel::GetTypeId());\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"The scenario can be 'UMa'or 'UMi-StreetCanyon'\");\n    }\n\n    // create the propagation loss model\n    m_propagationLossModel = propagationLossModelFactory.Create<ThreeGppPropagationLossModel>();\n    m_propagationLossModel->SetAttribute(\"Frequency\", DoubleValue(frequency));\n    m_propagationLossModel->SetAttribute(\"ShadowingEnabled\", BooleanValue(false));\n\n    // create the spectrum propagation loss model\n    m_spectrumLossModel = CreateObject<ThreeGppSpectrumPropagationLossModel>();\n    m_spectrumLossModel->SetChannelModelAttribute(\"Frequency\", DoubleValue(frequency));\n    m_spectrumLossModel->SetChannelModelAttribute(\"Scenario\", StringValue(scenario));\n\n    // create the channel condition model and associate it with the spectrum and\n    // propagation loss model\n    Ptr<ChannelConditionModel> condModel =\n        channelConditionModelFactory.Create<ChannelConditionModel>();\n    m_spectrumLossModel->SetChannelModelAttribute(\"ChannelConditionModel\", PointerValue(condModel));\n    m_propagationLossModel->SetChannelConditionModel(condModel);\n\n    // create the chennel model\n    Ptr<ThreeGppChannelModel> channelModel = CreateObject<ThreeGppChannelModel>();\n    channelModel->SetAttribute(\"Frequency\", DoubleValue(frequency));\n    channelModel->SetAttribute(\"Scenario\", StringValue(scenario));\n    channelModel->SetAttribute(\"ChannelConditionModel\", PointerValue(condModel));\n\n    // create the antenna objects and set their dimensions\n    Ptr<UniformPlanarArray> txAntenna =\n        CreateObjectWithAttributes<UniformPlanarArray>(\"NumColumns\",\n                                                       UintegerValue(2),\n                                                       \"NumRows\",\n                                                       UintegerValue(2));\n    Ptr<UniformPlanarArray> rxAntenna =\n        CreateObjectWithAttributes<UniformPlanarArray>(\"NumColumns\",\n                                                       UintegerValue(2),\n                                                       \"NumRows\",\n                                                       UintegerValue(2));\n\n    // set the beamforming vectors\n    DoBeamforming(txDev, txAntenna, rxDev);\n    DoBeamforming(rxDev, rxAntenna, txDev);\n\n    channelModel->AssignStreams(stream);\n\n    Ptr<const ThreeGppChannelModel::ChannelMatrix> channelMatrix1 =\n        channelModel->GetChannel(txMob, rxMob, txAntenna, rxAntenna);\n\n    /*  for (uint32_t i = 0; i < channelMatrix1->m_channel.size (); i++)\n      {\n          for (uint32_t j = 0; j < channelMatrix1->m_channel.at (0).size (); j++)\n          {\n              std::cout << channelMatrix1->m_channel[i][j][0] << std::endl;\n          }\n      }*/\n\n    Ptr<const SpectrumModel> sm1 =\n        NrSpectrumValueHelper::GetSpectrumModel(rbNum, frequency, subcarrierSpacing);\n    std::vector<int> activeRbs;\n    for (size_t rbId = 0; rbId < sm1->GetNumBands(); rbId++)\n    {\n        activeRbs.push_back(rbId);\n    }\n    Ptr<const SpectrumValue> txPsd1 = NrSpectrumValueHelper::CreateTxPowerSpectralDensity(\n        txPower,\n        activeRbs,\n        sm1,\n        NrSpectrumValueHelper::UNIFORM_POWER_ALLOCATION_BW);\n    Ptr<SpectrumSignalParameters> txParams1 = Create<SpectrumSignalParameters>();\n    txParams1->psd = txPsd1->Copy();\n    std::cout << \"Average tx power 1: \"\n              << 10 * log10(Sum(*txPsd1) / txPsd1->GetSpectrumModel()->GetNumBands()) << \" dBm\"\n              << std::endl;\n    Ptr<SpectrumValue> rxPsd1 = m_spectrumLossModel->DoCalcRxPowerSpectralDensity(txParams1,\n                                                                                  txMob,\n                                                                                  rxMob,\n                                                                                  txAntenna,\n                                                                                  rxAntenna);\n    std::cout << \"Average rx power 1: \"\n              << 10 * log10(Sum(*rxPsd1) / rxPsd1->GetSpectrumModel()->GetNumBands()) << \" dBm\"\n              << std::endl;\n\n    channelModel = {nullptr};\n    channelModel = CreateObject<ThreeGppChannelModel>();\n    channelModel->SetAttribute(\"Frequency\", DoubleValue(frequency));\n    channelModel->SetAttribute(\"Scenario\", StringValue(scenario));\n    channelModel->SetAttribute(\"ChannelConditionModel\", PointerValue(condModel));\n\n    channelModel->AssignStreams(stream);\n\n    Ptr<const ThreeGppChannelModel::ChannelMatrix> channelMatrix2 =\n        channelModel->GetChannel(txMob, rxMob, txAntenna, rxAntenna);\n\n    /*  for (uint32_t i = 0; i < channelMatrix2->m_channel.size (); i++)\n      {\n          for (uint32_t j = 0; j < channelMatrix2->m_channel.at (0).size (); j++)\n          {\n              std::cout << channelMatrix2->m_channel[i][j][0] << std::endl;\n          }\n      }*/\n\n    if (channelMatrix1->m_channel != channelMatrix2->m_channel)\n    {\n        std::cout << \"matrices are different\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"matrices are the same\" << std::endl;\n    }\n\n    Ptr<const SpectrumModel> sm2 =\n        NrSpectrumValueHelper::GetSpectrumModel(rbNum, frequency, subcarrierSpacing);\n    std::vector<int> activeRbs2;\n    for (size_t rbId = 0; rbId < sm2->GetNumBands(); rbId++)\n    {\n        activeRbs2.push_back(rbId);\n    }\n    Ptr<const SpectrumValue> txPsd2 = NrSpectrumValueHelper::CreateTxPowerSpectralDensity(\n        txPower,\n        activeRbs2,\n        sm2,\n        NrSpectrumValueHelper::UNIFORM_POWER_ALLOCATION_BW);\n    Ptr<SpectrumSignalParameters> txParams2 = Create<SpectrumSignalParameters>();\n    txParams2->psd = txPsd2->Copy();\n\n    std::cout << \"Average tx power 1: \"\n              << 10 * log10(Sum(*txPsd2) / txPsd2->GetSpectrumModel()->GetNumBands()) << \" dBm\"\n              << std::endl;\n    Ptr<SpectrumValue> rxPsd2 = m_spectrumLossModel->DoCalcRxPowerSpectralDensity(txParams2,\n                                                                                  txMob,\n                                                                                  rxMob,\n                                                                                  txAntenna,\n                                                                                  rxAntenna);\n    std::cout << \"Average rx power 1: \"\n              << 10 * log10(Sum(*rxPsd2) / rxPsd2->GetSpectrumModel()->GetNumBands()) << \" dBm\"\n              << std::endl;\n\n    Simulator::Stop(MilliSeconds(simTimeMs));\n    Simulator::Run();\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/cttc-error-model-amc.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2019 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-helper.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/nr-point-to-point-epc-helper.h\"\n#include \"ns3/point-to-point-helper.h\"\n#include <ns3/antenna-module.h>\n\n#include <chrono>\n\n/**\n * \\file cttc-error-model-amc.cc\n * \\ingroup examples\n * \\brief Error model example with adaptive modulation and coding: 1 gNB and 1 UE, multiple packets\n * with non-varying fading conditions.\n *\n * This example allows the user to test the end-to-end performance with the new\n * NR PHY abstraction model for error modeling by using adaptive modulation and coding (AMC).\n * It allows the user to set the gNB-UE distance, the MCS table, the error model type, and the HARQ\n * method.\n *\n * The NR error model can be set as \"--errorModel=ns3::NrEesmCcT1\", for HARQ-CC and MCS Table1,\n * while \"--errorModel=ns3::NrLteMiErrorModel\" configures the LTE error model.\n * For NR, you can choose between different types of error model, which use\n * different tables and different methods to process the HARQ history, e.g.,\n * \"--errorModel=ns3::NrEesmIrT1\", for HARQ-IR and MCS Table2.\n *\n * The AMC model defaults to the Error-model based AMC, but can\n * be changed through to use the Shannon-based model, through the AmcModel attribute, manually.\n *\n * The scenario consists of a single gNB and a single UE, placed at positions (0.0, 0.0, 10), and\n * (0.0, ueY, 1.5), respectively. ueY can be configured by the user, e.g. \"ueY=20\", and defaults\n * to 30 m.\n *\n * By default, the program uses the 3GPP channel model, Urban Micro scenario, without shadowing and\n * with probabilistic line of sight / non-line of sight option. The program runs for 5 seconds and\n * one packet is transmitted every 200 ms from gNB to UE (donwlink direction). The packet size can\n * be configured by using the following parameter: \"--packetSize=1000\". There are no channel updates\n * (the channel update period is 0 ms), so that we allow for proper MCS adaptation.\n *\n * This simulation prints the output to the terminal. The output statistics are\n * averaged among all the transmitted packets.\n *\n * To run the simulation with the default configuration one shall run the\n * following in the command line:\n *\n * ./ns3 run cttc-error-model-amc\n *\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CttcErrorModelAmcExample\");\n\nstatic Ptr<ListPositionAllocator>\nGetGnbPositions(double gNbHeight = 10.0)\n{\n    Ptr<ListPositionAllocator> pos = CreateObject<ListPositionAllocator>();\n    pos->Add(Vector(0.0, 0.0, gNbHeight));\n\n    return pos;\n}\n\nstatic Ptr<ListPositionAllocator>\nGetUePositions(double ueY, double ueHeight = 1.5)\n{\n    Ptr<ListPositionAllocator> pos = CreateObject<ListPositionAllocator>();\n    pos->Add(Vector(0.0, ueY, ueHeight));\n\n    return pos;\n}\n\nstatic std::vector<uint64_t> packetsTime;\n\nstatic void\nPrintRxPkt([[maybe_unused]] std::string context, Ptr<const Packet> pkt)\n{\n    // ASSUMING ONE UE\n    SeqTsHeader seqTs;\n    pkt->PeekHeader(seqTs);\n    packetsTime.push_back((Simulator::Now() - seqTs.GetTs()).GetMicroSeconds());\n}\n\nint\nmain(int argc, char* argv[])\n{\n    const uint8_t gNbNum = 1;\n    const uint8_t ueNum = 1;\n    double totalTxPower = 4;\n    uint16_t numerologyBwp = 4;\n    double centralFrequencyBand = 28e9;\n    double bandwidthBand = 100e6;\n    double ueY = 30.0;\n\n    double simTime = 5.0; // 5 seconds: to give time AMC to stabilize\n    uint32_t pktSize = 500;\n    Time udpAppStartTime = MilliSeconds(1000);\n    Time packetInterval = MilliSeconds(200);\n    Time updateChannelInterval = MilliSeconds(0); // no channel updates to test AMC\n\n    std::string errorModel = \"ns3::NrEesmCcT1\";\n\n    CommandLine cmd(__FILE__);\n\n    cmd.AddValue(\"simTime\", \"Simulation time\", simTime);\n    cmd.AddValue(\"errorModelType\",\n                 \"Error model type: ns3::NrEesmCcT1, ns3::NrEesmCcT2, ns3::NrEesmIrT1, \"\n                 \"ns3::NrEesmIrT2, ns3::NrLteMiErrorModel\",\n                 errorModel);\n    cmd.AddValue(\"ueY\", \"Y position of any UE\", ueY);\n    cmd.AddValue(\"pktSize\", \"Packet Size\", pktSize);\n\n    cmd.Parse(argc, argv);\n\n    uint32_t packets = (simTime - udpAppStartTime.GetSeconds()) / packetInterval.GetSeconds();\n    NS_ABORT_IF(packets == 0);\n\n    /*\n     * Default values for the simulation. We are progressively removing all\n     * the instances of SetDefault, but we need it for legacy code (LTE)\n     */\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n\n    /*\n     * TODO: remove all the instances of SetDefault, NrEesmErrorModel, NrAmc\n     */\n\n    Config::SetDefault(\"ns3::NrAmc::ErrorModelType\", TypeIdValue(TypeId::LookupByName(errorModel)));\n    Config::SetDefault(\"ns3::NrAmc::AmcModel\",\n                       EnumValue(NrAmc::ErrorModel)); // NrAmc::ShannonModel or NrAmc::ErrorModel\n\n    // create base stations and mobile terminals\n    NodeContainer gNbNodes;\n    NodeContainer ueNodes;\n    MobilityHelper mobility;\n\n    double gNbHeight = 10.0;\n    double ueHeight = 1.5;\n\n    gNbNodes.Create(gNbNum);\n    ueNodes.Create(ueNum);\n\n    Ptr<ListPositionAllocator> gNbPositionAlloc = GetGnbPositions(gNbHeight);\n    Ptr<ListPositionAllocator> uePositionAlloc = GetUePositions(ueY, ueHeight);\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(gNbPositionAlloc);\n    mobility.Install(gNbNodes);\n\n    mobility.SetPositionAllocator(uePositionAlloc);\n    mobility.Install(ueNodes);\n\n    /*\n     * Setup the NR module. We create the various helpers needed for the\n     * NR simulation:\n     * - EpcHelper, which will setup the core network\n     * - IdealBeamformingHelper, which takes care of the beamforming part\n     * - NrHelper, which takes care of creating and connecting the various\n     * part of the NR stack\n     */\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n\n    // Put the pointers inside nrHelper\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    /*\n     * Spectrum division. We create one operational band, with one CC, and the CC with a single\n     * bandwidth part.\n     */\n    BandwidthPartInfoPtrVector allBwps;\n    CcBwpCreator ccBwpCreator;\n    const uint8_t numCcPerBand = 1;\n\n    CcBwpCreator::SimpleOperationBandConf bandConf(centralFrequencyBand,\n                                                   bandwidthBand,\n                                                   numCcPerBand,\n                                                   BandwidthPartInfo::UMi_StreetCanyon);\n    OperationBandInfo band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);\n\n    /*\n     * Attributes of ThreeGppChannelModel still cannot be set in our way.\n     * TODO: Coordinate with Tommaso\n     */\n    Config::SetDefault(\"ns3::ThreeGppChannelModel::UpdatePeriod\", TimeValue(updateChannelInterval));\n    nrHelper->SetChannelConditionModelAttribute(\"UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n\n    /*\n     * Initialize channel and pathloss, plus other things inside band.\n     */\n    nrHelper->InitializeOperationBand(&band);\n    allBwps = CcBwpCreator::GetAllBwps({band});\n\n    Packet::EnableChecking();\n    Packet::EnablePrinting();\n\n    /*\n     *  Case (i): Attributes valid for all the nodes\n     */\n    // Beamforming method\n    idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));\n\n    // Core latency\n    epcHelper->SetAttribute(\"S1uLinkDelay\", TimeValue(MilliSeconds(0)));\n\n    // Antennas for all the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(2));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(4));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Antennas for all the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(4));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(8));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Scheduler\n    nrHelper->SetSchedulerAttribute(\"FixedMcsDl\", BooleanValue(false));\n    nrHelper->SetSchedulerAttribute(\"FixedMcsUl\", BooleanValue(false));\n\n    // Error Model: UE and GNB with same spectrum error model.\n    nrHelper->SetUlErrorModel(errorModel);\n    nrHelper->SetDlErrorModel(errorModel);\n\n    // Both DL and UL AMC will have the same model behind.\n    nrHelper->SetGnbDlAmcAttribute(\n        \"AmcModel\",\n        EnumValue(NrAmc::ErrorModel)); // NrAmc::ShannonModel or NrAmc::ErrorModel\n    nrHelper->SetGnbUlAmcAttribute(\n        \"AmcModel\",\n        EnumValue(NrAmc::ErrorModel)); // NrAmc::ShannonModel or NrAmc::ErrorModel\n\n    uint32_t bwpId = 0;\n\n    // gNb routing between Bearer and bandwidh part\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\", UintegerValue(bwpId));\n\n    // Ue routing between Bearer and bandwidth part\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\", UintegerValue(bwpId));\n\n    NetDeviceContainer gnbNetDev = nrHelper->InstallGnbDevice(gNbNodes, allBwps);\n    NetDeviceContainer ueNetDev = nrHelper->InstallUeDevice(ueNodes, allBwps);\n\n    int64_t randomStream = 1;\n    randomStream += nrHelper->AssignStreams(gnbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);\n\n    /*\n     * Case (iii): Go node for node and change the attributes we have to setup\n     * per-node.\n     */\n\n    // Get the first netdevice (enbNetDev.Get (0)) and the first bandwidth part (0)\n    // and set the attribute.\n    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 0)\n        ->SetAttribute(\"Numerology\", UintegerValue(numerologyBwp));\n    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 0)->SetAttribute(\"TxPower\", DoubleValue(totalTxPower));\n\n    // When all the configuration is done, explicitly call UpdateConfig ()\n\n    for (auto it = gnbNetDev.Begin(); it != gnbNetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.000)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));\n\n    // Set the default gateway for the UEs\n    for (uint32_t j = 0; j < ueNodes.GetN(); ++j)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(ueNodes.Get(j)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // assign IP address to UEs, and install UDP downlink applications\n    uint16_t dlPort = 1234;\n    ApplicationContainer clientApps;\n    ApplicationContainer serverApps;\n\n    ApplicationContainer clientAppsEmbb;\n    ApplicationContainer serverAppsEmbb;\n\n    UdpServerHelper dlPacketSinkHelper(dlPort);\n    serverApps.Add(dlPacketSinkHelper.Install(ueNodes));\n\n    // configure here UDP traffic\n    for (uint32_t j = 0; j < ueNodes.GetN(); ++j)\n    {\n        UdpClientHelper dlClient(ueIpIface.GetAddress(j), dlPort);\n        dlClient.SetAttribute(\"MaxPackets\", UintegerValue(packets));\n        dlClient.SetAttribute(\"PacketSize\", UintegerValue(pktSize));\n        dlClient.SetAttribute(\"Interval\", TimeValue(packetInterval));\n\n        clientApps.Add(dlClient.Install(remoteHost));\n    }\n\n    for (uint32_t j = 0; j < serverApps.GetN(); ++j)\n    {\n        Ptr<UdpServer> client = DynamicCast<UdpServer>(serverApps.Get(j));\n        NS_ASSERT(client != nullptr);\n        std::stringstream ss;\n        ss << j;\n        client->TraceConnect(\"Rx\", ss.str(), MakeCallback(&PrintRxPkt));\n    }\n\n    // start UDP server and client apps\n    serverApps.Start(udpAppStartTime);\n    clientApps.Start(udpAppStartTime);\n    serverApps.Stop(Seconds(simTime));\n    clientApps.Stop(Seconds(simTime));\n\n    // attach UEs to the closest eNB\n    nrHelper->AttachToClosestEnb(ueNetDev, gnbNetDev);\n\n    // enable the traces provided by the nr module\n    // nrHelper->EnableTraces();\n\n    Simulator::Stop(Seconds(simTime));\n\n    auto start = std::chrono::steady_clock::now();\n\n    Simulator::Run();\n\n    auto end = std::chrono::steady_clock::now();\n\n    uint64_t sum = 0;\n    uint32_t cont = 0;\n    for (auto& v : packetsTime)\n    {\n        if (v < 100000)\n        {\n            sum += v;\n            cont++;\n        }\n    }\n    std::cout << \"Packets received: \" << packetsTime.size() << std::endl;\n    std::cout << \"Counter (packets not affected by reordering): \" << +cont << std::endl;\n\n    if (packetsTime.size() > 0 && cont > 0)\n    {\n        std::cout << \"Average e2e latency (over all received packets): \" << sum / packetsTime.size()\n                  << \" us\" << std::endl;\n        std::cout << \"Average e2e latency (over counter): \" << sum / cont << \" us\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"Average e2e latency: Not Available\" << std::endl;\n    }\n\n    for (auto it = serverApps.Begin(); it != serverApps.End(); ++it)\n    {\n        uint64_t recv = DynamicCast<UdpServer>(*it)->GetReceived();\n        std::cout << \"Sent: \" << packets << \" Recv: \" << recv << \" Lost: \" << packets - recv\n                  << \" pkts, ( \" << (static_cast<double>(packets - recv) / packets) * 100.0\n                  << \" % )\" << std::endl;\n    }\n\n    Simulator::Destroy();\n\n    std::cout << \"Running time: \"\n              << std::chrono::duration_cast<std::chrono::seconds>(end - start).count() << \" s.\"\n              << std::endl;\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/cttc-error-model-comparison.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2019 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-helper.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/nr-point-to-point-epc-helper.h\"\n#include \"ns3/point-to-point-helper.h\"\n\n/**\n * \\file cttc-error-model-comparison.cc\n * \\ingroup examples\n * \\brief Error model example comparison: TBS for all MCSs.\n *\n * This example allows the user to compare the Transport Block Size that is obtained\n * for each MCS index under different error models (NR and LTE) and different MCS Tables.\n *\n * The NR error model can be set as \"--errorModel=ns3::NrEesmCcT1\", for HARQ-CC and MCS Table1,\n * while \"--errorModel=ns3::NrLteMiErrorModel\" configures the LTE error model.\n * For NR, you can choose between different types of error model, which use\n * different tables and different methods to process the HARQ history, e.g.,\n * \"--errorModel=ns3::NrEesmIrT1\", for HARQ-IR and MCS Table2.\n *\n * There is no deployment scenario configured, the example directly computes the TBS\n * for all MCSs of the configured error model and MCS Table, assuming numerology 4\n * and 100 MHz of channel bandwidth.\n *\n * This simulation prints the output to the terminal, showing for each MCS: 1)\n * the TBS that fits in 1 OFDM symbol (whole bandwidth) and 2) the TBS that fits\n * in 1 OFDM symbol and a single RB.\n *\n * To run the simulation with the default configuration one shall run the\n * following in the command line:\n *\n * ./ns3 run cttc-error-model-comparison\n *\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CttcErrorModelComparisonExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    std::string errorModel = \"ns3::NrEesmCcT1\";\n\n    CommandLine cmd(__FILE__);\n\n    cmd.AddValue(\"errorModelType\",\n                 \"Error model type: ns3::NrEesmCcT1, ns3::NrEesmCcT2, ns3::NrEesmIrT1, \"\n                 \"ns3::NrEesmIrT2, ns3::NrLteMiErrorModel\",\n                 errorModel);\n\n    cmd.Parse(argc, argv);\n\n    /*\n     * TODO: remove all the instances of SetDefault, NrEesmErrorModel, NrAmc\n     */\n    Config::SetDefault(\"ns3::NrAmc::ErrorModelType\", TypeIdValue(TypeId::LookupByName(errorModel)));\n    Config::SetDefault(\"ns3::NrAmc::AmcModel\", EnumValue(NrAmc::ShannonModel));\n\n    // Compute number of RBs that fit in 100 MHz channel bandwidth with numerology 4 (240 kHz SCS)\n    const uint8_t numerology = 4;\n    const uint32_t bandwidth = 100e6;\n    const uint32_t numRbsInBandwidth = bandwidth / (15e3 * std::pow(2, numerology) * 12);\n\n    Ptr<NrAmc> amc = CreateObject<NrAmc>();\n    amc->SetDlMode();\n\n    std::string tbs;\n    for (uint32_t mcs = 0; mcs <= amc->GetMaxMcs(); ++mcs)\n    {\n        std::stringstream ss;\n        ss << \"\\nResults for DL (UL only in NR case): MCS \" << mcs << \". TBS in 1 RB: [\"\n           << amc->CalculateTbSize(mcs, 1) << \"] bytes. TBS in 1 sym: [\"\n           << amc->CalculateTbSize(mcs, numRbsInBandwidth) << \"] bytes.\";\n        tbs += ss.str();\n    }\n\n    std::cout << \"NUMEROLOGY 4, 100e6 BANDWIDTH, Error Model: \";\n    std::cout << errorModel << \". Results: \" << std::endl;\n    std::cout << tbs << std::endl;\n\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/cttc-error-model.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2019 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-helper.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/nr-point-to-point-epc-helper.h\"\n#include \"ns3/point-to-point-helper.h\"\n#include <ns3/antenna-module.h>\n\n#include <chrono>\n\n/**\n * \\file cttc-error-model.cc\n * \\ingroup examples\n * \\brief Error model example with fixed MCS: 1 gNB and 1 UE, multiple packets with varying fading\n * conditions.\n *\n * This example allows the user to test the end-to-end performance with the new\n * NR PHY abstraction model for error modeling by using a fixed MCS. It allows the user to set the\n * MCS, the gNB-UE distance, the MCS table, the error model type, and the HARQ method.\n *\n * The NR error model can be set as \"--errorModel=ns3::NrEesmCcT1\", for HARQ-CC and MCS Table1,\n * while \"--errorModel=ns3::NrLteMiErrorModel\" configures the LTE error model.\n * For NR, you can choose between different types of error model, which use\n * different tables and different methods to process the HARQ history, e.g.,\n * \"--errorModel=ns3::NrEesmIrT1\", for HARQ-IR and MCS Table2.\n * You can fix also the MCS index to use with \"--mcs=7\" (7 in this case), which refers\n * to the configured MCS table.\n *\n * The scenario consists of a single gNB and a single UE, placed at positions (0.0, 0.0, 10), and\n * (0.0, ueY, 1.5), respectively. ueY can be configured by the user, e.g. \"ueY=20\", and defaults\n * to 30 m.\n *\n * By default, the program uses the 3GPP channel model, Urban Micro scenario, without shadowing and\n * with probabilistic line of sight / non-line of sight option. The program runs for 50 seconds and\n * one packet is transmitted every 200 ms from gNB to UE (donwlink direction). The packet size can\n * be configured by using the following parameter: \"--packetSize=1000\". The channel update period is\n * 150 ms, so that every packet encounters a different fading condition.\n *\n * This simulation prints the output to the terminal. The output statistics are\n * averaged among all the transmitted packets.\n *\n * To run the simulation with the default configuration one shall run the\n * following in the command line:\n *\n * ./ns3 run cttc-error-model\n *\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CttcErrorModelExample\");\n\nstatic Ptr<ListPositionAllocator>\nGetGnbPositions(double gNbHeight = 10.0)\n{\n    Ptr<ListPositionAllocator> pos = CreateObject<ListPositionAllocator>();\n    pos->Add(Vector(0.0, 0.0, gNbHeight));\n\n    return pos;\n}\n\nstatic Ptr<ListPositionAllocator>\nGetUePositions(double ueY, double ueHeight = 1.5)\n{\n    Ptr<ListPositionAllocator> pos = CreateObject<ListPositionAllocator>();\n    pos->Add(Vector(0.0, ueY, ueHeight));\n\n    return pos;\n}\n\nstatic std::vector<uint64_t> packetsTime;\n\nstatic void\nPrintRxPkt([[maybe_unused]] std::string context, Ptr<const Packet> pkt)\n{\n    // ASSUMING ONE UE\n    SeqTsHeader seqTs;\n    pkt->PeekHeader(seqTs);\n    packetsTime.push_back((Simulator::Now() - seqTs.GetTs()).GetMicroSeconds());\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t mcs = 13;\n    const uint8_t gNbNum = 1;\n    const uint8_t ueNum = 1;\n    double totalTxPower = 4;\n    uint16_t numerologyBwp = 4;\n    double centralFrequencyBand = 28e9;\n    double bandwidthBand = 100e6;\n    double ueY = 30.0;\n\n    double simTime = 10.0; // 50 seconds: to take statistics\n    uint32_t pktSize = 500;\n    Time udpAppStartTime = MilliSeconds(1000);\n    Time packetInterval = MilliSeconds(200);\n    Time updateChannelInterval = MilliSeconds(150);\n    bool isUl = false;\n\n    std::string errorModel = \"ns3::NrEesmCcT1\";\n\n    CommandLine cmd(__FILE__);\n\n    cmd.AddValue(\"simTime\", \"Simulation time\", simTime);\n    cmd.AddValue(\"mcs\", \"The MCS that will be used in this example\", mcs);\n    cmd.AddValue(\"errorModelType\",\n                 \"Error model type: ns3::NrEesmCcT1, ns3::NrEesmCcT2, ns3::NrEesmIrT1, \"\n                 \"ns3::NrEesmIrT2, ns3::NrLteMiErrorModel\",\n                 errorModel);\n    cmd.AddValue(\"ueY\", \"Y position of any UE\", ueY);\n    cmd.AddValue(\"pktSize\", \"Packet Size\", pktSize);\n    cmd.AddValue(\"isUl\", \"Is this an UL transmission?\", isUl);\n\n    cmd.Parse(argc, argv);\n\n    uint32_t packets = (simTime - udpAppStartTime.GetSeconds()) / packetInterval.GetSeconds();\n    NS_ABORT_IF(packets == 0);\n\n    /*\n     * Default values for the simulation. We are progressively removing all\n     * the instances of SetDefault, but we need it for legacy code (LTE)\n     */\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n\n    Config::SetDefault(\"ns3::NrAmc::ErrorModelType\", TypeIdValue(TypeId::LookupByName(errorModel)));\n    Config::SetDefault(\"ns3::NrAmc::AmcModel\",\n                       EnumValue(NrAmc::ShannonModel)); // NOT USED in this example. MCS is fixed.\n\n    // create base stations and mobile terminals\n    NodeContainer gNbNodes;\n    NodeContainer ueNodes;\n    MobilityHelper mobility;\n\n    double gNbHeight = 10.0;\n    double ueHeight = 1.5;\n\n    gNbNodes.Create(gNbNum);\n    ueNodes.Create(ueNum);\n\n    Ptr<ListPositionAllocator> gNbPositionAlloc = GetGnbPositions(gNbHeight);\n    Ptr<ListPositionAllocator> uePositionAlloc = GetUePositions(ueY, ueHeight);\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(gNbPositionAlloc);\n    mobility.Install(gNbNodes);\n\n    mobility.SetPositionAllocator(uePositionAlloc);\n    mobility.Install(ueNodes);\n\n    /*\n     * Setup the NR module. We create the various helpers needed for the\n     * NR simulation:\n     * - EpcHelper, which will setup the core network\n     * - IdealBeamformingHelper, which takes care of the beamforming part\n     * - NrHelper, which takes care of creating and connecting the various\n     * part of the NR stack\n     */\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n\n    // Put the pointers inside nrHelper\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    /*\n     * Spectrum division. We create one operational band, with one CC, and the CC with a single\n     * bandwidth part.\n     */\n    BandwidthPartInfoPtrVector allBwps;\n    CcBwpCreator ccBwpCreator;\n    const uint8_t numCcPerBand = 1;\n\n    CcBwpCreator::SimpleOperationBandConf bandConf(centralFrequencyBand,\n                                                   bandwidthBand,\n                                                   numCcPerBand,\n                                                   BandwidthPartInfo::UMi_StreetCanyon);\n    OperationBandInfo band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);\n\n    /*\n     * Attributes of ThreeGppChannelModel still cannot be set in our way.\n     * TODO: Coordinate with Tommaso\n     */\n    Config::SetDefault(\"ns3::ThreeGppChannelModel::UpdatePeriod\", TimeValue(updateChannelInterval));\n    nrHelper->SetChannelConditionModelAttribute(\"UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n\n    /*\n     * Initialize channel and pathloss, plus other things inside band.\n     */\n    nrHelper->InitializeOperationBand(&band);\n    allBwps = CcBwpCreator::GetAllBwps({band});\n\n    Packet::EnableChecking();\n    Packet::EnablePrinting();\n\n    /*\n     *  Case (i): Attributes valid for all the nodes\n     */\n    // Beamforming method\n    idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));\n\n    // Core latency\n    epcHelper->SetAttribute(\"S1uLinkDelay\", TimeValue(MilliSeconds(0)));\n\n    // Antennas for all the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(2));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(4));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Antennas for all the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(4));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(8));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Scheduler\n    nrHelper->SetSchedulerAttribute(\"FixedMcsDl\", BooleanValue(true));\n    nrHelper->SetSchedulerAttribute(\"FixedMcsUl\", BooleanValue(true));\n    nrHelper->SetSchedulerAttribute(\"StartingMcsDl\", UintegerValue(mcs));\n    nrHelper->SetSchedulerAttribute(\"StartingMcsUl\", UintegerValue(mcs));\n\n    // Error Model: UE and GNB with same spectrum error model.\n    nrHelper->SetUlErrorModel(errorModel);\n    nrHelper->SetDlErrorModel(errorModel);\n\n    // Both DL and UL AMC will have the same model behind.\n    // Note: NOT USED in this example. MCS is fixed.\n    nrHelper->SetGnbDlAmcAttribute(\"AmcModel\", EnumValue(NrAmc::ShannonModel));\n    nrHelper->SetGnbUlAmcAttribute(\"AmcModel\", EnumValue(NrAmc::ShannonModel));\n\n    nrHelper->SetUePhyAttribute(\"TxPower\", DoubleValue(totalTxPower));\n\n    uint32_t bwpId = 0;\n\n    // gNb routing between Bearer and bandwidh part\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\", UintegerValue(bwpId));\n\n    // Ue routing between Bearer and bandwidth part\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\", UintegerValue(bwpId));\n\n    NetDeviceContainer gnbNetDev = nrHelper->InstallGnbDevice(gNbNodes, allBwps);\n    NetDeviceContainer ueNetDev = nrHelper->InstallUeDevice(ueNodes, allBwps);\n\n    int64_t randomStream = 1;\n    randomStream += nrHelper->AssignStreams(gnbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);\n\n    /*\n     * Case (iii): Go node for node and change the attributes we have to setup\n     * per-node.\n     */\n\n    // Get the first netdevice (enbNetDev.Get (0)) and the first bandwidth part (0)\n    // and set the attribute.\n    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 0)\n        ->SetAttribute(\"Numerology\", UintegerValue(numerologyBwp));\n    nrHelper->GetGnbPhy(gnbNetDev.Get(0), 0)->SetAttribute(\"TxPower\", DoubleValue(totalTxPower));\n\n    // When all the configuration is done, explicitly call UpdateConfig ()\n\n    for (auto it = gnbNetDev.Begin(); it != gnbNetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.000)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));\n\n    // Set the default gateway for the UEs\n    for (uint32_t j = 0; j < ueNodes.GetN(); ++j)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(ueNodes.Get(j)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // assign IP address to UEs, and install UDP downlink applications\n    uint16_t dlPort = 1234;\n    UdpServerHelper dlPacketSinkHelper(dlPort);\n    ApplicationContainer txApps;\n    ApplicationContainer sinkApps;\n    NodeContainer txNodes;\n    NodeContainer sinkNodes;\n    Ipv4InterfaceContainer sinkIps;\n\n    if (isUl)\n    {\n        sinkIps.Add(internetIpIfaces.Get(1));\n        sinkNodes = remoteHostContainer;\n        txNodes = ueNodes;\n    }\n    else\n    {\n        sinkIps = ueIpIface;\n        sinkNodes = ueNodes;\n        txNodes = remoteHostContainer;\n    }\n\n    // configure here UDP traffic\n    for (uint32_t i = 0; i < txNodes.GetN(); ++i)\n    {\n        for (uint32_t j = 0; j < sinkNodes.GetN(); ++j)\n        {\n            UdpClientHelper dlClient(sinkIps.GetAddress(j), dlPort);\n            dlClient.SetAttribute(\"MaxPackets\", UintegerValue(packets));\n            dlClient.SetAttribute(\"PacketSize\", UintegerValue(pktSize));\n            dlClient.SetAttribute(\"Interval\", TimeValue(packetInterval));\n\n            txApps.Add(dlClient.Install(txNodes.Get(i)));\n        }\n    }\n\n    sinkApps.Add(dlPacketSinkHelper.Install(sinkNodes));\n    for (uint32_t j = 0; j < sinkApps.GetN(); ++j)\n    {\n        Ptr<UdpServer> client = DynamicCast<UdpServer>(sinkApps.Get(j));\n        NS_ASSERT(client != nullptr);\n        std::stringstream ss;\n        ss << j;\n        client->TraceConnect(\"Rx\", ss.str(), MakeCallback(&PrintRxPkt));\n    }\n\n    // start UDP server and client apps\n    sinkApps.Start(udpAppStartTime);\n    txApps.Start(udpAppStartTime);\n    sinkApps.Stop(Seconds(simTime));\n    txApps.Stop(Seconds(simTime));\n\n    // attach UEs to the closest eNB\n    nrHelper->AttachToClosestEnb(ueNetDev, gnbNetDev);\n\n    // enable the traces provided by the nr module\n    // nrHelper->EnableTraces();\n\n    Simulator::Stop(Seconds(simTime));\n\n    auto start = std::chrono::steady_clock::now();\n\n    Simulator::Run();\n\n    auto end = std::chrono::steady_clock::now();\n\n    uint64_t sum = 0;\n    uint32_t cont = 0;\n    for (auto& v : packetsTime)\n    {\n        if (v < 100000)\n        {\n            sum += v;\n            cont++;\n        }\n    }\n    std::cout << \"Packets received: \" << packetsTime.size() << std::endl;\n    std::cout << \"Counter (packets not affected by reordering): \" << +cont << std::endl;\n\n    if (packetsTime.size() > 0 && cont > 0)\n    {\n        std::cout << \"Average e2e latency (over all received packets): \" << sum / packetsTime.size()\n                  << \" us\" << std::endl;\n        std::cout << \"Average e2e latency (over counter): \" << sum / cont << \" us\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"Average e2e latency: Not Available\" << std::endl;\n    }\n\n    for (auto it = sinkApps.Begin(); it != sinkApps.End(); ++it)\n    {\n        uint64_t recv = DynamicCast<UdpServer>(*it)->GetReceived();\n        std::cout << \"Sent: \" << packets << \" Recv: \" << recv << \" Lost: \" << packets - recv\n                  << \" pkts, ( \" << (static_cast<double>(packets - recv) / packets) * 100.0\n                  << \" % )\" << std::endl;\n    }\n\n    Simulator::Destroy();\n\n    std::cout << \"Running time: \"\n              << std::chrono::duration_cast<std::chrono::seconds>(end - start).count() << \" s.\"\n              << std::endl;\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/cttc-fh-compression.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2020 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n/**\n * \\ingroup examples\n * \\file cttc-fh-compression.cc\n * \\brief A multi-cell network deployment with site sectorization\n *\n * This example describes how to setup a simulation using the 3GPP channel model\n * from TR 38.900. This example consists of an hexagonal grid deployment\n * consisting on a central site and a number of outer rings of sites around this\n * central site. Each site is sectorized, meaning that a number of three antenna\n * arrays or panels are deployed per gNB. These three antennas are pointing to\n * 30\u00ba, 150\u00ba and 270\u00ba w.r.t. the horizontal axis. We allocate a band to each\n * sector of a site, and the bands are contiguous in frequency.\n *\n * We provide a number of simulation parameters that can be configured in the\n * command line, such as the number of UEs per cell or the number of outer rings.\n * Please have a look at the possible parameters to know what you can configure\n * through the command line.\n *\n * With the default configuration, the example will create one DL flow per UE.\n * The example will print on-screen the end-to-end result of each flow,\n * as well as writing them on a file.\n *\n * \\code{.unparsed}\n$ ./ns3 run \"cttc-fh-compression --PrintHelp\"\n    \\endcode\n *\n */\n\n/*\n * Include part. Often, you will have to include the headers for an entire module;\n * do that by including the name of the module you need with the suffix \"-module.h\".\n */\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/config-store.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include <ns3/antenna-module.h>\n#include <ns3/radio-environment-map-helper.h>\n#include <ns3/rng-seed-manager.h>\n#include <ns3/three-gpp-ftp-m1-helper.h>\n\n#include <algorithm>\n#include <iostream>\n/*\n * To be able to use LOG_* functions.\n */\n#include \"ns3/log.h\"\n\n/*\n * Use, always, the namespace ns3. All the NR classes are inside such namespace.\n */\nusing namespace ns3;\n\n/*\n * With this line, we will be able to see the logs of the file by enabling the\n * component \"FhCompression\", in this way:\n *\n * $ export NS_LOG=\"FhCompression=level_info|prefix_func|prefix_time\"\n */\nNS_LOG_COMPONENT_DEFINE(\"FhCompression\");\n\nclass RadioNetworkParametersHelper\n{\n  public:\n    /**\n     * \\brief Set the radio network parameters to LTE.\n     * \\param freqReuse The cell frequency reuse.\n     */\n    void SetNetworkToLte(const std::string scenario,\n                         const std::string operationMode,\n                         uint16_t numCcs);\n\n    /**\n     * \\brief Set the radio network parameters to NR.\n     * \\param scenario Urban scenario (UMa or UMi).\n     * \\param numerology Numerology to use.\n     * \\param freqReuse The cell frequency reuse.\n     */\n    void SetNetworkToNr(const std::string scenario,\n                        const std::string operationMode,\n                        uint16_t numerology,\n                        uint16_t numCcs);\n\n    /**\n     * \\brief Gets the BS transmit power\n     * \\return Transmit power in dBW\n     */\n    double GetTxPower();\n\n    /**\n     * \\brief Gets the operation bandwidth\n     * \\return Bandwidth in Hz\n     */\n    double GetBandwidth();\n\n    /**\n     * \\brief Gets the central frequency\n     * \\return Central frequency in Hz\n     */\n    double GetCentralFrequency();\n\n    /**\n     * \\brief Gets the band numerology\n     * \\return Numerology\n     */\n    uint16_t GetNumerology();\n\n    /**\n     * \\brief Converts the maxMcsVectorInput (string) into an std::vector of maximum MCS used per\n     * cell \\return maxMcsVector\n     */\n    std::vector<int16_t> GetMcsVectorFromInput();\n\n  private:\n    double m_txPower{-1.0};          //!< Transmit power in dBm\n    double m_bandwidth{0.0};         //!< System bandwidth in Hz\n    double m_centralFrequency{-1.0}; //!< Band central frequency in Hz\n    uint16_t m_numerology{0};        //!< Operation band numerology\n};\n\nstd::vector<int16_t>\nGetMcsVectorFromInput(const std::string& pattern)\n{\n    static std::unordered_map<std::string, int16_t> lookupTable = {\n        {\"1\", 1},   {\"2\", 2},   {\"3\", 3},   {\"4\", 4},   {\"5\", 5},   {\"6\", 6},   {\"7\", 7},\n        {\"8\", 8},   {\"9\", 9},   {\"10\", 10}, {\"11\", 11}, {\"12\", 12}, {\"13\", 13}, {\"14\", 14},\n        {\"15\", 15}, {\"16\", 16}, {\"17\", 17}, {\"18\", 18}, {\"19\", 19}, {\"20\", 20}, {\"21\", 21},\n        {\"22\", 22}, {\"23\", 23}, {\"24\", 24}, {\"25\", 25}, {\"26\", 26}, {\"27\", 27}, {\"28\", 28},\n    };\n\n    std::vector<int16_t> vector;\n    std::stringstream ss(pattern);\n    std::string token;\n    std::vector<std::string> extracted;\n\n    while (std::getline(ss, token, '|'))\n    {\n        extracted.push_back(token);\n    }\n\n    for (const auto& v : extracted)\n    {\n        if (lookupTable.find(v) == lookupTable.end())\n        {\n            NS_FATAL_ERROR(\"Not valid MCS input\");\n        }\n        vector.push_back(lookupTable[v]);\n    }\n\n    return vector;\n}\n\nvoid\nRadioNetworkParametersHelper::SetNetworkToLte(const std::string scenario,\n                                              const std::string operationMode,\n                                              uint16_t numCcs)\n{\n    NS_ABORT_MSG_IF(scenario != \"UMa\" && scenario != \"UMi\", \"Unsupported scenario\");\n\n    m_numerology = 0;\n    m_centralFrequency = 2e9;\n    m_bandwidth = 20e6 * numCcs; // 100 RBs per CC (freqReuse)\n    if (operationMode == \"FDD\")\n    {\n        m_bandwidth += m_bandwidth;\n    }\n    if (scenario == \"UMa\")\n    {\n        m_txPower = 43;\n    }\n    else\n    {\n        m_txPower = 30;\n    }\n}\n\nvoid\nRadioNetworkParametersHelper::SetNetworkToNr(const std::string scenario,\n                                             const std::string operationMode,\n                                             uint16_t numerology,\n                                             uint16_t numCcs)\n{\n    NS_ABORT_MSG_IF(scenario != \"UMa\" && scenario != \"UMi\", \"Unsupported scenario\");\n\n    m_numerology = numerology;\n    m_centralFrequency = 2e9;\n    m_bandwidth = 100e6 * numCcs; // 20e6 = 100 RBs per CC (freqReuse)\n    if (operationMode == \"FDD\")\n    {\n        m_bandwidth += m_bandwidth;\n    }\n    if (scenario == \"UMa\")\n    {\n        m_txPower = 43;\n    }\n    else\n    {\n        m_txPower = 30;\n    }\n}\n\ndouble\nRadioNetworkParametersHelper::GetTxPower()\n{\n    return m_txPower;\n}\n\ndouble\nRadioNetworkParametersHelper::GetBandwidth()\n{\n    return m_bandwidth;\n}\n\ndouble\nRadioNetworkParametersHelper::GetCentralFrequency()\n{\n    return m_centralFrequency;\n}\n\nuint16_t\nRadioNetworkParametersHelper::GetNumerology()\n{\n    return m_numerology;\n}\n\nvoid\nSet5gLenaSimulatorParameters(HexagonalGridScenarioHelper gridScenario,\n                             std::string scenario,\n                             std::string radioNetwork,\n                             std::string errorModel,\n                             std::string operationMode,\n                             std::string direction,\n                             uint16_t numerology,\n                             std::string pattern1,\n                             std::string pattern2,\n                             bool uniformPattern,\n                             NodeContainer gnbSector1Container,\n                             NodeContainer gnbSector2Container,\n                             NodeContainer gnbSector3Container,\n                             NodeContainer ueSector1Container,\n                             NodeContainer ueSector2Container,\n                             NodeContainer ueSector3Container,\n                             Ptr<PointToPointEpcHelper>& baseEpcHelper,\n                             Ptr<NrHelper>& nrHelper,\n                             NetDeviceContainer& gnbSector1NetDev,\n                             NetDeviceContainer& gnbSector2NetDev,\n                             NetDeviceContainer& gnbSector3NetDev,\n                             NetDeviceContainer& ueSector1NetDev,\n                             NetDeviceContainer& ueSector2NetDev,\n                             NetDeviceContainer& ueSector3NetDev,\n                             int16_t maxMcsDl1,\n                             int16_t maxMcsDl2,\n                             std::vector<int16_t>& maxMcsVector,\n                             bool uniformMcs,\n                             bool uniformLambda)\n{\n    /*\n     * Create the radio network related parameters\n     */\n    RadioNetworkParametersHelper ranHelper;\n    if (radioNetwork == \"LTE\")\n    {\n        ranHelper.SetNetworkToLte(scenario, operationMode, 1);\n        if (errorModel == \"\")\n        {\n            errorModel = \"ns3::LenaErrorModel\";\n        }\n        else if (errorModel != \"ns3::NrLteMiErrorModel\" && errorModel != \"ns3::LenaErrorModel\")\n        {\n            NS_ABORT_MSG(\"The selected error model is not recommended for LTE\");\n        }\n    }\n    else if (radioNetwork == \"NR\")\n    {\n        ranHelper.SetNetworkToNr(scenario, operationMode, numerology, 1);\n        if (errorModel == \"\")\n        {\n            errorModel = \"ns3::NrEesmIrT2\";\n        }\n        else if (errorModel == \"ns3::NrLteMiErrorModel\")\n        {\n            NS_ABORT_MSG(\"The selected error model is not recommended for NR\");\n        }\n    }\n    else\n    {\n        NS_ABORT_MSG(\"Unrecognized radio network technology\");\n    }\n\n    /*\n     * Setup the NR module. We create the various helpers needed for the\n     * NR simulation:\n     * - IdealBeamformingHelper, which takes care of the beamforming part\n     * - NrHelper, which takes care of creating and connecting the various\n     * part of the NR stack\n     */\n\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    nrHelper = CreateObject<NrHelper>();\n\n    // Put the pointers inside nrHelper\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n\n    Ptr<NrPointToPointEpcHelper> epcHelper = DynamicCast<NrPointToPointEpcHelper>(baseEpcHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    /*\n     * Spectrum division. We create one operational band containing three\n     * component carriers, and each CC containing a single bandwidth part\n     * centered at the frequency specified by the input parameters.\n     * Each spectrum part length is, as well, specified by the input parameters.\n     * The operational band will use StreetCanyon channel or UrbanMacro modeling.\n     */\n    BandwidthPartInfoPtrVector allBwps;\n    BandwidthPartInfoPtrVector bwps1;\n    BandwidthPartInfoPtrVector bwps2;\n    BandwidthPartInfoPtrVector bwps3;\n    CcBwpCreator ccBwpCreator;\n    // Create the configuration for the CcBwpHelper. SimpleOperationBandConf creates\n    // a single BWP per CC. Get the spectrum values from the RadioNetworkParametersHelper\n    double centralFrequencyBand = ranHelper.GetCentralFrequency();\n    double bandwidthBand = ranHelper.GetBandwidth();\n    const uint8_t numCcPerBand = 1; // In this example, each cell will have one CC with one BWP\n    BandwidthPartInfo::Scenario scene;\n    if (scenario == \"UMi\")\n    {\n        scene = BandwidthPartInfo::UMi_StreetCanyon;\n    }\n    else if (scenario == \"UMa\")\n    {\n        scene = BandwidthPartInfo::UMa;\n    }\n    else\n    {\n        NS_ABORT_MSG(\"Unsupported scenario\");\n    }\n\n    /*\n     * Attributes of ThreeGppChannelModel still cannot be set in our way.\n     * TODO: Coordinate with Tommaso\n     */\n    Config::SetDefault(\"ns3::ThreeGppChannelModel::UpdatePeriod\",\n                       TimeValue(MilliSeconds(0))); // 100ms\n    nrHelper->SetChannelConditionModelAttribute(\"UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n\n    // Error Model: UE and GNB with same spectrum error model.\n    nrHelper->SetUlErrorModel(errorModel);\n    nrHelper->SetDlErrorModel(errorModel);\n\n    // Both DL and UL AMC will have the same model behind.\n    nrHelper->SetGnbDlAmcAttribute(\n        \"AmcModel\",\n        EnumValue(NrAmc::ErrorModel)); // NrAmc::ShannonModel or NrAmc::ErrorModel\n    nrHelper->SetGnbUlAmcAttribute(\n        \"AmcModel\",\n        EnumValue(NrAmc::ErrorModel)); // NrAmc::ShannonModel or NrAmc::ErrorModel\n\n    /*\n     * Create the necessary operation bands. In this example, each sector operates\n     * in a separate band. Each band contains a single component carrier (CC),\n     * which is made of one BWP in TDD operation mode or two BWPs in FDD mode.\n     * Note that BWPs have the same bandwidth. Therefore, CCs and bands in FDD are\n     * twice larger than in TDD.\n     *\n     * The configured spectrum division for TDD operation is:\n     * |---Band1---|---Band2---|---Band3---|\n     * |----CC1----|----CC2----|----CC3----|\n     * |----BWP1---|----BWP2---|----BWP3---|\n     *\n     * And the configured spectrum division for FDD operation is:\n     * |---------Band1---------|---------Band2---------|---------Band3---------|\n     * |----------CC1----------|----------CC2----------|----------CC3----------|\n     * |----BWP1---|----BWP2---|----BWP3---|----BWP4---|----BWP5---|----BWP6---|\n     */\n    double centralFrequencyBand1 = centralFrequencyBand - bandwidthBand;\n    double centralFrequencyBand2 = centralFrequencyBand;\n    double centralFrequencyBand3 = centralFrequencyBand + bandwidthBand;\n    double bandwidthBand1 = bandwidthBand;\n    double bandwidthBand2 = bandwidthBand;\n    double bandwidthBand3 = bandwidthBand;\n\n    uint8_t numBwpPerCc = 1;\n    if (operationMode == \"FDD\")\n    {\n        numBwpPerCc = 2; // FDD will have 2 BWPs per CC\n    }\n\n    CcBwpCreator::SimpleOperationBandConf bandConf1(centralFrequencyBand1,\n                                                    bandwidthBand1,\n                                                    numCcPerBand,\n                                                    scene);\n    bandConf1.m_numBwp = numBwpPerCc; // FDD will have 2 BWPs per CC\n    CcBwpCreator::SimpleOperationBandConf bandConf2(centralFrequencyBand2,\n                                                    bandwidthBand2,\n                                                    numCcPerBand,\n                                                    scene);\n    bandConf2.m_numBwp = numBwpPerCc; // FDD will have 2 BWPs per CC\n    CcBwpCreator::SimpleOperationBandConf bandConf3(centralFrequencyBand3,\n                                                    bandwidthBand3,\n                                                    numCcPerBand,\n                                                    scene);\n    bandConf3.m_numBwp = numBwpPerCc; // FDD will have 2 BWPs per CC\n\n    // By using the configuration created, it is time to make the operation bands\n    OperationBandInfo band1 = ccBwpCreator.CreateOperationBandContiguousCc(bandConf1);\n    OperationBandInfo band2 = ccBwpCreator.CreateOperationBandContiguousCc(bandConf2);\n    OperationBandInfo band3 = ccBwpCreator.CreateOperationBandContiguousCc(bandConf3);\n\n    /*\n     * Initialize channel and pathloss, plus other things inside band1. If needed,\n     * the band configuration can be done manually, but we leave it for more\n     * sophisticated examples. For the moment, this method will take care\n     * of all the spectrum initialization needs.\n     */\n    nrHelper->InitializeOperationBand(&band1);\n    nrHelper->InitializeOperationBand(&band2);\n    nrHelper->InitializeOperationBand(&band3);\n    allBwps = CcBwpCreator::GetAllBwps({band1, band2, band3});\n    bwps1 = CcBwpCreator::GetAllBwps({band1});\n    bwps2 = CcBwpCreator::GetAllBwps({band2});\n    bwps3 = CcBwpCreator::GetAllBwps({band3});\n\n    /*\n     * Start to account for the bandwidth used by the example, as well as\n     * the total power that has to be divided among the BWPs. Since there is only\n     * one band and one BWP occupying the entire band, there is no need to divide\n     * power among BWPs.\n     */\n    double totalTxPower = ranHelper.GetTxPower(); // Convert to mW\n    double x = pow(10, totalTxPower / 10);\n\n    /*\n     * allBwps contains all the spectrum configuration needed for the nrHelper.\n     *\n     * Now, we can setup the attributes. We can have three kind of attributes:\n     * (i) parameters that are valid for all the bandwidth parts and applies to\n     * all nodes, (ii) parameters that are valid for all the bandwidth parts\n     * and applies to some node only, and (iii) parameters that are different for\n     * every bandwidth parts. The approach is:\n     *\n     * - for (i): Configure the attribute through the helper, and then install;\n     * - for (ii): Configure the attribute through the helper, and then install\n     * for the first set of nodes. Then, change the attribute through the helper,\n     * and install again;\n     * - for (iii): Install, and then configure the attributes by retrieving\n     * the pointer needed, and calling \"SetAttribute\" on top of such pointer.\n     *\n     */\n\n    Packet::EnableChecking();\n    Packet::EnablePrinting();\n\n    /*\n     *  Case (i): Attributes valid for all the nodes\n     */\n    // Beamforming method\n    if (radioNetwork == \"LTE\")\n    {\n        idealBeamformingHelper->SetAttribute(\n            \"BeamformingMethod\",\n            TypeIdValue(QuasiOmniDirectPathBeamforming::GetTypeId()));\n    }\n    else\n    {\n        idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                             TypeIdValue(DirectPathBeamforming::GetTypeId()));\n    }\n\n    //\n\n    // Scheduler type\n    if (radioNetwork == \"LTE\")\n    {\n        nrHelper->SetSchedulerTypeId(TypeId::LookupByName(\"ns3::NrMacSchedulerOfdmaPF\"));\n        nrHelper->SetSchedulerAttribute(\"DlCtrlSymbols\", UintegerValue(1));\n    }\n    // nrHelper->SetSchedulerAttribute (\"MaxDlMcs\", UintegerValue (maxMcsDl1));\n    // nrHelper->SetSchedulerAttribute (\"MaxDlMcs\", UintegerValue (10));  // 27, 19, 10, 4 for\n    // mcsT2,\n    //  28, 16, 9 for mcsT1\n\n    // Core latency\n    epcHelper->SetAttribute(\"S1uLinkDelay\", TimeValue(MilliSeconds(0)));\n\n    // Antennas for all the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(1));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(1));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Antennas for all the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(8));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(8));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<ThreeGppAntennaModel>()));\n\n    // UE transmit power\n    nrHelper->SetUePhyAttribute(\"TxPower\", DoubleValue(20.0));\n\n    // Set LTE RBG size\n    if (radioNetwork == \"LTE\")\n    {\n        nrHelper->SetGnbMacAttribute(\"NumRbPerRbg\", UintegerValue(4));\n    }\n\n    // We assume a common traffic pattern for all UEs\n    uint32_t bwpIdForLowLat = 0;\n    if (operationMode == \"FDD\" && direction == \"UL\")\n    {\n        bwpIdForLowLat = 1;\n    }\n\n    // gNb routing between Bearer and bandwidth part\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_VIDEO_TCP_DEFAULT\",\n                                                 UintegerValue(bwpIdForLowLat));\n\n    // Ue routing between Bearer and bandwidth part\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"NGBR_VIDEO_TCP_DEFAULT\",\n                                                UintegerValue(bwpIdForLowLat));\n\n    /*\n     * We miss many other parameters. By default, not configuring them is equivalent\n     * to use the default values. Please, have a look at the documentation to see\n     * what are the default values for all the attributes you are not seeing here.\n     */\n\n    /*\n     * Case (ii): Attributes valid for a subset of the nodes\n     */\n\n    // NOT PRESENT IN THIS SIMPLE EXAMPLE\n\n    /*\n     * We have configured the attributes we needed. Now, install and get the pointers\n     * to the NetDevices, which contains all the NR stack:\n     */\n\n    //  NetDeviceContainer enbNetDev = nrHelper->InstallGnbDevice (gridScenario.GetBaseStations (),\n    //  allBwps);\n    gnbSector1NetDev = nrHelper->InstallGnbDevice(gnbSector1Container, bwps1);\n    gnbSector2NetDev = nrHelper->InstallGnbDevice(gnbSector2Container, bwps2);\n    gnbSector3NetDev = nrHelper->InstallGnbDevice(gnbSector3Container, bwps3);\n    ueSector1NetDev = nrHelper->InstallUeDevice(ueSector1Container, bwps1);\n    ueSector2NetDev = nrHelper->InstallUeDevice(ueSector2Container, bwps2);\n    ueSector3NetDev = nrHelper->InstallUeDevice(ueSector3Container, bwps3);\n\n    int64_t randomStream = 1;\n    randomStream += nrHelper->AssignStreams(gnbSector1NetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(gnbSector2NetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(gnbSector3NetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueSector1NetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueSector2NetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueSector3NetDev, randomStream);\n\n    /*\n     * Case (iii): Go node for node and change the attributes we have to setup\n     * per-node.\n     */\n    int16_t maxMcsPerCell[gridScenario.GetNumCells()];\n    if (uniformMcs) // if uniformMcs -> same maximum MCS for all cells, input parameter maxMcsDl1\n    {\n        for (uint32_t i = 0; i < gridScenario.GetNumCells(); ++i)\n        {\n            maxMcsPerCell[i] = maxMcsDl1;\n            std::cout << \"Cell: \" << i << \" mcs (same mcs): \" << maxMcsPerCell[i] << std::endl;\n        }\n    }\n    else // Different cells may use different maxMcs (in case of different TDD patterns)\n    {\n        // algorithms for non-uniform max MCS\n        if (uniformPattern &&\n            uniformLambda) // if uniformPattern and uniformLambda --> no difference in max MCS\n        {\n            for (uint32_t i = 0; i < gridScenario.GetNumCells(); ++i)\n            {\n                maxMcsPerCell[i] = maxMcsDl1;\n                std::cout << \"Cell: \" << i << \" mcs (diff mcs): \" << maxMcsPerCell[i] << std::endl;\n            }\n        }\n        else if (uniformLambda &&\n                 !uniformPattern) // case of using different TDD patterns (per cell)\n        {\n            for (uint32_t i = 0; i < gridScenario.GetNumCells(); ++i)\n            {\n                if (i % 2 == 1) // pattern1\n                {\n                    maxMcsPerCell[i] = maxMcsDl1;\n                }\n                else // pattern2\n                {\n                    maxMcsPerCell[i] = maxMcsDl2;\n                }\n                std::cout << \"Cell: \" << i << \" mcs (diff tdd): \" << maxMcsPerCell[i] << std::endl;\n            }\n        }\n        else if (uniformPattern && !uniformLambda) // case of using different lambda (per cell)\n        {\n            for (uint32_t i = 0; i < gridScenario.GetNumCells(); ++i)\n            {\n                maxMcsPerCell[i] = maxMcsVector[i];\n                std::cout << \"Cell: \" << i << \" mcs (diff lambda): \" << maxMcsPerCell[i]\n                          << std::endl;\n            }\n        }\n    }\n\n    // Sectors (cells) of a site are pointing at different directions\n    double orientationRads = gridScenario.GetAntennaOrientationRadians(0);\n    uint32_t globalCellId = 0;\n    for (uint32_t numCell = 0; numCell < gnbSector1NetDev.GetN(); ++numCell)\n    {\n        Ptr<NetDevice> gnb = gnbSector1NetDev.Get(numCell);\n        uint32_t numBwps = nrHelper->GetNumberBwp(gnb);\n        if (numBwps == 1) // TDD\n        {\n            // Change the antenna orientation\n            Ptr<NrGnbPhy> phy = nrHelper->GetGnbPhy(gnb, 0);\n            Ptr<UniformPlanarArray> antenna =\n                DynamicCast<UniformPlanarArray>(phy->GetSpectrumPhy()->GetAntenna());\n            antenna->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n\n            // Set numerology\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"Numerology\",\n                                                      UintegerValue(ranHelper.GetNumerology()));\n\n            // Set TX power\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"TxPower\", DoubleValue(10 * log10(x)));\n\n            // Set TDD pattern\n            if (uniformPattern || (globalCellId % 2 == 1))\n            {\n                nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"Pattern\", StringValue(pattern1));\n            }\n            else\n            {\n                nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"Pattern\", StringValue(pattern2));\n            }\n\n            // Set max MCS\n            nrHelper->GetScheduler(gnb, 0)->SetAttribute(\"MaxDlMcs\",\n                                                         IntegerValue(maxMcsPerCell[globalCellId]));\n            // nrHelper->GetGnbMac (gnb, 0)->SetAttribute (\"MaxDlMcs\", UintegerValue (10));  // 27,\n            // 19, 10, 4 for mcsT2,\n            //  28, 16, 9 for mcsT1\n        }\n\n        else if (numBwps == 2) // FDD\n        {\n            // Change the antenna orientation\n            Ptr<NrGnbPhy> phy0 = nrHelper->GetGnbPhy(gnb, 0);\n            Ptr<UniformPlanarArray> antenna0 =\n                DynamicCast<UniformPlanarArray>(phy0->GetSpectrumPhy()->GetAntenna());\n            antenna0->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n            Ptr<NrGnbPhy> phy1 = nrHelper->GetGnbPhy(gnb, 1);\n            Ptr<UniformPlanarArray> antenna1 =\n                DynamicCast<UniformPlanarArray>(phy1->GetSpectrumPhy()->GetAntenna());\n            antenna1->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n\n            // Set numerology\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"Numerology\",\n                                                      UintegerValue(ranHelper.GetNumerology()));\n            nrHelper->GetGnbPhy(gnb, 1)->SetAttribute(\"Numerology\",\n                                                      UintegerValue(ranHelper.GetNumerology()));\n\n            // Set TX power\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"TxPower\", DoubleValue(10 * log10(x)));\n            nrHelper->GetGnbPhy(gnb, 1)->SetAttribute(\"TxPower\", DoubleValue(-30.0));\n            // Set TDD pattern\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\n                \"Pattern\",\n                StringValue(\"DL|DL|DL|DL|DL|DL|DL|DL|DL|DL|\"));\n            nrHelper->GetGnbPhy(gnb, 1)->SetAttribute(\n                \"Pattern\",\n                StringValue(\"UL|UL|UL|UL|UL|UL|UL|UL|UL|UL|\"));\n\n            // Link the two FDD BWP\n            nrHelper->GetBwpManagerGnb(gnb)->SetOutputLink(1, 0);\n        }\n\n        else\n        {\n            NS_ABORT_MSG(\"Incorrect number of BWPs per CC\");\n        }\n        globalCellId++;\n    }\n\n    orientationRads = gridScenario.GetAntennaOrientationRadians(1);\n    for (uint32_t numCell = 0; numCell < gnbSector2NetDev.GetN(); ++numCell)\n    {\n        Ptr<NetDevice> gnb = gnbSector2NetDev.Get(numCell);\n        uint32_t numBwps = nrHelper->GetNumberBwp(gnb);\n        if (numBwps == 1) // TDD\n        {\n            // Change the antenna orientation\n            Ptr<NrGnbPhy> phy = nrHelper->GetGnbPhy(gnb, 0);\n            Ptr<UniformPlanarArray> antenna =\n                DynamicCast<UniformPlanarArray>(phy->GetSpectrumPhy()->GetAntenna());\n            antenna->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n\n            // Set numerology\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"Numerology\",\n                                                      UintegerValue(ranHelper.GetNumerology()));\n\n            // Set TX power\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"TxPower\", DoubleValue(10 * log10(x)));\n\n            // Set TDD pattern\n            if (uniformPattern || (globalCellId % 2 == 1))\n            {\n                nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"Pattern\", StringValue(pattern1));\n            }\n            else\n            {\n                nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"Pattern\", StringValue(pattern2));\n            }\n\n            // Set max MCS\n            nrHelper->GetScheduler(gnb, 0)->SetAttribute(\"MaxDlMcs\",\n                                                         IntegerValue(maxMcsPerCell[globalCellId]));\n            // nrHelper->GetGnbMac (gnb, 0)->SetAttribute (\"MaxDlMcs\", UintegerValue (10));  // 27,\n            // 19, 10, 4 for mcsT2,\n            //  28, 16, 9 for mcsT1\n        }\n\n        else if (numBwps == 2) // FDD\n        {\n            // Change the antenna orientation\n            Ptr<NrGnbPhy> phy0 = nrHelper->GetGnbPhy(gnb, 0);\n            Ptr<UniformPlanarArray> antenna0 =\n                DynamicCast<UniformPlanarArray>(phy0->GetSpectrumPhy()->GetAntenna());\n            antenna0->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n            Ptr<NrGnbPhy> phy1 = nrHelper->GetGnbPhy(gnb, 1);\n            Ptr<UniformPlanarArray> antenna1 =\n                DynamicCast<UniformPlanarArray>(phy1->GetSpectrumPhy()->GetAntenna());\n            antenna1->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n\n            // Set numerology\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"Numerology\",\n                                                      UintegerValue(ranHelper.GetNumerology()));\n            nrHelper->GetGnbPhy(gnb, 1)->SetAttribute(\"Numerology\",\n                                                      UintegerValue(ranHelper.GetNumerology()));\n\n            // Set TX power\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"TxPower\", DoubleValue(10 * log10(x)));\n            nrHelper->GetGnbPhy(gnb, 1)->SetAttribute(\"TxPower\", DoubleValue(-30.0));\n\n            // Set TDD pattern\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\n                \"Pattern\",\n                StringValue(\"DL|DL|DL|DL|DL|DL|DL|DL|DL|DL|\"));\n            nrHelper->GetGnbPhy(gnb, 1)->SetAttribute(\n                \"Pattern\",\n                StringValue(\"UL|UL|UL|UL|UL|UL|UL|UL|UL|UL|\"));\n\n            // Link the two FDD BWP\n            nrHelper->GetBwpManagerGnb(gnb)->SetOutputLink(1, 0);\n        }\n\n        else\n        {\n            NS_ABORT_MSG(\"Incorrect number of BWPs per CC\");\n        }\n        globalCellId++;\n    }\n\n    orientationRads = gridScenario.GetAntennaOrientationRadians(2);\n    for (uint32_t numCell = 0; numCell < gnbSector3NetDev.GetN(); ++numCell)\n    {\n        Ptr<NetDevice> gnb = gnbSector3NetDev.Get(numCell);\n        uint32_t numBwps = nrHelper->GetNumberBwp(gnb);\n        if (numBwps == 1) // TDD\n        {\n            // Change the antenna orientation\n            Ptr<NrGnbPhy> phy = nrHelper->GetGnbPhy(gnb, 0);\n            Ptr<UniformPlanarArray> antenna =\n                DynamicCast<UniformPlanarArray>(phy->GetSpectrumPhy()->GetAntenna());\n            antenna->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n\n            // Set numerology\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"Numerology\",\n                                                      UintegerValue(ranHelper.GetNumerology()));\n\n            // Set TX power\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"TxPower\", DoubleValue(10 * log10(x)));\n\n            // Set TDD pattern\n            if (uniformPattern || (globalCellId % 2 == 1))\n            {\n                nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"Pattern\", StringValue(pattern1));\n            }\n            else\n            {\n                nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"Pattern\", StringValue(pattern2));\n            }\n\n            // Set max MCS\n            nrHelper->GetScheduler(gnb, 0)->SetAttribute(\"MaxDlMcs\",\n                                                         IntegerValue(maxMcsPerCell[globalCellId]));\n            // nrHelper->GetGnbMac (gnb, 0)->SetAttribute (\"MaxDlMcs\", UintegerValue (10));  // 27,\n            // 19, 10, 4 for mcsT2,\n            //  28, 16, 9 for mcsT1\n        }\n\n        else if (numBwps == 2) // FDD\n        {\n            // Change the antenna orientation\n            Ptr<NrGnbPhy> phy0 = nrHelper->GetGnbPhy(gnb, 0);\n            Ptr<UniformPlanarArray> antenna0 =\n                DynamicCast<UniformPlanarArray>(phy0->GetSpectrumPhy()->GetAntenna());\n            antenna0->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n            Ptr<NrGnbPhy> phy1 = nrHelper->GetGnbPhy(gnb, 1);\n            Ptr<UniformPlanarArray> antenna1 =\n                DynamicCast<UniformPlanarArray>(phy1->GetSpectrumPhy()->GetAntenna());\n            antenna1->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n\n            // Set numerology\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"Numerology\",\n                                                      UintegerValue(ranHelper.GetNumerology()));\n            nrHelper->GetGnbPhy(gnb, 1)->SetAttribute(\"Numerology\",\n                                                      UintegerValue(ranHelper.GetNumerology()));\n\n            // Set TX power\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"TxPower\", DoubleValue(10 * log10(x)));\n            nrHelper->GetGnbPhy(gnb, 1)->SetAttribute(\"TxPower\", DoubleValue(-30.0));\n\n            // Set TDD pattern\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\n                \"Pattern\",\n                StringValue(\"DL|DL|DL|DL|DL|DL|DL|DL|DL|DL|\"));\n            nrHelper->GetGnbPhy(gnb, 1)->SetAttribute(\n                \"Pattern\",\n                StringValue(\"UL|UL|UL|UL|UL|UL|UL|UL|UL|UL|\"));\n\n            // Link the two FDD BWP\n            nrHelper->GetBwpManagerGnb(gnb)->SetOutputLink(1, 0);\n        }\n\n        else\n        {\n            NS_ABORT_MSG(\"Incorrect number of BWPs per CC\");\n        }\n        globalCellId++;\n    }\n\n    // Set the UE routing:\n\n    if (operationMode == \"FDD\")\n    {\n        for (uint32_t i = 0; i < ueSector1NetDev.GetN(); i++)\n        {\n            nrHelper->GetBwpManagerUe(ueSector1NetDev.Get(i))->SetOutputLink(0, 1);\n        }\n\n        for (uint32_t i = 0; i < ueSector2NetDev.GetN(); i++)\n        {\n            nrHelper->GetBwpManagerUe(ueSector2NetDev.Get(i))->SetOutputLink(0, 1);\n        }\n\n        for (uint32_t i = 0; i < ueSector3NetDev.GetN(); i++)\n        {\n            nrHelper->GetBwpManagerUe(ueSector3NetDev.Get(i))->SetOutputLink(0, 1);\n        }\n    }\n\n    // When all the configuration is done, explicitly call UpdateConfig ()\n\n    for (auto it = gnbSector1NetDev.Begin(); it != gnbSector1NetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = gnbSector2NetDev.Begin(); it != gnbSector2NetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = gnbSector3NetDev.Begin(); it != gnbSector3NetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueSector1NetDev.Begin(); it != ueSector1NetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueSector2NetDev.Begin(); it != ueSector2NetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueSector3NetDev.Begin(); it != ueSector3NetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    /*\n     * Variables that represent the parameters we will accept as input by the\n     * command line. Each of them is initialized with a default value.\n     */\n    // Scenario parameters (that we will use inside this script):\n    uint16_t numOuterRings = 0;\n    uint16_t ueNumPergNb = 2;\n    bool logging = false;\n    bool traces = true;\n    std::string simulator = \"\";\n    std::string scenario = \"UMi\";\n    std::string radioNetwork = \"NR\";   // LTE or NR\n    std::string operationMode = \"TDD\"; // TDD or FDD\n\n    // Traffic parameters (that we will use inside this script:)\n    uint32_t udpPacketSize = 600; // bytes\n    uint32_t lambda = 2000;       // 4000*600*8 = 19.2 Mbps/UE,\n                                  // 3000*600*8 = 14.4 Mbps/UE,\n                                  // 2000*600*8 = 9.6 Mbps/UE\n                                  // 1500*600*8 = 7.2 Mbps/UE\n                                  // 1000*600*8 = 4.8 Mbps/UE\n\n    bool ftpM1Enabled = true;\n    double ftpLambda = 5;\n    uint32_t ftpFileSize = 512000; // in bytes\n    uint16_t ftpPortSector1 = 2001;\n    uint16_t ftpPortSector2 = 2002;\n    uint16_t ftpPortSector3 = 2003;\n    uint32_t ftpClientAppStartTimeMs = 400;\n    uint32_t ftpServerAppStartTimeMs = 400;\n    // Simulation parameters. Please don't use double to indicate seconds, use\n    // milliseconds and integers to avoid representation errors.\n    uint32_t simTimeMs = 1400;\n    uint32_t udpAppStartTimeMs = 400;\n    std::string direction = \"DL\";\n\n    // Spectrum parameters. We will take the input from the command line, and then\n    //  we will pass them inside the NR module.\n    uint16_t numerologyBwp = 2;\n    //  double centralFrequencyBand = 0.0;  // RadioNetworkParametersHelper provides this hard-coded\n    //  value double bandwidthBand = 0.0;  // RadioNetworkParametersHelper provides this hard-coded\n    //  values\n    std::string pattern1 =\n        \"F|F|F|F|F|F|F|F|F|F|\"; // Pattern can be e.g. \"DL|S|UL|UL|DL|DL|S|UL|UL|DL|\"\n    std::string pattern2 = \"F|F|F|F|F|UL|UL|UL|UL|UL|\";\n    bool uniformPattern = true;\n    bool uniformMcs = true;\n    bool uniformLambda = true;\n\n    // Where we will store the output files.\n    std::string simTag = \"default\";\n    std::string outputDir = \"./\";\n\n    // Error models\n    std::string errorModel = \"ns3::NrEesmIrT2\";\n\n    // Max DL MCS index\n    int16_t maxMcs1 = 28;\n    int16_t maxMcs2 = 28;\n    // std::vector<uint16_t> maxMcsVector ={4,6,8};\n    std::string maxMcsVectorInput = \"1|2|4\";\n\n    /*\n     * From here, we instruct the ns3::CommandLine class of all the input parameters\n     * that we may accept as input, as well as their description, and the storage\n     * variable.\n     */\n    CommandLine cmd(__FILE__);\n\n    cmd.AddValue(\"scenario\", \"The urban scenario string (UMa or UMi)\", scenario);\n    cmd.AddValue(\"numRings\", \"The number of rings around the central site\", numOuterRings);\n    cmd.AddValue(\"ueNumPergNb\",\n                 \"The number of UE per cell or gNB in multiple-ue topology\",\n                 ueNumPergNb);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.AddValue(\"traces\", \"Enable output traces\", traces);\n    cmd.AddValue(\"packetSize\", \"packet size in bytes to be used by UE traffic\", udpPacketSize);\n    cmd.AddValue(\"lambda\", \"Number of UDP packets generated in one second per UE\", lambda);\n    cmd.AddValue(\"uniformLambda\",\n                 \"1: Use same lambda (packets/s) for all UEs and cells (equal to 'lambda' input), \"\n                 \"0: use different packet arrival rates (lambdas) among cells\",\n                 uniformLambda);\n    cmd.AddValue(\"simTimeMs\", \"Simulation time\", simTimeMs);\n    cmd.AddValue(\"numerologyBwp\", \"The numerology to be used (NR only)\", numerologyBwp);\n    cmd.AddValue(\"pattern1\", \"The TDD pattern to use\", pattern1);\n    cmd.AddValue(\"pattern2\", \"The TDD pattern to use\", pattern2);\n    cmd.AddValue(\"uniformPattern\",\n                 \"1: Use same TDD pattern (pattern1) for all cells, 0: use different TDD patterns \"\n                 \"(pattern1 and pattern2) for cells\",\n                 uniformPattern);\n    cmd.AddValue(\"direction\", \"The flow direction (DL or UL)\", direction);\n    //  cmd.AddValue (\"centralFrequencyBand\",\n    //                \"The system frequency to be used in band 1\",\n    //                centralFrequencyBand);\n    //  cmd.AddValue (\"bandwidthBand\",\n    //                \"The system bandwidth to be used in band 1\",\n    //                bandwidthBand);\n    cmd.AddValue(\"technology\", \"The radio access network technology\", radioNetwork);\n    cmd.AddValue(\"operationMode\", \"The network operation mode can be TDD or FDD\", operationMode);\n    cmd.AddValue(\"simTag\",\n                 \"tag to be appended to output filenames to distinguish simulation campaigns\",\n                 simTag);\n    cmd.AddValue(\"outputDir\", \"directory where to store simulation results\", outputDir);\n    cmd.AddValue(\"ftpM1Enabled\",\n                 \"An indicator whether to enable FTP Model 1 traffic model. To enable configure 1, \"\n                 \"to disable 0.\",\n                 ftpM1Enabled);\n\n    // Parse the command line\n    cmd.Parse(argc, argv);\n\n    /*\n     * Check if the frequency and numerology are in the allowed range.\n     * If you need to add other checks, here is the best position to put them.\n     */\n    //  NS_ABORT_IF (centralFrequencyBand > 100e9);\n    NS_ABORT_IF(numerologyBwp > 4);\n    NS_ABORT_MSG_IF(direction != \"DL\" && direction != \"UL\", \"Flow direction can only be DL or UL\");\n    NS_ABORT_MSG_IF(operationMode != \"TDD\" && operationMode != \"FDD\",\n                    \"Operation mode can only be TDD or FDD\");\n    NS_ABORT_MSG_IF(radioNetwork != \"LTE\" && radioNetwork != \"NR\",\n                    \"Unrecognized radio network technology\");\n    /*\n     * If the logging variable is set to true, enable the log of some components\n     * through the code. The same effect can be obtained through the use\n     * of the NS_LOG environment variable:\n     *\n     * export NS_LOG=\"UdpClient=level_info|prefix_time|prefix_func|prefix_node:UdpServer=...\"\n     *\n     * Usually, the environment variable way is preferred, as it is more customizable,\n     * and more expressive.\n     */\n    if (logging)\n    {\n        LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"LtePdcp\", LOG_LEVEL_INFO);\n        //      LogComponentEnable (\"NrMacSchedulerOfdma\", LOG_LEVEL_ALL);\n    }\n\n    /*\n     * Default values for the simulation. We are progressively removing all\n     * the instances of SetDefault, but we need it for legacy code (LTE)\n     */\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n\n    /*\n     * Create the scenario. In our examples, we heavily use helpers that setup\n     * the gnbs and ue following a pre-defined pattern. Please have a look at the\n     * GridScenarioHelper documentation to see how the nodes will be distributed.\n     */\n    HexagonalGridScenarioHelper gridScenario;\n    gridScenario.SetSectorization(HexagonalGridScenarioHelper::TRIPLE);\n    gridScenario.SetNumRings(numOuterRings);\n    gridScenario.SetScenarioParameters(scenario);\n    uint16_t gNbNum = gridScenario.GetNumCells();\n    std::cout << \"numcells: \" << gNbNum << std::endl;\n    uint32_t ueNum = ueNumPergNb * gNbNum;\n    std::cout << \"numUEs: \" << ueNum << std::endl;\n    gridScenario.SetUtNumber(ueNum);\n    gridScenario.AssignStreams(RngSeedManager::GetRun());\n    gridScenario.CreateScenario(); //!< Creates and plots the network deployment\n    const uint16_t ffr =\n        3; // Fractional Frequency Reuse scheme to mitigate intra-site inter-sector interferences\n\n    /*\n     * Create different gNB NodeContainer for the different sectors.\n     */\n    NodeContainer gnbSector1Container;\n    NodeContainer gnbSector2Container;\n    NodeContainer gnbSector3Container;\n    for (uint32_t j = 0; j < gridScenario.GetBaseStations().GetN(); ++j)\n    {\n        Ptr<Node> gnb = gridScenario.GetBaseStations().Get(j);\n        switch (j % ffr)\n        {\n        case 0:\n            gnbSector1Container.Add(gnb);\n            break;\n        case 1:\n            gnbSector2Container.Add(gnb);\n            break;\n        case 2:\n            gnbSector3Container.Add(gnb);\n            break;\n        default:\n            NS_ABORT_MSG(\"ffr param cannot be larger than 3\");\n            break;\n        }\n    }\n\n    /*\n     * Create different UE NodeContainer for the different sectors.\n     */\n    NodeContainer ueSector1Container;\n    NodeContainer ueSector2Container;\n    NodeContainer ueSector3Container;\n\n    for (uint32_t j = 0; j < gridScenario.GetUserTerminals().GetN(); ++j)\n    {\n        Ptr<Node> ue = gridScenario.GetUserTerminals().Get(j);\n        switch (j % ffr)\n        {\n        case 0:\n            ueSector1Container.Add(ue);\n            break;\n        case 1:\n            ueSector2Container.Add(ue);\n            break;\n        case 2:\n            ueSector3Container.Add(ue);\n            break;\n        default:\n            NS_ABORT_MSG(\"ffr param cannot be larger than 3\");\n            break;\n        }\n    }\n\n    /*\n     * Setup the LTE or NR module. We create the various helpers needed inside\n     * their respective configuration functions\n     */\n    Ptr<PointToPointEpcHelper> epcHelper;\n\n    NetDeviceContainer gnbSector1NetDev;\n    NetDeviceContainer gnbSector2NetDev;\n    NetDeviceContainer gnbSector3NetDev;\n    NetDeviceContainer ueSector1NetDev;\n    NetDeviceContainer ueSector2NetDev;\n    NetDeviceContainer ueSector3NetDev;\n\n    Ptr<LteHelper> lteHelper = nullptr;\n    Ptr<NrHelper> nrHelper = nullptr;\n\n    std::vector<int16_t> maxMcsVector = GetMcsVectorFromInput(maxMcsVectorInput);\n\n    epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Set5gLenaSimulatorParameters(gridScenario,\n                                 scenario,\n                                 radioNetwork,\n                                 errorModel,\n                                 operationMode,\n                                 direction,\n                                 numerologyBwp,\n                                 pattern1,\n                                 pattern2,\n                                 uniformPattern,\n                                 gnbSector1Container,\n                                 gnbSector2Container,\n                                 gnbSector3Container,\n                                 ueSector1Container,\n                                 ueSector2Container,\n                                 ueSector3Container,\n                                 epcHelper,\n                                 nrHelper,\n                                 gnbSector1NetDev,\n                                 gnbSector2NetDev,\n                                 gnbSector3NetDev,\n                                 ueSector1NetDev,\n                                 ueSector2NetDev,\n                                 ueSector3NetDev,\n                                 maxMcs1,\n                                 maxMcs2,\n                                 maxMcsVector,\n                                 uniformMcs,\n                                 uniformLambda);\n\n    // From here, it is standard NS3. In the future, we will create helpers\n    // for this part as well.\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.000)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(gridScenario.GetUserTerminals());\n\n    Ipv4InterfaceContainer ueSector1IpIface =\n        epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueSector1NetDev));\n    Ipv4InterfaceContainer ueSector2IpIface =\n        epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueSector2NetDev));\n    Ipv4InterfaceContainer ueSector3IpIface =\n        epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueSector3NetDev));\n\n    Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress(1);\n\n    // Set the default gateway for the UEs\n    for (uint32_t j = 0; j < gridScenario.GetUserTerminals().GetN(); ++j)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting = ipv4RoutingHelper.GetStaticRouting(\n            gridScenario.GetUserTerminals().Get(j)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // attach UEs to their gNB. Try to attach them per cellId order\n    for (uint32_t u = 0; u < ueNum; ++u)\n    {\n        uint32_t sector = u % ffr;\n        uint32_t i = u / ffr;\n        if (sector == 0)\n        {\n            Ptr<NetDevice> gnbNetDev = gnbSector1NetDev.Get(i % gridScenario.GetNumSites());\n            Ptr<NetDevice> ueNetDev = ueSector1NetDev.Get(i);\n            if (lteHelper != nullptr)\n            {\n                lteHelper->Attach(ueNetDev, gnbNetDev);\n            }\n            else if (nrHelper != nullptr)\n            {\n                nrHelper->AttachToEnb(ueNetDev, gnbNetDev);\n            }\n            else\n            {\n                NS_ABORT_MSG(\"Programming error\");\n            }\n            if (logging == true)\n            {\n                Vector gnbpos = gnbNetDev->GetNode()->GetObject<MobilityModel>()->GetPosition();\n                Vector uepos = ueNetDev->GetNode()->GetObject<MobilityModel>()->GetPosition();\n                double distance = CalculateDistance(gnbpos, uepos);\n                std::cout << \"Distance = \" << distance << \" meters\" << std::endl;\n            }\n        }\n        else if (sector == 1)\n        {\n            Ptr<NetDevice> gnbNetDev = gnbSector2NetDev.Get(i % gridScenario.GetNumSites());\n            Ptr<NetDevice> ueNetDev = ueSector2NetDev.Get(i);\n            if (lteHelper != nullptr)\n            {\n                lteHelper->Attach(ueNetDev, gnbNetDev);\n            }\n            else if (nrHelper != nullptr)\n            {\n                nrHelper->AttachToEnb(ueNetDev, gnbNetDev);\n            }\n            else\n            {\n                NS_ABORT_MSG(\"Programming error\");\n            }\n            if (logging == true)\n            {\n                Vector gnbpos = gnbNetDev->GetNode()->GetObject<MobilityModel>()->GetPosition();\n                Vector uepos = ueNetDev->GetNode()->GetObject<MobilityModel>()->GetPosition();\n                double distance = CalculateDistance(gnbpos, uepos);\n                std::cout << \"Distance = \" << distance << \" meters\" << std::endl;\n            }\n        }\n        else if (sector == 2)\n        {\n            Ptr<NetDevice> gnbNetDev = gnbSector3NetDev.Get(i % gridScenario.GetNumSites());\n            Ptr<NetDevice> ueNetDev = ueSector3NetDev.Get(i);\n            if (lteHelper != nullptr)\n            {\n                lteHelper->Attach(ueNetDev, gnbNetDev);\n            }\n            else if (nrHelper != nullptr)\n            {\n                nrHelper->AttachToEnb(ueNetDev, gnbNetDev);\n            }\n            else\n            {\n                NS_ABORT_MSG(\"Programming error\");\n            }\n            if (logging == true)\n            {\n                Vector gnbpos = gnbNetDev->GetNode()->GetObject<MobilityModel>()->GetPosition();\n                Vector uepos = ueNetDev->GetNode()->GetObject<MobilityModel>()->GetPosition();\n                double distance = CalculateDistance(gnbpos, uepos);\n                std::cout << \"Distance = \" << distance << \" meters\" << std::endl;\n            }\n        }\n        else\n        {\n            NS_ABORT_MSG(\"Number of sector cannot be larger than 3\");\n        }\n    }\n\n    /*\n     * Traffic part. Install two kind of traffic: low-latency and voice, each\n     * identified by a particular source port.\n     */\n    uint16_t dlPortLowLat = 1234;\n\n    ApplicationContainer serverApps;\n\n    // The sink will always listen to the specified ports\n    UdpServerHelper dlPacketSinkLowLat(dlPortLowLat);\n\n    // The server, that is the application which is listening, is installed in the UE\n    if (direction == \"DL\")\n    {\n        serverApps.Add(dlPacketSinkLowLat.Install(\n            {ueSector1Container, ueSector2Container, ueSector3Container}));\n    }\n    else\n    {\n        serverApps.Add(dlPacketSinkLowLat.Install(remoteHost));\n    }\n\n    /*\n     * Configure attributes for the different generators, using user-provided\n     * parameters for generating a CBR traffic\n     *\n     * Low-Latency configuration and object creation:\n     */\n    UdpClientHelper dlClientLowLat;\n    dlClientLowLat.SetAttribute(\"RemotePort\", UintegerValue(dlPortLowLat));\n    dlClientLowLat.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    dlClientLowLat.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSize));\n    // dlClientLowLat.SetAttribute (\"Interval\", TimeValue (Seconds (1.0/lambda)));\n\n    // The bearer that will carry low latency traffic\n    EpsBearer lowLatBearer(EpsBearer::NGBR_VIDEO_TCP_DEFAULT);\n\n    // The filter for the low-latency traffic\n    Ptr<EpcTft> lowLatTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfLowLat;\n    if (direction == \"DL\")\n    {\n        dlpfLowLat.localPortStart = dlPortLowLat;\n        dlpfLowLat.localPortEnd = dlPortLowLat;\n        dlpfLowLat.direction = EpcTft::DOWNLINK;\n    }\n    else\n    {\n        dlpfLowLat.remotePortStart = dlPortLowLat;\n        dlpfLowLat.remotePortEnd = dlPortLowLat;\n        dlpfLowLat.direction = EpcTft::UPLINK;\n    }\n    lowLatTft->Add(dlpfLowLat);\n\n    uint32_t lambdaPerCell[gridScenario.GetNumCells()];\n    if (uniformLambda)\n    {\n        for (uint32_t bs = 0; bs < gridScenario.GetNumCells(); ++bs)\n        {\n            lambdaPerCell[bs] = lambda;\n            std::cout << \"Cell: \" << bs << \" lambda (same lambda): \" << lambdaPerCell[bs]\n                      << std::endl;\n        }\n    }\n    else // non-uniform lambda values among the cells!\n    {\n        for (uint32_t bs = 0; bs < gridScenario.GetNumCells(); ++bs)\n        {\n            lambdaPerCell[bs] = 1000 + bs * 2000;\n            std::cout << \"Cell: \" << bs << \" lambda (diff lambda): \" << lambdaPerCell[bs]\n                      << std::endl;\n        }\n    }\n\n    /*\n     * Let's install the applications!\n     */\n    ApplicationContainer clientApps;\n    ApplicationContainer ftpClientAppsSector1;\n    ApplicationContainer ftpServerAppsSector1;\n    ApplicationContainer ftpClientAppsSector2;\n    ApplicationContainer ftpServerAppsSector2;\n    ApplicationContainer ftpClientAppsSector3;\n    ApplicationContainer ftpServerAppsSector3;\n    Ptr<ThreeGppFtpM1Helper> ftpHelperSector1;\n    Ptr<ThreeGppFtpM1Helper> ftpHelperSector2;\n    Ptr<ThreeGppFtpM1Helper> ftpHelperSector3;\n\n    if (ftpM1Enabled)\n    {\n        // sector 1 FTP M1 applications configuration\n        ftpHelperSector1 = CreateObject<ThreeGppFtpM1Helper>(&ftpServerAppsSector1,\n                                                             &ftpClientAppsSector1,\n                                                             &ueSector1Container,\n                                                             &remoteHostContainer,\n                                                             &ueSector1IpIface);\n        ftpHelperSector1->Configure(ftpPortSector1,\n                                    MilliSeconds(ftpServerAppStartTimeMs),\n                                    MilliSeconds(ftpClientAppStartTimeMs),\n                                    MilliSeconds(simTimeMs),\n                                    ftpLambda,\n                                    ftpFileSize);\n        ftpHelperSector1->Start();\n\n        // sector 2 FTP M1 applications configuration\n        ftpHelperSector2 = CreateObject<ThreeGppFtpM1Helper>(&ftpServerAppsSector2,\n                                                             &ftpClientAppsSector2,\n                                                             &ueSector2Container,\n                                                             &remoteHostContainer,\n                                                             &ueSector2IpIface);\n        ftpHelperSector2->Configure(ftpPortSector2,\n                                    MilliSeconds(ftpServerAppStartTimeMs),\n                                    MilliSeconds(ftpClientAppStartTimeMs),\n                                    MilliSeconds(simTimeMs),\n                                    ftpLambda,\n                                    ftpFileSize);\n        ftpHelperSector2->Start();\n\n        // sector 3 FTP M1 applications configuration\n        ftpHelperSector3 = CreateObject<ThreeGppFtpM1Helper>(&ftpServerAppsSector3,\n                                                             &ftpClientAppsSector3,\n                                                             &ueSector3Container,\n                                                             &remoteHostContainer,\n                                                             &ueSector3IpIface);\n        ftpHelperSector3->Configure(ftpPortSector3,\n                                    MilliSeconds(ftpServerAppStartTimeMs),\n                                    MilliSeconds(ftpClientAppStartTimeMs),\n                                    MilliSeconds(simTimeMs),\n                                    ftpLambda,\n                                    ftpFileSize);\n        ftpHelperSector3->Start();\n\n        clientApps.Add(ftpClientAppsSector1);\n        clientApps.Add(ftpClientAppsSector2);\n        clientApps.Add(ftpClientAppsSector3);\n\n        serverApps.Add(ftpServerAppsSector1);\n        serverApps.Add(ftpServerAppsSector2);\n        serverApps.Add(ftpServerAppsSector3);\n    }\n    else\n    {\n        for (uint32_t i = 0; i < ueSector1Container.GetN(); ++i)\n        {\n            dlClientLowLat.SetAttribute(\n                \"Interval\",\n                TimeValue(Seconds(1.0 / lambdaPerCell[(i % gridScenario.GetNumSites()) *\n                                                      gridScenario.GetNumSectorsPerSite()])));\n            std::cout << \"ue (sector1): \" << i << \" index: \"\n                      << (i % gridScenario.GetNumSites()) * gridScenario.GetNumSectorsPerSite()\n                      << \" lambda: \"\n                      << lambdaPerCell[(i % gridScenario.GetNumSites()) *\n                                       gridScenario.GetNumSectorsPerSite()]\n                      << std::endl;\n            Ptr<Node> ue = ueSector1Container.Get(i);\n            Ptr<NetDevice> ueDevice = ueSector1NetDev.Get(i);\n            Address ueAddress = ueSector1IpIface.GetAddress(i);\n\n            // The client, who is transmitting, is installed in the remote host,\n            // with destination address set to the address of the UE\n            if (direction == \"DL\")\n            {\n                dlClientLowLat.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n                clientApps.Add(dlClientLowLat.Install(remoteHost));\n            }\n            else\n            {\n                dlClientLowLat.SetAttribute(\"RemoteAddress\", AddressValue(remoteHostAddr));\n                clientApps.Add(dlClientLowLat.Install(ue));\n            }\n            // Activate a dedicated bearer for the traffic type\n            if (lteHelper != nullptr)\n            {\n                lteHelper->ActivateDedicatedEpsBearer(ueDevice, lowLatBearer, lowLatTft);\n            }\n            else if (nrHelper != nullptr)\n            {\n                nrHelper->ActivateDedicatedEpsBearer(ueDevice, lowLatBearer, lowLatTft);\n            }\n            else\n            {\n                NS_ABORT_MSG(\"Programming error\");\n            }\n        }\n\n        for (uint32_t i = 0; i < ueSector2Container.GetN(); ++i)\n        {\n            dlClientLowLat.SetAttribute(\n                \"Interval\",\n                TimeValue(Seconds(1.0 / lambdaPerCell[(i % gridScenario.GetNumSites()) *\n                                                          gridScenario.GetNumSectorsPerSite() +\n                                                      1])));\n            std::cout << \"ue (sector2): \" << i << \" index: \"\n                      << (i % gridScenario.GetNumSites()) * gridScenario.GetNumSectorsPerSite() + 1\n                      << \" lambda: \"\n                      << lambdaPerCell[(i % gridScenario.GetNumSites()) *\n                                           gridScenario.GetNumSectorsPerSite() +\n                                       1]\n                      << std::endl;\n            Ptr<Node> ue = ueSector2Container.Get(i);\n            Ptr<NetDevice> ueDevice = ueSector2NetDev.Get(i);\n            Address ueAddress = ueSector2IpIface.GetAddress(i);\n\n            // The client, who is transmitting, is instaviso entonces pronto, sualled in the remote\n            // host, with destination address set to the address of the UE\n            if (direction == \"DL\")\n            {\n                dlClientLowLat.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n                clientApps.Add(dlClientLowLat.Install(remoteHost));\n            }\n            else\n            {\n                dlClientLowLat.SetAttribute(\"RemoteAddress\", AddressValue(remoteHostAddr));\n                clientApps.Add(dlClientLowLat.Install(ue));\n            }\n            // Activate a dedicated bearer for the traffic type\n            if (lteHelper != nullptr)\n            {\n                lteHelper->ActivateDedicatedEpsBearer(ueDevice, lowLatBearer, lowLatTft);\n            }\n            else if (nrHelper != nullptr)\n            {\n                nrHelper->ActivateDedicatedEpsBearer(ueDevice, lowLatBearer, lowLatTft);\n            }\n            else\n            {\n                NS_ABORT_MSG(\"Programming error\");\n            }\n        }\n\n        for (uint32_t i = 0; i < ueSector3Container.GetN(); ++i)\n        {\n            dlClientLowLat.SetAttribute(\n                \"Interval\",\n                TimeValue(Seconds(1.0 / lambdaPerCell[(i % gridScenario.GetNumSites()) *\n                                                          gridScenario.GetNumSectorsPerSite() +\n                                                      2])));\n            std::cout << \"ue (sector3): \" << i << \" index: \"\n                      << (i % gridScenario.GetNumSites()) * gridScenario.GetNumSectorsPerSite() + 2\n                      << \" lambda: \"\n                      << lambdaPerCell[(i % gridScenario.GetNumSites()) *\n                                           gridScenario.GetNumSectorsPerSite() +\n                                       2]\n                      << std::endl;\n            Ptr<Node> ue = ueSector3Container.Get(i);\n            Ptr<NetDevice> ueDevice = ueSector3NetDev.Get(i);\n            Address ueAddress = ueSector3IpIface.GetAddress(i);\n\n            // The client, who is transmitting, is installed in the remote host,\n            // with destination address set to the address of the UE\n            if (direction == \"DL\")\n            {\n                dlClientLowLat.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n                clientApps.Add(dlClientLowLat.Install(remoteHost));\n            }\n            else\n            {\n                dlClientLowLat.SetAttribute(\"RemoteAddress\", AddressValue(remoteHostAddr));\n                clientApps.Add(dlClientLowLat.Install(ue));\n            }\n            // Activate a dedicated bearer for the traffic type\n            if (lteHelper != nullptr)\n            {\n                lteHelper->ActivateDedicatedEpsBearer(ueDevice, lowLatBearer, lowLatTft);\n            }\n            else if (nrHelper != nullptr)\n            {\n                nrHelper->ActivateDedicatedEpsBearer(ueDevice, lowLatBearer, lowLatTft);\n            }\n            else\n            {\n                NS_ABORT_MSG(\"Programming error\");\n            }\n        }\n    }\n\n    // start UDP server and client apps\n    serverApps.Start(MilliSeconds(udpAppStartTimeMs));\n    clientApps.Start(MilliSeconds(udpAppStartTimeMs));\n    serverApps.Stop(MilliSeconds(simTimeMs));\n    clientApps.Stop(MilliSeconds(simTimeMs));\n\n    // enable the traces provided by the nr module\n    if (traces == true)\n    {\n        if (lteHelper != nullptr)\n        {\n            lteHelper->EnableTraces();\n        }\n        else if (nrHelper != nullptr)\n        {\n            nrHelper->EnableTraces();\n        }\n    }\n\n    FlowMonitorHelper flowmonHelper;\n    NodeContainer endpointNodes;\n    endpointNodes.Add(remoteHost);\n    endpointNodes.Add(gridScenario.GetUserTerminals());\n\n    Ptr<ns3::FlowMonitor> monitor = flowmonHelper.Install(endpointNodes);\n    monitor->SetAttribute(\"DelayBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"JitterBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"PacketSizeBinWidth\", DoubleValue(20));\n\n    Simulator::Stop(MilliSeconds(simTimeMs));\n    Simulator::Run();\n\n    /*\n     * To check what was installed in the memory, i.e., BWPs of eNb Device, and its configuration.\n     * Example is: Node 1 -> Device 0 -> BandwidthPartMap -> {0,1} BWPs -> NrGnbPhy -> Numerology,\n    GtkConfigStore config;\n    config.ConfigureAttributes ();\n    */\n\n    // Print per-flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier =\n        DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n\n    double averageFlowThroughput = 0.0;\n    double averageFlowDelay = 0.0;\n\n    std::ofstream outFile;\n    std::string filename = outputDir + \"/\" + simTag;\n    double delayValues[stats.size()];\n    uint64_t cont = 0;\n\n    outFile.open(filename.c_str(), std::ofstream::out | std::ofstream::trunc);\n    if (!outFile.is_open())\n    {\n        std::cerr << \"Can't open file \" << filename << std::endl;\n        return 1;\n    }\n\n    outFile.setf(std::ios_base::fixed);\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin();\n         i != stats.end();\n         ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        std::stringstream protoStream;\n        protoStream << (uint16_t)t.protocol;\n        if (t.protocol == 6)\n        {\n            protoStream.str(\"TCP\");\n        }\n        if (t.protocol == 17)\n        {\n            protoStream.str(\"UDP\");\n        }\n        // outFile << \"Flow \" << i->first << \" (\" << t.sourceAddress << \":\" << t.sourcePort << \" ->\n        // \" << t.destinationAddress << \":\" << t.destinationPort << \") proto \" << protoStream.str ()\n        // << \"\\n\"; outFile << \"  Tx Packets: \" << i->second.txPackets << \"\\n\"; outFile << \"  Tx\n        // Bytes:   \" << i->second.txBytes << \"\\n\"; outFile << \"  TxOffered:  \" << i->second.txBytes\n        // * 8.0 / ((simTimeMs - udpAppStartTimeMs) / 1000.0) / 1000.0 / 1000.0  << \" Mbps\\n\";\n        // outFile << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n        if (i->second.rxPackets > 0)\n        {\n            // Measure the duration of the flow from receiver's perspective\n            // double rxDuration = i->second.timeLastRxPacket.GetSeconds () -\n            // i->second.timeFirstTxPacket.GetSeconds ();\n            double rxDuration = (simTimeMs - udpAppStartTimeMs) / 1000.0;\n\n            averageFlowThroughput += i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000;\n            averageFlowDelay += 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;\n            delayValues[cont] = 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;\n            cont++;\n\n            // outFile << \"  Throughput: \" << i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000  <<\n            // \" Mbps\\n\"; outFile << \"  Mean delay:  \" << 1000 * i->second.delaySum.GetSeconds () /\n            // i->second.rxPackets << \" ms\\n\"; outFile << \"  Mean upt:  \" << i->second.uptSum /\n            // i->second.rxPackets / 1000/1000 << \" Mbps \\n\"; outFile << \"  Mean jitter:  \" << 1000\n            // * i->second.jitterSum.GetSeconds () / i->second.rxPackets  << \" ms\\n\";\n        }\n        else\n        {\n            // outFile << \"  Throughput:  0 Mbps\\n\";\n            // outFile << \"  Mean delay:  0 ms\\n\";\n            // outFile << \"  Mean jitter: 0 ms\\n\";\n        }\n        // outFile << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n    }\n    std::sort(delayValues, delayValues + stats.size());\n    // for (uint32_t i = 0; i < stats.size(); i++)\n    //   {\n    //     std::cout << delayValues[i] << \" \";\n    //   }\n    // double FiftyTileFlowDelay = (delayValues[stats.size()/2] + delayValues[stats.size()/2 -1])/2;\n    double FiftyTileFlowDelay = delayValues[stats.size() / 2];\n\n    outFile << \"\\n\\n  Mean flow throughput: \" << averageFlowThroughput / stats.size() << \"\\n\";\n    outFile << \"  Mean flow delay: \" << averageFlowDelay / stats.size() << \"\\n\";\n    outFile << \"  Median flow delay: \" << FiftyTileFlowDelay << \"\\n\";\n\n    outFile.close();\n\n    std::ifstream f(filename.c_str());\n\n    if (f.is_open())\n    {\n        std::cout << f.rdbuf();\n    }\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/cttc-lte-ca-demo.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2019 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n/**\n * \\ingroup examples\n * \\file cttc-lte-ca-demo.cc\n * \\brief Example for setting LTE CA scenario\n *\n * This example describes how to setup a simulation using the 3GPP channel model\n * from TR 38.900. This example consists of 1 gNb and 1 UE. Have a look at the\n * possible parameters to know what you can configure through the command line.\n *\n * The example allows 2 configurations:\n *\n * An exclusivley TDD scenario, with 2 bands including 1 and 2 CCs, respectively.\n * Each CC includes 1 BWP. In this case 3 flows are created, 2 DL and 1 UL.\n *\n * A mixed TDD/FDD scenario with 2 bands including 1 and 2 CCs respectively. The\n * 1st and the 2nd CC include 1 TDD BWP each, while the 3rd CC is set to FDD\n * operation mode, thus it includes 2 BWPs (one for DL and 1 for UL). In this\n * case 4 flows are created, 2 DL and 2 UL.\n *\n * The example will print on-screen the end-to-end result of one (or two) flows,\n * as well as writing them on a file.\n *\n * \\code{.unparsed}\n$ ./ns3 run \"cttc-lte-ca-demo --PrintHelp\"\n    \\endcode\n *\n */\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/bandwidth-part-gnb.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/config-store.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-helper.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/nr-point-to-point-epc-helper.h\"\n#include \"ns3/point-to-point-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"3gppChannelFdmLteComponentCarriersExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    uint16_t gNbNum = 1;\n    uint16_t ueNumPergNb = 1;\n\n    uint8_t numBands = 2;\n    double centralFrequencyBand40 = 2350e6;\n    double bandwidthBand40 = 50e6;\n    double centralFrequencyBand38 = 2595e6;\n    double bandwidthBand38 = 100e6;\n\n    double bandwidth = 20e6;\n\n    uint16_t numerologyBwp0 = 0;\n    uint16_t numerologyBwp1 = 0;\n    uint16_t numerologyBwp2 = 0;\n    uint16_t numerologyBwpDl = 0;\n    uint16_t numerologyBwpUl = 0;\n\n    double totalTxPower = 13;\n    std::string pattern =\n        \"DL|S|UL|UL|DL|DL|S|UL|UL|DL|\"; // Pattern can be e.g. \"DL|S|UL|UL|DL|DL|S|UL|UL|DL|\"\n    std::string patternDL = \"DL|DL|DL|DL|DL|DL|DL|DL|DL|DL|\";\n    std::string patternUL = \"UL|UL|UL|UL|UL|UL|UL|UL|UL|UL|\";\n    std::string operationMode = \"TDD\"; // TDD or FDD (mixed TDD and FDD mode)\n\n    bool cellScan = false;\n    double beamSearchAngleStep = 10.0;\n\n    uint32_t udpPacketSizeUll = 915;\n    uint32_t udpPacketSizeBe = 915;\n    uint32_t lambdaUll = 10000;\n    uint32_t lambdaBe = 10000;\n\n    bool enableLowLat = true;\n    bool enableVideo = true;\n    bool enableVoice = true;\n    bool enableGaming = false; // If FDD is selected is set automaticaly to true\n\n    bool logging = false;\n\n    std::string simTag = \"default\";\n    std::string outputDir = \"./\";\n\n    double simTime = 1.4;         // seconds\n    double udpAppStartTime = 0.4; // seconds\n\n    CommandLine cmd(__FILE__);\n\n    cmd.AddValue(\"simTime\", \"Simulation time\", simTime);\n    cmd.AddValue(\"gNbNum\", \"The number of gNbs in multiple-ue topology\", gNbNum);\n    cmd.AddValue(\"ueNumPergNb\", \"The number of UE per gNb in multiple-ue topology\", ueNumPergNb);\n    cmd.AddValue(\"numBands\",\n                 \"Number of operation bands. More than one implies non-contiguous CC\",\n                 numBands);\n    cmd.AddValue(\"bandwidthBand40\", \"The system bandwidth to be used in band 1\", bandwidthBand40);\n    cmd.AddValue(\"bandwidthBand38\", \"The system bandwidth to be used in band 2\", bandwidthBand38);\n    cmd.AddValue(\"bandwidth\", \"The bandwidth of the CCs \", bandwidth);\n    cmd.AddValue(\"numerologyBwp0\", \"The numerology to be used in bandwidth part 1\", numerologyBwp0);\n    cmd.AddValue(\"numerologyBwp1\", \"The numerology to be used in bandwidth part 1\", numerologyBwp1);\n    cmd.AddValue(\"numerologyBwp2\", \"The numerology to be used in bandwidth part 2\", numerologyBwp2);\n    cmd.AddValue(\"numerologyBwpDl\",\n                 \"The numerology to be used in bandwidth part 2\",\n                 numerologyBwpDl);\n    cmd.AddValue(\"numerologyBwpUl\",\n                 \"The numerology to be used in bandwidth part 2\",\n                 numerologyBwpUl);\n    cmd.AddValue(\"totalTxPower\",\n                 \"total tx power that will be proportionally assigned to\"\n                 \" bandwidth parts depending on each BWP bandwidth \",\n                 totalTxPower);\n    cmd.AddValue(\"tddPattern\",\n                 \"LTE TDD pattern to use (e.g. --tddPattern=DL|S|UL|UL|UL|DL|S|UL|UL|UL|)\",\n                 pattern);\n    cmd.AddValue(\"operationMode\",\n                 \"The network operation mode can be TDD or FDD (In this case it\"\n                 \"will be mixed TDD and FDD)\",\n                 operationMode);\n    cmd.AddValue(\"cellScan\",\n                 \"Use beam search method to determine beamforming vector,\"\n                 \"true to use cell scanning method\",\n                 cellScan);\n    cmd.AddValue(\"beamSearchAngleStep\",\n                 \"Beam search angle step for beam search method\",\n                 beamSearchAngleStep);\n    cmd.AddValue(\"packetSizeUll\",\n                 \"packet size in bytes to be used by ultra low latency traffic\",\n                 udpPacketSizeUll);\n    cmd.AddValue(\"packetSizeBe\",\n                 \"packet size in bytes to be used by best effort traffic\",\n                 udpPacketSizeBe);\n    cmd.AddValue(\"lambdaUll\",\n                 \"Number of UDP packets in one second for ultra low latency traffic\",\n                 lambdaUll);\n    cmd.AddValue(\"lambdaBe\",\n                 \"Number of UDP packets in one second for best effor traffic\",\n                 lambdaBe);\n    cmd.AddValue(\"enableLowLat\",\n                 \"If true, enables low latency traffic transmission (DL)\",\n                 enableLowLat);\n    cmd.AddValue(\"enableVideo\", \"If true, enables video traffic transmission (DL)\", enableVideo);\n    cmd.AddValue(\"enableVoice\", \"If true, enables voice traffic transmission (UL)\", enableVoice);\n    cmd.AddValue(\"enableGaming\", \"If true, enables gaming traffic transmission (UL)\", enableGaming);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.AddValue(\"simTag\",\n                 \"tag to be appended to output filenames to distinguish simulation campaigns\",\n                 simTag);\n    cmd.AddValue(\"outputDir\", \"directory where to store simulation results\", outputDir);\n\n    cmd.Parse(argc, argv);\n\n    NS_ABORT_IF(numBands < 1);\n    NS_ABORT_MSG_IF(enableLowLat == false && enableVideo == false && enableVoice == false &&\n                        enableGaming == false && operationMode == \"TDD\",\n                    \"For TDD enable one of the flows\");\n\n    // ConfigStore inputConfig;\n    // inputConfig.ConfigureDefaults ();\n\n    // enable logging or not\n    if (logging)\n    {\n        //      LogComponentEnable (\"Nr3gppPropagationLossModel\", LOG_LEVEL_ALL);\n        //      LogComponentEnable (\"Nr3gppBuildingsPropagationLossModel\", LOG_LEVEL_ALL);\n        //      LogComponentEnable (\"Nr3gppChannel\", LOG_LEVEL_ALL);\n        //      LogComponentEnable (\"UdpClient\", LOG_LEVEL_INFO);\n        //      LogComponentEnable (\"UdpServer\", LOG_LEVEL_INFO);\n        //      LogComponentEnable (\"LtePdcp\", LOG_LEVEL_INFO);\n        //      LogComponentEnable (\"BwpManagerGnb\", LOG_LEVEL_INFO);\n        //      LogComponentEnable (\"BwpManagerAlgorithm\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"NrGnbPhy\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"NrUePhy\", LOG_LEVEL_INFO);\n        //      LogComponentEnable (\"NrGnbMac\", LOG_LEVEL_INFO);\n        //      LogComponentEnable (\"NrUeMac\", LOG_LEVEL_INFO);\n    }\n\n    // create base stations and mobile terminals\n    NodeContainer gNbNodes;\n    NodeContainer ueNodes;\n    MobilityHelper mobility;\n\n    double gNbHeight = 10;\n    double ueHeight = 1.5;\n\n    gNbNodes.Create(gNbNum);\n    ueNodes.Create(ueNumPergNb * gNbNum);\n\n    Ptr<ListPositionAllocator> apPositionAlloc = CreateObject<ListPositionAllocator>();\n    Ptr<ListPositionAllocator> staPositionAlloc = CreateObject<ListPositionAllocator>();\n    int32_t yValue = 0.0;\n\n    for (uint32_t i = 1; i <= gNbNodes.GetN(); ++i)\n    {\n        // 2.0, -2.0, 6.0, -6.0, 10.0, -10.0, ....\n        if (i % 2 != 0)\n        {\n            yValue = static_cast<int>(i) * 30;\n        }\n        else\n        {\n            yValue = -yValue;\n        }\n\n        apPositionAlloc->Add(Vector(0.0, yValue, gNbHeight));\n\n        // 1.0, -1.0, 3.0, -3.0, 5.0, -5.0, ...\n        double xValue = 0.0;\n        for (uint32_t j = 1; j <= ueNumPergNb; ++j)\n        {\n            if (j % 2 != 0)\n            {\n                xValue = j;\n            }\n            else\n            {\n                xValue = -xValue;\n            }\n\n            if (yValue > 0)\n            {\n                staPositionAlloc->Add(Vector(xValue, 10, ueHeight));\n            }\n            else\n            {\n                staPositionAlloc->Add(Vector(xValue, -10, ueHeight));\n            }\n        }\n    }\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(apPositionAlloc);\n    mobility.Install(gNbNodes);\n\n    mobility.SetPositionAllocator(staPositionAlloc);\n    mobility.Install(ueNodes);\n\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n    epcHelper->SetAttribute(\"S1uLinkDelay\", TimeValue(MilliSeconds(0)));\n    if (cellScan)\n    {\n        idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                             TypeIdValue(CellScanBeamforming::GetTypeId()));\n        idealBeamformingHelper->SetBeamformingAlgorithmAttribute(\"BeamSearchAngleStep\",\n                                                                 DoubleValue(beamSearchAngleStep));\n    }\n    else\n    {\n        idealBeamformingHelper->SetAttribute(\n            \"BeamformingMethod\",\n            TypeIdValue(QuasiOmniDirectPathBeamforming::GetTypeId()));\n    }\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n\n    std::string errorModel = \"ns3::NrLteMiErrorModel\";\n    // Scheduler\n    nrHelper->SetSchedulerAttribute(\"FixedMcsDl\", BooleanValue(false));\n    nrHelper->SetSchedulerAttribute(\"FixedMcsUl\", BooleanValue(false));\n\n    // Error Model: UE and GNB with same spectrum error model.\n    nrHelper->SetUlErrorModel(errorModel);\n    nrHelper->SetDlErrorModel(errorModel);\n\n    // Both DL and UL AMC will have the same model behind.\n    nrHelper->SetGnbDlAmcAttribute(\n        \"AmcModel\",\n        EnumValue(NrAmc::ErrorModel)); // NrAmc::ShannonModel or NrAmc::ErrorModel\n    nrHelper->SetGnbUlAmcAttribute(\n        \"AmcModel\",\n        EnumValue(NrAmc::ErrorModel)); // NrAmc::ShannonModel or NrAmc::ErrorModel\n\n    /*\n     * Adjust the average number of Reference symbols per RB only for LTE case,\n     * which is larger than in NR. We assume a value of 4 (could be 3 too).\n     */\n    nrHelper->SetGnbDlAmcAttribute(\"NumRefScPerRb\", UintegerValue(2));\n    nrHelper->SetGnbUlAmcAttribute(\"NumRefScPerRb\", UintegerValue(2));\n    nrHelper->SetGnbMacAttribute(\"NumRbPerRbg\", UintegerValue(4));\n    nrHelper->SetSchedulerAttribute(\"DlCtrlSymbols\", UintegerValue(1));\n    nrHelper->SetSchedulerTypeId(TypeId::LookupByName(\"ns3::NrMacSchedulerOfdmaPF\"));\n\n    /*\n     * Setup the operation bands.\n     * In this example, two standard operation bands are deployed:\n     *\n     * Band 38 that has a component carrier (CC) of 20 MHz\n     * Band 40 that has two non-contiguous CCs of 20 MHz each.\n     *\n     * If TDD mode is defined, 1 BWP per CC is created. All BWPs are TDD.\n     * If FDD mode is defined, Band 40 CC2 containes 2 BWPs (1 DL - 1 UL), while\n     * Band 40 CC1 has one TDD BWP and Band 38 CC0 also has one TDD BWP.\n     *\n     * This example manually creates a non-contiguous CC configuration with 2 CCs.\n     * First CC has two BWPs and the second only one.\n     *\n     * The configured spectrum division for TDD mode is:\n     * |--------- Band 40 --------|   |--------------- Band 38 ---------------|\n     * |---------- CC0 -----------|   |-------- CC1-------||------- CC2-------|\n     * |---------- BWP0 ----------|   |------- BWP1 ------||------ BWP2 ------|\n     *\n     * The configured spectrum division for FDD mode is:\n     * |-------- Band 40 ---------|   |----------------- Band 38 ----------------|\n     * |---------- CC0 -----------|   |------- CC1-------|  |-------- CC2--------|\n     * |---------- BWP0 ----------|   |------ BWP1 ------|  |- BWP2DL -|- BWP2UL-|\n     *\n     *\n     * In this example, each UE generates as many flows as the number of bwps\n     * (i.e. 3 flows in case of TDD mode and 4 in case mixed TDD with FDD).\n     * Each flow will be transmitted on a dedicated BWP. In particular, low\n     * latency flow is set as DL and goes through BWP0, voice is set as UL and\n     * goes through BWP1, video is set as DL and goes through BWP2DL, and gaming\n     * is enabled only in the mixed TDD/FDD mode, it is set as UL and goes\n     * through BWP2UL.\n     */\n    uint8_t numCcs = 3;\n\n    BandwidthPartInfoPtrVector allBwps;\n\n    // Create the configuration for band40 (CC0 - BWP0)\n    OperationBandInfo band40;\n    band40.m_centralFrequency = centralFrequencyBand40;\n    band40.m_channelBandwidth = bandwidthBand40;\n    band40.m_lowerFrequency = band40.m_centralFrequency - band40.m_channelBandwidth / 2;\n    band40.m_higherFrequency = band40.m_centralFrequency + band40.m_channelBandwidth / 2;\n\n    // Component Carrier 0\n    std::unique_ptr<ComponentCarrierInfo> cc0(new ComponentCarrierInfo());\n    cc0->m_ccId = 0;\n    cc0->m_centralFrequency = band40.m_lowerFrequency + bandwidth;\n    cc0->m_channelBandwidth = bandwidth;\n    cc0->m_lowerFrequency = cc0->m_centralFrequency - cc0->m_channelBandwidth / 2;\n    cc0->m_higherFrequency = cc0->m_centralFrequency + cc0->m_channelBandwidth / 2;\n\n    // BWP 0\n    std::unique_ptr<BandwidthPartInfo> bwp0(new BandwidthPartInfo());\n    bwp0->m_bwpId = 0;\n    bwp0->m_centralFrequency = cc0->m_centralFrequency;\n    bwp0->m_channelBandwidth = cc0->m_channelBandwidth;\n    bwp0->m_lowerFrequency = cc0->m_lowerFrequency;\n    bwp0->m_higherFrequency = cc0->m_higherFrequency;\n\n    cc0->AddBwp(std::move(bwp0));\n\n    band40.AddCc(std::move(cc0));\n\n    // Create the configuration for band38\n    OperationBandInfo band38;\n    band38.m_centralFrequency = centralFrequencyBand38;\n    band38.m_channelBandwidth = bandwidthBand38;\n    band38.m_lowerFrequency = band38.m_centralFrequency - band38.m_channelBandwidth / 2;\n    band38.m_higherFrequency = band38.m_centralFrequency + band38.m_channelBandwidth / 2;\n\n    //(CC1 - BWP1)\n    // Component Carrier 1\n    std::unique_ptr<ComponentCarrierInfo> cc1(new ComponentCarrierInfo());\n    cc1->m_ccId = 1;\n    cc1->m_centralFrequency = band38.m_lowerFrequency + bandwidth;\n    cc1->m_channelBandwidth = bandwidth;\n    cc1->m_lowerFrequency = cc1->m_centralFrequency - cc1->m_channelBandwidth / 2;\n    cc1->m_higherFrequency = cc1->m_centralFrequency + cc1->m_channelBandwidth / 2;\n\n    // BWP 1\n    std::unique_ptr<BandwidthPartInfo> bwp1(new BandwidthPartInfo());\n    bwp1->m_bwpId = 1;\n    bwp1->m_centralFrequency = cc1->m_centralFrequency;\n    bwp1->m_channelBandwidth = cc1->m_channelBandwidth;\n    bwp1->m_lowerFrequency = cc1->m_lowerFrequency;\n    bwp1->m_higherFrequency = cc1->m_higherFrequency;\n\n    cc1->AddBwp(std::move(bwp1));\n\n    std::unique_ptr<ComponentCarrierInfo> cc2(new ComponentCarrierInfo());\n    std::unique_ptr<BandwidthPartInfo> bwp2(new BandwidthPartInfo());\n    std::unique_ptr<BandwidthPartInfo> bwpdl(new BandwidthPartInfo());\n    std::unique_ptr<BandwidthPartInfo> bwpul(new BandwidthPartInfo());\n\n    // Component Carrier 2\n    cc2->m_ccId = 2;\n    cc2->m_centralFrequency = band38.m_higherFrequency - bandwidth;\n    cc2->m_channelBandwidth = bandwidth;\n    cc2->m_lowerFrequency = cc2->m_centralFrequency - cc2->m_channelBandwidth / 2;\n    cc2->m_higherFrequency = cc2->m_centralFrequency + cc2->m_channelBandwidth / 2;\n\n    if (operationMode == \"TDD\") //(CC2 - BWP2)\n    {\n        bwp2->m_bwpId = 1;\n        bwp2->m_centralFrequency = cc2->m_centralFrequency;\n        bwp2->m_channelBandwidth = cc2->m_channelBandwidth;\n        bwp2->m_lowerFrequency = cc2->m_lowerFrequency;\n        bwp2->m_higherFrequency = cc2->m_higherFrequency;\n\n        cc2->AddBwp(std::move(bwp2));\n    }\n    else // FDD case  (CC2 - BWPdl & BWPul)\n    {\n        // BWP DL\n        bwpdl->m_bwpId = 2;\n        bwpdl->m_channelBandwidth = cc2->m_channelBandwidth / 2;\n        bwpdl->m_lowerFrequency = cc2->m_lowerFrequency;\n        bwpdl->m_higherFrequency = bwpdl->m_lowerFrequency + bwpdl->m_channelBandwidth;\n        bwpdl->m_centralFrequency = bwpdl->m_lowerFrequency + bwpdl->m_channelBandwidth / 2;\n\n        cc2->AddBwp(std::move(bwpdl));\n\n        // BWP UL\n        bwpul->m_bwpId = 3;\n        bwpul->m_channelBandwidth = cc2->m_channelBandwidth / 2;\n        bwpul->m_lowerFrequency = cc2->m_centralFrequency;\n        bwpul->m_higherFrequency = cc2->m_higherFrequency;\n        bwpul->m_centralFrequency = bwpul->m_lowerFrequency + bwpul->m_channelBandwidth / 2;\n\n        cc2->AddBwp(std::move(bwpul));\n    }\n\n    band38.AddCc(std::move(cc1));\n    band38.AddCc(std::move(cc2));\n\n    nrHelper->InitializeOperationBand(&band40);\n    nrHelper->InitializeOperationBand(&band38);\n\n    allBwps = CcBwpCreator::GetAllBwps({band38, band40});\n\n    // Antennas for all the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(1));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(1));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Antennas for all the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(2));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(2));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Assign each flow type to a BWP\n    uint32_t bwpIdForLowLat = 0;\n    uint32_t bwpIdForVoice = 1;\n    uint32_t bwpIdForVideo = 2;\n    uint32_t bwpIdForVideoGaming = 3;\n\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\",\n                                                 UintegerValue(bwpIdForLowLat));\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"GBR_CONV_VOICE\", UintegerValue(bwpIdForVoice));\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_VIDEO_TCP_PREMIUM\",\n                                                 UintegerValue(bwpIdForVideo));\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_VOICE_VIDEO_GAMING\",\n                                                 UintegerValue(bwpIdForVideoGaming));\n\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\", UintegerValue(bwpIdForLowLat));\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"GBR_CONV_VOICE\", UintegerValue(bwpIdForVoice));\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"NGBR_VIDEO_TCP_PREMIUM\",\n                                                UintegerValue(bwpIdForVideo));\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"NGBR_VOICE_VIDEO_GAMING\",\n                                                UintegerValue(bwpIdForVideoGaming));\n\n    // install nr net devices\n    NetDeviceContainer enbNetDev = nrHelper->InstallGnbDevice(gNbNodes, allBwps);\n    NetDeviceContainer ueNetDev = nrHelper->InstallUeDevice(ueNodes, allBwps);\n\n    int64_t randomStream = 1;\n    randomStream += nrHelper->AssignStreams(enbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);\n\n    // Share the total transmission power among CCs proportionally with the BW\n    double x = pow(10, totalTxPower / 10);\n    double totalBandwidth = numCcs * bandwidth;\n\n    // Band40: CC0 - BWP0 & Band38: CC1 - BWP1\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)\n        ->SetAttribute(\"Numerology\", UintegerValue(numerologyBwp0));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)\n        ->SetAttribute(\n            \"TxPower\",\n            DoubleValue(10 *\n                        log10((band40.GetBwpAt(0, 0)->m_channelBandwidth / totalBandwidth) * x)));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)->SetAttribute(\"Pattern\", StringValue(pattern));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)->SetAttribute(\"RbOverhead\", DoubleValue(0.1));\n\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)\n        ->SetAttribute(\"Numerology\", UintegerValue(numerologyBwp1));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)\n        ->SetAttribute(\n            \"TxPower\",\n            DoubleValue(10 *\n                        log10((band38.GetBwpAt(0, 0)->m_channelBandwidth / totalBandwidth) * x)));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)->SetAttribute(\"Pattern\", StringValue(pattern));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)->SetAttribute(\"RbOverhead\", DoubleValue(0.1));\n\n    // Band38: CC2 - BWP2\n    if (operationMode == \"TDD\")\n    {\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)\n            ->SetAttribute(\"Numerology\", UintegerValue(numerologyBwp2));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)\n            ->SetAttribute(\n                \"TxPower\",\n                DoubleValue(\n                    10 * log10((band38.GetBwpAt(1, 0)->m_channelBandwidth / totalBandwidth) * x)));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)->SetAttribute(\"Pattern\", StringValue(pattern));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)->SetAttribute(\"RbOverhead\", DoubleValue(0.1));\n    }\n    else // FDD case\n    {\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)\n            ->SetAttribute(\"Numerology\", UintegerValue(numerologyBwpDl));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)\n            ->SetAttribute(\n                \"TxPower\",\n                DoubleValue(\n                    10 * log10((band38.GetBwpAt(1, 0)->m_channelBandwidth / totalBandwidth) * x)));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)->SetAttribute(\"Pattern\", StringValue(patternDL));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)->SetAttribute(\"RbOverhead\", DoubleValue(0.1));\n\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 3)\n            ->SetAttribute(\"Numerology\", UintegerValue(numerologyBwpUl));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 3)->SetAttribute(\"Pattern\", StringValue(patternUL));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 3)->SetAttribute(\"RbOverhead\", DoubleValue(0.1));\n\n        // Link the two FDD BWP:\n        nrHelper->GetBwpManagerGnb(enbNetDev.Get(0))->SetOutputLink(3, 2);\n\n        // Set the UE routing:\n        for (uint32_t i = 0; i < ueNetDev.GetN(); i++)\n        {\n            nrHelper->GetBwpManagerUe(ueNetDev.Get(i))->SetOutputLink(2, 3);\n        }\n\n        // enable 4rth flow\n        enableGaming = true;\n    }\n\n    // When all the configuration is done, explicitly call UpdateConfig ()\n    for (auto it = enbNetDev.Begin(); it != enbNetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.000)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));\n\n    // Set the default gateway for the UEs\n    for (uint32_t j = 0; j < ueNodes.GetN(); ++j)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(ueNodes.Get(j)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // attach UEs to the closest eNB\n    nrHelper->AttachToClosestEnb(ueNetDev, enbNetDev);\n\n    // install UDP applications\n    uint16_t dlPortLowLat = 1234;\n    uint16_t ulPortVoice = 1235;\n    uint16_t dlPortVideo = 1236;\n    uint16_t ulPortGaming = 1237;\n\n    ApplicationContainer serverApps;\n\n    // The sink will always listen to the specified ports\n    UdpServerHelper dlPacketSinkLowLat(dlPortLowLat);\n    UdpServerHelper ulPacketSinkVoice(ulPortVoice);\n    UdpServerHelper dlPacketSinkVideo(dlPortVideo);\n    UdpServerHelper ulPacketSinkGaming(ulPortGaming);\n\n    // The server, that is the application which is listening, is installed in the UE\n    // for the DL traffic, and in the remote host for the UL traffic\n    serverApps.Add(dlPacketSinkLowLat.Install(ueNodes));\n    serverApps.Add(ulPacketSinkVoice.Install(remoteHost));\n    serverApps.Add(dlPacketSinkVideo.Install(ueNodes));\n    serverApps.Add(ulPacketSinkGaming.Install(remoteHost));\n\n    /*\n     * Configure attributes for the different generators, using user-provided\n     * parameters for generating a CBR traffic\n     *\n     * Low-Latency configuration and object creation:\n     */\n    UdpClientHelper dlClientLowLat;\n    dlClientLowLat.SetAttribute(\"RemotePort\", UintegerValue(dlPortLowLat));\n    dlClientLowLat.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    dlClientLowLat.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSizeBe));\n    dlClientLowLat.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambdaBe)));\n\n    // The bearer that will carry low latency traffic\n    EpsBearer lowLatBearer(EpsBearer::NGBR_LOW_LAT_EMBB);\n\n    // The filter for the low-latency traffic\n    Ptr<EpcTft> lowLatTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfLowLat;\n    dlpfLowLat.localPortStart = dlPortLowLat;\n    dlpfLowLat.localPortEnd = dlPortLowLat;\n    lowLatTft->Add(dlpfLowLat);\n\n    // Voice configuration and object creation:\n    UdpClientHelper ulClientVoice;\n    ulClientVoice.SetAttribute(\"RemotePort\", UintegerValue(ulPortVoice));\n    ulClientVoice.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    ulClientVoice.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSizeBe));\n    ulClientVoice.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambdaBe)));\n\n    // The bearer that will carry voice traffic\n    EpsBearer voiceBearer(EpsBearer::GBR_CONV_VOICE);\n\n    // The filter for the voice traffic\n    Ptr<EpcTft> voiceTft = Create<EpcTft>();\n    EpcTft::PacketFilter ulpfVoice;\n    ulpfVoice.localPortStart = ulPortVoice;\n    ulpfVoice.localPortEnd = ulPortVoice;\n    ulpfVoice.direction = EpcTft::UPLINK;\n    voiceTft->Add(ulpfVoice);\n\n    // Video configuration and object creation:\n    UdpClientHelper dlClientVideo;\n    dlClientVideo.SetAttribute(\"RemotePort\", UintegerValue(dlPortVideo));\n    dlClientVideo.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    dlClientVideo.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSizeUll));\n    dlClientVideo.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambdaUll)));\n\n    // The bearer that will carry video traffic\n    EpsBearer videoBearer(EpsBearer::NGBR_VIDEO_TCP_PREMIUM);\n\n    // The filter for the video traffic\n    Ptr<EpcTft> videoTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfVideo;\n    dlpfVideo.localPortStart = dlPortVideo;\n    dlpfVideo.localPortEnd = dlPortVideo;\n    videoTft->Add(dlpfVideo);\n\n    // Gaming configuration and object creation:\n    UdpClientHelper ulClientGaming;\n    ulClientGaming.SetAttribute(\"RemotePort\", UintegerValue(ulPortGaming));\n    ulClientGaming.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    ulClientGaming.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSizeUll));\n    ulClientGaming.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambdaUll)));\n\n    // The bearer that will carry gaming traffic\n    EpsBearer gamingBearer(EpsBearer::NGBR_VOICE_VIDEO_GAMING);\n\n    // The filter for the gaming traffic\n    Ptr<EpcTft> gamingTft = Create<EpcTft>();\n    EpcTft::PacketFilter ulpfGaming;\n    ulpfGaming.remotePortStart = ulPortGaming;\n    ulpfGaming.remotePortEnd = ulPortGaming;\n    ulpfGaming.direction = EpcTft::UPLINK;\n    gamingTft->Add(ulpfGaming);\n\n    //  Install the applications\n    ApplicationContainer clientApps;\n\n    for (uint32_t i = 0; i < ueNodes.GetN(); ++i)\n    {\n        Ptr<Node> ue = ueNodes.Get(i);\n        Ptr<NetDevice> ueDevice = ueNetDev.Get(i);\n        Address ueAddress = ueIpIface.GetAddress(i);\n\n        // The client, who is transmitting, is installed in the remote host,\n        // with destination address set to the address of the UE\n        if (enableLowLat)\n        {\n            dlClientLowLat.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n            clientApps.Add(dlClientLowLat.Install(remoteHost));\n\n            nrHelper->ActivateDedicatedEpsBearer(ueDevice, lowLatBearer, lowLatTft);\n        }\n        if (enableVideo)\n        {\n            dlClientVideo.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n            clientApps.Add(dlClientVideo.Install(remoteHost));\n\n            nrHelper->ActivateDedicatedEpsBearer(ueDevice, videoBearer, videoTft);\n        }\n\n        // For the uplink, the installation happens in the UE, and the remote address\n        // is the one of the remote host\n\n        if (enableVoice)\n        {\n            ulClientVoice.SetAttribute(\"RemoteAddress\",\n                                       AddressValue(internetIpIfaces.GetAddress(1)));\n            clientApps.Add(ulClientVoice.Install(ue));\n\n            nrHelper->ActivateDedicatedEpsBearer(ueDevice, voiceBearer, voiceTft);\n        }\n\n        if (enableGaming)\n        {\n            ulClientGaming.SetAttribute(\"RemoteAddress\",\n                                        AddressValue(internetIpIfaces.GetAddress(1)));\n            clientApps.Add(ulClientGaming.Install(ue));\n\n            nrHelper->ActivateDedicatedEpsBearer(ueDevice, gamingBearer, gamingTft);\n        }\n    }\n\n    // start UDP server and client apps\n    serverApps.Start(Seconds(udpAppStartTime));\n    clientApps.Start(Seconds(udpAppStartTime));\n    serverApps.Stop(Seconds(simTime));\n    clientApps.Stop(Seconds(simTime));\n\n    // enable the traces provided by the nr module\n    nrHelper->EnableTraces();\n\n    FlowMonitorHelper flowmonHelper;\n    NodeContainer endpointNodes;\n    endpointNodes.Add(remoteHost);\n    endpointNodes.Add(ueNodes);\n\n    Ptr<ns3::FlowMonitor> monitor = flowmonHelper.Install(endpointNodes);\n    monitor->SetAttribute(\"DelayBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"JitterBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"PacketSizeBinWidth\", DoubleValue(20));\n\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n\n    /*\n     * To check what was installed in the memory, i.e., BWPs of eNb Device, and its configuration.\n     * Example is: Node 1 -> Device 0 -> BandwidthPartMap -> {0,1} BWPs -> NrGnbPhy ->\n    NrPhyMacCommong-> Numerology, Bandwidth, ... GtkConfigStore config; config.ConfigureAttributes\n    ();\n    */\n\n    // Print per-flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier =\n        DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n\n    double averageFlowThroughput = 0.0;\n    double averageFlowDelay = 0.0;\n\n    std::ofstream outFile;\n    std::string filename = outputDir + \"/\" + simTag;\n    outFile.open(filename.c_str(), std::ofstream::out | std::ofstream::trunc);\n    if (!outFile.is_open())\n    {\n        std::cerr << \"Can't open file \" << filename << std::endl;\n        return 1;\n    }\n\n    outFile.setf(std::ios_base::fixed);\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin();\n         i != stats.end();\n         ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        std::stringstream protoStream;\n        protoStream << (uint16_t)t.protocol;\n        if (t.protocol == 6)\n        {\n            protoStream.str(\"TCP\");\n        }\n        if (t.protocol == 17)\n        {\n            protoStream.str(\"UDP\");\n        }\n        outFile << \"Flow \" << i->first << \" (\" << t.sourceAddress << \":\" << t.sourcePort << \" -> \"\n                << t.destinationAddress << \":\" << t.destinationPort << \") proto \"\n                << protoStream.str() << \"\\n\";\n        outFile << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n        outFile << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n        outFile << \"  TxOffered:  \"\n                << i->second.txBytes * 8.0 / (simTime - udpAppStartTime) / 1000 / 1000 << \" Mbps\\n\";\n        outFile << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n        if (i->second.rxPackets > 0)\n        {\n            // Measure the duration of the flow from receiver's perspective\n            // double rxDuration = i->second.timeLastRxPacket.GetSeconds () -\n            // i->second.timeFirstTxPacket.GetSeconds ();\n            double rxDuration = (simTime - udpAppStartTime);\n\n            averageFlowThroughput += i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000;\n            averageFlowDelay += 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;\n\n            outFile << \"  Throughput: \" << i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000\n                    << \" Mbps\\n\";\n            outFile << \"  Mean delay:  \"\n                    << 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n            // outFile << \"  Mean upt:  \" << i->second.uptSum / i->second.rxPackets / 1000/1000 << \"\n            // Mbps \\n\";\n            outFile << \"  Mean jitter:  \"\n                    << 1000 * i->second.jitterSum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n        }\n        else\n        {\n            outFile << \"  Throughput:  0 Mbps\\n\";\n            outFile << \"  Mean delay:  0 ms\\n\";\n            outFile << \"  Mean jitter: 0 ms\\n\";\n        }\n        outFile << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n    }\n\n    outFile << \"\\n\\n  Aggregated throughput: \" << averageFlowThroughput << \"\\n\";\n    outFile << \"  Mean flow throughput: \" << averageFlowThroughput / stats.size() << \"\\n\";\n    outFile << \"  Mean flow delay: \" << averageFlowDelay / stats.size() << \"\\n\";\n\n    outFile.close();\n\n    std::ifstream f(filename.c_str());\n\n    if (f.is_open())\n    {\n        std::cout << f.rdbuf();\n    }\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/cttc-nr-cc-bwp-demo.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2019 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/config-store.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/ideal-beamforming-algorithm.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-helper.h\"\n#include \"ns3/nr-mac-scheduler-tdma-rr.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/nr-point-to-point-epc-helper.h\"\n#include \"ns3/point-to-point-helper.h\"\n#include \"ns3/point-to-point-module.h\"\n\n/**\n * \\file cttc-nr-cc-bwp-demo.cc\n * \\ingroup examples\n *\n * \\brief Creates a NR TDD deployment with a configurable number of sites, UEs, downlink and uplink\nflows.\n *\n * This example describes how to setup a simulation using the 3GPP channel model\n * from TR 38.900. This example consists of configurable number of NR base stations\n * (gNBs) with an also configurable number of UEs attached to each gNB.\n *\n * In this example, the network operates in TDD in a given band. This band is\n * splited in a number of Component Carriers (CC). There are two methods to do\n * this separation: automatic or manual.\n * The automatic way divides the bandwidth in a given number of equally-sized\n * contiguous CCs. In the example, the number of contiguous CCs is 4, but can be\n * changed. In the manual way, the simulator user is free to create CCs and\n * bandwidth parts (BWPs) on their way. The helper will take care of validating\n * the customized spectrum allocation. The example provides 2 CCs, one with 2\n * BWPs and another one with one single BWP occupying the whole CC bandwidth.\n *\n * By default, the example uses the non-automatic spectrum division. The number\n * of gNBs and UEs is 1. The UE may generate 3 different flows in downlink and\n * other 3 flows in uplink. Each directional flow belongs to a different traffic\n * pattern, which is map to a unique BWP in the configuration, demonstrating that\n * carrier aggregation can be done in our module just by multiplexing flows on\n * different CCs.\n *\n * We provide a number of simulation parameters that can be configured in the\n * command line, such as the number of UEs per gNB or traffic flow directions.\n * Please have a look at the possible parameters to know what you can configure\n * through the command line.\n *\n * The example will print on-screen the end-to-end result of one (or two) flows,\n * With the default configuration, the example will create one DL flow per UE.\n * The example will print on-screen the end-to-end result of each flow,\n * as well as writing them on a file.\n *\n * \\code{.unparsed}\n$ ./ns3 run \"cttc-nr-cc-bwp-demo --PrintHelp\"\n    \\endcode\n */\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"3gppChannelFdmComponentCarriersBandwidthPartsExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    uint16_t gNbNum = 1;\n    uint16_t ueNumPergNb = 1;\n    uint16_t numFlowsUe = 3;\n\n    uint8_t numBands = 1;\n    double centralFrequencyBand = 28e9;\n    double bandwidthBand = 3e9;\n\n    bool contiguousCc = false;\n    uint16_t numerology = 3; // numerology for contiguous case\n\n    // non-contiguous case\n    double centralFrequencyCc0 = 28e9;\n    double centralFrequencyCc1 = 29e9;\n    double bandwidthCc0 = 400e6;\n    double bandwidthCc1 = 100e6;\n    uint16_t numerologyCc0Bwp0 = 3;\n    uint16_t numerologyCc0Bwp1 = 4;\n    uint16_t numerologyCc1Bwp0 = 3;\n\n    std::string pattern =\n        \"F|F|F|F|F|F|F|F|F|F|\"; // Pattern can be e.g. \"DL|S|UL|UL|DL|DL|S|UL|UL|DL|\"\n    double totalTxPower = 8;\n    bool cellScan = false;\n    double beamSearchAngleStep = 10.0;\n\n    bool udpFullBuffer = false;\n    uint32_t udpPacketSizeUll = 100;\n    uint32_t udpPacketSizeBe = 1252;\n    uint32_t lambdaUll = 10000;\n    uint32_t lambdaBe = 1000;\n\n    bool logging = false;\n\n    bool disableDl = false;\n    bool disableUl = true;\n\n    std::string simTag = \"default\";\n    std::string outputDir = \"./\";\n\n    double simTime = 1;           // seconds\n    double udpAppStartTime = 0.4; // seconds\n\n    CommandLine cmd(__FILE__);\n\n    cmd.AddValue(\"simTime\", \"Simulation time\", simTime);\n    cmd.AddValue(\"gNbNum\", \"The number of gNbs in multiple-ue topology\", gNbNum);\n    cmd.AddValue(\"ueNumPergNb\", \"The number of UE per gNb in multiple-ue topology\", ueNumPergNb);\n    cmd.AddValue(\"numBands\",\n                 \"Number of operation bands. More than one implies non-contiguous CC\",\n                 numBands);\n    cmd.AddValue(\"centralFrequencyBand\",\n                 \"The system frequency to be used in band 1\",\n                 centralFrequencyBand);\n    cmd.AddValue(\"bandwidthBand\", \"The system bandwidth to be used in band 1\", bandwidthBand);\n    cmd.AddValue(\"contiguousCc\",\n                 \"Simulate with contiguous CC or non-contiguous CC example\",\n                 contiguousCc);\n    cmd.AddValue(\"numerology\", \"Numerlogy to be used in contiguous case\", numerology);\n    cmd.AddValue(\"centralFrequencyCc0\",\n                 \"The system frequency to be used in CC 0\",\n                 centralFrequencyCc0);\n    cmd.AddValue(\"bandwidthBand\", \"The system bandwidth to be used in CC 0\", bandwidthCc0);\n    cmd.AddValue(\"centralFrequencyCc1\",\n                 \"The system frequency to be used in CC 1\",\n                 centralFrequencyCc1);\n    cmd.AddValue(\"bandwidthBand\", \"The system bandwidth to be used in CC 1\", bandwidthCc1);\n    cmd.AddValue(\"numerologyCc0Bwp0\", \"Numerlogy to be used in CC 0, BWP 0\", numerologyCc0Bwp0);\n    cmd.AddValue(\"numerologyCc0Bwp1\", \"Numerlogy to be used in CC 0, BWP 1\", numerologyCc0Bwp1);\n    cmd.AddValue(\"numerologyCc1Bwp0\", \"Numerlogy to be used in CC 1, BWP 0\", numerologyCc1Bwp0);\n    cmd.AddValue(\"tddPattern\",\n                 \"LTE TDD pattern to use (e.g. --tddPattern=DL|S|UL|UL|UL|DL|S|UL|UL|UL|)\",\n                 pattern);\n    cmd.AddValue(\"totalTxPower\",\n                 \"total tx power that will be proportionally assigned to\"\n                 \" bandwidth parts depending on each BWP bandwidth \",\n                 totalTxPower);\n    cmd.AddValue(\"cellScan\",\n                 \"Use beam search method to determine beamforming vector,\"\n                 \"true to use cell scanning method\",\n                 cellScan);\n    cmd.AddValue(\"beamSearchAngleStep\",\n                 \"Beam search angle step for beam search method\",\n                 beamSearchAngleStep);\n    cmd.AddValue(\"udpFullBuffer\",\n                 \"Whether to set the full buffer traffic; if this parameter is \"\n                 \"set then the udpInterval parameter will be neglected.\",\n                 udpFullBuffer);\n    cmd.AddValue(\"packetSizeUll\",\n                 \"packet size in bytes to be used by ultra low latency traffic\",\n                 udpPacketSizeUll);\n    cmd.AddValue(\"packetSizeBe\",\n                 \"packet size in bytes to be used by best effort traffic\",\n                 udpPacketSizeBe);\n    cmd.AddValue(\"lambdaUll\",\n                 \"Number of UDP packets in one second for ultra low latency traffic\",\n                 lambdaUll);\n    cmd.AddValue(\"lambdaBe\",\n                 \"Number of UDP packets in one second for best effor traffic\",\n                 lambdaBe);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.AddValue(\"disableDl\", \"Disable DL flow\", disableDl);\n    cmd.AddValue(\"disableUl\", \"Disable UL flow\", disableUl);\n    cmd.AddValue(\"simTag\",\n                 \"tag to be appended to output filenames to distinguish simulation campaigns\",\n                 simTag);\n    cmd.AddValue(\"outputDir\", \"directory where to store simulation results\", outputDir);\n\n    cmd.Parse(argc, argv);\n\n    NS_ABORT_IF(numBands < 1);\n    NS_ABORT_MSG_IF(disableDl == true && disableUl == true, \"Enable one of the flows\");\n\n    // ConfigStore inputConfig;\n    // inputConfig.ConfigureDefaults ();\n\n    // enable logging or not\n    if (logging)\n    {\n        LogComponentEnable(\"Nr3gppPropagationLossModel\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Nr3gppBuildingsPropagationLossModel\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Nr3gppChannel\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"LtePdcp\", LOG_LEVEL_INFO);\n    }\n\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n\n    // create base stations and mobile terminals\n    NodeContainer gNbNodes;\n    NodeContainer ueNodes;\n    MobilityHelper mobility;\n\n    double gNbHeight = 10;\n    double ueHeight = 1.5;\n\n    gNbNodes.Create(gNbNum);\n    ueNodes.Create(ueNumPergNb * gNbNum);\n\n    Ptr<ListPositionAllocator> apPositionAlloc = CreateObject<ListPositionAllocator>();\n    Ptr<ListPositionAllocator> staPositionAlloc = CreateObject<ListPositionAllocator>();\n    int32_t yValue = 0.0;\n\n    for (uint32_t i = 1; i <= gNbNodes.GetN(); ++i)\n    {\n        // 2.0, -2.0, 6.0, -6.0, 10.0, -10.0, ....\n        if (i % 2 != 0)\n        {\n            yValue = static_cast<int>(i) * 30;\n        }\n        else\n        {\n            yValue = -yValue;\n        }\n\n        apPositionAlloc->Add(Vector(0.0, yValue, gNbHeight));\n\n        // 1.0, -1.0, 3.0, -3.0, 5.0, -5.0, ...\n        double xValue = 0.0;\n        for (uint32_t j = 1; j <= ueNumPergNb; ++j)\n        {\n            if (j % 2 != 0)\n            {\n                xValue = j;\n            }\n            else\n            {\n                xValue = -xValue;\n            }\n\n            if (yValue > 0)\n            {\n                staPositionAlloc->Add(Vector(xValue, 10, ueHeight));\n            }\n            else\n            {\n                staPositionAlloc->Add(Vector(xValue, -10, ueHeight));\n            }\n        }\n    }\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(apPositionAlloc);\n    mobility.Install(gNbNodes);\n\n    mobility.SetPositionAllocator(staPositionAlloc);\n    mobility.Install(ueNodes);\n\n    // setup the nr simulation\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    /*\n     * Setup the configuration of the spectrum. There is a contiguous and a non-contiguous\n     * example:\n     * 1) One operation band is deployed with 4 contiguous component carriers\n     *    (CC)s, which are automatically generated by the ccBwpManager\n     * 2) One operation bands non-contiguous case. CCs and BWPs are manually created\n     */\n\n    BandwidthPartInfoPtrVector allBwps;\n    CcBwpCreator ccBwpCreator;\n\n    OperationBandInfo band;\n\n    // For the case of manual configuration of CCs and BWPs\n    std::unique_ptr<ComponentCarrierInfo> cc0(new ComponentCarrierInfo());\n    std::unique_ptr<BandwidthPartInfo> bwp0(new BandwidthPartInfo());\n    std::unique_ptr<BandwidthPartInfo> bwp1(new BandwidthPartInfo());\n\n    std::unique_ptr<ComponentCarrierInfo> cc1(new ComponentCarrierInfo());\n    std::unique_ptr<BandwidthPartInfo> bwp2(new BandwidthPartInfo());\n\n    if (contiguousCc == true)\n    {\n        /*\n         * CC band configuration n257F (NR Release 15): four contiguous CCs of\n         * 400MHz at maximum. In this automated example, each CC contains a single\n         * BWP occupying the whole CC bandwidth.\n         *\n         * The configured spectrum division is:\n         * ----------------------------- Band --------------------------------\n         * ------CC0------|------CC1-------|-------CC2-------|-------CC3-------\n         * ------BWP0-----|------BWP0------|-------BWP0------|-------BWP0------\n         */\n\n        const uint8_t numContiguousCcs = 4; // 4 CCs per Band\n\n        // Create the configuration for the CcBwpHelper\n        CcBwpCreator::SimpleOperationBandConf bandConf(centralFrequencyBand,\n                                                       bandwidthBand,\n                                                       numContiguousCcs,\n                                                       BandwidthPartInfo::UMi_StreetCanyon_LoS);\n\n        bandConf.m_numBwp = 1; // 1 BWP per CC\n\n        // By using the configuration created, it is time to make the operation band\n        band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);\n    }\n    else\n    {\n        /*\n         * The configured spectrum division is:\n         * ----------------------------- Band ---------------------------------\n         * ---------------CC0--------------|----------------CC1----------------\n         * ------BWP0------|------BWP1-----|----------------BWP0---------------\n         */\n        band.m_centralFrequency = centralFrequencyBand;\n        band.m_channelBandwidth = bandwidthBand;\n        band.m_lowerFrequency = band.m_centralFrequency - band.m_channelBandwidth / 2;\n        band.m_higherFrequency = band.m_centralFrequency + band.m_channelBandwidth / 2;\n        uint8_t bwpCount = 0;\n\n        // Component Carrier 0\n        cc0->m_ccId = 0;\n        cc0->m_centralFrequency = centralFrequencyCc0;\n        cc0->m_channelBandwidth = bandwidthCc0;\n        cc0->m_lowerFrequency = cc0->m_centralFrequency - cc0->m_channelBandwidth / 2;\n        cc0->m_higherFrequency = cc0->m_centralFrequency + cc0->m_channelBandwidth / 2;\n\n        // BWP 0\n        bwp0->m_bwpId = bwpCount;\n        bwp0->m_centralFrequency = cc0->m_lowerFrequency + 100e6;\n        bwp0->m_channelBandwidth = 200e6;\n        bwp0->m_lowerFrequency = bwp0->m_centralFrequency - bwp0->m_channelBandwidth / 2;\n        bwp0->m_higherFrequency = bwp0->m_centralFrequency + bwp0->m_channelBandwidth / 2;\n\n        cc0->AddBwp(std::move(bwp0));\n        ++bwpCount;\n\n        // BWP 01\n        bwp1->m_bwpId = bwpCount;\n        bwp1->m_centralFrequency = cc0->m_higherFrequency - 50e6;\n        bwp1->m_channelBandwidth = 100e6;\n        bwp1->m_lowerFrequency = bwp1->m_centralFrequency - bwp1->m_channelBandwidth / 2;\n        bwp1->m_higherFrequency = bwp1->m_centralFrequency + bwp1->m_channelBandwidth / 2;\n\n        cc0->AddBwp(std::move(bwp1));\n        ++bwpCount;\n\n        // Component Carrier 1\n        cc1->m_ccId = 1;\n        cc1->m_centralFrequency = centralFrequencyCc1;\n        cc1->m_channelBandwidth = bandwidthCc1;\n        cc1->m_lowerFrequency = cc1->m_centralFrequency - cc1->m_channelBandwidth / 2;\n        cc1->m_higherFrequency = cc1->m_centralFrequency + cc1->m_channelBandwidth / 2;\n\n        // BWP 2\n        bwp2->m_bwpId = bwpCount;\n        bwp2->m_centralFrequency = cc1->m_centralFrequency;\n        bwp2->m_channelBandwidth = cc1->m_channelBandwidth;\n        bwp2->m_lowerFrequency = cc1->m_lowerFrequency;\n        bwp2->m_higherFrequency = cc1->m_higherFrequency;\n\n        cc1->AddBwp(std::move(bwp2));\n        ++bwpCount;\n\n        // Add CC to the corresponding operation band.\n        band.AddCc(std::move(cc1));\n        band.AddCc(std::move(cc0));\n    }\n    /*else\n      {\n        nrHelper->SetAttribute (\"UseCa\", BooleanValue (false));\n      }*/\n\n    // NS_ABORT_MSG_IF (ccId < 1,\"No CC created\");\n\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n    epcHelper->SetAttribute(\"S1uLinkDelay\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetSchedulerTypeId(TypeId::LookupByName(\"ns3::NrMacSchedulerTdmaRR\"));\n    // Beamforming method\n    if (cellScan)\n    {\n        idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                             TypeIdValue(CellScanBeamforming::GetTypeId()));\n        idealBeamformingHelper->SetBeamformingAlgorithmAttribute(\"BeamSearchAngleStep\",\n                                                                 DoubleValue(beamSearchAngleStep));\n    }\n    else\n    {\n        idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                             TypeIdValue(DirectPathBeamforming::GetTypeId()));\n    }\n\n    nrHelper->InitializeOperationBand(&band);\n    allBwps = CcBwpCreator::GetAllBwps({band});\n\n    double x = pow(10, totalTxPower / 10);\n\n    // Antennas for all the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(2));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(4));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Antennas for all the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(4));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(8));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    uint32_t bwpIdForLowLat = 0;\n    uint32_t bwpIdForVoice = 1;\n    uint32_t bwpIdForVideo = 2;\n    uint32_t bwpIdForVideoGaming = 3;\n\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\",\n                                                 UintegerValue(bwpIdForLowLat));\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"GBR_CONV_VOICE\", UintegerValue(bwpIdForVoice));\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_VIDEO_TCP_PREMIUM\",\n                                                 UintegerValue(bwpIdForVideo));\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_VOICE_VIDEO_GAMING\",\n                                                 UintegerValue(bwpIdForVideoGaming));\n\n    // Install and get the pointers to the NetDevices\n    NetDeviceContainer enbNetDev = nrHelper->InstallGnbDevice(gNbNodes, allBwps);\n    NetDeviceContainer ueNetDev = nrHelper->InstallUeDevice(ueNodes, allBwps);\n\n    int64_t randomStream = 1;\n    randomStream += nrHelper->AssignStreams(enbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);\n\n    if (contiguousCc == true)\n    {\n        // Manually set the attribute of the netdevice (enbNetDev.Get (0)) and bandwidth part (0),\n        // (1), ...\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)\n            ->SetAttribute(\"Numerology\", UintegerValue(numerology));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)\n            ->SetAttribute(\"TxPower\", DoubleValue(10 * log10(0.25 * x)));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)->SetAttribute(\"Pattern\", StringValue(pattern));\n\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)\n            ->SetAttribute(\"Numerology\", UintegerValue(numerology));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)\n            ->SetAttribute(\"TxPower\", DoubleValue(10 * log10(0.25 * x)));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)->SetAttribute(\"Pattern\", StringValue(pattern));\n\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)\n            ->SetAttribute(\"Numerology\", UintegerValue(numerology));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)\n            ->SetAttribute(\"TxPower\", DoubleValue(10 * log10(0.25 * x)));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)->SetAttribute(\"Pattern\", StringValue(pattern));\n\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 3)\n            ->SetAttribute(\"Numerology\", UintegerValue(numerology));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 3)\n            ->SetAttribute(\"TxPower\", DoubleValue(10 * log10(0.25 * x)));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 3)->SetAttribute(\"Pattern\", StringValue(pattern));\n    }\n    else\n    {\n        // Set the attribute of the netdevice (enbNetDev.Get (0)) and bandwidth part (0), (1), ...\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)\n            ->SetAttribute(\"Numerology\", UintegerValue(numerologyCc0Bwp0));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)\n            ->SetAttribute(\n                \"TxPower\",\n                DoubleValue(10 *\n                            log10((band.GetBwpAt(0, 0)->m_channelBandwidth / bandwidthBand) * x)));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)->SetAttribute(\"Pattern\", StringValue(pattern));\n\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)\n            ->SetAttribute(\"Numerology\", UintegerValue(numerologyCc0Bwp1));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)\n            ->SetAttribute(\n                \"TxPower\",\n                DoubleValue(10 *\n                            log10((band.GetBwpAt(1, 0)->m_channelBandwidth / bandwidthBand) * x)));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)->SetAttribute(\"Pattern\", StringValue(pattern));\n\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)\n            ->SetAttribute(\"Numerology\", UintegerValue(numerologyCc1Bwp0));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)\n            ->SetAttribute(\n                \"TxPower\",\n                DoubleValue(10 *\n                            log10((band.GetBwpAt(1, 1)->m_channelBandwidth / bandwidthBand) * x)));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 2)->SetAttribute(\"Pattern\", StringValue(pattern));\n    }\n\n    for (auto it = enbNetDev.Begin(); it != enbNetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.000)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));\n\n    Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress(1);\n\n    // Set the default gateway for the UEs\n    for (uint32_t j = 0; j < ueNodes.GetN(); ++j)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(ueNodes.Get(j)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // attach UEs to the closest eNB before creating the dedicated flows\n    nrHelper->AttachToClosestEnb(ueNetDev, enbNetDev);\n\n    // install UDP applications\n    uint16_t dlPort = 1234;\n    uint16_t ulPort = dlPort + gNbNum * ueNumPergNb * numFlowsUe + 1;\n    ApplicationContainer clientApps;\n    ApplicationContainer serverApps;\n\n    for (uint32_t u = 0; u < ueNodes.GetN(); ++u)\n    {\n        for (uint16_t flow = 0; flow < numFlowsUe; ++flow)\n        {\n            if (!disableDl)\n            {\n                PacketSinkHelper dlPacketSinkHelper(\n                    \"ns3::UdpSocketFactory\",\n                    InetSocketAddress(Ipv4Address::GetAny(), dlPort));\n                serverApps.Add(dlPacketSinkHelper.Install(ueNodes.Get(u)));\n\n                UdpClientHelper dlClient(ueIpIface.GetAddress(u), dlPort);\n                dlClient.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSizeBe));\n                dlClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambdaUll)));\n                dlClient.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n                clientApps.Add(dlClient.Install(remoteHost));\n\n                Ptr<EpcTft> tft = Create<EpcTft>();\n                EpcTft::PacketFilter dlpf;\n                dlpf.localPortStart = dlPort;\n                dlpf.localPortEnd = dlPort;\n                ++dlPort;\n                tft->Add(dlpf);\n\n                enum EpsBearer::Qci q;\n                if (flow == 0)\n                {\n                    q = EpsBearer::NGBR_LOW_LAT_EMBB;\n                }\n                else if (flow == 1)\n                {\n                    q = EpsBearer::GBR_CONV_VOICE;\n                }\n                else if (flow == 2)\n                {\n                    q = EpsBearer::NGBR_VIDEO_TCP_PREMIUM;\n                }\n                else if (flow == 3)\n                {\n                    q = EpsBearer::NGBR_VOICE_VIDEO_GAMING;\n                }\n                else\n                {\n                    q = EpsBearer::NGBR_VIDEO_TCP_DEFAULT;\n                }\n                EpsBearer bearer(q);\n                nrHelper->ActivateDedicatedEpsBearer(ueNetDev.Get(u), bearer, tft);\n            }\n\n            if (!disableUl)\n            {\n                PacketSinkHelper ulPacketSinkHelper(\n                    \"ns3::UdpSocketFactory\",\n                    InetSocketAddress(Ipv4Address::GetAny(), ulPort));\n                serverApps.Add(ulPacketSinkHelper.Install(remoteHost));\n\n                UdpClientHelper ulClient(remoteHostAddr, ulPort);\n                ulClient.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSizeBe));\n                ulClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambdaUll)));\n                ulClient.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n                clientApps.Add(ulClient.Install(ueNodes.Get(u)));\n\n                Ptr<EpcTft> tft = Create<EpcTft>();\n                EpcTft::PacketFilter ulpf;\n                ulpf.remotePortStart = ulPort;\n                ulpf.remotePortEnd = ulPort;\n                ++ulPort;\n                tft->Add(ulpf);\n\n                enum EpsBearer::Qci q;\n                if (flow == 0)\n                {\n                    q = EpsBearer::NGBR_LOW_LAT_EMBB;\n                }\n                else if (flow == 1)\n                {\n                    q = EpsBearer::GBR_CONV_VOICE;\n                }\n                else if (flow == 2)\n                {\n                    q = EpsBearer::NGBR_VIDEO_TCP_PREMIUM;\n                }\n                else if (flow == 3)\n                {\n                    q = EpsBearer::NGBR_VOICE_VIDEO_GAMING;\n                }\n                else\n                {\n                    q = EpsBearer::NGBR_VIDEO_TCP_DEFAULT;\n                }\n                EpsBearer bearer(q);\n                nrHelper->ActivateDedicatedEpsBearer(ueNetDev.Get(u), bearer, tft);\n            }\n        }\n    }\n\n    // start UDP server and client apps\n    serverApps.Start(Seconds(udpAppStartTime));\n    clientApps.Start(Seconds(udpAppStartTime));\n    serverApps.Stop(Seconds(simTime));\n    clientApps.Stop(Seconds(simTime));\n\n    // enable the traces provided by the nr module\n    // nrHelper->EnableTraces();\n\n    FlowMonitorHelper flowmonHelper;\n    NodeContainer endpointNodes;\n    endpointNodes.Add(remoteHost);\n    endpointNodes.Add(ueNodes);\n\n    Ptr<ns3::FlowMonitor> monitor = flowmonHelper.Install(endpointNodes);\n    monitor->SetAttribute(\"DelayBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"JitterBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"PacketSizeBinWidth\", DoubleValue(20));\n\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n\n    /*\n     * To check what was installed in the memory, i.e., BWPs of eNb Device, and its configuration.\n     * Example is: Node 1 -> Device 0 -> BandwidthPartMap -> {0,1} BWPs -> NrGnbPhy ->\n    NrPhyMacCommong-> Numerology, Bandwidth, ... GtkConfigStore config; config.ConfigureAttributes\n    ();\n    */\n\n    // Print per-flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier =\n        DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n\n    double averageFlowThroughput = 0.0;\n    double averageFlowDelay = 0.0;\n\n    std::ofstream outFile;\n    std::string filename = outputDir + \"/\" + simTag;\n    outFile.open(filename.c_str(), std::ofstream::out | std::ofstream::trunc);\n    if (!outFile.is_open())\n    {\n        std::cerr << \"Can't open file \" << filename << std::endl;\n        return 1;\n    }\n\n    outFile.setf(std::ios_base::fixed);\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin();\n         i != stats.end();\n         ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        std::stringstream protoStream;\n        protoStream << (uint16_t)t.protocol;\n        if (t.protocol == 6)\n        {\n            protoStream.str(\"TCP\");\n        }\n        if (t.protocol == 17)\n        {\n            protoStream.str(\"UDP\");\n        }\n        outFile << \"Flow \" << i->first << \" (\" << t.sourceAddress << \":\" << t.sourcePort << \" -> \"\n                << t.destinationAddress << \":\" << t.destinationPort << \") proto \"\n                << protoStream.str() << \"\\n\";\n        outFile << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n        outFile << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n        outFile << \"  TxOffered:  \"\n                << i->second.txBytes * 8.0 / (simTime - udpAppStartTime) / 1000 / 1000 << \" Mbps\\n\";\n        outFile << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n        if (i->second.rxPackets > 0)\n        {\n            // Measure the duration of the flow from receiver's perspective\n            // double rxDuration = i->second.timeLastRxPacket.GetSeconds () -\n            // i->second.timeFirstTxPacket.GetSeconds ();\n            double rxDuration = (simTime - udpAppStartTime);\n\n            averageFlowThroughput += i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000;\n            averageFlowDelay += 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;\n\n            outFile << \"  Throughput: \" << i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000\n                    << \" Mbps\\n\";\n            outFile << \"  Mean delay:  \"\n                    << 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n            // outFile << \"  Mean upt:  \" << i->second.uptSum / i->second.rxPackets / 1000/1000 << \"\n            // Mbps \\n\";\n            outFile << \"  Mean jitter:  \"\n                    << 1000 * i->second.jitterSum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n        }\n        else\n        {\n            outFile << \"  Throughput:  0 Mbps\\n\";\n            outFile << \"  Mean delay:  0 ms\\n\";\n            outFile << \"  Mean jitter: 0 ms\\n\";\n        }\n        outFile << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n    }\n\n    outFile << \"\\n\\n  Mean flow throughput: \" << averageFlowThroughput / stats.size() << \"\\n\";\n    outFile << \"  Mean flow delay: \" << averageFlowDelay / stats.size() << \"\\n\";\n\n    outFile.close();\n\n    std::ifstream f(filename.c_str());\n\n    if (f.is_open())\n    {\n        std::cout << f.rdbuf();\n    }\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/cttc-nr-demo.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2019 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n/**\n * \\ingroup examples\n * \\file cttc-nr-demo.cc\n * \\brief A cozy, simple, NR demo (in a tutorial style)\n *\n * This example describes how to setup a simulation using the 3GPP channel model\n * from TR 38.900. This example consists of a simple grid topology, in which you\n * can choose the number of gNbs and UEs. Have a look at the possible parameters\n * to know what you can configure through the command line.\n *\n * With the default configuration, the example will create two flows that will\n * go through two different subband numerologies (or bandwidth parts). For that,\n * specifically, two bands are created, each with a single CC, and each CC containing\n * one bandwidth part.\n *\n * The example will print on-screen the end-to-end result of one (or two) flows,\n * as well as writing them on a file.\n *\n * \\code{.unparsed}\n$ ./ns3 run \"cttc-nr-demo --PrintHelp\"\n    \\endcode\n *\n */\n\n/*\n * Include part. Often, you will have to include the headers for an entire module;\n * do that by including the name of the module you need with the suffix \"-module.h\".\n */\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/buildings-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n/*\n * Use, always, the namespace ns3. All the NR classes are inside such namespace.\n */\nusing namespace ns3;\n\n/*\n * With this line, we will be able to see the logs of the file by enabling the\n * component \"CttcNrDemo\"\n */\nNS_LOG_COMPONENT_DEFINE(\"CttcNrDemo\");\n\nint\nmain(int argc, char* argv[])\n{\n    /*\n     * Variables that represent the parameters we will accept as input by the\n     * command line. Each of them is initialized with a default value, and\n     * possibly overridden below when command-line arguments are parsed.\n     */\n    // Scenario parameters (that we will use inside this script):\n    uint16_t gNbNum = 1;\n    uint16_t ueNumPergNb = 2;\n    bool logging = false;\n    bool doubleOperationalBand = true;\n\n    // Traffic parameters (that we will use inside this script):\n    uint32_t udpPacketSizeULL = 100;\n    uint32_t udpPacketSizeBe = 1252;\n    uint32_t lambdaULL = 10000;\n    uint32_t lambdaBe = 10000;\n\n    // Simulation parameters. Please don't use double to indicate seconds; use\n    // ns-3 Time values which use integers to avoid portability issues.\n    Time simTime = MilliSeconds(1000);\n    Time udpAppStartTime = MilliSeconds(400);\n\n    // NR parameters. We will take the input from the command line, and then we\n    // will pass them inside the NR module.\n    uint16_t numerologyBwp1 = 4;\n    double centralFrequencyBand1 = 28e9;\n    double bandwidthBand1 = 100e6;\n    uint16_t numerologyBwp2 = 2;\n    double centralFrequencyBand2 = 28.2e9;\n    double bandwidthBand2 = 100e6;\n    double totalTxPower = 4;\n\n    // Where we will store the output files.\n    std::string simTag = \"default\";\n    std::string outputDir = \"./\";\n\n    /*\n     * From here, we instruct the ns3::CommandLine class of all the input parameters\n     * that we may accept as input, as well as their description, and the storage\n     * variable.\n     */\n    CommandLine cmd(__FILE__);\n\n    cmd.AddValue(\"gNbNum\", \"The number of gNbs in multiple-ue topology\", gNbNum);\n    cmd.AddValue(\"ueNumPergNb\", \"The number of UE per gNb in multiple-ue topology\", ueNumPergNb);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.AddValue(\"doubleOperationalBand\",\n                 \"If true, simulate two operational bands with one CC for each band,\"\n                 \"and each CC will have 1 BWP that spans the entire CC.\",\n                 doubleOperationalBand);\n    cmd.AddValue(\"packetSizeUll\",\n                 \"packet size in bytes to be used by ultra low latency traffic\",\n                 udpPacketSizeULL);\n    cmd.AddValue(\"packetSizeBe\",\n                 \"packet size in bytes to be used by best effort traffic\",\n                 udpPacketSizeBe);\n    cmd.AddValue(\"lambdaUll\",\n                 \"Number of UDP packets in one second for ultra low latency traffic\",\n                 lambdaULL);\n    cmd.AddValue(\"lambdaBe\",\n                 \"Number of UDP packets in one second for best effor traffic\",\n                 lambdaBe);\n    cmd.AddValue(\"simTime\", \"Simulation time\", simTime);\n    cmd.AddValue(\"numerologyBwp1\", \"The numerology to be used in bandwidth part 1\", numerologyBwp1);\n    cmd.AddValue(\"centralFrequencyBand1\",\n                 \"The system frequency to be used in band 1\",\n                 centralFrequencyBand1);\n    cmd.AddValue(\"bandwidthBand1\", \"The system bandwidth to be used in band 1\", bandwidthBand1);\n    cmd.AddValue(\"numerologyBwp2\", \"The numerology to be used in bandwidth part 2\", numerologyBwp2);\n    cmd.AddValue(\"centralFrequencyBand2\",\n                 \"The system frequency to be used in band 2\",\n                 centralFrequencyBand2);\n    cmd.AddValue(\"bandwidthBand2\", \"The system bandwidth to be used in band 2\", bandwidthBand2);\n    cmd.AddValue(\"totalTxPower\",\n                 \"total tx power that will be proportionally assigned to\"\n                 \" bands, CCs and bandwidth parts depending on each BWP bandwidth \",\n                 totalTxPower);\n    cmd.AddValue(\"simTag\",\n                 \"tag to be appended to output filenames to distinguish simulation campaigns\",\n                 simTag);\n    cmd.AddValue(\"outputDir\", \"directory where to store simulation results\", outputDir);\n\n    // Parse the command line\n    cmd.Parse(argc, argv);\n\n    /*\n     * Check if the frequency is in the allowed range.\n     * If you need to add other checks, here is the best position to put them.\n     */\n    NS_ABORT_IF(centralFrequencyBand1 < 0.5e9 && centralFrequencyBand1 > 100e9);\n    NS_ABORT_IF(centralFrequencyBand2 < 0.5e9 && centralFrequencyBand2 > 100e9);\n\n    /*\n     * If the logging variable is set to true, enable the log of some components\n     * through the code. The same effect can be obtained through the use\n     * of the NS_LOG environment variable:\n     *\n     * export NS_LOG=\"UdpClient=level_info|prefix_time|prefix_func|prefix_node:UdpServer=...\"\n     *\n     * Usually, the environment variable way is preferred, as it is more customizable,\n     * and more expressive.\n     */\n    if (logging)\n    {\n        LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"LtePdcp\", LOG_LEVEL_INFO);\n    }\n\n    /*\n     * Default values for the simulation. We are progressively removing all\n     * the instances of SetDefault, but we need it for legacy code (LTE)\n     */\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n\n    /*\n     * Create the scenario. In our examples, we heavily use helpers that setup\n     * the gnbs and ue following a pre-defined pattern. Please have a look at the\n     * GridScenarioHelper documentation to see how the nodes will be distributed.\n     */\n    int64_t randomStream = 1;\n    GridScenarioHelper gridScenario;\n    gridScenario.SetRows(1);\n    gridScenario.SetColumns(gNbNum);\n    gridScenario.SetHorizontalBsDistance(5.0);\n    gridScenario.SetVerticalBsDistance(5.0);\n    gridScenario.SetBsHeight(1.5);\n    gridScenario.SetUtHeight(1.5);\n    // must be set before BS number\n    gridScenario.SetSectorization(GridScenarioHelper::SINGLE);\n    gridScenario.SetBsNumber(gNbNum);\n    gridScenario.SetUtNumber(ueNumPergNb * gNbNum);\n    gridScenario.SetScenarioHeight(3); // Create a 3x3 scenario where the UE will\n    gridScenario.SetScenarioLength(3); // be distribuited.\n    randomStream += gridScenario.AssignStreams(randomStream);\n    gridScenario.CreateScenario();\n\n    /*\n     * Create two different NodeContainer for the different traffic type.\n     * In ueLowLat we will put the UEs that will receive low-latency traffic,\n     * while in ueVoice we will put the UEs that will receive the voice traffic.\n     */\n    NodeContainer ueLowLatContainer;\n    NodeContainer ueVoiceContainer;\n\n    for (uint32_t j = 0; j < gridScenario.GetUserTerminals().GetN(); ++j)\n    {\n        Ptr<Node> ue = gridScenario.GetUserTerminals().Get(j);\n        if (j % 2 == 0)\n        {\n            ueLowLatContainer.Add(ue);\n        }\n        else\n        {\n            ueVoiceContainer.Add(ue);\n        }\n    }\n\n    /*\n     * TODO: Add a print, or a plot, that shows the scenario.\n     */\n\n    /*\n     * Setup the NR module. We create the various helpers needed for the\n     * NR simulation:\n     * - EpcHelper, which will setup the core network\n     * - IdealBeamformingHelper, which takes care of the beamforming part\n     * - NrHelper, which takes care of creating and connecting the various\n     * part of the NR stack\n     */\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n\n    // Put the pointers inside nrHelper\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    /*\n     * Spectrum division. We create two operational bands, each of them containing\n     * one component carrier, and each CC containing a single bandwidth part\n     * centered at the frequency specified by the input parameters.\n     * Each spectrum part length is, as well, specified by the input parameters.\n     * Both operational bands will use the StreetCanyon channel modeling.\n     */\n    BandwidthPartInfoPtrVector allBwps;\n    CcBwpCreator ccBwpCreator;\n    const uint8_t numCcPerBand = 1; // in this example, both bands have a single CC\n\n    // Create the configuration for the CcBwpHelper. SimpleOperationBandConf creates\n    // a single BWP per CC\n    CcBwpCreator::SimpleOperationBandConf bandConf1(centralFrequencyBand1,\n                                                    bandwidthBand1,\n                                                    numCcPerBand,\n                                                    BandwidthPartInfo::UMi_StreetCanyon);\n    CcBwpCreator::SimpleOperationBandConf bandConf2(centralFrequencyBand2,\n                                                    bandwidthBand2,\n                                                    numCcPerBand,\n                                                    BandwidthPartInfo::UMi_StreetCanyon);\n\n    // By using the configuration created, it is time to make the operation bands\n    OperationBandInfo band1 = ccBwpCreator.CreateOperationBandContiguousCc(bandConf1);\n    OperationBandInfo band2 = ccBwpCreator.CreateOperationBandContiguousCc(bandConf2);\n\n    /*\n     * The configured spectrum division is:\n     * ------------Band1--------------|--------------Band2-----------------\n     * ------------CC1----------------|--------------CC2-------------------\n     * ------------BWP1---------------|--------------BWP2------------------\n     */\n\n    /*\n     * Attributes of ThreeGppChannelModel still cannot be set in our way.\n     * TODO: Coordinate with Tommaso\n     */\n    Config::SetDefault(\"ns3::ThreeGppChannelModel::UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetChannelConditionModelAttribute(\"UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n\n    /*\n     * Initialize channel and pathloss, plus other things inside band1. If needed,\n     * the band configuration can be done manually, but we leave it for more\n     * sophisticated examples. For the moment, this method will take care\n     * of all the spectrum initialization needs.\n     */\n    nrHelper->InitializeOperationBand(&band1);\n\n    /*\n     * Start to account for the bandwidth used by the example, as well as\n     * the total power that has to be divided among the BWPs.\n     */\n    double x = pow(10, totalTxPower / 10);\n    double totalBandwidth = bandwidthBand1;\n\n    /*\n     * if not single band simulation, initialize and setup power in the second band\n     */\n    if (doubleOperationalBand)\n    {\n        // Initialize channel and pathloss, plus other things inside band2\n        nrHelper->InitializeOperationBand(&band2);\n        totalBandwidth += bandwidthBand2;\n        allBwps = CcBwpCreator::GetAllBwps({band1, band2});\n    }\n    else\n    {\n        allBwps = CcBwpCreator::GetAllBwps({band1});\n    }\n\n    /*\n     * allBwps contains all the spectrum configuration needed for the nrHelper.\n     *\n     * Now, we can setup the attributes. We can have three kind of attributes:\n     * (i) parameters that are valid for all the bandwidth parts and applies to\n     * all nodes, (ii) parameters that are valid for all the bandwidth parts\n     * and applies to some node only, and (iii) parameters that are different for\n     * every bandwidth parts. The approach is:\n     *\n     * - for (i): Configure the attribute through the helper, and then install;\n     * - for (ii): Configure the attribute through the helper, and then install\n     * for the first set of nodes. Then, change the attribute through the helper,\n     * and install again;\n     * - for (iii): Install, and then configure the attributes by retrieving\n     * the pointer needed, and calling \"SetAttribute\" on top of such pointer.\n     *\n     */\n\n    Packet::EnableChecking();\n    Packet::EnablePrinting();\n\n    /*\n     *  Case (i): Attributes valid for all the nodes\n     */\n    // Beamforming method\n    idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));\n\n    // Core latency\n    epcHelper->SetAttribute(\"S1uLinkDelay\", TimeValue(MilliSeconds(0)));\n\n    // Antennas for all the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(2));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(4));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Antennas for all the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(4));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(8));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    uint32_t bwpIdForLowLat = 0;\n    uint32_t bwpIdForVoice = 0;\n    if (doubleOperationalBand)\n    {\n        bwpIdForVoice = 1;\n        bwpIdForLowLat = 0;\n    }\n\n    // gNb routing between Bearer and bandwidh part\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\",\n                                                 UintegerValue(bwpIdForLowLat));\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"GBR_CONV_VOICE\", UintegerValue(bwpIdForVoice));\n\n    // Ue routing between Bearer and bandwidth part\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\", UintegerValue(bwpIdForLowLat));\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"GBR_CONV_VOICE\", UintegerValue(bwpIdForVoice));\n\n    /*\n     * We miss many other parameters. By default, not configuring them is equivalent\n     * to use the default values. Please, have a look at the documentation to see\n     * what are the default values for all the attributes you are not seeing here.\n     */\n\n    /*\n     * Case (ii): Attributes valid for a subset of the nodes\n     */\n\n    // NOT PRESENT IN THIS SIMPLE EXAMPLE\n\n    /*\n     * We have configured the attributes we needed. Now, install and get the pointers\n     * to the NetDevices, which contains all the NR stack:\n     */\n\n    NetDeviceContainer enbNetDev =\n        nrHelper->InstallGnbDevice(gridScenario.GetBaseStations(), allBwps);\n    NetDeviceContainer ueLowLatNetDev = nrHelper->InstallUeDevice(ueLowLatContainer, allBwps);\n    NetDeviceContainer ueVoiceNetDev = nrHelper->InstallUeDevice(ueVoiceContainer, allBwps);\n\n    randomStream += nrHelper->AssignStreams(enbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueLowLatNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueVoiceNetDev, randomStream);\n    /*\n     * Case (iii): Go node for node and change the attributes we have to setup\n     * per-node.\n     */\n\n    // Get the first netdevice (enbNetDev.Get (0)) and the first bandwidth part (0)\n    // and set the attribute.\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)\n        ->SetAttribute(\"Numerology\", UintegerValue(numerologyBwp1));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)\n        ->SetAttribute(\"TxPower\", DoubleValue(10 * log10((bandwidthBand1 / totalBandwidth) * x)));\n\n    if (doubleOperationalBand)\n    {\n        // Get the first netdevice (enbNetDev.Get (0)) and the second bandwidth part (1)\n        // and set the attribute.\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)\n            ->SetAttribute(\"Numerology\", UintegerValue(numerologyBwp2));\n        nrHelper->GetGnbPhy(enbNetDev.Get(0), 1)\n            ->SetTxPower(10 * log10((bandwidthBand2 / totalBandwidth) * x));\n    }\n\n    // When all the configuration is done, explicitly call UpdateConfig ()\n\n    for (auto it = enbNetDev.Begin(); it != enbNetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueLowLatNetDev.Begin(); it != ueLowLatNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueVoiceNetDev.Begin(); it != ueVoiceNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    // From here, it is standard NS3. In the future, we will create helpers\n    // for this part as well.\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.000)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(gridScenario.GetUserTerminals());\n\n    Ipv4InterfaceContainer ueLowLatIpIface =\n        epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueLowLatNetDev));\n    Ipv4InterfaceContainer ueVoiceIpIface =\n        epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueVoiceNetDev));\n\n    // Set the default gateway for the UEs\n    for (uint32_t j = 0; j < gridScenario.GetUserTerminals().GetN(); ++j)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting = ipv4RoutingHelper.GetStaticRouting(\n            gridScenario.GetUserTerminals().Get(j)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // attach UEs to the closest eNB\n    nrHelper->AttachToClosestEnb(ueLowLatNetDev, enbNetDev);\n    nrHelper->AttachToClosestEnb(ueVoiceNetDev, enbNetDev);\n\n    /*\n     * Traffic part. Install two kind of traffic: low-latency and voice, each\n     * identified by a particular source port.\n     */\n    uint16_t dlPortLowLat = 1234;\n    uint16_t dlPortVoice = 1235;\n\n    ApplicationContainer serverApps;\n\n    // The sink will always listen to the specified ports\n    UdpServerHelper dlPacketSinkLowLat(dlPortLowLat);\n    UdpServerHelper dlPacketSinkVoice(dlPortVoice);\n\n    // The server, that is the application which is listening, is installed in the UE\n    serverApps.Add(dlPacketSinkLowLat.Install(ueLowLatContainer));\n    serverApps.Add(dlPacketSinkVoice.Install(ueVoiceContainer));\n\n    /*\n     * Configure attributes for the different generators, using user-provided\n     * parameters for generating a CBR traffic\n     *\n     * Low-Latency configuration and object creation:\n     */\n    UdpClientHelper dlClientLowLat;\n    dlClientLowLat.SetAttribute(\"RemotePort\", UintegerValue(dlPortLowLat));\n    dlClientLowLat.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    dlClientLowLat.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSizeULL));\n    dlClientLowLat.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambdaULL)));\n\n    // The bearer that will carry low latency traffic\n    EpsBearer lowLatBearer(EpsBearer::NGBR_LOW_LAT_EMBB);\n\n    // The filter for the low-latency traffic\n    Ptr<EpcTft> lowLatTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfLowLat;\n    dlpfLowLat.localPortStart = dlPortLowLat;\n    dlpfLowLat.localPortEnd = dlPortLowLat;\n    lowLatTft->Add(dlpfLowLat);\n\n    // Voice configuration and object creation:\n    UdpClientHelper dlClientVoice;\n    dlClientVoice.SetAttribute(\"RemotePort\", UintegerValue(dlPortVoice));\n    dlClientVoice.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    dlClientVoice.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSizeBe));\n    dlClientVoice.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambdaBe)));\n\n    // The bearer that will carry voice traffic\n    EpsBearer voiceBearer(EpsBearer::GBR_CONV_VOICE);\n\n    // The filter for the voice traffic\n    Ptr<EpcTft> voiceTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfVoice;\n    dlpfVoice.localPortStart = dlPortVoice;\n    dlpfVoice.localPortEnd = dlPortVoice;\n    voiceTft->Add(dlpfVoice);\n\n    /*\n     * Let's install the applications!\n     */\n    ApplicationContainer clientApps;\n\n    for (uint32_t i = 0; i < ueLowLatContainer.GetN(); ++i)\n    {\n        Ptr<Node> ue = ueLowLatContainer.Get(i);\n        Ptr<NetDevice> ueDevice = ueLowLatNetDev.Get(i);\n        Address ueAddress = ueLowLatIpIface.GetAddress(i);\n\n        // The client, who is transmitting, is installed in the remote host,\n        // with destination address set to the address of the UE\n        dlClientLowLat.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n        clientApps.Add(dlClientLowLat.Install(remoteHost));\n\n        // Activate a dedicated bearer for the traffic type\n        nrHelper->ActivateDedicatedEpsBearer(ueDevice, lowLatBearer, lowLatTft);\n    }\n\n    for (uint32_t i = 0; i < ueVoiceContainer.GetN(); ++i)\n    {\n        Ptr<Node> ue = ueVoiceContainer.Get(i);\n        Ptr<NetDevice> ueDevice = ueVoiceNetDev.Get(i);\n        Address ueAddress = ueVoiceIpIface.GetAddress(i);\n\n        // The client, who is transmitting, is installed in the remote host,\n        // with destination address set to the address of the UE\n        dlClientVoice.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n        clientApps.Add(dlClientVoice.Install(remoteHost));\n\n        // Activate a dedicated bearer for the traffic type\n        nrHelper->ActivateDedicatedEpsBearer(ueDevice, voiceBearer, voiceTft);\n    }\n\n    // start UDP server and client apps\n    serverApps.Start(udpAppStartTime);\n    clientApps.Start(udpAppStartTime);\n    serverApps.Stop(simTime);\n    clientApps.Stop(simTime);\n\n    // enable the traces provided by the nr module\n    // nrHelper->EnableTraces();\n\n    FlowMonitorHelper flowmonHelper;\n    NodeContainer endpointNodes;\n    endpointNodes.Add(remoteHost);\n    endpointNodes.Add(gridScenario.GetUserTerminals());\n\n    Ptr<ns3::FlowMonitor> monitor = flowmonHelper.Install(endpointNodes);\n    monitor->SetAttribute(\"DelayBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"JitterBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"PacketSizeBinWidth\", DoubleValue(20));\n\n    Simulator::Stop(simTime);\n    Simulator::Run();\n\n    /*\n     * To check what was installed in the memory, i.e., BWPs of eNb Device, and its configuration.\n     * Example is: Node 1 -> Device 0 -> BandwidthPartMap -> {0,1} BWPs -> NrGnbPhy -> Numerology,\n    GtkConfigStore config;\n    config.ConfigureAttributes ();\n    */\n\n    // Print per-flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier =\n        DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n\n    double averageFlowThroughput = 0.0;\n    double averageFlowDelay = 0.0;\n\n    std::ofstream outFile;\n    std::string filename = outputDir + \"/\" + simTag;\n    outFile.open(filename.c_str(), std::ofstream::out | std::ofstream::trunc);\n    if (!outFile.is_open())\n    {\n        std::cerr << \"Can't open file \" << filename << std::endl;\n        return 1;\n    }\n\n    outFile.setf(std::ios_base::fixed);\n\n    double flowDuration = (simTime - udpAppStartTime).GetSeconds();\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin();\n         i != stats.end();\n         ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        std::stringstream protoStream;\n        protoStream << (uint16_t)t.protocol;\n        if (t.protocol == 6)\n        {\n            protoStream.str(\"TCP\");\n        }\n        if (t.protocol == 17)\n        {\n            protoStream.str(\"UDP\");\n        }\n        outFile << \"Flow \" << i->first << \" (\" << t.sourceAddress << \":\" << t.sourcePort << \" -> \"\n                << t.destinationAddress << \":\" << t.destinationPort << \") proto \"\n                << protoStream.str() << \"\\n\";\n        outFile << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n        outFile << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n        outFile << \"  TxOffered:  \" << i->second.txBytes * 8.0 / flowDuration / 1000.0 / 1000.0\n                << \" Mbps\\n\";\n        outFile << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n        if (i->second.rxPackets > 0)\n        {\n            // Measure the duration of the flow from receiver's perspective\n            averageFlowThroughput += i->second.rxBytes * 8.0 / flowDuration / 1000 / 1000;\n            averageFlowDelay += 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;\n\n            outFile << \"  Throughput: \" << i->second.rxBytes * 8.0 / flowDuration / 1000 / 1000\n                    << \" Mbps\\n\";\n            outFile << \"  Mean delay:  \"\n                    << 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n            // outFile << \"  Mean upt:  \" << i->second.uptSum / i->second.rxPackets / 1000/1000 << \"\n            // Mbps \\n\";\n            outFile << \"  Mean jitter:  \"\n                    << 1000 * i->second.jitterSum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n        }\n        else\n        {\n            outFile << \"  Throughput:  0 Mbps\\n\";\n            outFile << \"  Mean delay:  0 ms\\n\";\n            outFile << \"  Mean jitter: 0 ms\\n\";\n        }\n        outFile << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n    }\n\n    double meanFlowThroughput = averageFlowThroughput / stats.size();\n    double meanFlowDelay = averageFlowDelay / stats.size();\n\n    outFile << \"\\n\\n  Mean flow throughput: \" << meanFlowThroughput << \"\\n\";\n    outFile << \"  Mean flow delay: \" << meanFlowDelay << \"\\n\";\n\n    outFile.close();\n\n    std::ifstream f(filename.c_str());\n\n    if (f.is_open())\n    {\n        std::cout << f.rdbuf();\n    }\n\n    Simulator::Destroy();\n\n    if (argc == 0)\n    {\n        double toleranceMeanFlowThroughput = 0.0001 * 56.258560;\n        double toleranceMeanFlowDelay = 0.0001 * 0.553292;\n\n        if (meanFlowThroughput >= 56.258560 - toleranceMeanFlowThroughput &&\n            meanFlowThroughput <= 56.258560 + toleranceMeanFlowThroughput &&\n            meanFlowDelay >= 0.553292 - toleranceMeanFlowDelay &&\n            meanFlowDelay <= 0.553292 + toleranceMeanFlowDelay)\n        {\n            return EXIT_SUCCESS;\n        }\n        else\n        {\n            return EXIT_FAILURE;\n        }\n    }\n    else if (argc == 1 and ueNumPergNb == 9) // called from examples-to-run.py with these parameters\n    {\n        double toleranceMeanFlowThroughput = 0.0001 * 47.858536;\n        double toleranceMeanFlowDelay = 0.0001 * 10.504189;\n\n        if (meanFlowThroughput >= 47.858536 - toleranceMeanFlowThroughput &&\n            meanFlowThroughput <= 47.858536 + toleranceMeanFlowThroughput &&\n            meanFlowDelay >= 10.504189 - toleranceMeanFlowDelay &&\n            meanFlowDelay <= 10.504189 + toleranceMeanFlowDelay)\n        {\n            return EXIT_SUCCESS;\n        }\n        else\n        {\n            return EXIT_FAILURE;\n        }\n    }\n    else\n    {\n        return EXIT_SUCCESS; // we dont check other parameters configurations at the moment\n    }\n}\n"
    },
    {
      "file_path": "examples/cttc-nr-mimo-demo.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2021 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n/**\n * \\ingroup examples\n * \\file cttc-nr-mimo-demo.cc\n * \\brief A cozy, simple, NR MIMO demo (in a tutorial style)\n *\n * This example describes how to setup a MIMO simulation using the 3GPP channel model\n * from TR 38.900. This example consists of a simple topology, in which there\n * is only one gNB and one UE. Have a look at the possible parameters\n * to know what you can configure through the command line.\n *\n * With the default configuration, the example will create one DL flow that will\n * go through only one BWP.\n *\n * The example will print on-screen the end-to-end result of the flow,\n * as well as writing them in a file.\n *\n * \\code{.unparsed}\n$ ./ns3 run \"cttc-nr-mimo-demo --PrintHelp\"\n    \\endcode\n *\n */\n\n/*\n * Include part. Often, you will have to include the headers for an entire module;\n * do that by including the name of the module you need with the suffix \"-module.h\".\n */\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n/*\n * Use, always, the namespace ns3. All the NR classes are inside such namespace.\n */\nusing namespace ns3;\n\n/*\n * With this line, we will be able to see the logs of the file by enabling the\n * component \"CttcNrMimoDemo\"\n */\nNS_LOG_COMPONENT_DEFINE(\"CttcNrMimoDemo\");\n\nint\nmain(int argc, char* argv[])\n{\n    /*\n     * Variables that represent the parameters we will accept as input by the\n     * command line. Each of them is initialized with a default value, and\n     * possibly overridden below when command-line arguments are parsed.\n     */\n    // Scenario parameters (that we will use inside this script):\n    bool logging = false;\n\n    // Whether gNB and UE antenna arrays support\n    bool crossPolarizedGnb = true;\n    bool crossPolarizedUe = true;\n\n    // Number of rows and columns of antennas of Gnb and Ue\n    uint16_t numRowsGnb = 2;\n    uint16_t numColumnsGnb = 2;\n    uint16_t numRowsUe = 1;\n    uint16_t numColumnsUe = 1;\n\n    // Traffic parameters (that we will use inside this script):\n    uint32_t udpPacketSize = 1000;\n    // For 2x2 MIMO and NR MCS table 2, packet interval is 40000 ns to\n    // reach 200 mb/s\n    Time packetInterval = NanoSeconds(40000);\n\n    // distance between the gNB and the UE\n    uint16_t gnbUeDistance = 20; // meters\n\n    // Simulation parameters. Please don't use double to indicate seconds; use\n    // ns-3 Time values which use integers to avoid portability issues.\n    Time simTime = MilliSeconds(1000);\n    Time udpAppStartTime = MilliSeconds(400);\n\n    // NR parameters. We will take the input from the command line, and then we\n    // will pass them inside the NR module.\n    uint16_t numerology = 0;\n    double centralFrequency = 3.5e9;\n    double bandwidth = 20e6;\n    double gnbTxPower = 30; // dBm\n    double ueTxPower = 23;  // dBm\n    uint16_t fixedRankIndicator = 2;\n    bool useFixedRi = true;\n    double ro = 0;\n    uint16_t updatePeriodMs = 100;\n    uint16_t mcsTable = 2;\n\n    // The polarization slant angle of first and second subarray in degrees\n    double polSlantAngle1 = 0.0;\n    double polSlantAngle2 = 90.0;\n\n    // whether the cross polarization correlation is parameterized, when set to false correlation is\n    // calculated as per 3gpp channel model\n    bool parametrizedCorrelation = true;\n\n    // Where we will store the output files.\n    std::string simTag = \"default\";\n    std::string outputDir = \"./\";\n\n    /*\n     * From here, we instruct the ns3::CommandLine class of all the input parameters\n     * that we may accept as input, as well as their description, and the storage\n     * variable.\n     */\n    CommandLine cmd(__FILE__);\n\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.AddValue(\"crossPolarizedGnb\",\n                 \"Whether the gNB antenna array has the cross polarized antenna \"\n                 \"elements. If yes, gNB supports 2 streams, otherwise only 1 stream\",\n                 crossPolarizedGnb);\n    cmd.AddValue(\"crossPolarizedUe\",\n                 \"Whether the UE antenna array has the cross polarized antenna \"\n                 \"elements. If yes, UE supports 2 streams, otherwise only 1 stream\",\n                 crossPolarizedUe);\n    cmd.AddValue(\"numRowsGnb\", \"Number of antenna rows at the gNB\", numRowsGnb);\n    cmd.AddValue(\"numRowsUe\", \"Number of antenna rows at the UE\", numRowsUe);\n    cmd.AddValue(\"numColumnsGnb\", \"Number of antenna columns at the gNB\", numColumnsGnb);\n    cmd.AddValue(\"numColumnsUe\", \"Number of antenna columns at the UE\", numColumnsUe);\n    cmd.AddValue(\"ro\", \"The channel correlation parameter\", ro);\n    cmd.AddValue(\"packetSize\",\n                 \"packet size in bytes to be used by best effort traffic\",\n                 udpPacketSize);\n    cmd.AddValue(\"packetInterval\", \"Inter packet interval for CBR traffic\", packetInterval);\n    cmd.AddValue(\"simTime\", \"Simulation time\", simTime);\n    cmd.AddValue(\"numerology\", \"The numerology to be used\", numerology);\n    cmd.AddValue(\"centralFrequency\", \"The system frequency to be used in band 1\", centralFrequency);\n    cmd.AddValue(\"bandwidth\", \"The system bandwidth to be used\", bandwidth);\n    cmd.AddValue(\"gnbTxPower\", \"gNB TX power\", gnbTxPower);\n    cmd.AddValue(\"ueTxPower\", \"UE TX power\", ueTxPower);\n    cmd.AddValue(\"gnbUeDistance\",\n                 \"The distance between the gNB and the UE in the scenario\",\n                 gnbUeDistance);\n    cmd.AddValue(\"fixedRankIndicator\", \"The rank indicator used by the UE\", fixedRankIndicator);\n    cmd.AddValue(\"useFixedRi\",\n                 \"If true, UE will use a fixed configured RI value; otherwise, \"\n                 \"it will use an adaptive RI value based on the SINR of the streams\",\n                 useFixedRi);\n    cmd.AddValue(\n        \"updatePeriodMs\",\n        \"Channel update period in ms. If set to 0 then the channel update will be disabled\",\n        updatePeriodMs);\n    cmd.AddValue(\"polSlantAngle1\",\n                 \"Polarization slant angle of the first antenna sub-array/partition in degrees\",\n                 polSlantAngle1);\n    cmd.AddValue(\"polSlantAngle2\",\n                 \"Polarization slant angle of the second antenna sub-array/partition in degrees\",\n                 polSlantAngle2);\n    cmd.AddValue(\"parametrizedCorrelation\",\n                 \"Whether the cross polarization correlation is parameterized or \"\n                 \"calculated according to 3gpp channel model. When set to true \"\n                 \"it is parameterized, otherwise it is per 3gpp channel model\",\n                 parametrizedCorrelation);\n    cmd.AddValue(\"mcsTable\", \"The NR MCS table to be used\", mcsTable);\n    cmd.AddValue(\"simTag\",\n                 \"tag to be appended to output filenames to distinguish simulation campaigns\",\n                 simTag);\n    cmd.AddValue(\"outputDir\", \"directory where to store simulation results\", outputDir);\n\n    // Parse the command line\n    cmd.Parse(argc, argv);\n\n    /*\n     * Check if the frequency is in the allowed range.\n     * If you need to add other checks, here is the best position to put them.\n     */\n    NS_ABORT_IF(centralFrequency > 100e9);\n\n    /*\n     * If the logging variable is set to true, enable the log of some components\n     * through the code. The same effect can be obtained through the use\n     * of the NS_LOG environment variable:\n     *\n     * export NS_LOG=\"UdpClient=level_info|prefix_time|prefix_func|prefix_node:UdpServer=...\"\n     *\n     * Usually, the environment variable way is preferred, as it is more customizable,\n     * and more expressive.\n     */\n    if (logging)\n    {\n        LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"LtePdcp\", LOG_LEVEL_INFO);\n    }\n\n    /*\n     * Default values for the simulation. We are progressively removing all\n     * the instances of SetDefault, but we need it for legacy code (LTE)\n     */\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n\n    /*\n     * Attributes of ThreeGppChannelModel still cannot be set in our way.\n     */\n    Config::SetDefault(\"ns3::ThreeGppChannelModel::UpdatePeriod\",\n                       TimeValue(MilliSeconds(updatePeriodMs)));\n    Config::SetDefault(\"ns3::ThreeGppChannelModelParam::Ro\", DoubleValue(ro));\n    Config::SetDefault(\"ns3::ThreeGppChannelModelParam::ParametrizedCorrelation\",\n                       BooleanValue(parametrizedCorrelation));\n    Config::SetDefault(\"ns3::ThreeGppSpectrumPropagationLossModel::ChannelModel\",\n                       StringValue(\"ns3::ThreeGppChannelModelParam\"));\n\n    /*\n     * Create the scenario. In our examples, we heavily use helpers that setup\n     * the gnbs and ue following a pre-defined pattern. Please have a look at the\n     * GridScenarioHelper documentation to see how the nodes will be distributed.\n     */\n    int64_t randomStream = 1;\n\n    /*\n     * Assign mobility to the gNB and UEs.\n     *  1. Set mobility model type.\n     *  2. Store the positions in ListPositionAllocator for the gNB and UE\n     *  3. Install mobility model\n     */\n\n    /*\n     * Create NodeContainer for gNB and UE\n     */\n    NodeContainer gnbContainer;\n    gnbContainer.Create(1);\n    NodeContainer ueContainer;\n    ueContainer.Create(1);\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    Ptr<ListPositionAllocator> positionAllocUe = CreateObject<ListPositionAllocator>();\n    positionAllocUe->Add(Vector(0.0, 0.0, 10.0));\n    positionAllocUe->Add(Vector(gnbUeDistance, 0.0, 1.5));\n    mobility.SetPositionAllocator(positionAllocUe);\n    mobility.Install(gnbContainer);\n    mobility.Install(ueContainer);\n\n    /* The default topology is the following:\n     *\n     *         gNB..........(20 m)..........UE\n     *   (0.0, 0.0, 10.0)               (20, 0.0, 1.5)\n     */\n\n    /*\n     * Setup the NR module. We create the various helpers needed for the\n     * NR simulation:\n     * - EpcHelper, which will setup the core network\n     * - IdealBeamformingHelper, which takes care of the beamforming part\n     * - NrHelper, which takes care of creating and connecting the various\n     * part of the NR stack\n     */\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n\n    // Put the pointers inside nrHelper\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    /*\n     * Spectrum division. We create one operational band, containing\n     * one component carrier, and a single bandwidth part\n     * centered at the frequency specified by the input parameters.\n     * We will use the StreetCanyon channel modeling.\n     */\n    CcBwpCreator ccBwpCreator;\n    const uint8_t numCcPerBand = 1; // single CC\n\n    // Create the configuration for the CcBwpHelper. SimpleOperationBandConf creates\n    // a single BWP per CC\n    CcBwpCreator::SimpleOperationBandConf bandConf(centralFrequency,\n                                                   bandwidth,\n                                                   numCcPerBand,\n                                                   BandwidthPartInfo::UMi_StreetCanyon);\n\n    // By using the configuration created, it is time to make the operation bands\n    OperationBandInfo band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);\n\n    /*\n     * The configured spectrum division is:\n     * ------------Band--------------\n     * ------------CC1----------------\n     * ------------BWP1---------------\n     */\n\n    nrHelper->SetChannelConditionModelAttribute(\"UpdatePeriod\",\n                                                TimeValue(MilliSeconds(updatePeriodMs)));\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n\n    /*\n     * Initialize channel and pathloss, plus other things inside band. If needed,\n     * the band configuration can be done manually, but we leave it for more\n     * sophisticated examples. For the moment, this method will take care\n     * of all the spectrum initialization needs.\n     */\n    nrHelper->InitializeOperationBand(&band);\n\n    /*\n     * allBwps contains all the spectrum configuration needed by the nrHelper\n     * to install a device.\n     */\n    BandwidthPartInfoPtrVector allBwps;\n    allBwps = CcBwpCreator::GetAllBwps({band});\n\n    /*\n     * allBwps contains all the spectrum configuration needed for the nrHelper.\n     */\n\n    Packet::EnableChecking();\n    Packet::EnablePrinting();\n\n    /*\n     *  Attributes valid for all the nodes\n     */\n    // Error Model: gNB and UE with same spectrum error model.\n    std::string errorModel = \"ns3::NrEesmIrT\" + std::to_string(mcsTable);\n    nrHelper->SetDlErrorModel(errorModel);\n    nrHelper->SetUlErrorModel(errorModel);\n\n    // Both DL and UL AMC will have the same model behind.\n    nrHelper->SetGnbDlAmcAttribute(\"AmcModel\", EnumValue(NrAmc::ErrorModel));\n    nrHelper->SetGnbUlAmcAttribute(\"AmcModel\", EnumValue(NrAmc::ErrorModel));\n\n    // Beamforming method\n    idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));\n\n    // Core latency\n    epcHelper->SetAttribute(\"S1uLinkDelay\", TimeValue(MilliSeconds(0)));\n\n    // Antennas for all the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(numRowsUe));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(numColumnsUe));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // UE rank indicator\n    if (useFixedRi)\n    {\n        // it makes more sense to configure the rank indicator value\n        // if useFixedRi is true.\n        nrHelper->SetUePhyAttribute(\"UseFixedRi\", BooleanValue(useFixedRi));\n        nrHelper->SetUePhyAttribute(\"FixedRankIndicator\", UintegerValue(fixedRankIndicator));\n    }\n    else\n    {\n        nrHelper->SetUePhyAttribute(\"UseFixedRi\", BooleanValue(useFixedRi));\n    }\n\n    // Antennas for all the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(numRowsGnb));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(numColumnsGnb));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<ThreeGppAntennaModel>()));\n\n    uint32_t bwpId = 0;\n\n    // gNb routing between Bearer and bandwidth part\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\", UintegerValue(bwpId));\n\n    // UE routing between Bearer and bandwidth part\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\", UintegerValue(bwpId));\n\n    /*\n     * We miss many other parameters. By default, not configuring them is equivalent\n     * to use the default values. Please, have a look at the documentation to see\n     * what are the default values for all the attributes you are not seeing here.\n     */\n\n    /*\n     * We have configured the attributes we needed. Now, install and get the pointers\n     * to the NetDevices, which contains all the NR stack:\n     */\n\n    uint8_t subArraysGnb = 0;\n    uint8_t subArraysUe = 0;\n\n    if (crossPolarizedGnb)\n    {\n        subArraysGnb = 2;\n    }\n    else\n    {\n        subArraysGnb = 1;\n    }\n\n    if (crossPolarizedUe)\n    {\n        subArraysUe = 2;\n    }\n    else\n    {\n        subArraysUe = 1;\n    }\n\n    NetDeviceContainer enbNetDev = nrHelper->InstallGnbDevice(gnbContainer, allBwps, subArraysGnb);\n    NetDeviceContainer ueNetDev = nrHelper->InstallUeDevice(ueContainer, allBwps, subArraysUe);\n\n    /*\n     * Fix the random stream throughout the nr, propagation, and spectrum\n     * modules classes. This configuration is extremely important for the\n     * reproducibility of the results.\n     */\n    randomStream += nrHelper->AssignStreams(enbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);\n\n    /*\n     * Per Node attribute configuration. Get the node and change the attributes we\n     * have to setup.\n     */\n\n    // Get the first netdevice (enbNetDev.Get (0)) and the first bandwidth part (0)\n    // and set the attribute.\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)->SetAttribute(\"Numerology\", UintegerValue(numerology));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)->SetAttribute(\"TxPower\", DoubleValue(gnbTxPower));\n    double polarizationFirstSubArray = (polSlantAngle1 * M_PI) / 180.0;  // converting to radians\n    double polarizationSecondSubArray = (polSlantAngle2 * M_PI) / 180.0; // converting to radians\n    ObjectVectorValue gnbSpectrumPhys;\n    Ptr<NrSpectrumPhy> nrSpectrumPhy;\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)->GetAttribute(\"NrSpectrumPhyList\", gnbSpectrumPhys);\n    nrSpectrumPhy = gnbSpectrumPhys.Get(0)->GetObject<NrSpectrumPhy>();\n    nrSpectrumPhy->GetAntenna()->GetObject<UniformPlanarArray>()->SetAttribute(\n        \"PolSlantAngle\",\n        DoubleValue(polarizationFirstSubArray));\n    if (gnbSpectrumPhys.GetN() == 2)\n    {\n        nrSpectrumPhy = gnbSpectrumPhys.Get(1)->GetObject<NrSpectrumPhy>();\n        nrSpectrumPhy->GetAntenna()->GetObject<UniformPlanarArray>()->SetAttribute(\n            \"PolSlantAngle\",\n            DoubleValue(polarizationSecondSubArray));\n    }\n\n    // for UE\n    nrHelper->GetUePhy(ueNetDev.Get(0), 0)->SetAttribute(\"TxPower\", DoubleValue(ueTxPower));\n    ObjectVectorValue ueSpectrumPhys;\n    nrHelper->GetUePhy(ueNetDev.Get(0), 0)->GetAttribute(\"NrSpectrumPhyList\", ueSpectrumPhys);\n    nrSpectrumPhy = ueSpectrumPhys.Get(0)->GetObject<NrSpectrumPhy>();\n    nrSpectrumPhy->GetAntenna()->GetObject<UniformPlanarArray>()->SetAttribute(\n        \"PolSlantAngle\",\n        DoubleValue(polarizationFirstSubArray));\n    if (ueSpectrumPhys.GetN() == 2)\n    {\n        nrSpectrumPhy = ueSpectrumPhys.Get(1)->GetObject<NrSpectrumPhy>();\n        nrSpectrumPhy->GetAntenna()->GetObject<UniformPlanarArray>()->SetAttribute(\n            \"PolSlantAngle\",\n            DoubleValue(polarizationSecondSubArray));\n    }\n\n    // When all the configuration is done, explicitly call UpdateConfig ()\n\n    for (auto it = enbNetDev.Begin(); it != enbNetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    // From here, it is standard NS3. In the future, we will create helpers\n    // for this part as well.\n\n    // create the Internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.000)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(ueContainer);\n\n    Ipv4InterfaceContainer ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));\n    // Set the default gateway for the UE\n    Ptr<Ipv4StaticRouting> ueStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(ueContainer.Get(0)->GetObject<Ipv4>());\n    ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n\n    // attach UE to the closest eNB\n    nrHelper->AttachToClosestEnb(ueNetDev, enbNetDev);\n\n    /*\n     * Install DL traffic part.\n     */\n\n    uint16_t dlPort = 1234;\n\n    ApplicationContainer serverApps;\n\n    // The sink will always listen to the specified ports\n    UdpServerHelper dlPacketSink(dlPort);\n\n    // The server, that is the application which is listening, is installed in the UE\n    serverApps.Add(dlPacketSink.Install(ueContainer));\n\n    /*\n     * Configure attributes for the CBR traffic generator, using user-provided\n     * parameters\n     */\n    UdpClientHelper dlClient;\n    dlClient.SetAttribute(\"RemotePort\", UintegerValue(dlPort));\n    dlClient.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    dlClient.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSize));\n    dlClient.SetAttribute(\"Interval\", TimeValue(packetInterval));\n\n    // The bearer that will carry the traffic\n    EpsBearer epsBearer(EpsBearer::NGBR_LOW_LAT_EMBB);\n\n    // The filter for the traffic\n    Ptr<EpcTft> dlTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlPktFilter;\n    dlPktFilter.localPortStart = dlPort;\n    dlPktFilter.localPortEnd = dlPort;\n    dlTft->Add(dlPktFilter);\n\n    /*\n     * Let's install the applications!\n     */\n    ApplicationContainer clientApps;\n\n    for (uint32_t i = 0; i < ueContainer.GetN(); ++i)\n    {\n        Ptr<Node> ue = ueContainer.Get(i);\n        Ptr<NetDevice> ueDevice = ueNetDev.Get(i);\n        Address ueAddress = ueIpIface.GetAddress(i);\n\n        // The client, who is transmitting, is installed in the remote host,\n        // with destination address set to the address of the UE\n        dlClient.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n        clientApps.Add(dlClient.Install(remoteHost));\n\n        // Activate a dedicated bearer for the traffic\n        nrHelper->ActivateDedicatedEpsBearer(ueDevice, epsBearer, dlTft);\n    }\n\n    // start UDP server and client apps\n    serverApps.Start(udpAppStartTime);\n    clientApps.Start(udpAppStartTime);\n    serverApps.Stop(simTime);\n    clientApps.Stop(simTime);\n\n    // enable the traces provided by the nr module\n    nrHelper->EnableTraces();\n\n    FlowMonitorHelper flowmonHelper;\n    NodeContainer endpointNodes;\n    endpointNodes.Add(remoteHost);\n    endpointNodes.Add(ueContainer);\n\n    Ptr<ns3::FlowMonitor> monitor = flowmonHelper.Install(endpointNodes);\n    monitor->SetAttribute(\"DelayBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"JitterBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"PacketSizeBinWidth\", DoubleValue(20));\n\n    Simulator::Stop(simTime);\n    Simulator::Run();\n\n    /*\n     * To check what was installed in the memory, i.e., BWPs of eNb Device, and its configuration.\n     * Example is: Node 1 -> Device 0 -> BandwidthPartMap -> {0,1} BWPs -> NrGnbPhy -> Numerology,\n    GtkConfigStore config;\n    config.ConfigureAttributes ();\n    */\n\n    // Print per-flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier =\n        DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n\n    double averageFlowThroughput = 0.0;\n    double averageFlowDelay = 0.0;\n\n    std::ofstream outFile;\n    std::string filename = outputDir + \"/\" + simTag;\n    outFile.open(filename.c_str(), std::ofstream::out | std::ofstream::trunc);\n    if (!outFile.is_open())\n    {\n        std::cerr << \"Can't open file \" << filename << std::endl;\n        return 1;\n    }\n\n    outFile.setf(std::ios_base::fixed);\n\n    double flowDuration = (simTime - udpAppStartTime).GetSeconds();\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin();\n         i != stats.end();\n         ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        std::stringstream protoStream;\n        protoStream << (uint16_t)t.protocol;\n        if (t.protocol == 6)\n        {\n            protoStream.str(\"TCP\");\n        }\n        if (t.protocol == 17)\n        {\n            protoStream.str(\"UDP\");\n        }\n        outFile << \"Flow \" << i->first << \" (\" << t.sourceAddress << \":\" << t.sourcePort << \" -> \"\n                << t.destinationAddress << \":\" << t.destinationPort << \") proto \"\n                << protoStream.str() << \"\\n\";\n        outFile << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n        outFile << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n        outFile << \"  TxOffered:  \" << i->second.txBytes * 8.0 / flowDuration / 1000.0 / 1000.0\n                << \" Mbps\\n\";\n        outFile << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n        if (i->second.rxPackets > 0)\n        {\n            // Measure the duration of the flow from receiver's perspective\n            averageFlowThroughput += i->second.rxBytes * 8.0 / flowDuration / 1000 / 1000;\n            averageFlowDelay += 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;\n\n            outFile << \"  Throughput: \" << i->second.rxBytes * 8.0 / flowDuration / 1000 / 1000\n                    << \" Mbps\\n\";\n            outFile << \"  Mean delay:  \"\n                    << 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n            // outFile << \"  Mean upt:  \" << i->second.uptSum / i->second.rxPackets / 1000/1000 << \"\n            // Mbps \\n\";\n            outFile << \"  Mean jitter:  \"\n                    << 1000 * i->second.jitterSum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n        }\n        else\n        {\n            outFile << \"  Throughput:  0 Mbps\\n\";\n            outFile << \"  Mean delay:  0 ms\\n\";\n            outFile << \"  Mean jitter: 0 ms\\n\";\n        }\n        outFile << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n    }\n\n    outFile << \"\\n\\n  Mean flow throughput: \" << averageFlowThroughput / stats.size() << \"\\n\";\n    outFile << \"  Mean flow delay: \" << averageFlowDelay / stats.size() << \"\\n\";\n\n    outFile.close();\n\n    std::ifstream f(filename.c_str());\n\n    if (f.is_open())\n    {\n        std::cout << f.rdbuf();\n    }\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/cttc-nr-multi-flow-qos-sched.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2022 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n/**\n * \\ingroup examples\n * \\file cttc-nr-multi-flow-qos-sched.cc\n * \\brief This example allows testing the performance of the QoS scheduler\n *        (nr-mac-scheduler-ofdma/tdma-qos) in conjunction with the LC QoS\n *        scheduler versus other schedulers, such as the RR and PF in\n *        conjunction with the LC RR scheduler.\n *        The example has been designed to test the E2E delay and throughput\n *        in a single-cell scenario with 2 UEs, where 1 UE has a NON-GBR flow\n *        and the other UE has 2 flows. One NON-GBR flow, and 1 DC-GBR with\n *        its gbr requirements set (erabGuaranteedBitRate).\n *\n * \\code{.unparsed}\n$ ./ns3 run \"cttc-nr-multi-flow-qos-sched --PrintHelp\"\n    \\endcode\n *\n */\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/buildings-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CttcNrSimpleQosSched\");\n\nint\nmain(int argc, char* argv[])\n{\n    /*\n     * Variables that represent the parameters we will accept as input by the\n     * command line. Each of them is initialized with a default value, and\n     * possibly overridden below when command-line arguments are parsed.\n     */\n    // Scenario parameters (that we will use inside this script):\n    uint16_t gNbNum = 1;\n    uint16_t ueNumPergNb = 2;\n    bool logging = false;\n\n    // Simulation parameters. Please don't use double to indicate seconds; use\n    // ns-3 Time values which use integers to avoid portability issues.\n    Time simTime = MilliSeconds(1000);\n    Time udpAppStartTime = MilliSeconds(400);\n\n    // NR parameters. We will take the input from the command line, and then we\n    // will pass them inside the NR module.\n    uint16_t numerology = 0;\n    double centralFrequency = 4e9;\n    double bandwidth = 10e6;\n    double totalTxPower = 43;\n\n    bool enableOfdma = false;\n    std::string schedulerType = \"PF\";\n    bool enableQoSLcScheduler = false;\n\n    uint8_t priorityTrafficScenario = 0; // default is saturation\n\n    uint16_t mcsTable = 2;\n\n    bool enablePdcpDiscarding = false;\n    uint32_t discardTimerMs = 0;\n\n    bool enableNrHelperTraces = false;\n    bool enableQosTrafficTraces = true;\n    // Where we will store the output files.\n    std::string simTag = \"default\";\n    std::string outputDir = \"./\";\n\n    /*\n     * From here, we instruct the ns3::CommandLine class of all the input parameters\n     * that we may accept as input, as well as their description, and the storage\n     * variable.\n     */\n    CommandLine cmd;\n\n    cmd.AddValue(\"gNbNum\", \"The number of gNbs in multiple-ue topology\", gNbNum);\n    cmd.AddValue(\"ueNumPergNb\", \"The number of UE per gNb in multiple-ue topology\", ueNumPergNb);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.AddValue(\"priorityTrafficScenario\",\n                 \"The traffic scenario for the case of priority. Can be 0: saturation\"\n                 \"or 1: medium-load\",\n                 priorityTrafficScenario);\n    cmd.AddValue(\"simTime\", \"Simulation time\", simTime);\n    cmd.AddValue(\"numerology\", \"The numerology to be used\", numerology);\n    cmd.AddValue(\"centralFrequency\", \"The system frequency to be used\", centralFrequency);\n    cmd.AddValue(\"bandwidth\", \"The system bandwidth to be used\", bandwidth);\n    cmd.AddValue(\"totalTxPower\",\n                 \"total tx power that will be proportionally assigned to\"\n                 \" bands, CCs and bandwidth parts depending on each BWP bandwidth \",\n                 totalTxPower);\n    cmd.AddValue(\"simTag\",\n                 \"tag to be appended to output filenames to distinguish simulation campaigns\",\n                 simTag);\n    cmd.AddValue(\"outputDir\", \"directory where to store simulation results\", outputDir);\n    cmd.AddValue(\"enableOfdma\",\n                 \"If set to true it enables Ofdma scheduler. Default value is false (Tdma)\",\n                 enableOfdma),\n        cmd.AddValue(\"schedulerType\",\n                     \"PF: Proportional Fair (default), RR: Round-Robin, Qos\",\n                     schedulerType),\n        cmd.AddValue(\"enableQoSLcScheduler\",\n                     \"If set to true, it enables the QoS LC scheduler. Default is RR (false)\",\n                     enableQoSLcScheduler),\n        cmd.AddValue(\"enableNrHelperTraces\",\n                     \"If true, it enables the generation of the NrHelper traces, otherwise\"\n                     \"NrHelper traces will not be generated. Default value is false\",\n                     enableNrHelperTraces),\n        cmd.AddValue(\"enableQosTrafficTraces\",\n                     \"If true, it enables the generation of the the Delay and Throughput\"\n                     \"traces, otherwise these traces will not be generated. Default value is true\",\n                     enableQosTrafficTraces),\n        cmd.AddValue(\"enablePdcpDiscarding\",\n                     \"Whether to enable PDCP TX discarding\",\n                     enablePdcpDiscarding),\n        cmd.AddValue(\"discardTimerMs\",\n                     \"Discard timer value in milliseconds to use for all the flows\",\n                     discardTimerMs);\n\n    cmd.Parse(argc, argv);\n\n    // enable logging or not\n    if (logging)\n    {\n        LogLevel logLevel1 =\n            (LogLevel)(LOG_PREFIX_FUNC | LOG_PREFIX_TIME | LOG_PREFIX_NODE | LOG_LEVEL_INFO);\n        LogComponentEnable(\"NrMacSchedulerNs3\", logLevel1);\n        LogComponentEnable(\"NrMacSchedulerTdma\", logLevel1);\n    }\n\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n    Config::SetDefault(\"ns3::LteRlcUm::EnablePdcpDiscarding\", BooleanValue(enablePdcpDiscarding));\n    Config::SetDefault(\"ns3::LteRlcUm::DiscardTimerMs\", UintegerValue(discardTimerMs));\n\n    /*\n     * Create the scenario. In our examples, we heavily use helpers that setup\n     * the gnbs and ue following a pre-defined pattern. Please have a look at the\n     * GridScenarioHelper documentation to see how the nodes will be distributed.\n     */\n    int64_t randomStream = 1;\n\n    GridScenarioHelper gridScenario;\n    gridScenario.SetRows(1);\n    gridScenario.SetColumns(gNbNum);\n    gridScenario.SetHorizontalBsDistance(5.0);\n    gridScenario.SetVerticalBsDistance(5.0);\n    gridScenario.SetBsHeight(1.5);\n    gridScenario.SetUtHeight(1.5);\n    // must be set before BS number\n    gridScenario.SetSectorization(GridScenarioHelper::SINGLE);\n    gridScenario.SetBsNumber(gNbNum);\n    gridScenario.SetUtNumber(ueNumPergNb * gNbNum);\n    gridScenario.SetScenarioHeight(3); // Create a 3x3 scenario where the UE will\n    gridScenario.SetScenarioLength(3); // be distribuited.\n    randomStream += gridScenario.AssignStreams(randomStream);\n    gridScenario.CreateScenario();\n\n    uint32_t udpPacketSize1;\n    uint32_t udpPacketSize2;\n    uint32_t lambda1 = 1000;\n    uint32_t lambda2 = 1000;\n\n    if (priorityTrafficScenario == 0) // saturation\n    {\n        udpPacketSize1 = 3000;\n        udpPacketSize2 = 3000;\n    }\n    else if (priorityTrafficScenario == 1) // medium-load\n    {\n        udpPacketSize1 = 3000;\n        udpPacketSize2 = 1252;\n    }\n    else\n    {\n        NS_ABORT_MSG(\"The priorityTrafficScenario chosen is not correct. \"\n                     \"Please choose among 0: saturation and 1: medium-load\");\n    }\n\n    /*\n     * Create two different NodeContainer for the different traffic type.\n     * In ueLowLat we will put the UEs that will receive low-latency traffic,\n     * while in ueVoice we will put the UEs that will receive the voice traffic.\n     */\n    NodeContainer ue1flowContainer;\n    NodeContainer ue2flowsContainer;\n\n    for (uint32_t j = 0; j < gridScenario.GetUserTerminals().GetN(); ++j)\n    {\n        Ptr<Node> ue = gridScenario.GetUserTerminals().Get(j);\n\n        j % 2 == 0 ? ue1flowContainer.Add(ue) : ue2flowsContainer.Add(ue);\n    }\n\n    if (priorityTrafficScenario == 1)\n    {\n        lambda1 = 1000 / ue1flowContainer.GetN();\n        lambda2 = 1000 / ue2flowsContainer.GetN();\n    }\n\n    // setup the nr simulation\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n\n    // Put the pointers inside nrHelper\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n    epcHelper->SetAttribute(\"S1uLinkDelay\", TimeValue(MilliSeconds(0)));\n    Config::SetDefault(\"ns3::ThreeGppChannelModel::UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetChannelConditionModelAttribute(\"UpdatePeriod\", TimeValue(MilliSeconds(0)));\n\n    std::stringstream scheduler;\n    std::string subType;\n\n    subType = enableOfdma == false ? \"Tdma\" : \"Ofdma\";\n    scheduler << \"ns3::NrMacScheduler\" << subType << schedulerType;\n    std::cout << \"Scheduler: \" << scheduler.str() << std::endl;\n    nrHelper->SetSchedulerTypeId(TypeId::LookupByName(scheduler.str()));\n\n    if (enableQoSLcScheduler)\n    {\n        nrHelper->SetSchedulerAttribute(\"SchedLcAlgorithmType\",\n                                        TypeIdValue(NrMacSchedulerLcQos::GetTypeId()));\n    }\n\n    // Error Model: gNB and UE with same spectrum error model.\n    std::string errorModel = \"ns3::NrEesmIrT\" + std::to_string(mcsTable);\n    nrHelper->SetDlErrorModel(errorModel);\n    nrHelper->SetUlErrorModel(errorModel);\n\n    // Both DL and UL AMC will have the same model behind.\n    nrHelper->SetGnbDlAmcAttribute(\"AmcModel\", EnumValue(NrAmc::ErrorModel));\n    nrHelper->SetGnbUlAmcAttribute(\"AmcModel\", EnumValue(NrAmc::ErrorModel));\n\n    // Beamforming method\n    idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));\n\n    // Antennas for all the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(1));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(1));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Antennas for all the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(1));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(1));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    /*\n     * Setup the configuration of the spectrum. One operation band is deployed\n     * with 1 component carrier (CC), automatically generated by the ccBwpManager\n     */\n    BandwidthPartInfoPtrVector allBwps;\n    CcBwpCreator ccBwpCreator;\n    OperationBandInfo band;\n    const uint8_t numOfCcs = 1;\n\n    auto bandMask = NrHelper::INIT_PROPAGATION | NrHelper::INIT_CHANNEL;\n\n    /*\n     * The configured spectrum division for TDD is:\n     *\n     * |----Band1----|\n     * |-----CC1-----|\n     * |-----BWP1----|\n     */\n\n    // Create the configuration for the CcBwpHelper. SimpleOperationBandConf creates\n    // a single BWP per CC\n    CcBwpCreator::SimpleOperationBandConf bandConf(centralFrequency,\n                                                   bandwidth,\n                                                   numOfCcs,\n                                                   BandwidthPartInfo::UMi_StreetCanyon_LoS);\n\n    bandConf.m_numBwp = 1;\n    // By using the configuration created, it is time to make the operation band\n    band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);\n\n    nrHelper->InitializeOperationBand(&band, bandMask);\n    // nrHelper->InitializeOperationBand(&band);\n    allBwps = CcBwpCreator::GetAllBwps({band});\n\n    double x = pow(10, totalTxPower / 10);\n\n    Packet::EnableChecking();\n    Packet::EnablePrinting();\n\n    uint32_t bwpIdUe1 = 0;\n    uint32_t bwpIdUe2Flow1 = 0;\n    uint32_t bwpIdUe2Flow2 = 0;\n\n    // gNb routing between Bearer and bandwidh part\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\", UintegerValue(bwpIdUe1));\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\", UintegerValue(bwpIdUe2Flow1));\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"DGBR_INTER_SERV_87\",\n                                                 UintegerValue(bwpIdUe2Flow2));\n\n    // Ue routing between Bearer and bandwidth part\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\", UintegerValue(bwpIdUe1));\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\", UintegerValue(bwpIdUe2Flow1));\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"DGBR_INTER_SERV_87\", UintegerValue(bwpIdUe2Flow2));\n\n    /*\n     * We have configured the attributes we needed. Now, install and get the pointers\n     * to the NetDevices, which contains all the NR stack:\n     */\n    NetDeviceContainer enbNetDev =\n        nrHelper->InstallGnbDevice(gridScenario.GetBaseStations(), allBwps);\n    NetDeviceContainer ue1flowNetDev = nrHelper->InstallUeDevice(ue1flowContainer, allBwps);\n    NetDeviceContainer ue2flowsNetDev = nrHelper->InstallUeDevice(ue2flowsContainer, allBwps);\n\n    randomStream += nrHelper->AssignStreams(enbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ue1flowNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ue2flowsNetDev, randomStream);\n\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)->SetAttribute(\"Numerology\", UintegerValue(numerology));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)->SetAttribute(\"TxPower\", DoubleValue(10 * log10(x)));\n\n    // When all the configuration is done, explicitly call UpdateConfig ()\n    for (auto it = enbNetDev.Begin(); it != enbNetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ue1flowNetDev.Begin(); it != ue1flowNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n    for (auto it = ue2flowsNetDev.Begin(); it != ue2flowsNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.000)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(gridScenario.GetUserTerminals());\n\n    Ipv4InterfaceContainer ue1FlowIpIface;\n    Ipv4InterfaceContainer ue2FlowsIpIface;\n    ue1FlowIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ue1flowNetDev));\n    ue2FlowsIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ue2flowsNetDev));\n\n    // Set the default gateway for the UEs\n    for (uint32_t j = 0; j < gridScenario.GetUserTerminals().GetN(); ++j)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting = ipv4RoutingHelper.GetStaticRouting(\n            gridScenario.GetUserTerminals().Get(j)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // attach UEs to the closest gNB\n    nrHelper->AttachToClosestEnb(ue1flowNetDev, enbNetDev);\n    nrHelper->AttachToClosestEnb(ue2flowsNetDev, enbNetDev);\n\n    /*\n     * Traffic part. Install two kind of traffic: low-latency and voice, each\n     * identified by a particular source port.\n     */\n    uint16_t dlPortUe1flow = 1234;\n    uint16_t dlPortUe2flowsNgbr = 1235;\n    uint16_t dlPortUe2flowsDcGbr = 1236;\n\n    ApplicationContainer serverApps;\n\n    // The sink will always listen to the specified ports\n    UdpServerHelper dlPacketSinkUe1flow(dlPortUe1flow);\n    UdpServerHelper dlPacketSinkUe2flowsNgbr(dlPortUe2flowsNgbr);\n    UdpServerHelper dlPacketSinkUe2flowsDcGgbr(dlPortUe2flowsDcGbr);\n\n    // The server, that is the application which is listening, is installed in the UE\n    serverApps.Add(dlPacketSinkUe1flow.Install(ue1flowContainer));\n    serverApps.Add(dlPacketSinkUe2flowsNgbr.Install(ue2flowsContainer));\n    serverApps.Add(dlPacketSinkUe2flowsDcGgbr.Install(ue2flowsContainer));\n\n    /*\n     * Configure attributes for the different generators, using user-provided\n     * parameters for generating a CBR traffic\n     *\n     * UE with 1 flow configuration and object creation:\n     */\n    /******************************************************************************/\n    UdpClientHelper dlClientUe1flow;\n    dlClientUe1flow.SetAttribute(\"RemotePort\", UintegerValue(dlPortUe1flow));\n    dlClientUe1flow.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    dlClientUe1flow.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSize1));\n    dlClientUe1flow.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambda1)));\n\n    // The bearer that will carry UE with 1 flow Non GBR traffic\n    EpsBearer ue1flowBearer(EpsBearer::NGBR_LOW_LAT_EMBB);\n\n    // The filter for the UE with 1 flow Non GBR traffic\n    Ptr<EpcTft> ue1flowTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfUe1flow;\n    dlpfUe1flow.localPortStart = dlPortUe1flow;\n    dlpfUe1flow.localPortEnd = dlPortUe1flow;\n    ue1flowTft->Add(dlpfUe1flow);\n    /******************************************************************************/\n\n    /******************************************************************************/\n    // UE with 2 Flows Non GBR configuration and object creation:\n    UdpClientHelper dlClientUe2flowsNgbr;\n    dlClientUe2flowsNgbr.SetAttribute(\"RemotePort\", UintegerValue(dlPortUe2flowsNgbr));\n    dlClientUe2flowsNgbr.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    dlClientUe2flowsNgbr.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSize1));\n    dlClientUe2flowsNgbr.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambda1)));\n\n    // GbrQosInformation qosInfoInterServ2;\n    // qosInfoInterServ2.gbrDl = 6e6; // Downlink GBR\n\n    // The bearer that will carry UE with 2 Flows Non GBR traffic\n    EpsBearer ue2flowsNgbrBearer(EpsBearer::NGBR_LOW_LAT_EMBB); // qosInfoInterServ2);\n\n    // The filter for the UE with 2 Flows Non GBR traffic\n    Ptr<EpcTft> ue2flowsNgbrTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfUe2flowsNgbr;\n    dlpfUe2flowsNgbr.localPortStart = dlPortUe2flowsNgbr;\n    dlpfUe2flowsNgbr.localPortEnd = dlPortUe2flowsNgbr;\n    ue2flowsNgbrTft->Add(dlpfUe2flowsNgbr);\n    /******************************************************************************/\n\n    /******************************************************************************/\n    UdpClientHelper dlClientUe2flowsDcGbr;\n    dlClientUe2flowsDcGbr.SetAttribute(\"RemotePort\", UintegerValue(dlPortUe2flowsDcGbr));\n    dlClientUe2flowsDcGbr.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    dlClientUe2flowsDcGbr.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSize2));\n    dlClientUe2flowsDcGbr.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambda2)));\n\n    GbrQosInformation qosUe2flowsDcGbr;\n    qosUe2flowsDcGbr.gbrDl = 5e6; // Downlink GBR\n\n    // The bearer that will carry Ue 2 Flows DC GBR traffic\n    EpsBearer ue2flowsDcGbrBearer(EpsBearer::DGBR_INTER_SERV_87, qosUe2flowsDcGbr);\n\n    // The filter for the 2 Flows DC GBR traffic\n    Ptr<EpcTft> ue2FlowsDcGbrTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfUe2flowsDcGbr;\n    dlpfUe2flowsDcGbr.localPortStart = dlPortUe2flowsDcGbr;\n    dlpfUe2flowsDcGbr.localPortEnd = dlPortUe2flowsDcGbr;\n    ue2FlowsDcGbrTft->Add(dlpfUe2flowsDcGbr);\n    /******************************************************************************/\n\n    //  Install the applications\n    ApplicationContainer clientApps;\n\n    for (uint32_t i = 0; i < ue1flowContainer.GetN(); ++i)\n    {\n        Ptr<NetDevice> ueDevice = ue1flowNetDev.Get(i);\n        Address ueAddress = ue1FlowIpIface.GetAddress(i);\n\n        // The client, who is transmitting, is installed in the remote host,\n        // with destination address set to the address of the UE\n        dlClientUe1flow.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n        clientApps.Add(dlClientUe1flow.Install(remoteHost));\n\n        // Activate a dedicated bearer for the traffic type\n        nrHelper->ActivateDedicatedEpsBearer(ueDevice, ue1flowBearer, ue1flowTft);\n    }\n\n    for (uint32_t i = 0; i < ue2flowsContainer.GetN(); ++i)\n    {\n        Ptr<NetDevice> ueDevice = ue2flowsNetDev.Get(i);\n        Address ueAddress = ue2FlowsIpIface.GetAddress(i);\n\n        // The client, who is transmitting, is installed in the remote host,\n        // with destination address set to the address of the UE\n        dlClientUe2flowsNgbr.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n        clientApps.Add(dlClientUe2flowsNgbr.Install(remoteHost));\n\n        // Activate a dedicated bearer for the traffic type\n        nrHelper->ActivateDedicatedEpsBearer(ueDevice, ue2flowsNgbrBearer, ue2flowsNgbrTft);\n    }\n\n    for (uint32_t i = 0; i < ue2flowsContainer.GetN(); ++i)\n    {\n        Ptr<NetDevice> ueDevice = ue2flowsNetDev.Get(i);\n        Address ueAddress = ue2FlowsIpIface.GetAddress(i);\n\n        // The client, who is transmitting, is installed in the remote host,\n        // with destination address set to the address of the UE\n        dlClientUe2flowsDcGbr.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n        clientApps.Add(dlClientUe2flowsDcGbr.Install(remoteHost));\n\n        // Activate a dedicated bearer for the traffic type\n        nrHelper->ActivateDedicatedEpsBearer(ueDevice, ue2flowsDcGbrBearer, ue2FlowsDcGbrTft);\n    }\n\n    // start UDP server and client apps\n    serverApps.Start(udpAppStartTime);\n    clientApps.Start(udpAppStartTime);\n    serverApps.Stop(simTime);\n    clientApps.Stop(simTime);\n\n    // enable the traces provided by the nr module\n    if (enableNrHelperTraces)\n    {\n        nrHelper->EnableTraces();\n    }\n\n    FlowMonitorHelper flowmonHelper;\n    NodeContainer endpointNodes;\n    endpointNodes.Add(remoteHost);\n    endpointNodes.Add(gridScenario.GetUserTerminals());\n\n    Ptr<ns3::FlowMonitor> monitor = flowmonHelper.Install(endpointNodes);\n    monitor->SetAttribute(\"DelayBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"JitterBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"PacketSizeBinWidth\", DoubleValue(20));\n\n    Simulator::Stop(simTime);\n    Simulator::Run();\n\n    double averageFlowThroughput = 0.0;\n    double averageFlowDelay = 0.0;\n\n    std::ofstream delayFile;\n    std::ofstream throughputFile;\n\n    std::ostringstream delayFileName;\n    std::ostringstream throughputFileName;\n\n    std::string lcSced;\n    lcSced = enableQoSLcScheduler == true ? \"LcQos\" : \"LcRR\";\n\n    if (simTag == \"\")\n    {\n        delayFileName << \"Delay\"\n                      << \"_\" << schedulerType.c_str() << \"_\" << lcSced.c_str() << \".txt\";\n\n        throughputFileName << \"Throughput\"\n                           << \"_\" << schedulerType.c_str() << \"_\" << lcSced.c_str() << \".txt\";\n    }\n    else\n    {\n        delayFileName << outputDir << \"Delay\" << simTag << std::string(\".txt\").c_str();\n        throughputFileName << outputDir << \"Throughput\" << simTag << std::string(\".txt\").c_str();\n    }\n\n    if (enableQosTrafficTraces)\n    {\n        delayFile.open(delayFileName.str());\n        delayFile.setf(std::ios_base::fixed);\n\n        if (!delayFile.is_open())\n        {\n            NS_ABORT_MSG(\"Can't open file \" << delayFileName.str());\n        }\n        delayFile << \"source_address\"\n                  << \"\\t\"\n                  << \"source_port\"\n                  << \"\\t\"\n                  << \"dest_address\"\n                  << \"\\t\"\n                  << \"dest_port\"\n                  << \"\\t\"\n                  << \"delay\"\n                  << \"\\n\";\n\n        throughputFile.open(throughputFileName.str());\n        throughputFile.setf(std::ios_base::fixed);\n\n        if (!throughputFile.is_open())\n        {\n            NS_ABORT_MSG(\"Can't open file \" << throughputFileName.str());\n        }\n\n        throughputFile << \"source_port\"\n                       << \"\\t\"\n                       << \"dest_port\"\n                       << \"\\t\"\n                       << \"Throughput\"\n                       << \"\\t\"\n                       << \"Delay\"\n                       << \"\\n\";\n    }\n\n    /*\n     * To check what was installed in the memory, i.e., BWPs of eNb Device, and its configuration.\n     * Example is: Node 1 -> Device 0 -> BandwidthPartMap -> {0,1} BWPs -> NrGnbPhy -> Numerology,\n    GtkConfigStore config;\n    config.ConfigureAttributes ();\n    */\n\n    // Print per-flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier =\n        DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n\n    std::ofstream outFile;\n    std::string filename = outputDir + \"/\" + simTag;\n    outFile.open(filename.c_str(), std::ofstream::out | std::ofstream::trunc);\n    if (!outFile.is_open())\n    {\n        std::cerr << \"Can't open file \" << filename << std::endl;\n        return 1;\n    }\n\n    outFile.setf(std::ios_base::fixed);\n\n    double flowDuration = (simTime - udpAppStartTime).GetSeconds();\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin();\n         i != stats.end();\n         ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n\n        if (enableQosTrafficTraces)\n        {\n            for (uint32_t j = 0; j < i->second.delayHistogram.GetNBins(); j++)\n            {\n                Histogram h = i->second.delayHistogram;\n                if (h.GetBinCount(j))\n                {\n                    for (uint32_t k = 0; k < h.GetBinCount(j); k++)\n                    {\n                        delayFile << t.sourceAddress << \"\\t\" << t.sourcePort << \"\\t\"\n                                  << t.destinationAddress << \"\\t\" << t.destinationPort << \"\\t\"\n                                  << h.GetBinStart(j) << \"\\n\";\n                    }\n                }\n            }\n        }\n\n        std::stringstream protoStream;\n        protoStream << (uint16_t)t.protocol;\n        if (t.protocol == 6)\n        {\n            protoStream.str(\"TCP\");\n        }\n        if (t.protocol == 17)\n        {\n            protoStream.str(\"UDP\");\n        }\n        outFile << \"Flow \" << i->first << \" (\" << t.sourceAddress << \":\" << t.sourcePort << \" -> \"\n                << t.destinationAddress << \":\" << t.destinationPort << \") proto \"\n                << protoStream.str() << \"\\n\";\n        outFile << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n        outFile << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n        outFile << \"  TxOffered:  \" << i->second.txBytes * 8.0 / flowDuration / 1000.0 / 1000.0\n                << \" Mbps\\n\";\n        outFile << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n        if (i->second.rxPackets > 0)\n        {\n            // Measure the duration of the flow from receiver's perspective\n            averageFlowThroughput += i->second.rxBytes * 8.0 / flowDuration / 1000 / 1000;\n            averageFlowDelay += 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;\n\n            double throughput = i->second.rxBytes * 8.0 / flowDuration / 1000 / 1000;\n            double delay = 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;\n\n            outFile << \"  Throughput: \" << i->second.rxBytes * 8.0 / flowDuration / 1000 / 1000\n                    << \" Mbps\\n\";\n            outFile << \"  Mean delay:  \"\n                    << 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n            // outFile << \"  Mean upt:  \" << i->second.uptSum / i->second.rxPackets / 1000/1000 << \"\n            // Mbps \\n\";\n            outFile << \"  Mean jitter:  \"\n                    << 1000 * i->second.jitterSum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n\n            if (enableQosTrafficTraces)\n            {\n                throughputFile << t.sourcePort << \"\\t\" << t.destinationPort << \"\\t\" << throughput\n                               << \"\\t\" << delay << std::endl;\n            }\n        }\n        else\n        {\n            outFile << \"  Throughput:  0 Mbps\\n\";\n            outFile << \"  Mean delay:  0 ms\\n\";\n            outFile << \"  Mean jitter: 0 ms\\n\";\n\n            if (enableQosTrafficTraces)\n            {\n                throughputFile << t.sourcePort << \"\\t\" << t.destinationPort << \"\\t\" << 0 << \"\\t\"\n                               << 0 << std::endl;\n            }\n        }\n        outFile << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n    }\n\n    outFile << \"\\n\\n  Mean flow throughput: \" << averageFlowThroughput / stats.size() << \"\\n\";\n    outFile << \"  Mean flow delay: \" << averageFlowDelay / stats.size() << \"\\n\";\n\n    outFile.close();\n\n    std::ifstream f(filename.c_str());\n\n    if (f.is_open())\n    {\n        std::cout << f.rdbuf();\n    }\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/cttc-nr-notching.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2019 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/config-store.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/ideal-beamforming-algorithm.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-helper.h\"\n#include \"ns3/nr-mac-scheduler-ofdma-rr.h\"\n#include \"ns3/nr-mac-scheduler-tdma-rr.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/nr-point-to-point-epc-helper.h\"\n#include \"ns3/point-to-point-helper.h\"\n#include \"ns3/point-to-point-module.h\"\n\n/**\n * \\file cttc-nr-notching.cc\n * \\ingroup examples\n *\n * \\brief Creates a configurable NR TDD/FDD deployment with up to 2 gNBs, for\n * testing a notching mask.\n *\n * This example is used to study notching. By default the notching mask (mask with\n * 0s and 1s, where 0s denote the RBs to be notched) is configured to all ones,\n * meaning that no notched RBs are defined.\n *\n * The user can select through the command line the number of RBs to be notched,\n * as well as the starting RB.\n * If for example we want to mute RBs from 12 to 17, then the starting RB has to\n * be set to 12 and the number of notched RBs to 6.\n * All gNBs then, will be assigned the same notched mask.\n * The user can see the impact of the mask in the user throughput. As the notched\n * resources increase, it can be seen how the throughput is decreased and vice versa.\n *\n * TDD or FDD mode can be selected through the command line, as well as TDMA/OFDMA\n * and DL or/and UL traffic.\n * In case of TDD only 1 BWP is created, while for the FDD case a pair of DL/UL\n * BWPs are created.\n *\n * Please notice that the size of the mask depends on the bandwidth (BW). In this\n * example we support only BWs of 5, 10 and 20 MHz. If a user wants to test different\n * BWs or different mask sizes, will have to modify the example accordingly.\n *\n * Also notice that the number of notched RBs must be choosen wisely. If for example\n * someone sets the number of notched RBs too high and executes the example for\n * a high number of UEs, then it will result in error since there will not be\n * sufficient resources for the UE transmissions. In such case, either reduce the\n * number of UEs or the number of notched RBs.\n *\n * The example will print on-screen the end-to-end result of DL (and/or UL) flows,\n * as well as writing them on a file.\n *\n * \\code{.unparsed}\n$ ./ns3 run \"cttc-nr-notching --PrintHelp\"\n    \\endcode\n */\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CttcNrNotching\");\n\nint\nmain(int argc, char* argv[])\n{\n    uint16_t gNbNum = 1;\n    uint16_t ueNumPergNb = 2;\n\n    uint8_t numBands = 1;\n    double centralFrequencyBand = 2e9;\n\n    double bandwidth = 10e6; // BW changes later on, depending on whether TDD or FDD is selected\n\n    uint16_t numerology = 0; // Only numerology of 0 is supported in this example\n\n    double totalTxPower = 43;\n\n    std::string operationMode = \"TDD\"; // TDD or FDD\n    std::string pattern = \"DL|S|UL|UL|DL|DL|S|UL|UL|DL|\";\n\n    bool udpFullBuffer = false;\n    uint32_t udpPacketSizeUll = 100;\n    uint32_t udpPacketSizeBe = 1252;\n    uint32_t lambdaUll = 10000;\n    uint32_t lambdaBe = 1000;\n\n    bool logging = false;\n\n    bool enableDl = false;\n    bool enableUl = true;\n\n    bool enableOfdma = false;\n\n    int notchedRbStartDl = 0;\n    int numOfNotchedRbsDl = 0;\n\n    int notchedRbStartUl = 0;\n    int numOfNotchedRbsUl = 0;\n\n    std::string simTag = \"default\";\n    std::string outputDir = \"./\";\n\n    double simTime = 1;           // seconds\n    double udpAppStartTime = 0.4; // seconds\n\n    double validationValue1 = 0;\n    double validationValue2 = 0;\n\n    CommandLine cmd(__FILE__);\n\n    cmd.AddValue(\"simTime\", \"Simulation time\", simTime);\n    cmd.AddValue(\"gNbNum\",\n                 \"The number of gNbs. In this example up to 2 gNBs are supported\",\n                 gNbNum);\n    cmd.AddValue(\"ueNumPergNb\", \"The number of UEs per gNb\", ueNumPergNb);\n    cmd.AddValue(\"bandwidth\", \"The system bandwidth. Choose among 5, 10 and 20 MHz\", bandwidth);\n    cmd.AddValue(\"totalTxPower\",\n                 \"total tx power that will be proportionally assigned to\"\n                 \" bandwidth parts depending on each BWP bandwidth \",\n                 totalTxPower);\n    cmd.AddValue(\"operationMode\", \"The network operation mode can be TDD or FDD\", operationMode);\n    cmd.AddValue(\"tddPattern\",\n                 \"LTE TDD pattern to use (e.g. --tddPattern=DL|S|UL|UL|UL|DL|S|UL|UL|UL|)\",\n                 pattern);\n    cmd.AddValue(\"udpFullBuffer\",\n                 \"Whether to set the full buffer traffic; if this parameter is \"\n                 \"set then the udpInterval parameter will be neglected.\",\n                 udpFullBuffer);\n    cmd.AddValue(\"packetSizeUll\",\n                 \"packet size in bytes to be used by ultra low latency traffic\",\n                 udpPacketSizeUll);\n    cmd.AddValue(\"packetSizeBe\",\n                 \"packet size in bytes to be used by best effort traffic\",\n                 udpPacketSizeBe);\n    cmd.AddValue(\"lambdaUll\",\n                 \"Number of UDP packets in one second for ultra low latency traffic\",\n                 lambdaUll);\n    cmd.AddValue(\"lambdaBe\",\n                 \"Number of UDP packets in one second for best effor traffic\",\n                 lambdaBe);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.AddValue(\"enableDl\", \"Enable DL flow\", enableDl);\n    cmd.AddValue(\"enableUl\", \"Enable UL flow\", enableUl);\n    cmd.AddValue(\"enableOfdma\",\n                 \"enable Ofdma scheduler. If false (default) Tdma is enabled\",\n                 enableOfdma);\n    cmd.AddValue(\"notchedRbStartDl\",\n                 \"starting point of notched RBs (choose among RBs 0-52 for BW of 10 MHz)\"\n                 \"for the DL\",\n                 notchedRbStartDl);\n    cmd.AddValue(\"numOfNotchedRbsDl\",\n                 \"Number of notched RBs for the DL. \"\n                 \"Please be sure that the number of 'normal' RBs is sufficient to \"\n                 \"perform transmissions of the UEs. If an error occurs, please try \"\n                 \"to reduce either the number of UEs or the number of the RBs notched.\",\n                 numOfNotchedRbsDl);\n    cmd.AddValue(\"notchedRbStartUl\",\n                 \"starting point of notched RBs (choose among RBs 0-52 for BW of 10 MHz)\"\n                 \"for the UL\",\n                 notchedRbStartUl);\n    cmd.AddValue(\"numOfNotchedRbsUl\",\n                 \"Number of notched RBs for the UL. \"\n                 \"Please be sure that the number of 'normal' RBs is sufficient to \"\n                 \"perform transmissions of the UEs. If an error occurs, please try \"\n                 \"to reduce either the number of UEs or the number of the RBs notched.\",\n                 numOfNotchedRbsUl);\n    cmd.AddValue(\"simTag\",\n                 \"tag to be appended to output filenames to distinguish simulation campaigns\",\n                 simTag);\n    cmd.AddValue(\"outputDir\", \"directory where to store simulation results\", outputDir);\n    cmd.AddValue(\"validationValue1\",\n                 \"Value used when running test.py to check if the specific example result value is \"\n                 \"as expected\",\n                 validationValue1);\n    cmd.AddValue(\"validationValue2\",\n                 \"Value used when running test.py to check if the specific example result value is \"\n                 \"as expected\",\n                 validationValue2);\n    cmd.Parse(argc, argv);\n\n    NS_ABORT_IF(numBands < 1);\n    NS_ABORT_MSG_IF(enableDl == false && enableUl == false,\n                    \"Enable at least one of \"\n                    \"the flows (DL/UL)\");\n    NS_ABORT_MSG_IF(numerology != 0, \"Only numerology 0 is supported in this example\");\n\n    // Set the size of the mask according to the supported BW\n    int size = 0;\n    if (bandwidth == 5e6)\n    {\n        size = 26;\n        NS_ABORT_MSG_IF(notchedRbStartDl < 0 || notchedRbStartDl > 25,\n                        \"The starting point \"\n                        \"of the DL notched RBs must be between 0 and 25 for BW of 5MHz\");\n        NS_ABORT_MSG_IF((notchedRbStartDl + numOfNotchedRbsDl) > 25,\n                        \"The available RBs \"\n                        \"in DL are 26 (from 0 to 25) for BW of 5MHz\");\n        NS_ABORT_MSG_IF(notchedRbStartUl < 0 || notchedRbStartUl > 25,\n                        \"The starting point \"\n                        \"of the UL notched RBs must be between 0 and 25 for BW of 5MHz\");\n        NS_ABORT_MSG_IF((notchedRbStartUl + numOfNotchedRbsUl) > 25,\n                        \"The available RBs \"\n                        \"in UL are 26 (from 0 to 25) for BW of 5MHz\");\n    }\n    else if (bandwidth == 10e6)\n    {\n        size = 53;\n        NS_ABORT_MSG_IF(notchedRbStartDl < 0 || notchedRbStartDl > 52,\n                        \"The starting point \"\n                        \"of the DL notched RBs must be between 0 and 52 for BW of 10MHz\");\n        NS_ABORT_MSG_IF((notchedRbStartDl + numOfNotchedRbsDl) > 52,\n                        \"The available RBs \"\n                        \"in DL are 53 (from 0 to 52) for BW of 10MHz\");\n        NS_ABORT_MSG_IF(notchedRbStartUl < 0 || notchedRbStartUl > 52,\n                        \"The starting point \"\n                        \"of the UL notched RBs must be between 0 and 52 for BW of 10MHz\");\n        NS_ABORT_MSG_IF((notchedRbStartUl + numOfNotchedRbsUl) > 52,\n                        \"The available RBs \"\n                        \"in UL are 53 (from 0 to 52) for BW of 10MHz\");\n    }\n    else if (bandwidth == 20e6)\n    {\n        size = 106;\n        NS_ABORT_MSG_IF(notchedRbStartDl < 0 || notchedRbStartDl > 105,\n                        \"The starting point \"\n                        \"of the DL notched RBs must be between 0 and 105 for BW of 20MHz\");\n        NS_ABORT_MSG_IF((notchedRbStartDl + numOfNotchedRbsDl) > 105,\n                        \"The available RBs \"\n                        \"in DL are 106 (from 0 to 105) for BW of 20MHz\");\n        NS_ABORT_MSG_IF(notchedRbStartUl < 0 || notchedRbStartUl > 105,\n                        \"The starting point \"\n                        \"of the UL notched RBs must be between 0 and 105 for BW of 20MHz\");\n        NS_ABORT_MSG_IF((notchedRbStartUl + numOfNotchedRbsUl) > 105,\n                        \"The available RBs \"\n                        \"in UL are 106 (from 0 to 105) for BW of 20MHz\");\n    }\n    else\n    {\n        NS_ABORT_MSG(\"This bandwidth is not supported in this example. \"\n                     \"Please choose among 5MHz - 10MHz - 20MHz.\");\n    }\n\n    // Default mask (all 1s)\n    std::vector<uint8_t> notchedMaskDl(size, 1);\n    std::vector<uint8_t> notchedMaskUl(size, 1);\n\n    // mute RBs from notchedRbStart to (notchedRbStart + numOfNotchedRbs)\n    for (int i = notchedRbStartDl; i < (notchedRbStartDl + numOfNotchedRbsDl); i++)\n    {\n        notchedMaskDl[i] = 0;\n    }\n\n    for (int i = notchedRbStartUl; i < (notchedRbStartUl + numOfNotchedRbsUl); i++)\n    {\n        notchedMaskUl[i] = 0;\n    }\n\n    std::cout << \"DL notched Mask: \";\n    for (int x : notchedMaskDl)\n    {\n        std::cout << x << \" \";\n    }\n    std::cout << std::endl;\n    std::cout << \"UL notched Mask: \";\n    for (int x : notchedMaskUl)\n    {\n        std::cout << x << \" \";\n    }\n    std::cout << std::endl;\n    std::cout << \"Warning: Please be sure that the number of 'normal' RBs is \"\n              << \"sufficient to perform transmissions of the UEs.\\n If an error \"\n              << \"occurs, please try to reduce either the number of notched RBs \"\n              << \"or the number of UEs.\" << std::endl;\n\n    // enable logging or not\n    if (logging)\n    {\n        LogLevel logLevel1 =\n            (LogLevel)(LOG_PREFIX_FUNC | LOG_PREFIX_TIME | LOG_PREFIX_NODE | LOG_LEVEL_INFO);\n        LogLevel logLevel2 =\n            (LogLevel)(LOG_PREFIX_FUNC | LOG_PREFIX_TIME | LOG_PREFIX_NODE | LOG_LEVEL_DEBUG);\n        LogComponentEnable(\"NrMacSchedulerNs3\", logLevel1);\n        LogComponentEnable(\"NrMacSchedulerTdma\", logLevel1);\n        // LogComponentEnable (\"NrMacSchedulerTdmaRR\", logLevel1);\n        LogComponentEnable(\"NrMacSchedulerOfdma\", logLevel1);\n        // LogComponentEnable (\"NrMacSchedulerOfdmaRR\", logLevel1);\n        LogComponentEnable(\"CcBwpHelper\", logLevel2);\n    }\n\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n\n    int64_t randomStream = 1;\n\n    GridScenarioHelper gridScenario;\n    gridScenario.SetRows(1);\n    gridScenario.SetColumns(gNbNum);\n    gridScenario.SetHorizontalBsDistance(5.0);\n    gridScenario.SetVerticalBsDistance(5.0);\n    gridScenario.SetBsHeight(1.5);\n    gridScenario.SetUtHeight(1.5);\n    gridScenario.SetSectorization(GridScenarioHelper::SINGLE);\n    gridScenario.SetBsNumber(gNbNum);\n    gridScenario.SetUtNumber(ueNumPergNb * gNbNum);\n    gridScenario.SetScenarioHeight(3); // Create a 3x3 scenario where the UE will\n    gridScenario.SetScenarioLength(3); // be distribuited.\n    randomStream += gridScenario.AssignStreams(randomStream);\n    gridScenario.CreateScenario();\n\n    // setup the nr simulation\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n    epcHelper->SetAttribute(\"S1uLinkDelay\", TimeValue(MilliSeconds(0)));\n    if (enableOfdma)\n    {\n        nrHelper->SetSchedulerTypeId(TypeId::LookupByName(\"ns3::NrMacSchedulerOfdmaRR\"));\n    }\n    else\n    {\n        nrHelper->SetSchedulerTypeId(TypeId::LookupByName(\"ns3::NrMacSchedulerTdmaRR\"));\n    }\n\n    // Beamforming method\n    idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));\n\n    /*\n     * Setup the configuration of the spectrum. One operation band is deployed\n     * with 1 component carrier (CC), automatically generated by the ccBwpManager\n     */\n    BandwidthPartInfoPtrVector allBwps;\n    CcBwpCreator ccBwpCreator;\n\n    OperationBandInfo band;\n\n    /*\n     * The configured spectrum division for TDD is:\n     *\n     * |----Band1----|\n     * |-----CC1-----|\n     * |-----BWP1----|\n     *\n     * And the configured spectrum division for FDD operation is:\n     * |---------Band1---------|\n     * |----------CC1----------|\n     * |----BWP1---|----BWP2---|\n     */\n\n    const uint8_t numOfCcs = 1;\n\n    if (operationMode == \"FDD\")\n    {\n        // For FDD we have 2 BWPs so the BW must be doubled (e.g. for BW of 10MHz we\n        // need 20MHz --> 10MHz for the DL BWP and 10MHz for the UL BWP)\n        bandwidth = bandwidth * 2;\n    }\n\n    // Create the configuration for the CcBwpHelper\n    CcBwpCreator::SimpleOperationBandConf bandConf(centralFrequencyBand,\n                                                   bandwidth,\n                                                   numOfCcs,\n                                                   BandwidthPartInfo::UMi_StreetCanyon_LoS);\n\n    bandConf.m_numBwp = operationMode == \"FDD\" ? 2 : 1; // FDD will have 2 BWPs per CC\n\n    // By using the configuration created, it is time to make the operation band\n    band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);\n\n    nrHelper->InitializeOperationBand(&band);\n    allBwps = CcBwpCreator::GetAllBwps({band});\n\n    double x = pow(10, totalTxPower / 10);\n\n    // Antennas for all the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(1));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(1));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Antennas for all the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(4));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(8));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    uint32_t bwpIdForLowLat = 0;\n    uint32_t bwpIdForVideo = 0;\n\n    // gNb and UE routing between Bearer and bandwidh part\n    if (operationMode == \"TDD\")\n    {\n        nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\",\n                                                     UintegerValue(bwpIdForLowLat));\n        nrHelper->SetUeBwpManagerAlgorithmAttribute(\"NGBR_VIDEO_TCP_DEFAULT\",\n                                                    UintegerValue(bwpIdForVideo));\n    }\n    else\n    {\n        bwpIdForVideo = 1;\n        nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\",\n                                                     UintegerValue(bwpIdForLowLat));\n        nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_VIDEO_TCP_DEFAULT\",\n                                                     UintegerValue(bwpIdForVideo));\n\n        nrHelper->SetUeBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\",\n                                                    UintegerValue(bwpIdForLowLat));\n        nrHelper->SetUeBwpManagerAlgorithmAttribute(\"NGBR_VIDEO_TCP_DEFAULT\",\n                                                    UintegerValue(bwpIdForVideo));\n    }\n\n    // Install and get the pointers to the NetDevices\n    NetDeviceContainer enbNetDev =\n        nrHelper->InstallGnbDevice(gridScenario.GetBaseStations(), allBwps);\n    NetDeviceContainer ueNetDev =\n        nrHelper->InstallUeDevice(gridScenario.GetUserTerminals(), allBwps);\n\n    randomStream += nrHelper->AssignStreams(enbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);\n\n    for (uint32_t i = 0; i < gNbNum; ++i)\n    {\n        // Manually set the attribute of the netdevice (enbNetDev.Get (0)) and bandwidth part (0),\n        // (1), ...\n        nrHelper->GetGnbPhy(enbNetDev.Get(i), 0)\n            ->SetAttribute(\"Numerology\", UintegerValue(numerology));\n        nrHelper->GetGnbPhy(enbNetDev.Get(i), 0)\n            ->SetAttribute(\"TxPower\", DoubleValue(10 * log10(x)));\n\n        // Set the mask\n        Ptr<NrMacSchedulerNs3> schedulerBwp1 =\n            DynamicCast<NrMacSchedulerNs3>(nrHelper->GetScheduler(enbNetDev.Get(i), 0));\n        schedulerBwp1->SetDlNotchedRbgMask(notchedMaskDl);\n\n        if (operationMode == \"TDD\")\n        {\n            nrHelper->GetGnbPhy(enbNetDev.Get(i), 0)->SetAttribute(\"Pattern\", StringValue(pattern));\n            schedulerBwp1->SetUlNotchedRbgMask(notchedMaskUl);\n        }\n        else\n        {\n            nrHelper->GetGnbPhy(enbNetDev.Get(i), 0)\n                ->SetAttribute(\"Pattern\", StringValue(\"DL|DL|DL|DL|DL|DL|DL|DL|DL|DL|\"));\n\n            nrHelper->GetGnbPhy(enbNetDev.Get(i), 1)\n                ->SetAttribute(\"Numerology\", UintegerValue(numerology));\n            nrHelper->GetGnbPhy(enbNetDev.Get(i), 1)->SetAttribute(\"TxPower\", DoubleValue(-30.0));\n            nrHelper->GetGnbPhy(enbNetDev.Get(i), 1)\n                ->SetAttribute(\"Pattern\", StringValue(\"UL|UL|UL|UL|UL|UL|UL|UL|UL|UL|\"));\n\n            Ptr<NrMacSchedulerNs3> schedulerBwp2 =\n                DynamicCast<NrMacSchedulerNs3>(nrHelper->GetScheduler(enbNetDev.Get(i), 1));\n            schedulerBwp2->SetUlNotchedRbgMask(notchedMaskUl);\n\n            // Link the two FDD BWPs:\n            nrHelper->GetBwpManagerGnb(enbNetDev.Get(i))->SetOutputLink(1, 0);\n        }\n    }\n\n    if (operationMode == \"FDD\")\n    {\n        // Set the UE routing:\n        for (uint32_t i = 0; i < ueNetDev.GetN(); i++)\n        {\n            nrHelper->GetBwpManagerUe(ueNetDev.Get(i))->SetOutputLink(0, 1);\n        }\n    }\n\n    for (auto it = enbNetDev.Begin(); it != enbNetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.000)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(gridScenario.GetUserTerminals());\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));\n\n    // Set the default gateway for the UEs\n    for (uint32_t j = 0; j < gridScenario.GetUserTerminals().GetN(); ++j)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting = ipv4RoutingHelper.GetStaticRouting(\n            gridScenario.GetUserTerminals().Get(j)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // Attach to GNB\n    nrHelper->AttachToClosestEnb(ueNetDev, enbNetDev);\n\n    // install UDP applications\n    uint16_t dlPortLowLat = 1234;\n    uint16_t ulPortVoice = 1235;\n\n    ApplicationContainer serverApps;\n\n    // The sink will always listen to the specified ports\n    UdpServerHelper dlPacketSinkLowLat(dlPortLowLat);\n    UdpServerHelper ulPacketSinkVoice(ulPortVoice);\n\n    // The server, that is the application which is listening, is installed in the UE\n    // for the DL traffic, and in the remote host for the UL traffic\n    serverApps.Add(dlPacketSinkLowLat.Install(gridScenario.GetUserTerminals()));\n    serverApps.Add(ulPacketSinkVoice.Install(remoteHost));\n\n    /*\n     * Configure attributes for the different generators, using user-provided\n     * parameters for generating a CBR traffic\n     *\n     * Low-Latency configuration and object creation:\n     */\n    UdpClientHelper dlClientLowLat;\n    dlClientLowLat.SetAttribute(\"RemotePort\", UintegerValue(dlPortLowLat));\n    dlClientLowLat.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    dlClientLowLat.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSizeBe));\n    dlClientLowLat.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambdaBe)));\n\n    // The bearer that will carry low latency traffic\n    EpsBearer lowLatBearer(EpsBearer::NGBR_LOW_LAT_EMBB);\n\n    // The filter for the low-latency traffic\n    Ptr<EpcTft> lowLatTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfLowLat;\n    dlpfLowLat.localPortStart = dlPortLowLat;\n    dlpfLowLat.localPortEnd = dlPortLowLat;\n    lowLatTft->Add(dlpfLowLat);\n\n    // Voice configuration and object creation:\n    UdpClientHelper ulClientVoice;\n    ulClientVoice.SetAttribute(\"RemotePort\", UintegerValue(ulPortVoice));\n    ulClientVoice.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    ulClientVoice.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSizeBe));\n    ulClientVoice.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambdaBe)));\n\n    // The bearer that will carry voice traffic\n    EpsBearer videoBearer(EpsBearer::NGBR_VIDEO_TCP_DEFAULT);\n\n    // The filter for the voice traffic\n    Ptr<EpcTft> voiceTft = Create<EpcTft>();\n    EpcTft::PacketFilter ulpfVoice;\n    ulpfVoice.remotePortStart = ulPortVoice;\n    ulpfVoice.remotePortEnd = ulPortVoice;\n    ulpfVoice.direction = EpcTft::UPLINK;\n    voiceTft->Add(ulpfVoice);\n\n    //  Install the applications\n    ApplicationContainer clientApps;\n\n    for (uint32_t i = 0; i < gridScenario.GetUserTerminals().GetN(); ++i)\n    {\n        Ptr<Node> ue = gridScenario.GetUserTerminals().Get(i);\n        Ptr<NetDevice> ueDevice = ueNetDev.Get(i);\n        Address ueAddress = ueIpIface.GetAddress(i);\n\n        // The client, who is transmitting, is installed in the remote host,\n        // with destination address set to the address of the UE\n        if (enableDl)\n        {\n            dlClientLowLat.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n            clientApps.Add(dlClientLowLat.Install(remoteHost));\n\n            nrHelper->ActivateDedicatedEpsBearer(ueDevice, lowLatBearer, lowLatTft);\n        }\n        // For the uplink, the installation happens in the UE, and the remote address\n        // is the one of the remote host\n        if (enableUl)\n        {\n            ulClientVoice.SetAttribute(\"RemoteAddress\",\n                                       AddressValue(internetIpIfaces.GetAddress(1)));\n            clientApps.Add(ulClientVoice.Install(ue));\n\n            nrHelper->ActivateDedicatedEpsBearer(ueDevice, videoBearer, voiceTft);\n        }\n    }\n\n    // start UDP server and client apps\n    serverApps.Start(Seconds(udpAppStartTime));\n    clientApps.Start(Seconds(udpAppStartTime));\n    serverApps.Stop(Seconds(simTime));\n    clientApps.Stop(Seconds(simTime));\n\n    // enable the traces provided by the nr module\n    nrHelper->EnableTraces();\n\n    FlowMonitorHelper flowmonHelper;\n    NodeContainer endpointNodes;\n    endpointNodes.Add(remoteHost);\n    endpointNodes.Add(gridScenario.GetUserTerminals());\n\n    Ptr<ns3::FlowMonitor> monitor = flowmonHelper.Install(endpointNodes);\n    monitor->SetAttribute(\"DelayBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"JitterBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"PacketSizeBinWidth\", DoubleValue(20));\n\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n\n    /*\n     * To check what was installed in the memory, i.e., BWPs of eNb Device, and its configuration.\n     * Example is: Node 1 -> Device 0 -> BandwidthPartMap -> {0,1} BWPs -> NrGnbPhy ->\n    NrPhyMacCommong-> Numerology, Bandwidth, ... GtkConfigStore config; config.ConfigureAttributes\n    ();\n    */\n\n    // Print per-flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier =\n        DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n\n    double averageFlowThroughput = 0.0;\n    double averageFlowDelay = 0.0;\n\n    std::ofstream outFile;\n    std::string filename = outputDir + \"/\" + simTag;\n    outFile.open(filename.c_str(), std::ofstream::out | std::ofstream::trunc);\n    if (!outFile.is_open())\n    {\n        std::cerr << \"Can't open file \" << filename << std::endl;\n        return 1;\n    }\n\n    outFile.setf(std::ios_base::fixed);\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin();\n         i != stats.end();\n         ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        std::stringstream protoStream;\n        protoStream << (uint16_t)t.protocol;\n        if (t.protocol == 6)\n        {\n            protoStream.str(\"TCP\");\n        }\n        if (t.protocol == 17)\n        {\n            protoStream.str(\"UDP\");\n        }\n        outFile << \"Flow \" << i->first << \" (\" << t.sourceAddress << \":\" << t.sourcePort << \" -> \"\n                << t.destinationAddress << \":\" << t.destinationPort << \") proto \"\n                << protoStream.str() << \"\\n\";\n        outFile << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n        outFile << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n        outFile << \"  TxOffered:  \"\n                << i->second.txBytes * 8.0 / (simTime - udpAppStartTime) / 1000 / 1000 << \" Mbps\\n\";\n        outFile << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n        if (i->second.rxPackets > 0)\n        {\n            // Measure the duration of the flow from receiver's perspective\n            // double rxDuration = i->second.timeLastRxPacket.GetSeconds () -\n            // i->second.timeFirstTxPacket.GetSeconds ();\n            double rxDuration = (simTime - udpAppStartTime);\n\n            averageFlowThroughput += i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000;\n            averageFlowDelay += 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;\n\n            outFile << \"  Throughput: \" << i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000\n                    << \" Mbps\\n\";\n            outFile << \"  Mean delay:  \"\n                    << 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n            // outFile << \"  Mean upt:  \" << i->second.uptSum / i->second.rxPackets / 1000/1000 << \"\n            // Mbps \\n\";\n            outFile << \"  Mean jitter:  \"\n                    << 1000 * i->second.jitterSum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n\n            // used when running examples from test.py\n            if (validationValue1 && (i->first == 1))\n            {\n                if ((validationValue1 >\n                     (i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000) * 1.1) ||\n                    (validationValue1 < (i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000) * 0.9))\n                {\n                    NS_FATAL_ERROR(\"Example results for flow 1 has changed for more then +- 10% \"\n                                   \"wrt to the previous version of the ns-3 and NR module\");\n                }\n            }\n            else if (validationValue2 && (i->first == 2))\n            {\n                if ((validationValue2 >\n                     (i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000) * 1.1) ||\n                    (validationValue2 < (i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000) * 0.9))\n                {\n                    NS_FATAL_ERROR(\"Example results for flow 2 has changed for more then +- 10% \"\n                                   \"wrt to the previous version of the ns-3 and NR module\");\n                }\n            }\n        }\n        else\n        {\n            outFile << \"  Throughput:  0 Mbps\\n\";\n            outFile << \"  Mean delay:  0 ms\\n\";\n            outFile << \"  Mean jitter: 0 ms\\n\";\n        }\n        outFile << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n    }\n\n    outFile << \"\\n\\n  Mean flow throughput: \" << averageFlowThroughput / stats.size() << \"\\n\";\n    outFile << \"  Mean flow delay: \" << averageFlowDelay / stats.size() << \"\\n\";\n\n    outFile.close();\n\n    std::ifstream f(filename.c_str());\n\n    if (f.is_open())\n    {\n        std::cout << f.rdbuf();\n    }\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/cttc-nr-simple-qos-sched.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2022 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n/**\n * \\ingroup examples\n * \\file cttc-nr-simple-qos-sched.cc\n * \\brief A simple example for QoS scheduler (nr-mac-scheduler-ofdma/tdma-qos)\n *\n * This example describes how to setup a simulation using the QoS scheduler and\n * the 3GPP channel model from TR 38.900. This example consists of a simple\n * topology, in which there is only one gNB and two UEs with different QCI flows.\n * Have a look at the possible parameters to know what you can configure through\n * the command line.\n *\n * With the default configuration, the example will create one flow for each UE,\n * with different QCIs that will go through the same BWP.\n *\n * The example will print on-screen the end-to-end result of one (or two) flows,\n * as well as writing them on a file.\n *\n * \\code{.unparsed}\n$ ./ns3 run \"cttc-nr-simple-qos-sched --PrintHelp\"\n    \\endcode\n *\n */\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/buildings-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CttcNrSimpleQosSched\");\n\nint\nmain(int argc, char* argv[])\n{\n    /*\n     * Variables that represent the parameters we will accept as input by the\n     * command line. Each of them is initialized with a default value, and\n     * possibly overridden below when command-line arguments are parsed.\n     */\n    // Scenario parameters (that we will use inside this script):\n    uint16_t gNbNum = 1;\n    uint16_t ueNumPergNb = 2;\n    bool logging = false;\n\n    // Simulation parameters. Please don't use double to indicate seconds; use\n    // ns-3 Time values which use integers to avoid portability issues.\n    Time simTime = MilliSeconds(1000);\n    Time udpAppStartTime = MilliSeconds(400);\n\n    // NR parameters. We will take the input from the command line, and then we\n    // will pass them inside the NR module.\n    uint16_t numerology = 0;\n    double centralFrequency = 4e9;\n    double bandwidth = 5e6;\n    double totalTxPower = 43;\n\n    bool enableOfdma = false;\n\n    uint8_t priorityTrafficScenario = 0; // default is saturation\n\n    uint16_t mcsTable = 2;\n\n    // Where we will store the output files.\n    std::string simTag = \"default\";\n    std::string outputDir = \"./\";\n\n    /*\n     * From here, we instruct the ns3::CommandLine class of all the input parameters\n     * that we may accept as input, as well as their description, and the storage\n     * variable.\n     */\n    CommandLine cmd;\n\n    cmd.AddValue(\"gNbNum\", \"The number of gNbs in multiple-ue topology\", gNbNum);\n    cmd.AddValue(\"ueNumPergNb\", \"The number of UE per gNb in multiple-ue topology\", ueNumPergNb);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.AddValue(\"priorityTrafficScenario\",\n                 \"The traffic scenario for the case of priority. Can be 0: saturation\"\n                 \"or 1: medium-load\",\n                 priorityTrafficScenario);\n    cmd.AddValue(\"simTime\", \"Simulation time\", simTime);\n    cmd.AddValue(\"numerology\", \"The numerology to be used\", numerology);\n    cmd.AddValue(\"centralFrequency\", \"The system frequency to be used\", centralFrequency);\n    cmd.AddValue(\"bandwidth\", \"The system bandwidth to be used\", bandwidth);\n    cmd.AddValue(\"totalTxPower\",\n                 \"total tx power that will be proportionally assigned to\"\n                 \" bands, CCs and bandwidth parts depending on each BWP bandwidth \",\n                 totalTxPower);\n    cmd.AddValue(\"simTag\",\n                 \"tag to be appended to output filenames to distinguish simulation campaigns\",\n                 simTag);\n    cmd.AddValue(\"outputDir\", \"directory where to store simulation results\", outputDir);\n    cmd.AddValue(\"enableOfdma\",\n                 \"If set to true it enables Ofdma scheduler. Default value is false (Tdma)\",\n                 enableOfdma);\n\n    cmd.Parse(argc, argv);\n\n    // enable logging or not\n    if (logging)\n    {\n        LogLevel logLevel1 =\n            (LogLevel)(LOG_PREFIX_FUNC | LOG_PREFIX_TIME | LOG_PREFIX_NODE | LOG_LEVEL_INFO);\n        LogComponentEnable(\"NrMacSchedulerNs3\", logLevel1);\n        LogComponentEnable(\"NrMacSchedulerTdma\", logLevel1);\n    }\n\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n\n    /*\n     * Create the scenario. In our examples, we heavily use helpers that setup\n     * the gnbs and ue following a pre-defined pattern. Please have a look at the\n     * GridScenarioHelper documentation to see how the nodes will be distributed.\n     */\n    int64_t randomStream = 1;\n\n    GridScenarioHelper gridScenario;\n    gridScenario.SetRows(1);\n    gridScenario.SetColumns(gNbNum);\n    gridScenario.SetHorizontalBsDistance(5.0);\n    gridScenario.SetVerticalBsDistance(5.0);\n    gridScenario.SetBsHeight(1.5);\n    gridScenario.SetUtHeight(1.5);\n    // must be set before BS number\n    gridScenario.SetSectorization(GridScenarioHelper::SINGLE);\n    gridScenario.SetBsNumber(gNbNum);\n    gridScenario.SetUtNumber(ueNumPergNb * gNbNum);\n    gridScenario.SetScenarioHeight(3); // Create a 3x3 scenario where the UE will\n    gridScenario.SetScenarioLength(3); // be distribuited.\n    randomStream += gridScenario.AssignStreams(randomStream);\n    gridScenario.CreateScenario();\n\n    uint32_t udpPacketSizeULL;\n    uint32_t udpPacketSizeBe;\n    uint32_t lambdaULL = 1000;\n    uint32_t lambdaBe = 1000;\n\n    if (priorityTrafficScenario == 0) // saturation\n    {\n        udpPacketSizeULL = 3000;\n        udpPacketSizeBe = 3000;\n    }\n    else if (priorityTrafficScenario == 1) // medium-load\n    {\n        udpPacketSizeULL = 3000;\n        udpPacketSizeBe = 1252;\n    }\n    else\n    {\n        NS_ABORT_MSG(\"The priorityTrafficScenario chosen is not correct. \"\n                     \"Please choose among 0: saturation and 1: medium-load\");\n    }\n\n    /*\n     * Create two different NodeContainer for the different traffic type.\n     * In ueLowLat we will put the UEs that will receive low-latency traffic,\n     * while in ueVoice we will put the UEs that will receive the voice traffic.\n     */\n    NodeContainer ueLowLatContainer;\n    NodeContainer ueVoiceContainer;\n\n    for (uint32_t j = 0; j < gridScenario.GetUserTerminals().GetN(); ++j)\n    {\n        Ptr<Node> ue = gridScenario.GetUserTerminals().Get(j);\n\n        j % 2 == 0 ? ueLowLatContainer.Add(ue) : ueVoiceContainer.Add(ue);\n    }\n\n    if (priorityTrafficScenario == 1)\n    {\n        lambdaULL = 1000 / ueLowLatContainer.GetN();\n        lambdaBe = 1000 / ueVoiceContainer.GetN();\n    }\n\n    // setup the nr simulation\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n\n    // Put the pointers inside nrHelper\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n    epcHelper->SetAttribute(\"S1uLinkDelay\", TimeValue(MilliSeconds(0)));\n    Config::SetDefault(\"ns3::ThreeGppChannelModel::UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetChannelConditionModelAttribute(\"UpdatePeriod\", TimeValue(MilliSeconds(0)));\n\n    std::stringstream schedulerType;\n    std::string subType;\n    std::string sched;\n\n    subType = enableOfdma == false ? \"Tdma\" : \"Ofdma\";\n    sched = \"Qos\";\n    schedulerType << \"ns3::NrMacScheduler\" << subType << sched;\n    std::cout << \"SchedulerType: \" << schedulerType.str() << std::endl;\n    nrHelper->SetSchedulerTypeId(TypeId::LookupByName(schedulerType.str()));\n\n    // Error Model: gNB and UE with same spectrum error model.\n    std::string errorModel = \"ns3::NrEesmIrT\" + std::to_string(mcsTable);\n    nrHelper->SetDlErrorModel(errorModel);\n    nrHelper->SetUlErrorModel(errorModel);\n\n    // Both DL and UL AMC will have the same model behind.\n    nrHelper->SetGnbDlAmcAttribute(\"AmcModel\", EnumValue(NrAmc::ErrorModel));\n    nrHelper->SetGnbUlAmcAttribute(\"AmcModel\", EnumValue(NrAmc::ErrorModel));\n\n    // Beamforming method\n    idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));\n\n    // Antennas for all the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(1));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(1));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Antennas for all the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(1));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(1));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    /*\n     * Setup the configuration of the spectrum. One operation band is deployed\n     * with 1 component carrier (CC), automatically generated by the ccBwpManager\n     */\n    BandwidthPartInfoPtrVector allBwps;\n    CcBwpCreator ccBwpCreator;\n    OperationBandInfo band;\n    const uint8_t numOfCcs = 1;\n\n    /*\n     * The configured spectrum division for TDD is:\n     *\n     * |----Band1----|\n     * |-----CC1-----|\n     * |-----BWP1----|\n     */\n\n    // Create the configuration for the CcBwpHelper. SimpleOperationBandConf creates\n    // a single BWP per CC\n    CcBwpCreator::SimpleOperationBandConf bandConf(centralFrequency,\n                                                   bandwidth,\n                                                   numOfCcs,\n                                                   BandwidthPartInfo::UMi_StreetCanyon);\n\n    bandConf.m_numBwp = 1;\n    // By using the configuration created, it is time to make the operation band\n    band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);\n\n    nrHelper->InitializeOperationBand(&band);\n    allBwps = CcBwpCreator::GetAllBwps({band});\n\n    double x = pow(10, totalTxPower / 10);\n\n    Packet::EnableChecking();\n    Packet::EnablePrinting();\n\n    uint32_t bwpIdForLowLat = 0;\n    uint32_t bwpIdForVoice = 0;\n\n    // gNb routing between Bearer and bandwidh part\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\",\n                                                 UintegerValue(bwpIdForLowLat));\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"GBR_CONV_VOICE\", UintegerValue(bwpIdForVoice));\n\n    // Ue routing between Bearer and bandwidth part\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"NGBR_LOW_LAT_EMBB\", UintegerValue(bwpIdForLowLat));\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"GBR_CONV_VOICE\", UintegerValue(bwpIdForVoice));\n\n    /*\n     * We have configured the attributes we needed. Now, install and get the pointers\n     * to the NetDevices, which contains all the NR stack:\n     */\n    NetDeviceContainer enbNetDev =\n        nrHelper->InstallGnbDevice(gridScenario.GetBaseStations(), allBwps);\n    NetDeviceContainer ueLowLatNetDev = nrHelper->InstallUeDevice(ueLowLatContainer, allBwps);\n    NetDeviceContainer ueVoiceNetDev = nrHelper->InstallUeDevice(ueVoiceContainer, allBwps);\n\n    randomStream += nrHelper->AssignStreams(enbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueLowLatNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueVoiceNetDev, randomStream);\n\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)->SetAttribute(\"Numerology\", UintegerValue(numerology));\n    nrHelper->GetGnbPhy(enbNetDev.Get(0), 0)->SetAttribute(\"TxPower\", DoubleValue(10 * log10(x)));\n\n    // When all the configuration is done, explicitly call UpdateConfig ()\n    for (auto it = enbNetDev.Begin(); it != enbNetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueLowLatNetDev.Begin(); it != ueLowLatNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n    for (auto it = ueVoiceNetDev.Begin(); it != ueVoiceNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.000)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(gridScenario.GetUserTerminals());\n\n    Ipv4InterfaceContainer ueLowLatIpIface;\n    Ipv4InterfaceContainer ueVoiceIpIface;\n    ueLowLatIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueLowLatNetDev));\n    ueVoiceIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueVoiceNetDev));\n\n    // Set the default gateway for the UEs\n    for (uint32_t j = 0; j < gridScenario.GetUserTerminals().GetN(); ++j)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting = ipv4RoutingHelper.GetStaticRouting(\n            gridScenario.GetUserTerminals().Get(j)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // attach UEs to the closest gNB\n    nrHelper->AttachToClosestEnb(ueLowLatNetDev, enbNetDev);\n    nrHelper->AttachToClosestEnb(ueVoiceNetDev, enbNetDev);\n\n    /*\n     * Traffic part. Install two kind of traffic: low-latency and voice, each\n     * identified by a particular source port.\n     */\n    uint16_t dlPortLowLat = 1234;\n    uint16_t dlPortVoice = 1235;\n\n    ApplicationContainer serverApps;\n\n    // The sink will always listen to the specified ports\n    UdpServerHelper dlPacketSinkLowLat(dlPortLowLat);\n    UdpServerHelper dlPacketSinkVoice(dlPortVoice);\n\n    // The server, that is the application which is listening, is installed in the UE\n    serverApps.Add(dlPacketSinkLowLat.Install(ueLowLatContainer));\n    serverApps.Add(dlPacketSinkVoice.Install(ueVoiceContainer));\n\n    /*\n     * Configure attributes for the different generators, using user-provided\n     * parameters for generating a CBR traffic\n     *\n     * Low-Latency configuration and object creation:\n     */\n    UdpClientHelper dlClientLowLat;\n    dlClientLowLat.SetAttribute(\"RemotePort\", UintegerValue(dlPortLowLat));\n    dlClientLowLat.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    dlClientLowLat.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSizeULL));\n    dlClientLowLat.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambdaULL)));\n\n    // The bearer that will carry low latency traffic\n    EpsBearer lowLatBearer(EpsBearer::NGBR_LOW_LAT_EMBB);\n\n    // The filter for the low-latency traffic\n    Ptr<EpcTft> lowLatTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfLowLat;\n    dlpfLowLat.localPortStart = dlPortLowLat;\n    dlpfLowLat.localPortEnd = dlPortLowLat;\n    lowLatTft->Add(dlpfLowLat);\n\n    // Voice configuration and object creation:\n    UdpClientHelper dlClientVoice;\n    dlClientVoice.SetAttribute(\"RemotePort\", UintegerValue(dlPortVoice));\n    dlClientVoice.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    dlClientVoice.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSizeBe));\n    dlClientVoice.SetAttribute(\"Interval\", TimeValue(Seconds(1.0 / lambdaBe)));\n\n    // The bearer that will carry voice traffic\n    EpsBearer voiceBearer(EpsBearer::GBR_CONV_VOICE);\n\n    // The filter for the voice traffic\n    Ptr<EpcTft> voiceTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfVoice;\n    dlpfVoice.localPortStart = dlPortVoice;\n    dlpfVoice.localPortEnd = dlPortVoice;\n    voiceTft->Add(dlpfVoice);\n\n    //  Install the applications\n    ApplicationContainer clientApps;\n\n    for (uint32_t i = 0; i < ueLowLatContainer.GetN(); ++i)\n    {\n        Ptr<NetDevice> ueDevice = ueLowLatNetDev.Get(i);\n        Address ueAddress = ueLowLatIpIface.GetAddress(i);\n\n        // The client, who is transmitting, is installed in the remote host,\n        // with destination address set to the address of the UE\n        dlClientLowLat.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n        clientApps.Add(dlClientLowLat.Install(remoteHost));\n\n        // Activate a dedicated bearer for the traffic type\n        nrHelper->ActivateDedicatedEpsBearer(ueDevice, lowLatBearer, lowLatTft);\n    }\n\n    for (uint32_t i = 0; i < ueVoiceContainer.GetN(); ++i)\n    {\n        Ptr<NetDevice> ueDevice = ueVoiceNetDev.Get(i);\n        Address ueAddress = ueVoiceIpIface.GetAddress(i);\n\n        // The client, who is transmitting, is installed in the remote host,\n        // with destination address set to the address of the UE\n        dlClientVoice.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n        clientApps.Add(dlClientVoice.Install(remoteHost));\n\n        // Activate a dedicated bearer for the traffic type\n        nrHelper->ActivateDedicatedEpsBearer(ueDevice, voiceBearer, voiceTft);\n    }\n\n    // start UDP server and client apps\n    serverApps.Start(udpAppStartTime);\n    clientApps.Start(udpAppStartTime);\n    serverApps.Stop(simTime);\n    clientApps.Stop(simTime);\n\n    // enable the traces provided by the nr module\n    // nrHelper->EnableTraces();\n\n    FlowMonitorHelper flowmonHelper;\n    NodeContainer endpointNodes;\n    endpointNodes.Add(remoteHost);\n    endpointNodes.Add(gridScenario.GetUserTerminals());\n\n    Ptr<ns3::FlowMonitor> monitor = flowmonHelper.Install(endpointNodes);\n    monitor->SetAttribute(\"DelayBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"JitterBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"PacketSizeBinWidth\", DoubleValue(20));\n\n    Simulator::Stop(simTime);\n    Simulator::Run();\n\n    /*\n     * To check what was installed in the memory, i.e., BWPs of eNb Device, and its configuration.\n     * Example is: Node 1 -> Device 0 -> BandwidthPartMap -> {0,1} BWPs -> NrGnbPhy -> Numerology,\n    GtkConfigStore config;\n    config.ConfigureAttributes ();\n    */\n\n    // Print per-flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier =\n        DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n\n    double averageFlowThroughput = 0.0;\n    double averageFlowDelay = 0.0;\n\n    std::ofstream outFile;\n    std::string filename = outputDir + \"/\" + simTag;\n    outFile.open(filename.c_str(), std::ofstream::out | std::ofstream::trunc);\n    if (!outFile.is_open())\n    {\n        std::cerr << \"Can't open file \" << filename << std::endl;\n        return 1;\n    }\n\n    outFile.setf(std::ios_base::fixed);\n\n    double flowDuration = (simTime - udpAppStartTime).GetSeconds();\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin();\n         i != stats.end();\n         ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        std::stringstream protoStream;\n        protoStream << (uint16_t)t.protocol;\n        if (t.protocol == 6)\n        {\n            protoStream.str(\"TCP\");\n        }\n        if (t.protocol == 17)\n        {\n            protoStream.str(\"UDP\");\n        }\n        outFile << \"Flow \" << i->first << \" (\" << t.sourceAddress << \":\" << t.sourcePort << \" -> \"\n                << t.destinationAddress << \":\" << t.destinationPort << \") proto \"\n                << protoStream.str() << \"\\n\";\n        outFile << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n        outFile << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n        outFile << \"  TxOffered:  \" << i->second.txBytes * 8.0 / flowDuration / 1000.0 / 1000.0\n                << \" Mbps\\n\";\n        outFile << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n        if (i->second.rxPackets > 0)\n        {\n            // Measure the duration of the flow from receiver's perspective\n            averageFlowThroughput += i->second.rxBytes * 8.0 / flowDuration / 1000 / 1000;\n            averageFlowDelay += 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;\n\n            outFile << \"  Throughput: \" << i->second.rxBytes * 8.0 / flowDuration / 1000 / 1000\n                    << \" Mbps\\n\";\n            outFile << \"  Mean delay:  \"\n                    << 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n            // outFile << \"  Mean upt:  \" << i->second.uptSum / i->second.rxPackets / 1000/1000 << \"\n            // Mbps \\n\";\n            outFile << \"  Mean jitter:  \"\n                    << 1000 * i->second.jitterSum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n        }\n        else\n        {\n            outFile << \"  Throughput:  0 Mbps\\n\";\n            outFile << \"  Mean delay:  0 ms\\n\";\n            outFile << \"  Mean jitter: 0 ms\\n\";\n        }\n        outFile << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n    }\n\n    outFile << \"\\n\\n  Mean flow throughput: \" << averageFlowThroughput / stats.size() << \"\\n\";\n    outFile << \"  Mean flow delay: \" << averageFlowDelay / stats.size() << \"\\n\";\n\n    outFile.close();\n\n    std::ifstream f(filename.c_str());\n\n    if (f.is_open())\n    {\n        std::cout << f.rdbuf();\n    }\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/cttc-nr-traffic-3gpp-xr.cc",
      "code": "// Copyright (c) 2023 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/boolean.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/config-store.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-enb-rrc.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/xr-traffic-mixer-helper.h\"\n\n#include <vector>\n\n/**\n * \\file cttc-nr-traffic-3gpp-xr.cc\n * \\ingroup examples\n * \\brief Simple topology consisting of 1 GNB and various UEs.\n *  Can be configured with different 3GPP XR traffic generators (by using\n *  XR traffic mixer helper).\n *\n * To run the simulation with the default configuration one shall run the\n * following in the command line:\n *\n * ./ns3 run cttc-nr-traffic-generator-3gpp-xr\n *\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CttcNrTraffic3gppXr\");\n\nvoid\nWriteBytesSent(Ptr<TrafficGenerator> trafficGenerator,\n               uint64_t* previousBytesSent,\n               uint64_t* previousWindowBytesSent,\n               enum NrXrConfig NrXrConfig,\n               std::ofstream* outFileTx)\n{\n    uint64_t totalBytesSent = trafficGenerator->GetTotalBytes();\n    (*outFileTx) << \"\\n\"\n                 << Simulator::Now().GetMilliSeconds() << \"\\t\" << *previousWindowBytesSent\n                 << std::endl;\n    (*outFileTx) << \"\\n\"\n                 << Simulator::Now().GetMilliSeconds() << \"\\t\"\n                 << totalBytesSent - *previousBytesSent << std::endl;\n\n    *previousWindowBytesSent = totalBytesSent - *previousBytesSent;\n    *previousBytesSent = totalBytesSent;\n};\n\nvoid\nWriteBytesReceived(Ptr<PacketSink> packetSink, uint64_t* previousBytesReceived)\n{\n    uint64_t totalBytesReceived = packetSink->GetTotalRx();\n    *previousBytesReceived = totalBytesReceived;\n};\n\nvoid\nConfigureXrApp(NodeContainer& ueContainer,\n               uint32_t i,\n               Ipv4InterfaceContainer& ueIpIface,\n               enum NrXrConfig config,\n               uint16_t port,\n               std::string transportProtocol,\n               NodeContainer& remoteHostContainer,\n               NetDeviceContainer& ueNetDev,\n               Ptr<NrHelper> nrHelper,\n               EpsBearer& bearer,\n               Ptr<EpcTft> tft,\n               bool isMx1,\n               std::vector<Ptr<EpcTft>>& tfts,\n               ApplicationContainer& serverApps,\n               ApplicationContainer& clientApps,\n               ApplicationContainer& pingApps)\n{\n    XrTrafficMixerHelper trafficMixerHelper;\n    Ipv4Address ipAddress = ueIpIface.GetAddress(i, 0);\n    trafficMixerHelper.ConfigureXr(config);\n    auto it = XrPreconfig.find(config);\n\n    std::vector<Address> addresses;\n    std::vector<InetSocketAddress> localAddresses;\n    for (uint j = 0; j < it->second.size(); j++)\n    {\n        addresses.emplace_back(InetSocketAddress(ipAddress, port + j));\n        // The sink will always listen to the specified ports\n        localAddresses.emplace_back(InetSocketAddress(Ipv4Address::GetAny(), port + j));\n    }\n\n    ApplicationContainer currentUeClientApps;\n    currentUeClientApps.Add(\n        trafficMixerHelper.Install(transportProtocol, addresses, remoteHostContainer.Get(0)));\n\n    // Seed the ARP cache by pinging early in the simulation\n    // This is a workaround until a static ARP capability is provided\n    PingHelper ping(ipAddress);\n    pingApps.Add(ping.Install(remoteHostContainer));\n\n    Ptr<NetDevice> ueDevice = ueNetDev.Get(i);\n    // Activate a dedicated bearer for the traffic type per node\n    nrHelper->ActivateDedicatedEpsBearer(ueDevice, bearer, tft);\n    // Activate a dedicated bearer for the traffic type per node\n    if (isMx1)\n    {\n        nrHelper->ActivateDedicatedEpsBearer(ueDevice, bearer, tft);\n    }\n    else\n    {\n        NS_ASSERT(tfts.size() >= currentUeClientApps.GetN());\n        for (uint32_t j = 0; j < currentUeClientApps.GetN(); j++)\n        {\n            nrHelper->ActivateDedicatedEpsBearer(ueDevice, bearer, tfts[j]);\n        }\n    }\n\n    for (uint32_t j = 0; j < currentUeClientApps.GetN(); j++)\n    {\n        PacketSinkHelper dlPacketSinkHelper(transportProtocol, localAddresses.at(j));\n        Ptr<Application> packetSink = dlPacketSinkHelper.Install(ueContainer.Get(i)).Get(0);\n        serverApps.Add(packetSink);\n    }\n    clientApps.Add(currentUeClientApps);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    // set simulation time and mobility\n    uint32_t appDuration = 10000;\n    uint32_t appStartTimeMs = 400;\n    uint16_t numerology = 0;\n    uint16_t arUeNum = 1;\n    uint16_t vrUeNum = 1;\n    uint16_t cgUeNum = 1;\n    double centralFrequency = 4e9;\n    double bandwidth = 10e6;\n    double txPower = 41;\n    bool isMx1 = true;\n    bool useUdp = true;\n    double distance = 450;\n    uint32_t rngRun = 1;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"arUeNum\", \"The number of AR UEs\", arUeNum);\n    cmd.AddValue(\"vrUeNum\", \"The number of VR UEs\", vrUeNum);\n    cmd.AddValue(\"cgUeNum\", \"The number of CG UEs\", cgUeNum);\n    cmd.AddValue(\"numerology\", \"The numerology to be used.\", numerology);\n    cmd.AddValue(\"txPower\", \"Tx power to be configured to gNB\", txPower);\n    cmd.AddValue(\"frequency\", \"The system frequency\", centralFrequency);\n    cmd.AddValue(\"bandwidth\", \"The system bandwidth\", bandwidth);\n    cmd.AddValue(\"useUdp\",\n                 \"if true, the NGMN applications will run over UDP connection, otherwise a TCP \"\n                 \"connection will be used.\",\n                 useUdp);\n    cmd.AddValue(\"distance\",\n                 \"The radius of the disc (in meters) that the UEs will be distributed.\"\n                 \"Default value is 450m\",\n                 distance);\n    cmd.AddValue(\"isMx1\",\n                 \"if true M SDFs will be mapped to 1 DRB, otherwise the mapping will \"\n                 \"be 1x1, i.e., 1 SDF to 1 DRB.\",\n                 isMx1);\n    cmd.AddValue(\"rngRun\", \"Rng run random number.\", rngRun);\n    cmd.AddValue(\"appDuration\", \"Duration of the application in milliseconds.\", appDuration);\n    cmd.Parse(argc, argv);\n\n    NS_ABORT_MSG_IF(appDuration < 1000, \"The appDuration should be at least 1000ms.\");\n    NS_ABORT_MSG_IF(\n        !vrUeNum && !arUeNum && !cgUeNum,\n        \"Activate at least one type of XR traffic by configuring the number of XR users\");\n\n    uint32_t simTimeMs = appStartTimeMs + appDuration + 2000;\n\n    // Set simulation run number\n    SeedManager::SetRun(rngRun);\n\n    // setup the nr simulation\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n    // simple band configuration and initialize\n    CcBwpCreator ccBwpCreator;\n    CcBwpCreator::SimpleOperationBandConf bandConf(centralFrequency,\n                                                   bandwidth,\n                                                   1,\n                                                   BandwidthPartInfo::UMa_LoS);\n\n    OperationBandInfo band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);\n    nrHelper->InitializeOperationBand(&band);\n    BandwidthPartInfoPtrVector allBwps = CcBwpCreator::GetAllBwps({band});\n\n    nrHelper->SetGnbPhyAttribute(\"TxPower\", DoubleValue(txPower));\n    nrHelper->SetGnbPhyAttribute(\"Numerology\", UintegerValue(numerology));\n    nrHelper->SetGnbPhyAttribute(\"NoiseFigure\", DoubleValue(5));\n    nrHelper->SetUePhyAttribute(\"TxPower\", DoubleValue(23));\n    nrHelper->SetUePhyAttribute(\"NoiseFigure\", DoubleValue(7));\n\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n    Config::SetDefault(\"ns3::LteEnbRrc::EpsBearerToRlcMapping\",\n                       EnumValue(useUdp ? LteEnbRrc::RLC_UM_ALWAYS : LteEnbRrc::RLC_AM_ALWAYS));\n\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(4));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(8));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<ThreeGppAntennaModel>()));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaHorizontalSpacing\", DoubleValue(0.5));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaVerticalSpacing\", DoubleValue(0.8));\n    nrHelper->SetGnbAntennaAttribute(\"DowntiltAngle\", DoubleValue(0 * M_PI / 180.0));\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(1));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(1));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Beamforming method\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                         TypeIdValue(DirectPathBeamforming::GetTypeId()));\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    nrHelper->SetEpcHelper(epcHelper);\n    epcHelper->SetAttribute(\"S1uLinkDelay\", TimeValue(MilliSeconds(0)));\n\n    // Initialize nrHelper\n    nrHelper->Initialize();\n\n    NodeContainer gNbNodes;\n    NodeContainer ueNodes;\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    const double gNbHeight = 25;\n    const double ueHeight = 1.5;\n\n    gNbNodes.Create(1);\n    ueNodes.Create(arUeNum + vrUeNum + cgUeNum);\n\n    Ptr<ListPositionAllocator> bsPositionAlloc = CreateObject<ListPositionAllocator>();\n    bsPositionAlloc->Add(Vector(0.0, 0.0, gNbHeight));\n    mobility.SetPositionAllocator(bsPositionAlloc);\n    mobility.Install(gNbNodes);\n\n    Ptr<RandomDiscPositionAllocator> ueDiscPositionAlloc =\n        CreateObject<RandomDiscPositionAllocator>();\n    ueDiscPositionAlloc->SetX(0.0);\n    ueDiscPositionAlloc->SetY(0.0);\n    ueDiscPositionAlloc->SetZ(ueHeight);\n    mobility.SetPositionAllocator(ueDiscPositionAlloc);\n\n    for (uint32_t i = 0; i < ueNodes.GetN(); i++)\n    {\n        mobility.Install(ueNodes.Get(i));\n    }\n\n    /*\n     * Create various NodeContainer(s) for the different traffic types.\n     * In ueArContainer, ueVrContainer, ueCgContainer, we will put\n     * AR, VR, CG UEs, respectively.*/\n    NodeContainer ueArContainer;\n    NodeContainer ueVrContainer;\n    NodeContainer ueCgContainer;\n\n    for (auto j = 0; j < arUeNum; ++j)\n    {\n        Ptr<Node> ue = ueNodes.Get(j);\n        ueArContainer.Add(ue);\n    }\n    for (auto j = arUeNum; j < arUeNum + vrUeNum; ++j)\n    {\n        Ptr<Node> ue = ueNodes.Get(j);\n        ueVrContainer.Add(ue);\n    }\n    for (auto j = arUeNum + vrUeNum; j < arUeNum + vrUeNum + cgUeNum; ++j)\n    {\n        Ptr<Node> ue = ueNodes.Get(j);\n        ueCgContainer.Add(ue);\n    }\n\n    NetDeviceContainer gNbNetDev = nrHelper->InstallGnbDevice(gNbNodes, allBwps);\n    NetDeviceContainer ueArNetDev = nrHelper->InstallUeDevice(ueArContainer, allBwps);\n    NetDeviceContainer ueVrNetDev = nrHelper->InstallUeDevice(ueVrContainer, allBwps);\n    NetDeviceContainer ueCgNetDev = nrHelper->InstallUeDevice(ueCgContainer, allBwps);\n\n    int64_t randomStream = 1;\n    randomStream += nrHelper->AssignStreams(gNbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueArNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueVrNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueCgNetDev, randomStream);\n\n    for (auto it = gNbNetDev.Begin(); it != gNbNetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n    for (auto it = ueArNetDev.Begin(); it != ueArNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n    for (auto it = ueVrNetDev.Begin(); it != ueVrNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n    for (auto it = ueCgNetDev.Begin(); it != ueCgNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(1000));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.000)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(ueNodes);\n\n    Ipv4InterfaceContainer ueArIpIface;\n    Ipv4InterfaceContainer ueVrIpIface;\n    Ipv4InterfaceContainer ueCgIpIface;\n\n    ueArIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueArNetDev));\n    ueVrIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueVrNetDev));\n    ueCgIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueCgNetDev));\n\n    // Set the default gateway for the UEs\n    for (uint32_t j = 0; j < ueNodes.GetN(); ++j)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(ueNodes.Get(j)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // attach UEs to the closest eNB\n    nrHelper->AttachToClosestEnb(ueArNetDev, gNbNetDev);\n    nrHelper->AttachToClosestEnb(ueVrNetDev, gNbNetDev);\n    nrHelper->AttachToClosestEnb(ueCgNetDev, gNbNetDev);\n\n    // Install sink application\n    ApplicationContainer serverApps;\n\n    // configure the transport protocol to be used\n    std::string transportProtocol;\n    transportProtocol = useUdp == true ? \"ns3::UdpSocketFactory\" : \"ns3::TcpSocketFactory\";\n    uint16_t dlPortArStart = 1121; // AR has 3 flows\n    uint16_t dlPortArStop = 1124;\n    uint16_t dlPortVrStart = 1131;\n    uint16_t dlPortCgStart = 1141;\n\n    // The bearer that will carry AR traffic\n    EpsBearer arBearer(EpsBearer::NGBR_LOW_LAT_EMBB);\n    Ptr<EpcTft> arTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfAr;\n    std::vector<Ptr<EpcTft>> arTfts;\n\n    if (isMx1)\n    {\n        dlpfAr.localPortStart = dlPortArStart;\n        dlpfAr.localPortEnd = dlPortArStop;\n        arTft->Add(dlpfAr);\n    }\n    else\n    {\n        // create 3 xrTfts for 1x1 mapping\n        for (uint32_t i = 0; i < 3; i++)\n        {\n            Ptr<EpcTft> tempTft = Create<EpcTft>();\n            dlpfAr.localPortStart = dlPortArStart + i;\n            dlpfAr.localPortEnd = dlPortArStart + i;\n            tempTft->Add(dlpfAr);\n            arTfts.emplace_back(tempTft);\n        }\n    }\n    // The bearer that will carry VR traffic\n    EpsBearer vrBearer(EpsBearer::NGBR_LOW_LAT_EMBB);\n\n    Ptr<EpcTft> vrTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfVr;\n    dlpfVr.localPortStart = dlPortVrStart;\n    dlpfVr.localPortEnd = dlPortVrStart;\n    vrTft->Add(dlpfVr);\n\n    // The bearer that will carry CG traffic\n    EpsBearer cgBearer(EpsBearer::NGBR_LOW_LAT_EMBB);\n\n    Ptr<EpcTft> cgTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfCg;\n    dlpfCg.localPortStart = dlPortCgStart;\n    dlpfCg.localPortEnd = dlPortCgStart;\n    cgTft->Add(dlpfCg);\n\n    // Install traffic generators\n    ApplicationContainer clientApps;\n    ApplicationContainer pingApps;\n\n    std::ostringstream xrFileTag;\n\n    for (uint32_t i = 0; i < ueArContainer.GetN(); ++i)\n    {\n        ConfigureXrApp(ueArContainer,\n                       i,\n                       ueArIpIface,\n                       AR_M3,\n                       dlPortArStart,\n                       transportProtocol,\n                       remoteHostContainer,\n                       ueArNetDev,\n                       nrHelper,\n                       arBearer,\n                       arTft,\n                       isMx1,\n                       arTfts,\n                       serverApps,\n                       clientApps,\n                       pingApps);\n    }\n    // TODO for VR and CG of 2 flows Tfts and isMx1 have to be set. Currently they are\n    // hardcoded for 1 flow\n    for (uint32_t i = 0; i < ueVrContainer.GetN(); ++i)\n    {\n        ConfigureXrApp(ueVrContainer,\n                       i,\n                       ueVrIpIface,\n                       VR_DL1,\n                       dlPortVrStart,\n                       transportProtocol,\n                       remoteHostContainer,\n                       ueVrNetDev,\n                       nrHelper,\n                       vrBearer,\n                       vrTft,\n                       1,\n                       arTfts,\n                       serverApps,\n                       clientApps,\n                       pingApps);\n    }\n    for (uint32_t i = 0; i < ueCgContainer.GetN(); ++i)\n    {\n        ConfigureXrApp(ueCgContainer,\n                       i,\n                       ueCgIpIface,\n                       CG_DL1,\n                       dlPortCgStart,\n                       transportProtocol,\n                       remoteHostContainer,\n                       ueCgNetDev,\n                       nrHelper,\n                       cgBearer,\n                       cgTft,\n                       1,\n                       arTfts,\n                       serverApps,\n                       clientApps,\n                       pingApps);\n    }\n\n    pingApps.Start(MilliSeconds(100));\n    pingApps.Stop(MilliSeconds(appStartTimeMs));\n\n    // start server and client apps\n    serverApps.Start(MilliSeconds(appStartTimeMs));\n    clientApps.Start(MilliSeconds(appStartTimeMs));\n    serverApps.Stop(MilliSeconds(simTimeMs));\n    clientApps.Stop(MilliSeconds(appStartTimeMs + appDuration));\n\n    FlowMonitorHelper flowmonHelper;\n    NodeContainer endpointNodes;\n    endpointNodes.Add(remoteHost);\n    endpointNodes.Add(ueNodes);\n\n    Ptr<ns3::FlowMonitor> monitor = flowmonHelper.Install(endpointNodes);\n    monitor->SetAttribute(\"DelayBinWidth\", DoubleValue(0.0001));\n    monitor->SetAttribute(\"JitterBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"PacketSizeBinWidth\", DoubleValue(20));\n\n    Simulator::Stop(MilliSeconds(simTimeMs));\n    Simulator::Run();\n\n    // Print per-flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier =\n        DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n\n    double averageFlowThroughput = 0.0;\n    double averageFlowDelay = 0.0;\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin();\n         i != stats.end();\n         ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        std::stringstream protoStream;\n        protoStream << (uint16_t)t.protocol;\n        if (t.protocol == 6)\n        {\n            protoStream.str(\"TCP\");\n        }\n        if (t.protocol == 17)\n        {\n            protoStream.str(\"UDP\");\n        }\n\n        Time txDuration = MilliSeconds(appDuration);\n        std::cout << \"Flow \" << i->first << \" (\" << t.sourceAddress << \":\" << t.sourcePort << \" -> \"\n                  << t.destinationAddress << \":\" << t.destinationPort << \") proto \"\n                  << protoStream.str() << \"\\n\";\n        std::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n        std::cout << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n        std::cout << \"  TxOffered:  \"\n                  << ((i->second.txBytes * 8.0) / txDuration.GetSeconds()) * 1e-6 << \" Mbps\\n\";\n        std::cout << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n\n        if (i->second.rxPackets > 0)\n        {\n            // Measure the duration of the flow from receiver's perspective\n            Time rxDuration = i->second.timeLastRxPacket - i->second.timeFirstTxPacket;\n            averageFlowThroughput += ((i->second.rxBytes * 8.0) / rxDuration.GetSeconds()) * 1e-6;\n            averageFlowDelay += 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;\n\n            double throughput = ((i->second.rxBytes * 8.0) / rxDuration.GetSeconds()) * 1e-6;\n            double delay = 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;\n            double jitter = 1000 * i->second.jitterSum.GetSeconds() / i->second.rxPackets;\n\n            std::cout << \"  Throughput: \" << throughput << \" Mbps\\n\";\n            std::cout << \"  Mean delay:  \" << delay << \" ms\\n\";\n            std::cout << \"  Mean jitter:  \" << jitter << \" ms\\n\";\n        }\n        else\n        {\n            std::cout << \"  Throughput:  0 Mbps\\n\";\n            std::cout << \"  Mean delay:  0 ms\\n\";\n            std::cout << \"  Mean upt:  0  Mbps \\n\";\n            std::cout << \"  Mean jitter: 0 ms\\n\";\n        }\n        std::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n    }\n\n    std::cout << \"\\n\\n  Mean flow throughput: \" << averageFlowThroughput / stats.size()\n              << \"Mbps \\n\";\n    std::cout << \"  Mean flow delay: \" << averageFlowDelay / stats.size() << \" ms\\n\";\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/cttc-nr-traffic-ngmn-mixed.cc",
      "code": "// Copyright (c) 2023 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n/**\n * \\ingroup examples\n * \\file cttc-nr-traffic-ngmn-mixed.cc\n * \\brief A hegagonal topology example used to show how to configure different\n * NGMN types of traffics or NGMN mixed scenario\n *\n * The example consists of an hexagonal grid deployment\n * consisting on a central site and a number of outer rings of sites around this\n * central site. Each site is sectorized, meaning that a number of three antenna\n * arrays or panels are deployed per gNB. These three antennas are pointing to\n * 30\u00ba, 150\u00ba and 270\u00ba w.r.t. the horizontal axis.\n * We allocate a band to each sector of a site, and the bands are contiguous in frequency.\n * We provide a number of simulation parameters that can be configured in the\n * command line.\n *\n * Please have a look at the possible parameters to know what you can configure\n * through the command line.\n *\n * \\code{.unparsed}\n$ ./ns3 run \"cttc-nr-traffic-ngmn-mixed --PrintHelp\"\n    \\endcode\n *\n * The example will print on-screen the end-to-end result of each flow,\n * as well as writing them on a file.\n *\n */\n\n/*\n * Include part. Often, you will have to include the headers for an entire module;\n * do that by including the name of the module you need with the suffix \"-module.h\".\n */\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/config-store.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include <ns3/antenna-module.h>\n#include <ns3/ping-helper.h>\n#include <ns3/radio-environment-map-helper.h>\n#include <ns3/rng-seed-manager.h>\n#include <ns3/three-gpp-ftp-m1-helper.h>\n#include <ns3/three-gpp-http-client.h>\n#include <ns3/three-gpp-http-helper.h>\n#include <ns3/three-gpp-http-server.h>\n#include <ns3/three-gpp-http-variables.h>\n#include <ns3/traffic-generator-ngmn-ftp-multi.h>\n#include <ns3/traffic-generator-ngmn-gaming.h>\n#include <ns3/traffic-generator-ngmn-video.h>\n#include <ns3/traffic-generator-ngmn-voip.h>\n\n#include <algorithm>\n#include <iostream>\n\nusing namespace ns3;\n\n/*\n * With this line, we will be able to see the logs of the file by enabling the\n * component \"CttcTrafficExample\", in this way:\n *\n * $ export NS_LOG=\"CttcTrafficExample=level_info|prefix_func|prefix_time\"\n */\nNS_LOG_COMPONENT_DEFINE(\"CttcNrTrafficNgmnMixed\");\n\nclass RadioNetworkParametersHelper\n{\n  public:\n    /**\n     * \\brief Set the main radio network parameters.\n     * \\param freqReuse The cell frequency reuse.\n     */\n    void SetNetworkParams(const std::string scenario,\n                          const std::string operationMode,\n                          uint16_t numCcs);\n    /**\n     * \\brief Gets the BS transmit power\n     * \\return Transmit power in dBW\n     */\n    double GetTxPower();\n\n    /**\n     * \\brief Gets the operation bandwidth\n     * \\return Bandwidth in Hz\n     */\n    double GetBandwidth();\n\n    /**\n     * \\brief Gets the central frequency\n     * \\return Central frequency in Hz\n     */\n    double GetCentralFrequency();\n\n  private:\n    double m_txPower{-1.0};          //!< Transmit power in dBm\n    double m_bandwidth{0.0};         //!< System bandwidth in Hz\n    double m_centralFrequency{-1.0}; //!< Band central frequency in Hz\n};\n\nvoid\nRadioNetworkParametersHelper::SetNetworkParams(const std::string scenario,\n                                               const std::string operationMode,\n                                               uint16_t numCcs)\n{\n    NS_ABORT_MSG_IF(scenario != \"UMa\" && scenario != \"UMi\", \"Unsupported scenario\");\n\n    m_centralFrequency = 2e9;\n    m_bandwidth = 20e6 * numCcs; // 100 RBs per CC (freqReuse)\n    if (operationMode == \"FDD\")\n    {\n        m_bandwidth += m_bandwidth;\n    }\n    if (scenario == \"UMa\")\n    {\n        m_txPower = 43;\n    }\n    else\n    {\n        m_txPower = 30;\n    }\n}\n\ndouble\nRadioNetworkParametersHelper::GetTxPower()\n{\n    return m_txPower;\n}\n\ndouble\nRadioNetworkParametersHelper::GetBandwidth()\n{\n    return m_bandwidth;\n}\n\ndouble\nRadioNetworkParametersHelper::GetCentralFrequency()\n{\n    return m_centralFrequency;\n}\n\nvoid\nSet5gLenaSimulatorParameters(HexagonalGridScenarioHelper gridScenario,\n                             std::string scenario,\n                             std::string radioNetwork,\n                             std::string operationMode,\n                             std::string direction,\n                             NodeContainer gnbSector1Container,\n                             NodeContainer gnbSector2Container,\n                             NodeContainer gnbSector3Container,\n                             NodeContainer ueSector1Container,\n                             NodeContainer ueSector2Container,\n                             NodeContainer ueSector3Container,\n                             Ptr<PointToPointEpcHelper>& baseEpcHelper,\n                             Ptr<NrHelper>& nrHelper,\n                             NetDeviceContainer& gnbSector1NetDev,\n                             NetDeviceContainer& gnbSector2NetDev,\n                             NetDeviceContainer& gnbSector3NetDev,\n                             NetDeviceContainer& ueSector1NetDev,\n                             NetDeviceContainer& ueSector2NetDev,\n                             NetDeviceContainer& ueSector3NetDev,\n                             bool uniformLambda)\n{\n    /*\n     * Create the radio network related parameters\n     */\n    RadioNetworkParametersHelper ranHelper;\n    ranHelper.SetNetworkParams(scenario, operationMode, 1);\n\n    /*\n     * Setup the NR module. We create the various helpers needed for the\n     * NR simulation:\n     * - IdealBeamformingHelper, which takes care of the beamforming part\n     * - NrHelper, which takes care of creating and connecting the various\n     * part of the NR stack\n     */\n\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    nrHelper = CreateObject<NrHelper>();\n\n    // Put the pointers inside nrHelper\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n\n    Ptr<NrPointToPointEpcHelper> epcHelper = DynamicCast<NrPointToPointEpcHelper>(baseEpcHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    /*\n     * Spectrum division. We create one operational band containing three\n     * component carriers, and each CC containing a single bandwidth part\n     * centered at the frequency specified by the input parameters.\n     * Each spectrum part length is, as well, specified by the input parameters.\n     * The operational band will use StreetCanyon channel or UrbanMacro modeling.\n     */\n    BandwidthPartInfoPtrVector allBwps, bwps1, bwps2, bwps3;\n    CcBwpCreator ccBwpCreator;\n    // Create the configuration for the CcBwpHelper. SimpleOperationBandConf creates\n    // a single BWP per CC. Get the spectrum values from the RadioNetworkParametersHelper\n    double centralFrequencyBand = ranHelper.GetCentralFrequency();\n    double bandwidthBand = ranHelper.GetBandwidth();\n    const uint8_t numCcPerBand = 1; // In this example, each cell will have one CC with one BWP\n    BandwidthPartInfo::Scenario scene;\n    if (scenario == \"UMi\")\n    {\n        scene = BandwidthPartInfo::UMi_StreetCanyon;\n    }\n    else if (scenario == \"UMa\")\n    {\n        scene = BandwidthPartInfo::UMa;\n    }\n    else\n    {\n        NS_ABORT_MSG(\"Unsupported scenario\");\n    }\n\n    /*\n     * Attributes of ThreeGppChannelModel still cannot be set in our way.\n     * TODO: Coordinate with Tommaso\n     */\n    Config::SetDefault(\"ns3::ThreeGppChannelModel::UpdatePeriod\",\n                       TimeValue(MilliSeconds(0))); // 100ms\n    nrHelper->SetChannelConditionModelAttribute(\"UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n\n    std::string errorModel = \"\";\n\n    if (radioNetwork == \"LTE\")\n    {\n        errorModel = \"ns3::LenaErrorModel\";\n    }\n    else if (radioNetwork == \"NR\")\n    {\n        errorModel = \"ns3::NrEesmIrT2\";\n    }\n\n    // Error Model: UE and GNB with same spectrum error model.\n    nrHelper->SetUlErrorModel(errorModel);\n    nrHelper->SetDlErrorModel(errorModel);\n\n    // Both DL and UL AMC will have the same model behind.\n    nrHelper->SetGnbDlAmcAttribute(\n        \"AmcModel\",\n        EnumValue(NrAmc::ErrorModel)); // NrAmc::ShannonModel or NrAmc::ErrorModel\n    nrHelper->SetGnbUlAmcAttribute(\n        \"AmcModel\",\n        EnumValue(NrAmc::ErrorModel)); // NrAmc::ShannonModel or NrAmc::ErrorModel\n\n    /*\n     * Create the necessary operation bands. In this example, each sector operates\n     * in a separate band. Each band contains a single component carrier (CC),\n     * which is made of one BWP in TDD operation mode or two BWPs in FDD mode.\n     * Note that BWPs have the same bandwidth. Therefore, CCs and bands in FDD are\n     * twice larger than in TDD.\n     *\n     * The configured spectrum division for TDD operation is:\n     * |---Band1---|---Band2---|---Band3---|\n     * |----CC1----|----CC2----|----CC3----|\n     * |----BWP1---|----BWP2---|----BWP3---|\n     *\n     * And the configured spectrum division for FDD operation is:\n     * |---------Band1---------|---------Band2---------|---------Band3---------|\n     * |----------CC1----------|----------CC2----------|----------CC3----------|\n     * |----BWP1---|----BWP2---|----BWP3---|----BWP4---|----BWP5---|----BWP6---|\n     */\n    double centralFrequencyBand1 = centralFrequencyBand - bandwidthBand;\n    double centralFrequencyBand2 = centralFrequencyBand;\n    double centralFrequencyBand3 = centralFrequencyBand + bandwidthBand;\n    double bandwidthBand1 = bandwidthBand;\n    double bandwidthBand2 = bandwidthBand;\n    double bandwidthBand3 = bandwidthBand;\n\n    uint8_t numBwpPerCc = 1;\n    if (operationMode == \"FDD\")\n    {\n        numBwpPerCc = 2; // FDD will have 2 BWPs per CC\n    }\n\n    CcBwpCreator::SimpleOperationBandConf bandConf1(centralFrequencyBand1,\n                                                    bandwidthBand1,\n                                                    numCcPerBand,\n                                                    scene);\n    bandConf1.m_numBwp = numBwpPerCc; // FDD will have 2 BWPs per CC\n    CcBwpCreator::SimpleOperationBandConf bandConf2(centralFrequencyBand2,\n                                                    bandwidthBand2,\n                                                    numCcPerBand,\n                                                    scene);\n    bandConf2.m_numBwp = numBwpPerCc; // FDD will have 2 BWPs per CC\n    CcBwpCreator::SimpleOperationBandConf bandConf3(centralFrequencyBand3,\n                                                    bandwidthBand3,\n                                                    numCcPerBand,\n                                                    scene);\n    bandConf3.m_numBwp = numBwpPerCc; // FDD will have 2 BWPs per CC\n\n    // By using the configuration created, it is time to make the operation bands\n    OperationBandInfo band1 = ccBwpCreator.CreateOperationBandContiguousCc(bandConf1);\n    OperationBandInfo band2 = ccBwpCreator.CreateOperationBandContiguousCc(bandConf2);\n    OperationBandInfo band3 = ccBwpCreator.CreateOperationBandContiguousCc(bandConf3);\n\n    /*\n     * Initialize channel and pathloss, plus other things inside band1. If needed,\n     * the band configuration can be done manually, but we leave it for more\n     * sophisticated examples. For the moment, this method will take care\n     * of all the spectrum initialization needs.\n     */\n    nrHelper->InitializeOperationBand(&band1);\n    nrHelper->InitializeOperationBand(&band2);\n    nrHelper->InitializeOperationBand(&band3);\n    allBwps = CcBwpCreator::GetAllBwps({band1, band2, band3});\n    bwps1 = CcBwpCreator::GetAllBwps({band1});\n    bwps2 = CcBwpCreator::GetAllBwps({band2});\n    bwps3 = CcBwpCreator::GetAllBwps({band3});\n\n    double txPower = ranHelper.GetTxPower(); // Convert to mW\n\n    /*\n     * allBwps contains all the spectrum configuration needed for the nrHelper.\n     *\n     * Now, we can setup the attributes. We can have three kind of attributes:\n     * (i) parameters that are valid for all the bandwidth parts and applies to\n     * all nodes, (ii) parameters that are valid for all the bandwidth parts\n     * and applies to some node only, and (iii) parameters that are different for\n     * every bandwidth parts. The approach is:\n     *\n     * - for (i): Configure the attribute through the helper, and then install;\n     * - for (ii): Configure the attribute through the helper, and then install\n     * for the first set of nodes. Then, change the attribute through the helper,\n     * and install again;\n     * - for (iii): Install, and then configure the attributes by retrieving\n     * the pointer needed, and calling \"SetAttribute\" on top of such pointer.\n     *\n     */\n\n    Packet::EnableChecking();\n    Packet::EnablePrinting();\n\n    /*\n     *  Case (i): Attributes valid for all the nodes\n     */\n    // Beamforming method\n    if (radioNetwork == \"LTE\")\n    {\n        idealBeamformingHelper->SetAttribute(\n            \"BeamformingMethod\",\n            TypeIdValue(QuasiOmniDirectPathBeamforming::GetTypeId()));\n    }\n    else\n    {\n        idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                             TypeIdValue(DirectPathBeamforming::GetTypeId()));\n    }\n\n    // Scheduler type\n    if (radioNetwork == \"LTE\")\n    {\n        nrHelper->SetSchedulerTypeId(TypeId::LookupByName(\"ns3::NrMacSchedulerOfdmaPF\"));\n        nrHelper->SetSchedulerAttribute(\"DlCtrlSymbols\", UintegerValue(1));\n    }\n    // Core latency\n    epcHelper->SetAttribute(\"S1uLinkDelay\", TimeValue(MilliSeconds(0)));\n\n    // Antennas for all the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(1));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(1));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Antennas for all the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(8));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(8));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<ThreeGppAntennaModel>()));\n\n    // Set numerology\n    nrHelper->SetGnbPhyAttribute(\"Numerology\", UintegerValue(1));\n    // Set gNB TX power\n    nrHelper->SetGnbPhyAttribute(\"TxPower\", DoubleValue(txPower));\n    // UE transmit power\n    nrHelper->SetUePhyAttribute(\"TxPower\", DoubleValue(20.0));\n\n    // Set LTE RBG size\n    if (radioNetwork == \"LTE\")\n    {\n        nrHelper->SetGnbMacAttribute(\"NumRbPerRbg\", UintegerValue(4));\n    }\n\n    // We assume a common traffic pattern for all UEs\n    uint32_t bwpIdForLowLat = 0;\n    if (operationMode == \"FDD\" && direction == \"UL\")\n    {\n        bwpIdForLowLat = 1;\n    }\n\n    // TODO check later when QoS scheduler is in place, that the type of bearer coresponds to the\n    // type of traffic gNb routing between Bearer and bandwidth part\n    nrHelper->SetGnbBwpManagerAlgorithmAttribute(\"NGBR_VIDEO_TCP_DEFAULT\",\n                                                 UintegerValue(bwpIdForLowLat));\n\n    // Ue routing between Bearer and bandwidth part\n    nrHelper->SetUeBwpManagerAlgorithmAttribute(\"NGBR_VIDEO_TCP_DEFAULT\",\n                                                UintegerValue(bwpIdForLowLat));\n\n    /*\n     * We have configured the attributes we needed. Now, install and get the pointers\n     * to the NetDevices, which contains all the NR stack:\n     */\n\n    //  NetDeviceContainer enbNetDev = nrHelper->InstallGnbDevice (gridScenario.GetBaseStations (),\n    //  allBwps);\n    gnbSector1NetDev = nrHelper->InstallGnbDevice(gnbSector1Container, bwps1);\n    gnbSector2NetDev = nrHelper->InstallGnbDevice(gnbSector2Container, bwps2);\n    gnbSector3NetDev = nrHelper->InstallGnbDevice(gnbSector3Container, bwps3);\n    ueSector1NetDev = nrHelper->InstallUeDevice(ueSector1Container, bwps1);\n    ueSector2NetDev = nrHelper->InstallUeDevice(ueSector2Container, bwps2);\n    ueSector3NetDev = nrHelper->InstallUeDevice(ueSector3Container, bwps3);\n\n    int64_t randomStream = 1;\n    randomStream += nrHelper->AssignStreams(gnbSector1NetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(gnbSector2NetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(gnbSector3NetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueSector1NetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueSector2NetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueSector3NetDev, randomStream);\n\n    /*\n     * Case (iii): Go node for node and change the attributes we have to setup\n     * per-node.\n     */\n\n    // Sectors (cells) of a site are pointing at different directions\n    double orientationRads = gridScenario.GetAntennaOrientationRadians(0);\n    for (uint32_t numCell = 0; numCell < gnbSector1NetDev.GetN(); ++numCell)\n    {\n        Ptr<NetDevice> gnb = gnbSector1NetDev.Get(numCell);\n        uint32_t numBwps = nrHelper->GetNumberBwp(gnb);\n        if (numBwps == 1) // TDD\n        {\n            // Change the antenna orientation\n            Ptr<NrGnbPhy> phy = nrHelper->GetGnbPhy(gnb, 0);\n            Ptr<UniformPlanarArray> antenna =\n                DynamicCast<UniformPlanarArray>(phy->GetSpectrumPhy(0)->GetAntenna());\n            antenna->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n            // Set TDD pattern\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"Pattern\",\n                                                      StringValue(\"F|F|F|F|F|F|F|F|F|F|\"));\n        }\n\n        else if (numBwps == 2) // FDD\n        {\n            // Change the antenna orientation\n            Ptr<NrGnbPhy> phy0 = nrHelper->GetGnbPhy(gnb, 0);\n            Ptr<UniformPlanarArray> antenna0 =\n                DynamicCast<UniformPlanarArray>(phy0->GetSpectrumPhy(0)->GetAntenna());\n            antenna0->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n            Ptr<NrGnbPhy> phy1 = nrHelper->GetGnbPhy(gnb, 1);\n            Ptr<UniformPlanarArray> antenna1 =\n                DynamicCast<UniformPlanarArray>(phy1->GetSpectrumPhy(0)->GetAntenna());\n            antenna1->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n            // Set TDD pattern\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\n                \"Pattern\",\n                StringValue(\"DL|DL|DL|DL|DL|DL|DL|DL|DL|DL|\"));\n            nrHelper->GetGnbPhy(gnb, 1)->SetAttribute(\n                \"Pattern\",\n                StringValue(\"UL|UL|UL|UL|UL|UL|UL|UL|UL|UL|\"));\n\n            // Link the two FDD BWP\n            nrHelper->GetBwpManagerGnb(gnb)->SetOutputLink(1, 0);\n        }\n\n        else\n        {\n            NS_ABORT_MSG(\"Incorrect number of BWPs per CC\");\n        }\n    }\n\n    orientationRads = gridScenario.GetAntennaOrientationRadians(1);\n    for (uint32_t numCell = 0; numCell < gnbSector2NetDev.GetN(); ++numCell)\n    {\n        Ptr<NetDevice> gnb = gnbSector2NetDev.Get(numCell);\n        uint32_t numBwps = nrHelper->GetNumberBwp(gnb);\n        if (numBwps == 1) // TDD\n        {\n            // Change the antenna orientation\n            Ptr<NrGnbPhy> phy = nrHelper->GetGnbPhy(gnb, 0);\n            Ptr<UniformPlanarArray> antenna =\n                DynamicCast<UniformPlanarArray>(phy->GetSpectrumPhy(0)->GetAntenna());\n            antenna->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n            // Set TDD pattern\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"Pattern\",\n                                                      StringValue(\"F|F|F|F|F|F|F|F|F|F|\"));\n        }\n\n        else if (numBwps == 2) // FDD\n        {\n            // Change the antenna orientation\n            Ptr<NrGnbPhy> phy0 = nrHelper->GetGnbPhy(gnb, 0);\n            Ptr<UniformPlanarArray> antenna0 =\n                DynamicCast<UniformPlanarArray>(phy0->GetSpectrumPhy(0)->GetAntenna());\n            antenna0->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n            Ptr<NrGnbPhy> phy1 = nrHelper->GetGnbPhy(gnb, 1);\n            Ptr<UniformPlanarArray> antenna1 =\n                DynamicCast<UniformPlanarArray>(phy1->GetSpectrumPhy(0)->GetAntenna());\n            antenna1->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n            // Set TDD pattern\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\n                \"Pattern\",\n                StringValue(\"DL|DL|DL|DL|DL|DL|DL|DL|DL|DL|\"));\n            nrHelper->GetGnbPhy(gnb, 1)->SetAttribute(\n                \"Pattern\",\n                StringValue(\"UL|UL|UL|UL|UL|UL|UL|UL|UL|UL|\"));\n            // Link the two FDD BWP\n            nrHelper->GetBwpManagerGnb(gnb)->SetOutputLink(1, 0);\n        }\n\n        else\n        {\n            NS_ABORT_MSG(\"Incorrect number of BWPs per CC\");\n        }\n    }\n\n    orientationRads = gridScenario.GetAntennaOrientationRadians(2);\n    for (uint32_t numCell = 0; numCell < gnbSector3NetDev.GetN(); ++numCell)\n    {\n        Ptr<NetDevice> gnb = gnbSector3NetDev.Get(numCell);\n        uint32_t numBwps = nrHelper->GetNumberBwp(gnb);\n        if (numBwps == 1) // TDD\n        {\n            // Change the antenna orientation\n            Ptr<NrGnbPhy> phy = nrHelper->GetGnbPhy(gnb, 0);\n            Ptr<UniformPlanarArray> antenna =\n                DynamicCast<UniformPlanarArray>(phy->GetSpectrumPhy(0)->GetAntenna());\n            antenna->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n            // Set TDD pattern\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\"Pattern\",\n                                                      StringValue(\"F|F|F|F|F|F|F|F|F|F|\"));\n        }\n\n        else if (numBwps == 2) // FDD\n        {\n            // Change the antenna orientation\n            Ptr<NrGnbPhy> phy0 = nrHelper->GetGnbPhy(gnb, 0);\n            Ptr<UniformPlanarArray> antenna0 =\n                DynamicCast<UniformPlanarArray>(phy0->GetSpectrumPhy(0)->GetAntenna());\n            antenna0->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n            Ptr<NrGnbPhy> phy1 = nrHelper->GetGnbPhy(gnb, 1);\n            Ptr<UniformPlanarArray> antenna1 =\n                DynamicCast<UniformPlanarArray>(phy1->GetSpectrumPhy(0)->GetAntenna());\n            antenna1->SetAttribute(\"BearingAngle\", DoubleValue(orientationRads));\n            // Set TDD pattern\n            nrHelper->GetGnbPhy(gnb, 0)->SetAttribute(\n                \"Pattern\",\n                StringValue(\"DL|DL|DL|DL|DL|DL|DL|DL|DL|DL|\"));\n            nrHelper->GetGnbPhy(gnb, 1)->SetAttribute(\n                \"Pattern\",\n                StringValue(\"UL|UL|UL|UL|UL|UL|UL|UL|UL|UL|\"));\n            // Link the two FDD BWP\n            nrHelper->GetBwpManagerGnb(gnb)->SetOutputLink(1, 0);\n        }\n\n        else\n        {\n            NS_ABORT_MSG(\"Incorrect number of BWPs per CC\");\n        }\n    }\n\n    // Set the UE routing:\n\n    if (operationMode == \"FDD\")\n    {\n        for (uint32_t i = 0; i < ueSector1NetDev.GetN(); i++)\n        {\n            nrHelper->GetBwpManagerUe(ueSector1NetDev.Get(i))->SetOutputLink(0, 1);\n        }\n\n        for (uint32_t i = 0; i < ueSector2NetDev.GetN(); i++)\n        {\n            nrHelper->GetBwpManagerUe(ueSector2NetDev.Get(i))->SetOutputLink(0, 1);\n        }\n\n        for (uint32_t i = 0; i < ueSector3NetDev.GetN(); i++)\n        {\n            nrHelper->GetBwpManagerUe(ueSector3NetDev.Get(i))->SetOutputLink(0, 1);\n        }\n    }\n\n    // When all the configuration is done, explicitly call UpdateConfig ()\n\n    for (auto it = gnbSector1NetDev.Begin(); it != gnbSector1NetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n    for (auto it = gnbSector2NetDev.Begin(); it != gnbSector2NetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n    for (auto it = gnbSector3NetDev.Begin(); it != gnbSector3NetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n    for (auto it = ueSector1NetDev.Begin(); it != ueSector1NetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n    for (auto it = ueSector2NetDev.Begin(); it != ueSector2NetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n    for (auto it = ueSector3NetDev.Begin(); it != ueSector3NetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n}\n\nenum TrafficTypeConf\n{\n    UDP_CBR,     // 0\n    FTP_3GPP_M1, // 1\n    NGMN_FTP,    // 2\n    NGMN_VIDEO,  // 3\n    NGMN_HTTP,   // 4\n    NGMN_GAMING, // 5\n    NGMN_VOIP,   // 6\n    NGMN_MIXED   // 7\n};\n\n/**\n * \\brief operator << for TrafficTypeConf\n * \\param os output stream\n * \\param item TrafficType to print\n * \\return a copy of the output stream\n */\nstatic inline std::ostream&\noperator<<(std::ostream& os, const TrafficTypeConf& item)\n{\n    switch (item)\n    {\n    case UDP_CBR:\n        os << \"UDP CBR\";\n        break;\n    case FTP_3GPP_M1:\n        os << \"FTP 3GPP M1\";\n        break;\n    case NGMN_FTP:\n        os << \"NGMN FTP\";\n        break;\n    case NGMN_VIDEO:\n        os << \"NGMN VIDEO\";\n        break;\n    case NGMN_HTTP:\n        os << \"NGMN HTTP\";\n        break;\n    case NGMN_GAMING:\n        os << \"NGMN GAMING\";\n        break;\n    case NGMN_VOIP:\n        os << \"NGMN VOIP\";\n        break;\n    case NGMN_MIXED:\n        os << \"NGMN MIXED\";\n        break;\n    default:\n        NS_ABORT_MSG(\"Unknown traffic type\");\n    }\n    return os;\n}\n\nstatic inline std::istream&\noperator>>(std::istream& is, TrafficTypeConf& item)\n{\n    uint32_t inputValue;\n    is >> inputValue;\n    item = (TrafficTypeConf)inputValue;\n    return is;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    /*\n     * Variables that represent the parameters we will accept as input by the\n     * command line. Each of them is initialized with a default value.\n     */\n\n    TrafficTypeConf trafficTypeConf = FTP_3GPP_M1;\n    // Traffic parameters (that we will use inside this script:)\n    uint32_t udpPacketSize = 600; // bytes\n    // 4000*600*8 = 19.2 Mbps/UE,\n    // 3000*600*8 = 14.4 Mbps/UE,\n    // 2000*600*8 = 9.6 Mbps/UE\n    // 1500*600*8 = 7.2 Mbps/UE\n    // 1000*600*8 = 4.8 Mbps/UE\n    uint32_t udpLambda = 2000;\n    double ftpM1Lambda = 5;\n    uint32_t ftpM1FileSize = 512000; // in bytes\n    Time clientAppStartTime = MilliSeconds(400);\n    Time serverAppStartTime = MilliSeconds(400);\n    // Simulation parameters. Please don't use double to indicate seconds, use\n    // milliseconds and integers to avoid representation errors.\n    uint32_t simTimeMs = 1400;\n    Time appStartTime = MilliSeconds(400);\n    std::string direction = \"DL\";\n    bool uniformLambda = true;\n\n    // topology\n    uint16_t numOuterRings = 0;\n    uint16_t uesPerGnb = 10;\n    std::string scenario = \"UMi\";\n    std::string radioNetwork = \"NR\";   // LTE or NR\n    std::string operationMode = \"TDD\"; // TDD or FDD\n\n    // Where we will store the output files.\n    std::string simTag = \"default\";\n    std::string outputDir = \"./\";\n    bool logging = false;\n    bool traces = true;\n    bool useUdp = true;\n\n    uint8_t ngmnMixedFtpPercentage = 10;\n    uint8_t ngmnMixedHttpPercentage = 20;\n    uint8_t ngmnMixedVideoPercentage = 20;\n    uint8_t ngmnMixedVoipPercentage = 30;\n    uint8_t ngmnMixedGamingPercentage = 20;\n\n    /*\n     * From here, we instruct the ns3::CommandLine class of all the input parameters\n     * that we may accept as input, as well as their description, and the storage\n     * variable.\n     */\n    CommandLine cmd(__FILE__);\n\n    cmd.AddValue(\"trafficTypeConf\",\n                 \"The traffic type to be configured. Currently the following options are \"\n                 \"available: 0 - UDP CBR, 1 - FTP Model 1, 2 - NGMN FTP, 3 - NGMN VIDEO, 4 - HTTP, \"\n                 \"5-NGMN GAMING, 6 - NGMN VOIP, 7 - NGMN MIXED (e.g., \"\n                 \"10% FTP, 20% HTTP, 20% VIDEO STREAMING, 30% VoIP, 20% GAMING)\",\n                 trafficTypeConf);\n    cmd.AddValue(\n        \"ngmnMixedFtpPercentage\",\n        \"If trafficTypeConf selected is NGMN MIXED this value can be configured to determine the \"\n        \"percentage of the FTP traffic. Percentage should be multiply of 10.\",\n        ngmnMixedFtpPercentage);\n    cmd.AddValue(\n        \"ngmnMixedHttpPercentage\",\n        \"If trafficTypeConf selected is NGMN MIXED this value can be configured to determine the \"\n        \"percentage of the HTTP traffic. Percentage should be multiply of 10.\",\n        ngmnMixedHttpPercentage);\n    cmd.AddValue(\n        \"ngmnMixedVideoPercentage\",\n        \"If trafficTypeConf selected is NGMN MIXED this value can be configured to determine the \"\n        \"percentage of the VIDEO traffic. Percentage should be multiply of 10.\",\n        ngmnMixedVideoPercentage);\n    cmd.AddValue(\n        \"ngmnMixedVoipPercentage\",\n        \"If trafficTypeConf selected is NGMN MIXED this value can be configured to determine the \"\n        \"percentage of the VoIP traffic. Percentage should be multiply of 10.\",\n        ngmnMixedVoipPercentage);\n    cmd.AddValue(\n        \"ngmnMixedGamingPercentage\",\n        \"If trafficTypeConf selected is NGMN MIXED this value can be configured to determine the \"\n        \"percentage of the GAMING traffic. Percentage should be multiply of 10.\",\n        ngmnMixedGamingPercentage);\n    cmd.AddValue(\"useUdp\",\n                 \"if true, the NGMN applications will run over UDP connection, otherwise a TCP \"\n                 \"connection will be used. \"\n                 \"Notice that HTTP application as it is present in ns-3 simulator is implemented \"\n                 \"as typical HTTP application, i.e., \"\n                 \"based on the TCP protocol and as such cannot be reconfigured to use UDP.\",\n                 useUdp);\n    cmd.AddValue(\"ftpM1Lambda\",\n                 \"The lambda to be used for FTP M1 traffic model (Typical values are 2.5, 5). \",\n                 ftpM1Lambda);\n    cmd.AddValue(\"udpLambda\", \"Number of UDP packets generated in one second per UE\", udpLambda);\n    cmd.AddValue(\"uniformLambda\",\n                 \"1: Use same lambda (packets/s) for all UEs and cells (equal to 'lambda' input), \"\n                 \"0: use different packet arrival rates (lambdas) among cells\",\n                 uniformLambda);\n    cmd.AddValue(\"scenario\", \"The urban scenario string (UMa or UMi)\", scenario);\n    cmd.AddValue(\"numRings\", \"The number of rings around the central site\", numOuterRings);\n    cmd.AddValue(\"uesPerGnb\",\n                 \"The number of UE per gNB, should be multiply of 10 so that the mixed traffic \"\n                 \"works correctly.\",\n                 uesPerGnb);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.AddValue(\"traces\", \"Enable output traces\", traces);\n    cmd.AddValue(\"packetSize\", \"packet size in bytes to be used by UE traffic\", udpPacketSize);\n    cmd.AddValue(\"simTimeMs\", \"Simulation time\", simTimeMs);\n    cmd.AddValue(\"direction\", \"The flow direction (DL or UL)\", direction);\n    cmd.AddValue(\"technology\", \"The radio access network technology\", radioNetwork);\n    cmd.AddValue(\"operationMode\", \"The network operation mode can be TDD or FDD\", operationMode);\n    cmd.AddValue(\"simTag\",\n                 \"tag to be appended to output filenames to distinguish simulation campaigns\",\n                 simTag);\n    cmd.AddValue(\"outputDir\", \"directory where to store simulation results\", outputDir);\n\n    // Parse the command line\n    cmd.Parse(argc, argv);\n\n    /*\n     * Check if the parameter values provided by the user are correct.\n     */\n    //  NS_ABORT_IF (centralFrequencyBand > 100e9);]\n    NS_ABORT_MSG_IF(\n        trafficTypeConf > 7,\n        \"Currently only supported values for traffic type are 0, 1, 2. Meaning: 0 -UDP CBR, 1 - \"\n        \"FTP Model 1, 2 - NGMN FTP, 3 - NGMN VIDEO, 4- HTTP, 5- NGMN GAMING, 6 - VOIP, 7 - NGMN \"\n        \"MIXED (e.g., 10% FTP, 20% HTTP, 20% VIDEO STREAMING, 30% VoIP, 20% GAMING\");\n    NS_ABORT_MSG_IF(direction != \"DL\" && direction != \"UL\", \"Flow direction can only be DL or UL\");\n    NS_ABORT_MSG_IF(operationMode != \"TDD\" && operationMode != \"FDD\",\n                    \"Operation mode can only be TDD or FDD\");\n    NS_ABORT_MSG_IF(radioNetwork != \"LTE\" && radioNetwork != \"NR\",\n                    \"Unrecognized radio network technology\");\n\n    NS_ABORT_MSG_IF(\n        trafficTypeConf == 7 &&\n            (ngmnMixedFtpPercentage + ngmnMixedHttpPercentage + ngmnMixedVideoPercentage +\n             ngmnMixedVoipPercentage + ngmnMixedGamingPercentage) != 100,\n        \"If trafficTypeConf selected is the NGMN mixed, then the sum of the percentages of FTP, \"\n        \"VOIP, HTTP, VIDEO STREAMING and GAMING traffic should give 100.\");\n    /*\n     * If the logging variable is set to true, enable the log of some components\n     * through the code. The same effect can be obtained through the use\n     * of the NS_LOG environment variable:\n     *\n     * export NS_LOG=\"UdpClient=level_info|prefix_time|prefix_func|prefix_node:UdpServer=...\"\n     *\n     * Usually, the environment variable way is preferred, as it is more customizable,\n     * and more expressive.\n     */\n    if (logging)\n    {\n        LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n        //      LogComponentEnable (\"NrMacSchedulerOfdma\", LOG_LEVEL_ALL);\n    }\n\n    // configure the transport protocol to be used\n    std::string transportProtocol;\n    if (useUdp)\n    {\n        transportProtocol = \"ns3::UdpSocketFactory\";\n    }\n    else\n    {\n        transportProtocol = \"ns3::TcpSocketFactory\";\n    }\n\n    Time simTime = MilliSeconds(simTimeMs);\n\n    std::cout << \"\\n  Traffic configuration selected is: \" << trafficTypeConf << std::endl;\n\n    /*\n     * Create the scenario. In our examples, we heavily use helpers that setup\n     * the gnbs and ue following a pre-defined pattern. Please have a look at the\n     * GridScenarioHelper documentation to see how the nodes will be distributed.\n     */\n    HexagonalGridScenarioHelper gridScenario;\n    gridScenario.SetSectorization(HexagonalGridScenarioHelper::TRIPLE);\n    gridScenario.SetNumRings(numOuterRings);\n    gridScenario.SetScenarioParameters(scenario);\n    uint16_t gNbNum = gridScenario.GetNumCells();\n    std::cout << \"  GNB num: \" << gNbNum << std::endl;\n    uint32_t ueNum = uesPerGnb * gNbNum;\n    std::cout << \"  UE num: \" << ueNum << std::endl;\n    gridScenario.SetUtNumber(ueNum);\n    gridScenario.AssignStreams(RngSeedManager::GetRun());\n    gridScenario.CreateScenario(); //!< Creates and plots the network deployment\n    const uint16_t ffr =\n        3; // Fractional Frequency Reuse scheme to mitigate intra-site inter-sector interferences\n\n    /*\n     * Create different gNB NodeContainer for the different sectors.\n     */\n    NodeContainer gnbSector1Container, gnbSector2Container, gnbSector3Container;\n    for (uint32_t j = 0; j < gridScenario.GetBaseStations().GetN(); ++j)\n    {\n        Ptr<Node> gnb = gridScenario.GetBaseStations().Get(j);\n        switch (j % ffr)\n        {\n        case 0:\n            gnbSector1Container.Add(gnb);\n            break;\n        case 1:\n            gnbSector2Container.Add(gnb);\n            break;\n        case 2:\n            gnbSector3Container.Add(gnb);\n            break;\n        default:\n            NS_ABORT_MSG(\"ffr param cannot be larger than 3\");\n            break;\n        }\n    }\n\n    /*\n     * Create different UE NodeContainer for the different sectors.\n     */\n    NodeContainer ueSector1Container, ueSector2Container, ueSector3Container;\n\n    for (uint32_t j = 0; j < gridScenario.GetUserTerminals().GetN(); ++j)\n    {\n        Ptr<Node> ue = gridScenario.GetUserTerminals().Get(j);\n        switch (j % ffr)\n        {\n        case 0:\n            ueSector1Container.Add(ue);\n            break;\n        case 1:\n            ueSector2Container.Add(ue);\n            break;\n        case 2:\n            ueSector3Container.Add(ue);\n            break;\n        default:\n            NS_ABORT_MSG(\"ffr param cannot be larger than 3\");\n            break;\n        }\n    }\n\n    /*\n     * Setup the 5G-LENA scenario\n     */\n    Ptr<PointToPointEpcHelper> epcHelper;\n\n    NetDeviceContainer gnbSector1NetDev, gnbSector2NetDev, gnbSector3NetDev;\n    NetDeviceContainer ueSector1NetDev, ueSector2NetDev, ueSector3NetDev;\n\n    Ptr<NrHelper> nrHelper = nullptr;\n\n    epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Set5gLenaSimulatorParameters(gridScenario,\n                                 scenario,\n                                 radioNetwork,\n                                 operationMode,\n                                 direction,\n                                 gnbSector1Container,\n                                 gnbSector2Container,\n                                 gnbSector3Container,\n                                 ueSector1Container,\n                                 ueSector2Container,\n                                 ueSector3Container,\n                                 epcHelper,\n                                 nrHelper,\n                                 gnbSector1NetDev,\n                                 gnbSector2NetDev,\n                                 gnbSector3NetDev,\n                                 ueSector1NetDev,\n                                 ueSector2NetDev,\n                                 ueSector3NetDev,\n                                 uniformLambda);\n\n    // From here, it is standard NS3. In the future, we will create helpers\n    // for this part as well.\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.000)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(gridScenario.GetUserTerminals());\n\n    // if the mixed traffic type selected then determine for each which container IDs correposnd to\n    // each traffic type\n\n    std::set<uint16_t> ngmnFtpIds;\n    std::set<uint16_t> ngmnVideoIds;\n    std::set<uint16_t> ngmnVoipIds;\n    std::set<uint16_t> ngmnHttpIds;\n    std::set<uint16_t> ngmnGamingIds;\n\n    // configure indexes of UEs per traffic type\n\n    if (trafficTypeConf == NGMN_MIXED)\n    {\n        // check if there is enough UEs to configure NGMN_MIXED traffic type\n        NS_ABORT_MSG_UNLESS((ueSector1NetDev.GetN() % 10) == 0,\n                            \"The number of UEs per sector must be mupliply of 10 when NGMN MIXED \"\n                            \"traffic configured\");\n\n        std::cout << \"\\n ueSector1NetDev:\" << ueSector1NetDev.GetN() / 10 << std::endl;\n        NS_ABORT_MSG_UNLESS((ueSector1NetDev.GetN() / 10) >= 1,\n                            \"The number of UEs per sector must be at least 10 when NGMN MIXED \"\n                            \"traffic is configured\");\n\n        uint16_t ftp = (ueSector1NetDev.GetN() / 10) * ngmnMixedFtpPercentage / 10;\n        uint16_t http = (ueSector1NetDev.GetN() / 10) * ngmnMixedHttpPercentage / 10;\n        uint16_t video = (ueSector1NetDev.GetN() / 10) * ngmnMixedVideoPercentage / 10;\n        uint16_t voip = (ueSector1NetDev.GetN() / 10) * ngmnMixedVoipPercentage / 10;\n        uint16_t gaming = (ueSector1NetDev.GetN() / 10) * ngmnMixedGamingPercentage / 10;\n        uint16_t index = 0;\n\n        std::cout << \"\\n Each sector has:\" << std::endl;\n        std::cout << ftp << \" UEs with NGMN FTP traffic\" << std::endl;\n        std::cout << http << \" UEs with NGMN HTTP traffic\" << std::endl;\n        std::cout << video << \" UEs with NGMN VIDEO traffic\" << std::endl;\n        std::cout << voip << \" UEs with NGMN VOIP traffic\" << std::endl;\n        std::cout << gaming << \" UEs with NGMN GAMING traffic\" << std::endl;\n\n        for (uint16_t i = 0; i < ftp; i++)\n        {\n            ngmnFtpIds.insert(index++);\n        }\n\n        for (uint16_t i = 0; i < http; i++)\n        {\n            ngmnHttpIds.insert(index++);\n        }\n\n        for (uint16_t i = 0; i < video; i++)\n        {\n            ngmnVideoIds.insert(index++);\n        }\n\n        for (uint16_t i = 0; i < voip; i++)\n        {\n            ngmnVoipIds.insert(index++);\n        }\n\n        for (uint16_t i = 0; i < gaming; i++)\n        {\n            ngmnGamingIds.insert(index++);\n        }\n    }\n\n    Ipv4InterfaceContainer ueSector1IpIface =\n        epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueSector1NetDev));\n    Ipv4InterfaceContainer ueSector2IpIface =\n        epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueSector2NetDev));\n    Ipv4InterfaceContainer ueSector3IpIface =\n        epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueSector3NetDev));\n\n    Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress(1);\n\n    // Set the default gateway for the UEs\n    for (uint32_t j = 0; j < gridScenario.GetUserTerminals().GetN(); ++j)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting = ipv4RoutingHelper.GetStaticRouting(\n            gridScenario.GetUserTerminals().Get(j)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // attach UEs to their gNB. Try to attach them per cellId order\n    for (uint32_t u = 0; u < ueNum; ++u)\n    {\n        uint32_t sector = u % ffr;\n        uint32_t i = u / ffr;\n        if (sector == 0)\n        {\n            Ptr<NetDevice> gnbNetDev = gnbSector1NetDev.Get(i % gridScenario.GetNumSites());\n            Ptr<NetDevice> ueNetDev = ueSector1NetDev.Get(i);\n\n            nrHelper->AttachToEnb(ueNetDev, gnbNetDev);\n\n            if (logging == true)\n            {\n                Vector gnbpos = gnbNetDev->GetNode()->GetObject<MobilityModel>()->GetPosition();\n                Vector uepos = ueNetDev->GetNode()->GetObject<MobilityModel>()->GetPosition();\n                double distance = CalculateDistance(gnbpos, uepos);\n                std::cout << \"Distance = \" << distance << \" meters\" << std::endl;\n            }\n        }\n        else if (sector == 1)\n        {\n            Ptr<NetDevice> gnbNetDev = gnbSector2NetDev.Get(i % gridScenario.GetNumSites());\n            Ptr<NetDevice> ueNetDev = ueSector2NetDev.Get(i);\n            nrHelper->AttachToEnb(ueNetDev, gnbNetDev);\n            if (logging == true)\n            {\n                Vector gnbpos = gnbNetDev->GetNode()->GetObject<MobilityModel>()->GetPosition();\n                Vector uepos = ueNetDev->GetNode()->GetObject<MobilityModel>()->GetPosition();\n                double distance = CalculateDistance(gnbpos, uepos);\n                std::cout << \"Distance = \" << distance << \" meters\" << std::endl;\n            }\n        }\n        else if (sector == 2)\n        {\n            Ptr<NetDevice> gnbNetDev = gnbSector3NetDev.Get(i % gridScenario.GetNumSites());\n            Ptr<NetDevice> ueNetDev = ueSector3NetDev.Get(i);\n            nrHelper->AttachToEnb(ueNetDev, gnbNetDev);\n            if (logging == true)\n            {\n                Vector gnbpos = gnbNetDev->GetNode()->GetObject<MobilityModel>()->GetPosition();\n                Vector uepos = ueNetDev->GetNode()->GetObject<MobilityModel>()->GetPosition();\n                double distance = CalculateDistance(gnbpos, uepos);\n                std::cout << \"Distance = \" << distance << \" meters\" << std::endl;\n            }\n        }\n        else\n        {\n            NS_ABORT_MSG(\"Number of sector cannot be larger than 3\");\n        }\n    }\n\n    /*\n     * Traffic part. Install two kind of traffic: low-latency and voice, each\n     * identified by a particular source port.\n     */\n    uint16_t dlPortLowLat = 1234;\n\n    ApplicationContainer serverApps;\n\n    // The sink will always listen to the specified ports\n    UdpServerHelper dlPacketSinkLowLat(dlPortLowLat);\n\n    // The server, that is the application which is listening, is installed in the UE\n    if (direction == \"DL\")\n    {\n        serverApps.Add(dlPacketSinkLowLat.Install(\n            {ueSector1Container, ueSector2Container, ueSector3Container}));\n    }\n    else\n    {\n        serverApps.Add(dlPacketSinkLowLat.Install(remoteHost));\n    }\n\n    /*\n     * Configure attributes for the different generators, using user-provided\n     * parameters for generating a CBR traffic\n     *\n     * Low-Latency configuration and object creation:\n     */\n    UdpClientHelper dlClientLowLat;\n    dlClientLowLat.SetAttribute(\"RemotePort\", UintegerValue(dlPortLowLat));\n    dlClientLowLat.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n    dlClientLowLat.SetAttribute(\"PacketSize\", UintegerValue(udpPacketSize));\n    // dlClientLowLat.SetAttribute (\"Interval\", TimeValue (Seconds (1.0/lambda)));\n\n    // The bearer that will carry low latency traffic\n    EpsBearer lowLatBearer(EpsBearer::NGBR_VIDEO_TCP_DEFAULT);\n\n    // The filter for the low-latency traffic\n    Ptr<EpcTft> lowLatTft = Create<EpcTft>();\n    EpcTft::PacketFilter dlpfLowLat;\n    if (direction == \"DL\")\n    {\n        dlpfLowLat.localPortStart = dlPortLowLat;\n        dlpfLowLat.localPortEnd = dlPortLowLat;\n        dlpfLowLat.direction = EpcTft::DOWNLINK;\n    }\n    else\n    {\n        dlpfLowLat.remotePortStart = dlPortLowLat;\n        dlpfLowLat.remotePortEnd = dlPortLowLat;\n        dlpfLowLat.direction = EpcTft::UPLINK;\n    }\n    lowLatTft->Add(dlpfLowLat);\n\n    uint32_t lambdaPerCell[gridScenario.GetNumCells()];\n\n    if (trafficTypeConf == UDP_CBR)\n    {\n        if (uniformLambda)\n        {\n            for (uint32_t bs = 0; bs < gridScenario.GetNumCells(); ++bs)\n            {\n                lambdaPerCell[bs] = udpLambda;\n                std::cout << \"Cell: \" << bs << \" lambda (same lambda): \" << lambdaPerCell[bs]\n                          << std::endl;\n            }\n        }\n        else // non-uniform lambda values among the cells!\n        {\n            for (uint32_t bs = 0; bs < gridScenario.GetNumCells(); ++bs)\n            {\n                lambdaPerCell[bs] = 1000 + bs * 2000;\n                std::cout << \"Cell: \" << bs << \" lambda (diff lambda): \" << lambdaPerCell[bs]\n                          << std::endl;\n            }\n        }\n    }\n\n    /*\n     * Let's install the applications!\n     */\n    ApplicationContainer clientApps;\n    ApplicationContainer ftpClientAppsSector1, ftpServerAppsSector1;\n    ApplicationContainer ftpClientAppsSector2, ftpServerAppsSector2;\n    ApplicationContainer ftpClientAppsSector3, ftpServerAppsSector3;\n    Ptr<ThreeGppFtpM1Helper> ftpHelperSector1;\n    Ptr<ThreeGppFtpM1Helper> ftpHelperSector2;\n    Ptr<ThreeGppFtpM1Helper> ftpHelperSector3;\n    uint32_t port1 = 2001, port2 = 2002, port3 = 2003;\n    // Seed the ARP cache by pinging early in the simulation\n    // This is a workaround until a static ARP capability is provided\n    ApplicationContainer pingApps;\n\n    if (trafficTypeConf == FTP_3GPP_M1)\n    {\n        // sector 1 FTP M1 applications configuration\n        ftpHelperSector1 = CreateObject<ThreeGppFtpM1Helper>(&ftpServerAppsSector1,\n                                                             &ftpClientAppsSector1,\n                                                             &ueSector1Container,\n                                                             &remoteHostContainer,\n                                                             &ueSector1IpIface);\n        ftpHelperSector1->Configure(port1,\n                                    serverAppStartTime,\n                                    clientAppStartTime,\n                                    simTime,\n                                    ftpM1Lambda,\n                                    ftpM1FileSize);\n        ftpHelperSector1->Start();\n\n        // sector 2 FTP M1 applications configuration\n        ftpHelperSector2 = CreateObject<ThreeGppFtpM1Helper>(&ftpServerAppsSector2,\n                                                             &ftpClientAppsSector2,\n                                                             &ueSector2Container,\n                                                             &remoteHostContainer,\n                                                             &ueSector2IpIface);\n        ftpHelperSector2->Configure(port2,\n                                    serverAppStartTime,\n                                    clientAppStartTime,\n                                    simTime,\n                                    ftpM1Lambda,\n                                    ftpM1FileSize);\n        ftpHelperSector2->Start();\n\n        // sector 3 FTP M1 applications configuration\n        ftpHelperSector3 = CreateObject<ThreeGppFtpM1Helper>(&ftpServerAppsSector3,\n                                                             &ftpClientAppsSector3,\n                                                             &ueSector3Container,\n                                                             &remoteHostContainer,\n                                                             &ueSector3IpIface);\n        ftpHelperSector3->Configure(port3,\n                                    serverAppStartTime,\n                                    clientAppStartTime,\n                                    simTime,\n                                    ftpM1Lambda,\n                                    ftpM1FileSize);\n        ftpHelperSector3->Start();\n\n        clientApps.Add(ftpClientAppsSector1);\n        clientApps.Add(ftpClientAppsSector2);\n        clientApps.Add(ftpClientAppsSector3);\n\n        serverApps.Add(ftpServerAppsSector1);\n        serverApps.Add(ftpServerAppsSector2);\n        serverApps.Add(ftpServerAppsSector3);\n    }\n\n    if (trafficTypeConf == NGMN_FTP || (trafficTypeConf == NGMN_MIXED && ngmnFtpIds.size() > 0))\n    {\n        uint32_t portFtpNgmn = 2000;\n\n        if (direction == \"DL\")\n        {\n            // configure FTP clients with file transfer application that generates multiple file\n            // transfers\n            TrafficGeneratorHelper ftpHelper(transportProtocol,\n                                             Address(),\n                                             TrafficGeneratorNgmnFtpMulti::GetTypeId());\n            ftpHelper.SetAttribute(\"PacketSize\", UintegerValue(1448));\n            ftpHelper.SetAttribute(\"MaxFileSize\", UintegerValue(5e6));\n\n            // configure clients on sector 1\n            for (uint32_t i = 0; i < ueSector1IpIface.GetN(); i++)\n            {\n                // in case of NGMN traffic allow installation of the specific traffic type only on\n                // the specific nodes\n                if ((trafficTypeConf == NGMN_MIXED) and (ngmnFtpIds.find(i) == ngmnFtpIds.end()))\n                {\n                    continue;\n                }\n\n                Ipv4Address ipAddress = ueSector1IpIface.GetAddress(i, 0);\n                AddressValue ueAddress(InetSocketAddress(ipAddress, portFtpNgmn));\n                ftpHelper.SetAttribute(\"Remote\", ueAddress);\n                clientApps.Add(ftpHelper.Install(remoteHostContainer));\n                // Seed the ARP cache by pinging early in the simulation\n                // This is a workaround until a static ARP capability is provided\n                PingHelper ping(ipAddress);\n                pingApps.Add(ping.Install(remoteHostContainer));\n            }\n            // configure clients on sector 2\n            for (uint32_t i = 0; i < ueSector2IpIface.GetN(); i++)\n            {\n                // in case of NGMN traffic allow installation of the specific traffic type only on\n                // the specific nodes\n                if ((trafficTypeConf == NGMN_MIXED) and (ngmnFtpIds.find(i) == ngmnFtpIds.end()))\n                {\n                    continue;\n                }\n                Ipv4Address ipAddress = ueSector2IpIface.GetAddress(i, 0);\n                AddressValue ueAddress(InetSocketAddress(ipAddress, portFtpNgmn));\n                ftpHelper.SetAttribute(\"Remote\", ueAddress);\n                clientApps.Add(ftpHelper.Install(remoteHostContainer));\n                // Seed the ARP cache by pinging early in the simulation\n                // This is a workaround until a static ARP capability is provided\n                PingHelper ping(ipAddress);\n                pingApps.Add(ping.Install(remoteHostContainer));\n            }\n            // configure clients on sector 3\n            for (uint32_t i = 0; i < ueSector3IpIface.GetN(); i++)\n            {\n                // in case of NGMN traffic allow installation of the specific traffic type only on\n                // the specific nodes\n                if ((trafficTypeConf == NGMN_MIXED) and (ngmnFtpIds.find(i) == ngmnFtpIds.end()))\n                {\n                    continue;\n                }\n\n                Ipv4Address ipAddress = ueSector3IpIface.GetAddress(i, 0);\n                AddressValue ueAddress(InetSocketAddress(ipAddress, portFtpNgmn));\n                ftpHelper.SetAttribute(\"Remote\", ueAddress);\n                clientApps.Add(ftpHelper.Install(remoteHostContainer));\n                // Seed the ARP cache by pinging early in the simulation\n                // This is a workaround until a static ARP capability is provided\n                PingHelper ping(ipAddress);\n                pingApps.Add(ping.Install(remoteHostContainer));\n            }\n\n            // configure FTP servers\n            InetSocketAddress localAddress(Ipv4Address::GetAny(), portFtpNgmn);\n            PacketSinkHelper packetSinkHelper(transportProtocol, localAddress);\n\n            for (uint32_t index = 0; index < ueSector1IpIface.GetN(); index++)\n            {\n                // in case of NGMN traffic we install packet sink for the subset of the nodes\n                if ((trafficTypeConf == NGMN_MIXED) and\n                    (ngmnFtpIds.find(index) == ngmnFtpIds.end()))\n                {\n                    continue;\n                }\n                serverApps.Add(packetSinkHelper.Install(ueSector1Container.Get(index)));\n                serverApps.Add(packetSinkHelper.Install(ueSector2Container.Get(index)));\n                serverApps.Add(packetSinkHelper.Install(ueSector3Container.Get(index)));\n            }\n        }\n        else\n        {\n            NS_ABORT_MSG(\"Not yet supported option of FTP NGMN traffic with the UL traffic in this \"\n                         \"example. If you need it implement this else block\");\n        }\n    }\n\n    if (trafficTypeConf == NGMN_VIDEO || (trafficTypeConf == NGMN_MIXED && ngmnVideoIds.size() > 0))\n    {\n        uint32_t portNgmnVideo = 4000;\n\n        if (direction == \"DL\")\n        {\n            // configure FTP clients with file transfer application that generates multiple file\n            // transfers\n            TrafficGeneratorHelper trafficGeneratorHelper(transportProtocol,\n                                                          Address(),\n                                                          TrafficGeneratorNgmnVideo::GetTypeId());\n            trafficGeneratorHelper.SetAttribute(\"NumberOfPacketsInFrame\", UintegerValue(8));\n            trafficGeneratorHelper.SetAttribute(\"InterframeIntervalTime\",\n                                                TimeValue(Seconds(0.100)));\n\n            // configure clients on sector 1\n            for (uint32_t i = 0; i < ueSector1IpIface.GetN(); i++)\n            {\n                // in case of NGMN trafic allow installation of the specific traffic type only on\n                // the specific nodes\n                if ((trafficTypeConf == NGMN_MIXED) and\n                    (ngmnVideoIds.find(i) == ngmnVideoIds.end()))\n                {\n                    continue;\n                }\n\n                Ipv4Address ipAddress = ueSector1IpIface.GetAddress(i, 0);\n                AddressValue remoteAddress(InetSocketAddress(ipAddress, portNgmnVideo));\n                trafficGeneratorHelper.SetAttribute(\"Remote\", remoteAddress);\n                clientApps.Add(trafficGeneratorHelper.Install(remoteHostContainer));\n                // Seed the ARP cache by pinging early in the simulation\n                // This is a workaround until a static ARP capability is provided\n                PingHelper ping(ipAddress);\n                pingApps.Add(ping.Install(remoteHostContainer));\n            }\n            // configure clients on sector 2\n            for (uint32_t i = 0; i < ueSector2IpIface.GetN(); i++)\n            {\n                // in case of NGMN trafic allow installation of the specific traffic type only on\n                // the specific nodes\n                if ((trafficTypeConf == NGMN_MIXED) and\n                    (ngmnVideoIds.find(i) == ngmnVideoIds.end()))\n                {\n                    continue;\n                }\n\n                Ipv4Address ipAddress = ueSector2IpIface.GetAddress(i, 0);\n                AddressValue remoteAddress(InetSocketAddress(ipAddress, portNgmnVideo));\n                trafficGeneratorHelper.SetAttribute(\"Remote\", remoteAddress);\n                clientApps.Add(trafficGeneratorHelper.Install(remoteHostContainer));\n                // Seed the ARP cache by pinging early in the simulation\n                // This is a workaround until a static ARP capability is provided\n                PingHelper ping(ipAddress);\n                pingApps.Add(ping.Install(remoteHostContainer));\n            }\n            // configure clients on sector 3\n            for (uint32_t i = 0; i < ueSector3IpIface.GetN(); i++)\n            {\n                // in case of NGMN trafic allow installation of the specific traffic type only on\n                // the specific nodes\n                if ((trafficTypeConf == NGMN_MIXED) and\n                    (ngmnVideoIds.find(i) == ngmnVideoIds.end()))\n                {\n                    continue;\n                }\n\n                Ipv4Address ipAddress = ueSector3IpIface.GetAddress(i, 0);\n                AddressValue remoteAddress(InetSocketAddress(ipAddress, portNgmnVideo));\n                trafficGeneratorHelper.SetAttribute(\"Remote\", remoteAddress);\n                clientApps.Add(trafficGeneratorHelper.Install(remoteHostContainer));\n                // Seed the ARP cache by pinging early in the simulation\n                // This is a workaround until a static ARP capability is provided\n                PingHelper ping(ipAddress);\n                pingApps.Add(ping.Install(remoteHostContainer));\n            }\n\n            // configure servers\n            InetSocketAddress localAddress(Ipv4Address::GetAny(), portNgmnVideo);\n            PacketSinkHelper packetSinkHelper(transportProtocol, localAddress);\n\n            for (uint32_t index = 0; index < ueSector1IpIface.GetN(); index++)\n            {\n                // in case of NGMN traffic we install packet sink for the subset of the nodes\n                if ((trafficTypeConf == NGMN_MIXED) and\n                    (ngmnVideoIds.find(index) == ngmnVideoIds.end()))\n                {\n                    continue;\n                }\n\n                Ptr<PacketSink> ps1 = packetSinkHelper.Install(ueSector1Container.Get(index))\n                                          .Get(0)\n                                          ->GetObject<PacketSink>();\n                Ptr<PacketSink> ps2 = packetSinkHelper.Install(ueSector2Container.Get(index))\n                                          .Get(0)\n                                          ->GetObject<PacketSink>();\n                Ptr<PacketSink> ps3 = packetSinkHelper.Install(ueSector3Container.Get(index))\n                                          .Get(0)\n                                          ->GetObject<PacketSink>();\n                serverApps.Add(ps1);\n                serverApps.Add(ps2);\n                serverApps.Add(ps3);\n            }\n        }\n        else\n        {\n            NS_ABORT_MSG(\"Not yet supported option of FTP NGMN traffic with the UL traffic in this \"\n                         \"example. If you need it implement this else block\");\n        }\n    }\n\n    if (trafficTypeConf == NGMN_GAMING ||\n        (trafficTypeConf == NGMN_MIXED && ngmnGamingIds.size() > 0))\n    {\n        uint32_t portNgmnGaming = 5000;\n        if (direction == \"DL\")\n        {\n            // configure FTP clients with file transfer application that generates multiple file\n            // transfers\n            TrafficGeneratorHelper trafficGeneratorHelper(transportProtocol,\n                                                          Address(),\n                                                          TrafficGeneratorNgmnGaming::GetTypeId());\n            trafficGeneratorHelper.SetAttribute(\"IsDownlink\", BooleanValue(true));\n            trafficGeneratorHelper.SetAttribute(\"aParamPacketSizeDl\", UintegerValue(120));\n            trafficGeneratorHelper.SetAttribute(\"bParamPacketSizeDl\", DoubleValue(36));\n            trafficGeneratorHelper.SetAttribute(\"aParamPacketArrivalDl\", DoubleValue(45));\n            trafficGeneratorHelper.SetAttribute(\"bParamPacketArrivalDl\", DoubleValue(5.7));\n            trafficGeneratorHelper.SetAttribute(\"InitialPacketArrivalMin\", UintegerValue(0));\n            trafficGeneratorHelper.SetAttribute(\"InitialPacketArrivalMax\", UintegerValue(40));\n\n            // configure clients on sector 1\n            for (uint32_t i = 0; i < ueSector1IpIface.GetN(); i++)\n            {\n                // in case of NGMN trafic allow installation of the specific traffic type only on\n                // the specific nodes\n                if ((trafficTypeConf == NGMN_MIXED) and\n                    (ngmnGamingIds.find(i) == ngmnGamingIds.end()))\n                {\n                    continue;\n                }\n\n                Ipv4Address ipAddress = ueSector1IpIface.GetAddress(i, 0);\n                AddressValue remoteAddress(InetSocketAddress(ipAddress, portNgmnGaming));\n                trafficGeneratorHelper.SetAttribute(\"Remote\", remoteAddress);\n                clientApps.Add(trafficGeneratorHelper.Install(remoteHostContainer));\n                // Seed the ARP cache by pinging early in the simulation\n                // This is a workaround until a static ARP capability is provided\n                PingHelper ping(ipAddress);\n                pingApps.Add(ping.Install(remoteHostContainer));\n            }\n            // configure clients on sector 2\n            for (uint32_t i = 0; i < ueSector2IpIface.GetN(); i++)\n            {\n                // in case of NGMN trafic allow installation of the specific traffic type only on\n                // the specific nodes\n                if ((trafficTypeConf == NGMN_MIXED) and\n                    (ngmnGamingIds.find(i) == ngmnGamingIds.end()))\n                {\n                    continue;\n                }\n\n                Ipv4Address ipAddress = ueSector2IpIface.GetAddress(i, 0);\n                AddressValue remoteAddress(InetSocketAddress(ipAddress, portNgmnGaming));\n                trafficGeneratorHelper.SetAttribute(\"Remote\", remoteAddress);\n                clientApps.Add(trafficGeneratorHelper.Install(remoteHostContainer));\n                // Seed the ARP cache by pinging early in the simulation\n                // This is a workaround until a static ARP capability is provided\n                PingHelper ping(ipAddress);\n                pingApps.Add(ping.Install(remoteHostContainer));\n            }\n            // configure clients on sector 3\n            for (uint32_t i = 0; i < ueSector3IpIface.GetN(); i++)\n            {\n                // in case of NGMN trafic allow installation of the specific traffic type only on\n                // the specific nodes\n                if ((trafficTypeConf == NGMN_MIXED) and\n                    (ngmnGamingIds.find(i) == ngmnGamingIds.end()))\n                {\n                    continue;\n                }\n\n                Ipv4Address ipAddress = ueSector3IpIface.GetAddress(i, 0);\n                AddressValue remoteAddress(InetSocketAddress(ipAddress, portNgmnGaming));\n                trafficGeneratorHelper.SetAttribute(\"Remote\", remoteAddress);\n                clientApps.Add(trafficGeneratorHelper.Install(remoteHostContainer));\n                // Seed the ARP cache by pinging early in the simulation\n                // This is a workaround until a static ARP capability is provided\n                PingHelper ping(ipAddress);\n                pingApps.Add(ping.Install(remoteHostContainer));\n            }\n\n            // configure GAMING servers\n            InetSocketAddress localAddress(Ipv4Address::GetAny(), portNgmnGaming);\n            PacketSinkHelper packetSinkHelper(transportProtocol, localAddress);\n\n            for (uint32_t index = 0; index < ueSector1IpIface.GetN(); index++)\n            {\n                // in case of NGMN traffic we install packet sink for the subset of the nodes\n                if ((trafficTypeConf == NGMN_MIXED) and\n                    (ngmnGamingIds.find(index) == ngmnGamingIds.end()))\n                {\n                    continue;\n                }\n                serverApps.Add(packetSinkHelper.Install(ueSector1Container.Get(index)));\n                serverApps.Add(packetSinkHelper.Install(ueSector2Container.Get(index)));\n                serverApps.Add(packetSinkHelper.Install(ueSector3Container.Get(index)));\n            }\n        }\n        else\n        {\n            NS_ABORT_MSG(\"Not yet supported option of FTP NGMN traffic with the UL traffic in this \"\n                         \"example. If you need it implement this else block\");\n\n            // TODO extend\n            // configure FTP clients with file transfer application that generates multiple file\n            // transfers\n            // TrafficGeneratorHelper trafficGeneratorHelper (\"ns3::UdpSocketFactory\", Address (),\n            // TrafficGeneratorVideo::GetTypeId ()); trafficGeneratorHelper.SetAttribute\n            // (\"IsDownlink\", BooleanValue (false)); trafficGeneratorHelper.SetAttribute\n            // (\"aParamPacketSizeUl\", UintegerValue (45)); trafficGeneratorHelper.SetAttribute\n            // (\"bParamPacketSizeUl\", DoubleValue (5.7)); trafficGeneratorHelper.SetAttribute\n            // (\"PacketArrivalUl\", UintegerValue (40)); trafficGeneratorHelper.SetAttribute\n            // (\"InitialPacketArrivalMin\", UintegerValue (0)); trafficGeneratorHelper.SetAttribute\n            // (\"InitialPacketArrivalMax\", UintegerValue (40));\n        }\n    }\n\n    if (trafficTypeConf == NGMN_VOIP || (trafficTypeConf == NGMN_MIXED && ngmnVoipIds.size() > 0))\n    {\n        uint32_t portNgmnVoip = 5000;\n        if (direction == \"DL\")\n        {\n            // configure FTP clients with file transfer application that generates multiple file\n            // transfers\n            TrafficGeneratorHelper trafficGeneratorHelper(transportProtocol,\n                                                          Address(),\n                                                          TrafficGeneratorNgmnVoip::GetTypeId());\n\n            trafficGeneratorHelper.SetAttribute(\"EncoderFrameLength\", UintegerValue(20));\n            trafficGeneratorHelper.SetAttribute(\"MeanTalkSpurtDuration\", UintegerValue(2000));\n            trafficGeneratorHelper.SetAttribute(\"VoiceActivityFactor\", DoubleValue(0.5));\n            trafficGeneratorHelper.SetAttribute(\"VoicePayload\", UintegerValue(40));\n            trafficGeneratorHelper.SetAttribute(\"SIDPeriodicity\", UintegerValue(160));\n            trafficGeneratorHelper.SetAttribute(\"SIDPayload\", UintegerValue(15));\n\n            // configure clients on sector 1\n            for (uint32_t i = 0; i < ueSector1IpIface.GetN(); i++)\n            {\n                // in case of NGMN trafic allow installation of the specific traffic type only on\n                // the specific nodes\n                if ((trafficTypeConf == NGMN_MIXED) and (ngmnVoipIds.find(i) == ngmnVoipIds.end()))\n                {\n                    continue;\n                }\n\n                Ipv4Address ipAddress = ueSector1IpIface.GetAddress(i, 0);\n                AddressValue remoteAddress(InetSocketAddress(ipAddress, portNgmnVoip));\n                trafficGeneratorHelper.SetAttribute(\"Remote\", remoteAddress);\n                clientApps.Add(trafficGeneratorHelper.Install(remoteHostContainer));\n                // Seed the ARP cache by pinging early in the simulation\n                // This is a workaround until a static ARP capability is provided\n                PingHelper ping(ipAddress);\n                pingApps.Add(ping.Install(remoteHostContainer));\n            }\n            // configure clients on sector 2\n            for (uint32_t i = 0; i < ueSector2IpIface.GetN(); i++)\n            {\n                // in case of NGMN trafic allow installation of the specific traffic type only on\n                // the specific nodes\n                if ((trafficTypeConf == NGMN_MIXED) and (ngmnVoipIds.find(i) == ngmnVoipIds.end()))\n                {\n                    continue;\n                }\n\n                Ipv4Address ipAddress = ueSector2IpIface.GetAddress(i, 0);\n                AddressValue remoteAddress(InetSocketAddress(ipAddress, portNgmnVoip));\n                trafficGeneratorHelper.SetAttribute(\"Remote\", remoteAddress);\n                clientApps.Add(trafficGeneratorHelper.Install(remoteHostContainer));\n                // Seed the ARP cache by pinging early in the simulation\n                // This is a workaround until a static ARP capability is provided\n                PingHelper ping(ipAddress);\n                pingApps.Add(ping.Install(remoteHostContainer));\n            }\n            // configure clients on sector 3\n            for (uint32_t i = 0; i < ueSector3IpIface.GetN(); i++)\n            {\n                // in case of NGMN trafic allow installation of the specific traffic type only on\n                // the specific nodes\n                if ((trafficTypeConf == NGMN_MIXED) and (ngmnVoipIds.find(i) == ngmnVoipIds.end()))\n                {\n                    continue;\n                }\n\n                Ipv4Address ipAddress = ueSector3IpIface.GetAddress(i, 0);\n                AddressValue remoteAddress(InetSocketAddress(ipAddress, portNgmnVoip));\n                trafficGeneratorHelper.SetAttribute(\"Remote\", remoteAddress);\n                clientApps.Add(trafficGeneratorHelper.Install(remoteHostContainer));\n                // Seed the ARP cache by pinging early in the simulation\n                // This is a workaround until a static ARP capability is provided\n                PingHelper ping(ipAddress);\n                pingApps.Add(ping.Install(remoteHostContainer));\n            }\n\n            // configure servers\n            InetSocketAddress localAddress(Ipv4Address::GetAny(), portNgmnVoip);\n            PacketSinkHelper packetSinkHelper(transportProtocol, localAddress);\n\n            for (uint32_t index = 0; index < ueSector1IpIface.GetN(); index++)\n            {\n                // in case of NGMN traffic we install packet sink for the subset of the nodes\n                if ((trafficTypeConf == NGMN_MIXED) and\n                    (ngmnVoipIds.find(index) == ngmnVoipIds.end()))\n                {\n                    continue;\n                }\n                serverApps.Add(packetSinkHelper.Install(ueSector1Container.Get(index)));\n                serverApps.Add(packetSinkHelper.Install(ueSector2Container.Get(index)));\n                serverApps.Add(packetSinkHelper.Install(ueSector3Container.Get(index)));\n            }\n        }\n        else\n        {\n            NS_ABORT_MSG(\"Not yet supported option of NGMN VOIP traffic with the UL traffic in \"\n                         \"this example. If you need it implement this else block\");\n\n            // TODO extend\n            // configure FTP clients with file transfer application that generates multiple file\n            // transfers\n            // TrafficGeneratorHelper trafficGeneratorHelper (\"ns3::UdpSocketFactory\", Address (),\n            // TrafficGeneratorVideo::GetTypeId ()); trafficGeneratorHelper.SetAttribute\n            // (\"IsDownlink\", BooleanValue (false)); trafficGeneratorHelper.SetAttribute\n            // (\"aParamPacketSizeUl\", UintegerValue (45)); trafficGeneratorHelper.SetAttribute\n            // (\"bParamPacketSizeUl\", DoubleValue (5.7)); trafficGeneratorHelper.SetAttribute\n            // (\"PacketArrivalUl\", UintegerValue (40)); trafficGeneratorHelper.SetAttribute\n            // (\"InitialPacketArrivalMin\", UintegerValue (0)); trafficGeneratorHelper.SetAttribute\n            // (\"InitialPacketArrivalMax\", UintegerValue (40));\n        }\n    }\n\n    if (trafficTypeConf == NGMN_HTTP || (trafficTypeConf == NGMN_MIXED && ngmnHttpIds.size() > 0))\n    {\n        // uint32_t portNgmnHttp = 7000;\n        //  the way how ThreeGppHttpClient and ThreeGppHttpServer are implemented in ns-3\n        //  it seems that the client should be installed on UEs and server on remote host\n\n        NodeContainer httpUeContainer;\n\n        for (uint32_t i = 0; i < ueSector1Container.GetN(); i++)\n        {\n            // in case of NGMN trafic allow installation of the specific traffic type only on the\n            // specific nodes\n            if ((trafficTypeConf == NGMN_MIXED) and (ngmnHttpIds.find(i) == ngmnHttpIds.end()))\n            {\n                continue;\n            }\n            httpUeContainer.Add(ueSector1Container.Get(i));\n            httpUeContainer.Add(ueSector2Container.Get(i));\n            httpUeContainer.Add(ueSector3Container.Get(i));\n        }\n\n        // 1. Create HTTP client applications\n        ThreeGppHttpClientHelper clientHelper(remoteHostAddr);\n        // Install HTTP clients on UEs\n        ApplicationContainer clientApps = clientHelper.Install(httpUeContainer);\n\n        // 2. Create HTTP server applications\n        ThreeGppHttpServerHelper serverHelper(remoteHostAddr);\n        // Install HTTP server on a remote host node\n        ApplicationContainer serverApps = serverHelper.Install(remoteHostContainer.Get(0));\n        Ptr<ThreeGppHttpServer> httpServer = serverApps.Get(0)->GetObject<ThreeGppHttpServer>();\n\n        // 3. Setup HTTP variables for the server according to NGMN white paper\n        PointerValue ptrVal;\n        httpServer->GetAttribute(\"Variables\", ptrVal);\n        Ptr<ThreeGppHttpVariables> httpParameters = ptrVal.Get<ThreeGppHttpVariables>();\n        httpParameters->SetMainObjectSizeMean(10710);        // according to NGMN white paper\n        httpParameters->SetMainObjectSizeStdDev(25032);      // according to NGMN white paper\n        httpParameters->SetEmbeddedObjectSizeMean(7758);     // according to NGMN white paper\n        httpParameters->SetEmbeddedObjectSizeStdDev(126168); /// according to NGMN white paper\n        httpParameters->SetNumOfEmbeddedObjectsMax(55);      // according to NGMN white paper\n        httpParameters->SetNumOfEmbeddedObjectsScale(2);     // according to NGMN white paper\n        httpParameters->SetNumOfEmbeddedObjectsShape(1.1);   // according to NGMN white paper\n        httpParameters->SetReadingTimeMean(Seconds(30));     // according to NGMN white paper\n        httpParameters->SetParsingTimeMean(Seconds(0.13));   // according to NGMN white paper\n\n        for (uint32_t i = 0; i < ueSector1IpIface.GetN(); i++)\n        {\n            // in case of NGMN trafic allow installation of the specific traffic type only on the\n            // specific nodes\n            if ((trafficTypeConf == NGMN_MIXED) and (ngmnHttpIds.find(i) == ngmnHttpIds.end()))\n            {\n                continue;\n            }\n\n            Ipv4Address ipAddress = ueSector1IpIface.GetAddress(i, 0);\n            PingHelper ping(ipAddress);\n            pingApps.Add(ping.Install(remoteHostContainer));\n        }\n        // configure clients on sector 2\n        for (uint32_t i = 0; i < ueSector2IpIface.GetN(); i++)\n        {\n            // in case of NGMN trafic allow installation of the specific traffic type only on the\n            // specific nodes\n            if ((trafficTypeConf == NGMN_MIXED) and (ngmnHttpIds.find(i) == ngmnHttpIds.end()))\n            {\n                continue;\n            }\n\n            Ipv4Address ipAddress = ueSector2IpIface.GetAddress(i, 0);\n            PingHelper ping(ipAddress);\n            pingApps.Add(ping.Install(remoteHostContainer));\n        }\n        // configure clients on sector 3\n        for (uint32_t i = 0; i < ueSector3IpIface.GetN(); i++)\n        {\n            // in case of NGMN trafic allow installation of the specific traffic type only on the\n            // specific nodes\n            if ((trafficTypeConf == NGMN_MIXED) and (ngmnHttpIds.find(i) == ngmnHttpIds.end()))\n            {\n                continue;\n            }\n\n            Ipv4Address ipAddress = ueSector3IpIface.GetAddress(i, 0);\n            PingHelper ping(ipAddress);\n            pingApps.Add(ping.Install(remoteHostContainer));\n        }\n    }\n\n    if (trafficTypeConf == UDP_CBR)\n    {\n        for (uint32_t i = 0; i < ueSector1Container.GetN(); ++i)\n        {\n            dlClientLowLat.SetAttribute(\n                \"Interval\",\n                TimeValue(Seconds(1.0 / lambdaPerCell[(i % gridScenario.GetNumSites()) *\n                                                      gridScenario.GetNumSectorsPerSite()])));\n            std::cout << \"ue (sector1): \" << i << \" index: \"\n                      << (i % gridScenario.GetNumSites()) * gridScenario.GetNumSectorsPerSite()\n                      << \" lambda: \"\n                      << lambdaPerCell[(i % gridScenario.GetNumSites()) *\n                                       gridScenario.GetNumSectorsPerSite()]\n                      << std::endl;\n            Ptr<Node> ue = ueSector1Container.Get(i);\n            Ptr<NetDevice> ueDevice = ueSector1NetDev.Get(i);\n            Address ueAddress = ueSector1IpIface.GetAddress(i);\n\n            // The client, who is transmitting, is installed in the remote host,\n            // with destination address set to the address of the UE\n            if (direction == \"DL\")\n            {\n                dlClientLowLat.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n                clientApps.Add(dlClientLowLat.Install(remoteHost));\n            }\n            else\n            {\n                dlClientLowLat.SetAttribute(\"RemoteAddress\", AddressValue(remoteHostAddr));\n                clientApps.Add(dlClientLowLat.Install(ue));\n            }\n            // Activate a dedicated bearer for the traffic type\n            nrHelper->ActivateDedicatedEpsBearer(ueDevice, lowLatBearer, lowLatTft);\n        }\n\n        for (uint32_t i = 0; i < ueSector2Container.GetN(); ++i)\n        {\n            dlClientLowLat.SetAttribute(\n                \"Interval\",\n                TimeValue(Seconds(1.0 / lambdaPerCell[(i % gridScenario.GetNumSites()) *\n                                                          gridScenario.GetNumSectorsPerSite() +\n                                                      1])));\n            std::cout << \"ue (sector2): \" << i << \" index: \"\n                      << (i % gridScenario.GetNumSites()) * gridScenario.GetNumSectorsPerSite() + 1\n                      << \" lambda: \"\n                      << lambdaPerCell[(i % gridScenario.GetNumSites()) *\n                                           gridScenario.GetNumSectorsPerSite() +\n                                       1]\n                      << std::endl;\n            Ptr<Node> ue = ueSector2Container.Get(i);\n            Ptr<NetDevice> ueDevice = ueSector2NetDev.Get(i);\n            Address ueAddress = ueSector2IpIface.GetAddress(i);\n\n            // The client, who is transmitting, is instaviso entonces pronto, sualled in the remote\n            // host, with destination address set to the address of the UE\n            if (direction == \"DL\")\n            {\n                dlClientLowLat.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n                clientApps.Add(dlClientLowLat.Install(remoteHost));\n            }\n            else\n            {\n                dlClientLowLat.SetAttribute(\"RemoteAddress\", AddressValue(remoteHostAddr));\n                clientApps.Add(dlClientLowLat.Install(ue));\n            }\n            // Activate a dedicated bearer for the traffic type\n            nrHelper->ActivateDedicatedEpsBearer(ueDevice, lowLatBearer, lowLatTft);\n        }\n\n        for (uint32_t i = 0; i < ueSector3Container.GetN(); ++i)\n        {\n            dlClientLowLat.SetAttribute(\n                \"Interval\",\n                TimeValue(Seconds(1.0 / lambdaPerCell[(i % gridScenario.GetNumSites()) *\n                                                          gridScenario.GetNumSectorsPerSite() +\n                                                      2])));\n            std::cout << \"ue (sector3): \" << i << \" index: \"\n                      << (i % gridScenario.GetNumSites()) * gridScenario.GetNumSectorsPerSite() + 2\n                      << \" lambda: \"\n                      << lambdaPerCell[(i % gridScenario.GetNumSites()) *\n                                           gridScenario.GetNumSectorsPerSite() +\n                                       2]\n                      << std::endl;\n            Ptr<Node> ue = ueSector3Container.Get(i);\n            Ptr<NetDevice> ueDevice = ueSector3NetDev.Get(i);\n            Address ueAddress = ueSector3IpIface.GetAddress(i);\n\n            // The client, who is transmitting, is installed in the remote host,\n            // with destination address set to the address of the UE\n            if (direction == \"DL\")\n            {\n                dlClientLowLat.SetAttribute(\"RemoteAddress\", AddressValue(ueAddress));\n                clientApps.Add(dlClientLowLat.Install(remoteHost));\n            }\n            else\n            {\n                dlClientLowLat.SetAttribute(\"RemoteAddress\", AddressValue(remoteHostAddr));\n                clientApps.Add(dlClientLowLat.Install(ue));\n            }\n            // Activate a dedicated bearer for the traffic type\n            nrHelper->ActivateDedicatedEpsBearer(ueDevice, lowLatBearer, lowLatTft);\n        }\n    }\n\n    // Add one or two pings for ARP at the beginning of the simulation\n    pingApps.Start(Seconds(0.300));\n    pingApps.Stop(Seconds(0.500));\n    serverApps.Start(serverAppStartTime);\n    serverApps.Stop(simTime - MilliSeconds(400));\n    clientApps.Start(clientAppStartTime);\n    clientApps.Stop(simTime - MilliSeconds(400));\n\n    // enable the traces provided by the nr module\n    if (traces == true)\n    {\n        nrHelper->EnableTraces();\n    }\n\n    FlowMonitorHelper flowmonHelper;\n    NodeContainer endpointNodes;\n    endpointNodes.Add(remoteHost);\n    endpointNodes.Add(gridScenario.GetUserTerminals());\n\n    Ptr<ns3::FlowMonitor> monitor = flowmonHelper.Install(endpointNodes);\n    monitor->SetAttribute(\"DelayBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"JitterBinWidth\", DoubleValue(0.001));\n    monitor->SetAttribute(\"PacketSizeBinWidth\", DoubleValue(20));\n\n    Simulator::Stop(simTime);\n    Simulator::Run();\n\n    // Print per-flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier =\n        DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n\n    double averageFlowThroughput = 0.0;\n    double averageFlowDelay = 0.0;\n\n    std::ofstream outFile;\n    std::string filename = outputDir + \"/\" + simTag;\n    double delayValues[stats.size()];\n    uint64_t cont = 0;\n\n    outFile.open(filename.c_str(), std::ofstream::out | std::ofstream::trunc);\n    if (!outFile.is_open())\n    {\n        std::cerr << \"Can't open file \" << filename << std::endl;\n        return 1;\n    }\n\n    outFile.setf(std::ios_base::fixed);\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin();\n         i != stats.end();\n         ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        std::stringstream protoStream;\n        protoStream << (uint16_t)t.protocol;\n        if (t.protocol == 6)\n        {\n            protoStream.str(\"TCP\");\n        }\n        if (t.protocol == 17)\n        {\n            protoStream.str(\"UDP\");\n        }\n        std::cout << \"Flow \" << i->first << \" (\" << t.sourceAddress << \":\" << t.sourcePort << \" -> \"\n                  << t.destinationAddress << \":\" << t.destinationPort << \") proto \"\n                  << protoStream.str() << \"\\n\";\n        std::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n        std::cout << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n        std::cout << \"  TxOffered:  \"\n                  << i->second.txBytes * 8.0 / (simTime - appStartTime).GetSeconds() / 1000.0 /\n                         1000.0\n                  << \" Mbps\\n\";\n        std::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n        std::cout << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n        if (i->second.rxPackets > 0)\n        {\n            // Measure the duration of the flow from receiver's perspective\n            // double rxDuration = i->second.timeLastRxPacket.GetSeconds () -\n            // i->second.timeFirstTxPacket.GetSeconds ();\n            double rxDuration = (simTime - appStartTime).GetSeconds();\n\n            averageFlowThroughput += i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000;\n            averageFlowDelay += 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;\n            delayValues[cont] = 1000 * i->second.delaySum.GetSeconds() / i->second.rxPackets;\n            cont++;\n\n            std::cout << \"  Throughput: \" << i->second.rxBytes * 8.0 / rxDuration / 1000 / 1000\n                      << \" Mbps\\n\";\n            std::cout << \"  Mean delay:  \"\n                      << double(1000 * i->second.delaySum.GetSeconds()) / (i->second.rxPackets)\n                      << \" ms\\n\";\n            std::cout << \"  Last packet delay: \" << i->second.lastDelay.As(Time::MS) << \"\\n\";\n            // std::cout << \"  Mean upt:  \" << i->second.uptSum / i->second.rxPackets / 1000/1000 <<\n            // \" Mbps \\n\";\n            std::cout << \"  Mean jitter:  \"\n                      << 1000 * i->second.jitterSum.GetSeconds() / i->second.rxPackets << \" ms\\n\";\n        }\n        else\n        {\n            // outFile << \"  Throughput:  0 Mbps\\n\";\n            // outFile << \"  Mean delay:  0 ms\\n\";\n            // outFile << \"  Mean jitter: 0 ms\\n\";\n        }\n        // outFile << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n    }\n    std::sort(delayValues, delayValues + stats.size());\n    // for (uint32_t i = 0; i < stats.size(); i++)\n    //   {\n    //     std::cout << delayValues[i] << \" \";\n    //   }\n    // double FiftyTileFlowDelay = (delayValues[stats.size()/2] + delayValues[stats.size()/2 -1])/2;\n    double FiftyTileFlowDelay = delayValues[stats.size() / 2];\n\n    outFile << \"\\n\\n  Mean flow throughput: \" << averageFlowThroughput / stats.size() << \"\\n\";\n    outFile << \"  Mean flow delay: \" << averageFlowDelay / stats.size() << \"\\n\";\n    outFile << \"  Median flow delay: \" << FiftyTileFlowDelay << \"\\n\";\n\n    outFile.close();\n\n    std::ifstream f(filename.c_str());\n\n    if (f.is_open())\n    {\n        std::cout << f.rdbuf();\n    }\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/cttc-realistic-beamforming.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2020 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/eps-bearer-tag.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/point-to-point-helper.h\"\n#include \"ns3/stats-module.h\"\n#include <ns3/sqlite-output.h>\n\nconst uint32_t DB_ATTEMPT_LIMIT = 20; // how many times to try to perform DB query before giving up,\n                                      // we dont want to enter to a infinite loop\n\nusing namespace ns3;\n\n/**\n * \\ingroup examples\n * \\file realistic-beamforming.cc\n * \\brief Simulation script for the realistic beamforming evaluation.\n * Simulation allows to configure various parameters out of which the\n * most important are:\n * - distance (by configuring deltaX and deltaY parameters). Distance\n * between transmitter and the receiver is an important parameter\n * (since we want to evaluate how the distance impact the selection of\n * the correct beam). Distance will be configured with deltaX and delta Y\n * simulation parameters that define the relative position of UE with\n * respect to gNB's position.\n * - type of the beamfoming methods (because we want to obtain results\n * for both ideal beamforming algorithm and realistic beamforming\n * algorithm. Expected behavior is that as the distance increases that\n * the error in estimating channel increases, thus realistic beamforming\n * algorithm makes more mistakes when selecting the correct beams at the\n * transmiter and the receiver).\n * -rngRun - random run number that will allow us to run many simulations\n * and to average the results\n *\n * The topology is very simple, consists of a single gNB and UE.\n *\n * <pre>\n *\n *                                                   + UE\n *                                                   |\n *                                                   |\n *                                                deltaY\n *                                                   |\n *                                                   |\n *                                                   |\n *   gNB+  ------------deltaX-------------------------\n * </pre>\n *\n *\n * The output files contain SINR values. File name starts with the prefix\n * \"sinrs\" which is followed by the ${simTag} if provided or by default with\n * a string that briefly describes the configuration parameters\n * that are being set in the specific simulation execution.\n *\n * The output file is created by default in the root project directory if not\n * configured differently by setting resultsDirPath parameter of the Run()\n * function.\n * To run this simulation you can use for example the following command:\n *\n * ./ns3 run cttc-realistic-beamforming '--command=%s\n *    --deltaX=300\n *    --deltaY=0\n *    --algType=Real\n *    --rngRun=1\n *    --numerology=0\n *    --gnbAntenna=3gpp\n *    --ueAntenna=3gpp\n *    --uePower=10\n *    --scenario=Uma\n *    --simTag=-sim-campaign-algReal-rng1-mu0-gNb3gpp-ue3gpp\n *    --resultsDir=/tmp/results/realistic-beamforming/\n *    --dbName=realistic_beamforming.db\n *    --tableName=results'\n *\n * To check all the parameters that are available you can always use:\n *\n * ./ns3 run \"cttc-realistic-beamforming --PrintHelp\"\n *\n */\n\nNS_LOG_COMPONENT_DEFINE(\"CttcRealisticBeamforming\");\n\n/**\n * \\brief Main class\n */\nclass CttcRealisticBeamforming\n{\n  public:\n    enum BeamformingMethod\n    {\n        IDEAL,\n        REALISTIC,\n    };\n\n    /**\n     * \\brief This function converts a linear SINR value that is encapsulated in\n     * params structure to dBs, and then it prints the dB value to an output file\n     * containing SINR values.\n     * @param params RxPacketTraceParams structure that contains different\n     * attributes that define the reception of the packet\n     *\n     */\n    void UeReception(RxPacketTraceParams params);\n\n    /**\n     * \\brief Function that will save the configuration parameters to be used later for\n     * printing the results into the files.\n     *\n     * @param deltaX delta that will be used to determine X coordinate of UE wrt to gNB X coordinate\n     * @param deltaY delta that will be used to determine Y coordinate of UE wrt to gNB Y coordinate\n     * @param beamforming beamforming type: Ideal or Real\n     * @param realTriggerEvent if realistic beamforming is used it defines the trigger event\n     * @param idealPeriodicity if the ideal beamforming is used it defines the periodicity\n     * @param rngRun rngRun number that will be used to run the simulation\n     * @param numerology The numerology\n     * @param gnbAntenna antenna model to be used by gNB device, can be Iso or directional 3gpp\n     * @param ueAntenna antenna model to be used by UE device, can be Iso directional 3gpp\n     * @param scenario deployment scenario, can be Uma, Umi, Inh, Rma\n     * @param uePower uePower\n     * @param resultsDirPath results directory path\n     * @param tag A tag that contains some simulation run specific values in order\n     * to be able to distinguish the results file for different runs for different\n     * parameters configuration\n     */\n    void Configure(double deltaX,\n                   double deltaY,\n                   BeamformingMethod beamforming,\n                   RealisticBfManager::TriggerEvent realTriggerEvent,\n                   uint32_t idealPeriodicity,\n                   uint64_t rngRun,\n                   uint16_t numerology,\n                   std::string gnbAntenna,\n                   std::string ueAntenna,\n                   std::string scenario,\n                   double uePower,\n                   std::string resultsDirPath,\n                   std::string tag,\n                   std::string dbName,\n                   std::string tableName);\n\n    /**\n     * \\brief Function that will actually configure all the simulation parameters,\n     * topology and run the simulation by using the parameters that are being\n     * configured for the specific run.\n     */\n    void RunSimulation();\n    /**\n     * \\brief Destructor that closes the output file stream and finished the\n     *  writing into the files.\n     */\n    ~CttcRealisticBeamforming();\n    /**\n     * \\brief Creates a string tag that contains some simulation run specific values in\n     * order to be able to distinguish the results files for different runs for\n     * different parameters.\n     */\n    std::string BuildTag();\n    /**\n     * \\brief\n     * Prepare files for the output of the results\n     */\n    void PrepareOutputFiles();\n    /**\n     * \\brief\n     * Print the statistics to the output files\n     */\n    void PrintResultsToFiles();\n    /**\n     * \\brief\n     * Create traffic applications\n     */\n    void CreateDlTrafficApplications(ApplicationContainer& serverAppDl,\n                                     ApplicationContainer& clientAppDl,\n                                     NodeContainer& ueNode,\n                                     Ptr<Node> remoteHost,\n                                     NetDeviceContainer ueNetDev,\n                                     Ipv4InterfaceContainer& ueIpIface);\n\n    /**\n     * \\brief Prepare the database to print the results, e.g., open it, and\n     * create the necessary table if it does not exist.\n     * Method creates, if not exists, a table for storing the values. The table\n     * will contain the following columns:\n     *\n     * - \"(Sinr DOUBLE NOT NULL, \"\n     * - \"Distance DOUBLE NULL,\"\n     *   \"DeltaX DOUBLE NULL,\n     *   \"DeltaY DOUBLE NULL,\n     *   \"BeamformingType TEXT NOT NULL,\"\n     *   \"RngRun INTEGER NOT NULL,\"\n     *   \"numerology INTEGER NOT NULL,\"\n     *   \"gNBAntenna TEXT NOT NULL,\"\n     *   \"ueAntenna TEXT NOT NULL,\"\n     *   \"uePower INTEGER NOT NULL,\"\n     *   \"scenario TEXT NOT NULL,\"\n     * - \"Seed INTEGER NOT NULL,\"\n     * - \"Run INTEGER NOT NULL);\"\n     *\n     * NOTE: If the database already contains a table with\n     * the same name, this method will clean existing values\n     * with the same Run value.\n     */\n    void PrepareDatabase();\n\n    /**\n     * \\brief Insert results to the table in database.\n     */\n    void PrintResultsToDatabase();\n\n    /**\n     * \\brief Delete results entry from database if already exist\n     */\n    void DeleteFromDatabaseIfAlreadyExist();\n\n  private:\n    // output file streams\n    std::ofstream m_outSinrFile; //!< the output file stream for the SINR file in linear scale\n\n    // database related attributes\n    sqlite3* m_db{nullptr};                           //!< DB pointer\n    std::string m_tableName{\"results\"};               //!< Table name\n    std::string m_dbName{\"realistic_beamforming.db\"}; //!< Database name\n\n    // statistics collecting object\n    MinMaxAvgTotalCalculator<double> m_sinrStats; //!< the statistics calculator for SINR values\n\n    // main simulation parameters that is expected that user will change often\n    double m_deltaX{1};\n    double m_deltaY{1};\n    BeamformingMethod m_beamforming{IDEAL};\n    uint32_t m_rngRun{1};\n    RealisticBfManager::TriggerEvent m_realTriggerEvent{RealisticBfManager::SRS_COUNT};\n    uint32_t m_idealPeriodicity{0}; // ideal beamforming periodicity in the number of milli seconds\n    uint16_t m_numerology{0};\n    std::string m_gnbAntennaModel{\"Iso\"};\n    std::string m_ueAntennaModel{\"Iso\"};\n    std::string m_scenario{\"Uma\"};\n    std::string m_resultsDirPath{\"\"};\n    std::string m_tag{\"\"};\n    double m_gNbHeight{25};\n    double m_gNbTxPower{35};\n    BandwidthPartInfo::Scenario m_deployScenario{BandwidthPartInfo::UMa};\n    double m_ueTxPower{23};\n\n    // simulation parameters that are not expected to be changed often by the user\n    Time m_simTime = MilliSeconds(150);\n    Time m_udpAppStartTimeDl = MilliSeconds(100);\n    Time m_udpAppStopTimeDl = MilliSeconds(150);\n    uint32_t m_packetSize = 1000;\n    DataRate m_udpRate = DataRate(\"1kbps\");\n    double m_centralFrequency = 28e9;\n    double m_bandwidth = 100e6;\n    double m_ueHeight = 1.5; // UE antenna height is 1.5 meters\n\n    const uint8_t m_numCcPerBand = 1;\n    double m_gNbX = 0;\n    double m_gNbY = 0;\n};\n\n/**\n * Function that creates the output file name for the results.\n * @param directoryName Directory name\n * @param filePrefix The prefix for the file name, e.g. sinr\n * @param tag A tag that contains some simulation run specific values in order to be\n * able to distinguish the results file for different runs for different parameters\n * configuration\n * @return returns The full path file name string\n */\nstd::string\nBuildFileNameString(std::string directoryName, std::string filePrefix, std::string tag)\n{\n    std::ostringstream oss;\n    oss << directoryName << \"/\" << filePrefix << tag;\n    return oss.str();\n}\n\nstd::string\nCttcRealisticBeamforming::BuildTag()\n{\n    NS_LOG_FUNCTION(this);\n\n    std::ostringstream oss;\n    std::string algorithm = (m_beamforming == CttcRealisticBeamforming::IDEAL) ? \"I\" : \"R\";\n    double distance2D = sqrt(m_deltaX * m_deltaX + m_deltaY * m_deltaY);\n\n    oss << \"-\" << algorithm << \"-d\" << distance2D << \"-mu\" << m_numerology << \"-gnb\"\n        << m_gnbAntennaModel << \"-ue\" << m_ueAntennaModel << \"-uePow\" << m_ueTxPower << \"-scenario\"\n        << m_scenario;\n\n    return oss.str();\n}\n\nvoid\nCttcRealisticBeamforming::PrepareOutputFiles()\n{\n    NS_LOG_FUNCTION(this);\n    // If simulation tag is not provided create one, user can provide his own tag through the\n    // command line\n    if (m_tag == \"\")\n    {\n        m_tag = BuildTag();\n    }\n    std::string fileSinr = BuildFileNameString(m_resultsDirPath, \"sinrs\", m_tag);\n\n    m_outSinrFile.open(fileSinr.c_str(), std::ios_base::app);\n    m_outSinrFile.setf(std::ios_base::fixed);\n    NS_ABORT_MSG_IF(!m_outSinrFile.is_open(), \"Can't open file \" << fileSinr);\n}\n\nvoid\nCttcRealisticBeamforming::PrepareDatabase()\n{\n    NS_LOG_FUNCTION(this);\n\n    int rc = sqlite3_open((m_resultsDirPath + \"/\" + m_dbName).c_str(), &m_db);\n    NS_ABORT_MSG_UNLESS(rc == SQLITE_OK, \"Failed to open DB\");\n\n    std::string cmd = \"CREATE TABLE IF NOT EXISTS \" + m_tableName +\n                      \" (\"\n                      \"SINR DOUBLE NOT NULL, \"\n                      \"SINR_DB DOUBLE NOT NULL, \"\n                      \"Distance DOUBLE NOT NULL,\"\n                      \"DeltaX DOUBLE NOT NULL,\"\n                      \"DeltaY DOUBLE NOT NULL,\"\n                      \"BeamformingType TEXT NOT NULL,\"\n                      \"RngRun INTEGER NOT NULL,\"\n                      \"Numerology INTEGER NOT NULL,\"\n                      \"GnbAntenna TEXT NOT NULL,\"\n                      \"UeAntenna TEXT NOT NULL,\"\n                      \"UePower INTEGER NOT NULL,\"\n                      \"Scenario TEXT NOT NULL);\";\n\n    sqlite3_stmt* stmt;\n\n    // prepare the statement for creating the table\n    uint32_t attemptCount = 0;\n    do\n    {\n        rc = sqlite3_prepare_v2(m_db, cmd.c_str(), static_cast<int>(cmd.size()), &stmt, nullptr);\n        NS_ABORT_MSG_IF(\n            ++attemptCount == DB_ATTEMPT_LIMIT,\n            \"Waiting too much for sqlite3 database to be ready. \"\n            \"Check if you have the database/table open with another program. \"\n            \"If yes, close it before running again cttc-realistic-beamforming program.\\n\\n\");\n    } while (rc == SQLITE_BUSY || rc == SQLITE_LOCKED);\n    // check if it went correctly\n    NS_ABORT_MSG_UNLESS(\n        rc == SQLITE_OK || rc == SQLITE_DONE,\n        \"Could not prepare correctly the statement for creating the table. Db error:\"\n            << sqlite3_errmsg(m_db) << \"full command is: \\n\"\n            << cmd);\n\n    // execute a step operation on a statement until the result is ok or an error\n    attemptCount = 0;\n    do\n    {\n        rc = sqlite3_step(stmt);\n        NS_ABORT_MSG_IF(\n            ++attemptCount == DB_ATTEMPT_LIMIT,\n            \"Waiting too much for sqlite3 database to be ready. \"\n            \"Check if you have the database/table open with another program. \"\n            \"If yes, close it before running again cttc-realistic-beamforming program.\\n\\n\");\n    } while (rc == SQLITE_BUSY || rc == SQLITE_LOCKED);\n    // check if it went correctly\n    NS_ABORT_MSG_UNLESS(\n        rc == SQLITE_OK || rc == SQLITE_DONE,\n        \"Could not correctly execute the statement for creating the table. Db error:\"\n            << sqlite3_errmsg(m_db));\n\n    // finalize the statement until the result is ok or an error occures\n    attemptCount = 0;\n    do\n    {\n        rc = sqlite3_finalize(stmt);\n        NS_ABORT_MSG_IF(\n            ++attemptCount == DB_ATTEMPT_LIMIT,\n            \"Waiting too much for sqlite3 database to be ready. \"\n            \"Check if you have the database/table open with another program. \"\n            \"If yes, close it before running again cttc-realistic-beamforming program.\\n\\n\");\n    } while (rc == SQLITE_BUSY || rc == SQLITE_LOCKED);\n    // check if it went correctly\n    NS_ABORT_MSG_UNLESS(\n        rc == SQLITE_OK || rc == SQLITE_DONE,\n        \"Could not correctly execute the statement for creating the table. Db error:\"\n            << sqlite3_errmsg(m_db));\n}\n\nvoid\nCttcRealisticBeamforming::PrintResultsToDatabase()\n{\n    NS_LOG_FUNCTION(this);\n\n    DeleteFromDatabaseIfAlreadyExist();\n\n    sqlite3_stmt* stmt;\n    std::string cmd =\n        \"INSERT INTO \" + m_tableName + \" VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);\";\n    std::string beamformingType = (m_beamforming == IDEAL) ? \"Ideal\" : \"Real\";\n    int rc;\n    double distance2D = sqrt(m_deltaX * m_deltaX + m_deltaY * m_deltaY);\n\n    // prepare the statement for creating the table\n    uint32_t attemptCount = 0;\n    do\n    {\n        rc = sqlite3_prepare_v2(m_db, cmd.c_str(), static_cast<int>(cmd.size()), &stmt, nullptr);\n        NS_ABORT_MSG_IF(\n            ++attemptCount == DB_ATTEMPT_LIMIT,\n            \"Waiting too much for sqlite3 database to be ready. \"\n            \"Check if you have the database/table open with another program. \"\n            \"If yes, close it before running again cttc-realistic-beamforming program.\\n\\n\");\n    } while (rc == SQLITE_BUSY || rc == SQLITE_LOCKED);\n    // check if it went correctly\n    NS_ABORT_MSG_UNLESS(rc == SQLITE_OK || rc == SQLITE_DONE,\n                        \"Could not prepare correctly the insert into the table statement. \"\n                        \" Db error:\"\n                            << sqlite3_errmsg(m_db) << \". The full command is: \\n\"\n                            << cmd);\n\n    // add all parameters to the command\n    NS_ABORT_UNLESS(sqlite3_bind_double(stmt, 1, m_sinrStats.getMean()) == SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_double(stmt, 2, 10.0 * log10(m_sinrStats.getMean())) == SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_double(stmt, 3, distance2D) == SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_double(stmt, 4, m_deltaX) == SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_double(stmt, 5, m_deltaY) == SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_text(stmt, 6, beamformingType.c_str(), -1, SQLITE_STATIC) ==\n                    SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_int(stmt, 7, m_rngRun) == SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_int(stmt, 8, m_numerology) == SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_text(stmt, 9, m_gnbAntennaModel.c_str(), -1, SQLITE_STATIC) ==\n                    SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_text(stmt, 10, m_ueAntennaModel.c_str(), -1, SQLITE_STATIC) ==\n                    SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_int(stmt, 11, m_ueTxPower) == SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_text(stmt, 12, m_scenario.c_str(), -1, SQLITE_STATIC) ==\n                    SQLITE_OK);\n\n    // finalize the command\n    attemptCount = 0;\n    do\n    {\n        rc = sqlite3_step(stmt);\n        NS_ABORT_MSG_IF(\n            ++attemptCount == DB_ATTEMPT_LIMIT,\n            \"Waiting too much for sqlite3 database to be ready. \"\n            \"Check if you have the database/table open with another program. \"\n            \"If yes, close it before running again cttc-realistic-beamforming program.\\n\\n\");\n    } while (rc == SQLITE_BUSY || rc == SQLITE_LOCKED);\n    // check if it went correctly\n    NS_ABORT_MSG_UNLESS(\n        rc == SQLITE_OK || rc == SQLITE_DONE,\n        \"Could not correctly execute the statement. Db error:\" << sqlite3_errmsg(m_db));\n    attemptCount = 0;\n    do\n    {\n        rc = sqlite3_finalize(stmt);\n        NS_ABORT_MSG_IF(\n            ++attemptCount == DB_ATTEMPT_LIMIT,\n            \"Waiting too much for sqlite3 database to be ready. \"\n            \"Check if you have the database/table open with another program. \"\n            \"If yes, close it before running again cttc-realistic-beamforming program.\\n\\n\");\n    } while (rc == SQLITE_BUSY || rc == SQLITE_LOCKED);\n    NS_ABORT_MSG_UNLESS(\n        rc == SQLITE_OK || rc == SQLITE_DONE,\n        \"Could not correctly execute the statement. Db error:\" << sqlite3_errmsg(m_db));\n}\n\nvoid\nCttcRealisticBeamforming::DeleteFromDatabaseIfAlreadyExist()\n{\n    sqlite3_stmt* stmt;\n    std::string cmd = \"DELETE FROM \\\"\" + m_tableName +\n                      \"\\\" WHERE \"\n                      \"deltaX == ? AND \"         // 1\n                      \"deltaY == ? AND \"         // 2\n                      \"BeamformingType = ? AND \" // 3\n                      \"RngRun == ? AND \"         // 4\n                      \"Numerology == ? AND \"     // 5\n                      \"GnbAntenna = ? AND \"      // 6\n                      \"UeAntenna = ? AND \"       // 7\n                      \"UePower = ? AND \"         // 8\n                      \"Scenario = ?;\";           // 9\n    int rc;\n\n    // prepare the statement for creating the table\n    uint32_t attemptCount = 0;\n    do\n    {\n        rc = sqlite3_prepare_v2(m_db, cmd.c_str(), static_cast<int>(cmd.size()), &stmt, nullptr);\n        NS_ABORT_MSG_IF(\n            ++attemptCount == DB_ATTEMPT_LIMIT,\n            \"Waiting too much for sqlite3 database to be ready. \"\n            \"Check if you have the database/table open with another program. \"\n            \"If yes, close it before running again cttc-realistic-beamforming program.\\n\\n\");\n    } while (rc == SQLITE_BUSY || rc == SQLITE_LOCKED);\n    // check if it went correctly\n    NS_ABORT_MSG_UNLESS(rc == SQLITE_OK || rc == SQLITE_DONE,\n                        \"Could not prepare correctly the delete statement. \"\n                        \" Db error:\"\n                            << sqlite3_errmsg(m_db) << \". The full command is: \\n\"\n                            << cmd);\n\n    std::string beamformingType = (m_beamforming == IDEAL) ? \"Ideal\" : \"Real\";\n    // add all parameters to the command\n    NS_ABORT_UNLESS(sqlite3_bind_double(stmt, 1, m_deltaX) == SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_double(stmt, 2, m_deltaY) == SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_text(stmt, 3, beamformingType.c_str(), -1, SQLITE_STATIC) ==\n                    SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_int(stmt, 4, m_rngRun) == SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_int(stmt, 5, m_numerology) == SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_text(stmt, 6, m_gnbAntennaModel.c_str(), -1, SQLITE_STATIC) ==\n                    SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_text(stmt, 7, m_ueAntennaModel.c_str(), -1, SQLITE_STATIC) ==\n                    SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_int(stmt, 8, m_ueTxPower) == SQLITE_OK);\n    NS_ABORT_UNLESS(sqlite3_bind_text(stmt, 9, m_scenario.c_str(), -1, SQLITE_STATIC) == SQLITE_OK);\n\n    // finalize the command\n    attemptCount = 0;\n    do\n    {\n        rc = sqlite3_step(stmt);\n        NS_ABORT_MSG_IF(\n            ++attemptCount == DB_ATTEMPT_LIMIT,\n            \"Waiting too much for sqlite3 database to be ready. \"\n            \"Check if you have the database/table open with another program. \"\n            \"If yes, close it before running again cttc-realistic-beamforming program.\\n\\n\");\n    } while (rc == SQLITE_BUSY || rc == SQLITE_LOCKED);\n    // check if it went correctly\n    NS_ABORT_MSG_UNLESS(\n        rc == SQLITE_OK || rc == SQLITE_DONE,\n        \"Could not correctly execute the statement. Db error:\" << sqlite3_errmsg(m_db));\n    attemptCount = 0;\n    do\n    {\n        rc = sqlite3_finalize(stmt);\n        NS_ABORT_MSG_IF(\n            ++attemptCount == DB_ATTEMPT_LIMIT,\n            \"Waiting too much for sqlite3 database to be ready. \"\n            \"Check if you have the database/table open with another program. \"\n            \"If yes, close it before running again cttc-realistic-beamforming program.\\n\\n\");\n    } while (rc == SQLITE_BUSY || rc == SQLITE_LOCKED);\n    NS_ABORT_MSG_UNLESS(\n        rc == SQLITE_OK || rc == SQLITE_DONE,\n        \"Could not correctly execute the statement. Db error:\" << sqlite3_errmsg(m_db));\n}\n\nvoid\nCttcRealisticBeamforming::CreateDlTrafficApplications(ApplicationContainer& serverAppDl,\n                                                      ApplicationContainer& clientAppDl,\n                                                      NodeContainer& ueNode,\n                                                      Ptr<Node> remoteHost,\n                                                      NetDeviceContainer ueNetDev,\n                                                      Ipv4InterfaceContainer& ueIpIface)\n{\n    NS_LOG_FUNCTION(this);\n    uint16_t dlPort = 1234;\n    // Calculate UDP interval based on the packetSize and desired udp rate\n    Time udpInterval =\n        Time::FromDouble((m_packetSize * 8) / static_cast<double>(m_udpRate.GetBitRate()), Time::S);\n    UdpServerHelper dlPacketSinkHelper(dlPort);\n    serverAppDl.Add(dlPacketSinkHelper.Install(ueNode));\n    // Configure UDP downlink traffic\n    for (uint32_t i = 0; i < ueNetDev.GetN(); i++)\n    {\n        UdpClientHelper dlClient(ueIpIface.GetAddress(i), dlPort);\n        dlClient.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n        dlClient.SetAttribute(\"PacketSize\", UintegerValue(m_packetSize));\n        dlClient.SetAttribute(\n            \"Interval\",\n            TimeValue(udpInterval)); // we try to saturate, we just need to measure during a short\n                                     // time, how much traffic can handle each BWP\n        clientAppDl.Add(dlClient.Install(remoteHost));\n    }\n\n    // Start UDP server and client app, and configure stop time\n    serverAppDl.Start(m_udpAppStartTimeDl);\n    clientAppDl.Start(m_udpAppStartTimeDl);\n    serverAppDl.Stop(m_udpAppStopTimeDl);\n    clientAppDl.Stop(m_udpAppStopTimeDl);\n}\n\n/**\n * A callback function that redirects a call to the simulation setup instance.\n * @param simSetup A pointer to a simulation instance\n * @param params RxPacketTraceParams structure containing RX parameters\n */\nvoid\nUeReceptionTrace(CttcRealisticBeamforming* simSetup, RxPacketTraceParams params)\n{\n    simSetup->UeReception(params);\n}\n\nvoid\nCttcRealisticBeamforming::UeReception(RxPacketTraceParams params)\n{\n    m_sinrStats.Update(params.m_sinr); // we have to pass the linear value\n}\n\nCttcRealisticBeamforming::~CttcRealisticBeamforming()\n{\n    // close the output results file\n    m_outSinrFile.close();\n\n    // Failed to close the database\n    int rc = SQLITE_FAIL;\n    rc = sqlite3_close_v2(m_db);\n    NS_ABORT_MSG_UNLESS(rc == SQLITE_OK, \"Failed to close DB\");\n}\n\nvoid\nCttcRealisticBeamforming::PrintResultsToFiles()\n{\n    NS_LOG_FUNCTION(this);\n    m_outSinrFile << m_sinrStats.getMean() << std::endl;\n}\n\nvoid\nCttcRealisticBeamforming::Configure(double deltaX,\n                                    double deltaY,\n                                    BeamformingMethod beamforming,\n                                    RealisticBfManager::TriggerEvent realTriggerEvent,\n                                    uint32_t idealPeriodicity,\n                                    uint64_t rngRun,\n                                    uint16_t numerology,\n                                    std::string gNbAntennaModel,\n                                    std::string ueAntennaModel,\n                                    std::string scenario,\n                                    double uePower,\n                                    std::string resultsDirPath,\n                                    std::string tag,\n                                    std::string dbName,\n                                    std::string tableName)\n\n{\n    NS_LOG_FUNCTION(this);\n    m_deltaX = deltaX;\n    m_deltaY = deltaY;\n    m_beamforming = beamforming;\n    m_rngRun = rngRun;\n    m_realTriggerEvent = realTriggerEvent;\n    m_idealPeriodicity = idealPeriodicity;\n    m_numerology = numerology;\n    m_gnbAntennaModel = gNbAntennaModel;\n    m_ueAntennaModel = ueAntennaModel;\n    m_scenario = scenario;\n    m_ueTxPower = uePower;\n    m_resultsDirPath = resultsDirPath;\n    m_tag = tag;\n\n    if (scenario == \"Uma\") // parameters based on TR 38.901 full calibration for RMa, UMa, UMi and\n                           // InH_OfficeOpen, 30GHz band\n    {\n        m_gNbHeight = 25;  // gNB antenna height\n        m_gNbTxPower = 35; // gNB transmit power\n        m_deployScenario = BandwidthPartInfo::UMa;\n    }\n    else if (scenario == \"UmaLos\")\n    {\n        m_gNbHeight = 25;\n        m_gNbTxPower = 35;\n        m_deployScenario = BandwidthPartInfo::UMa_LoS;\n    }\n    else if (scenario == \"UmaNlos\")\n    {\n        m_gNbHeight = 25;\n        m_gNbTxPower = 35;\n        m_deployScenario = BandwidthPartInfo::UMa_nLoS;\n    }\n    else if (scenario == \"Rma\")\n    {\n        m_gNbHeight = 35;\n        m_gNbTxPower = 35;\n        m_deployScenario = BandwidthPartInfo::RMa;\n    }\n    else if (scenario == \"RmaLos\")\n    {\n        m_gNbHeight = 35;\n        m_gNbTxPower = 35;\n        m_deployScenario = BandwidthPartInfo::RMa_LoS;\n    }\n    else if (scenario == \"RmaNlos\")\n    {\n        m_gNbHeight = 35;\n        m_gNbTxPower = 35;\n        m_deployScenario = BandwidthPartInfo::RMa_nLoS;\n    }\n    else if (scenario == \"Umi\")\n    {\n        m_gNbHeight = 10;\n        m_gNbTxPower = 35;\n        m_deployScenario = BandwidthPartInfo::UMi_StreetCanyon;\n    }\n    else if (scenario == \"UmiLos\")\n    {\n        m_gNbHeight = 10;\n        m_gNbTxPower = 35;\n        m_deployScenario = BandwidthPartInfo::UMi_StreetCanyon_LoS;\n    }\n    else if (scenario == \"UmiNlos\")\n    {\n        m_gNbHeight = 10;\n        m_gNbTxPower = 35;\n        m_deployScenario = BandwidthPartInfo::UMi_StreetCanyon_nLoS;\n    }\n    else if (scenario == \"Inh\")\n    {\n        m_gNbHeight = 3;\n        m_gNbTxPower = 24;\n        m_deployScenario = BandwidthPartInfo::InH_OfficeOpen;\n    }\n    else if (scenario == \"InhLos\")\n    {\n        m_gNbHeight = 3;\n        m_gNbTxPower = 24;\n        m_deployScenario = BandwidthPartInfo::InH_OfficeOpen_LoS;\n    }\n    else if (scenario == \"InhNlos\")\n    {\n        m_gNbHeight = 3;\n        m_gNbTxPower = 24;\n        m_deployScenario = BandwidthPartInfo::InH_OfficeOpen_nLoS;\n    }\n    else\n    {\n        NS_ABORT_MSG(\"Not supported scenario:\" << scenario);\n    }\n}\n\nvoid\nCttcRealisticBeamforming::RunSimulation()\n{\n    NS_LOG_FUNCTION(this);\n\n    // Set simulation run number\n    SeedManager::SetRun(m_rngRun);\n\n    // Create gNB and UE nodes\n    NodeContainer gNbNode;\n    NodeContainer ueNode;\n    gNbNode.Create(1);\n    ueNode.Create(1);\n\n    // Set positions\n    Ptr<ListPositionAllocator> positions = CreateObject<ListPositionAllocator>();\n    positions->Add(Vector(m_gNbX, m_gNbY, m_gNbHeight)); // gNb will take this position\n    positions->Add(\n        Vector(m_gNbX + m_deltaX, m_gNbY + m_deltaY, m_ueHeight)); // UE will take this position\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(positions);\n    mobility.Install(gNbNode);\n    mobility.Install(ueNode);\n\n    // Create NR helpers: nr helper, epc helper, and beamforming helper\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n\n    // Initialize beamforming\n    Ptr<BeamformingHelperBase> beamformingHelper;\n\n    if (m_beamforming == CttcRealisticBeamforming::IDEAL)\n    {\n        beamformingHelper = CreateObject<IdealBeamformingHelper>();\n        beamformingHelper->SetAttribute(\"BeamformingPeriodicity\",\n                                        TimeValue(MilliSeconds(m_idealPeriodicity)));\n        beamformingHelper->SetBeamformingMethod(CellScanBeamforming::GetTypeId());\n    }\n    else if (m_beamforming == CttcRealisticBeamforming::REALISTIC)\n    {\n        beamformingHelper = CreateObject<RealisticBeamformingHelper>();\n        beamformingHelper->SetBeamformingMethod(RealisticBeamformingAlgorithm::GetTypeId());\n        // when realistic beamforming used, also realistic beam manager should be set\n        // TODO, move this to NrHelper, so user sets BeamformingMethod calling NrHelper\n        nrHelper->SetGnbBeamManagerTypeId(RealisticBfManager::GetTypeId());\n        nrHelper->SetGnbBeamManagerAttribute(\"TriggerEvent\", EnumValue(m_realTriggerEvent));\n    }\n    else\n    {\n        NS_ABORT_MSG(\"Unknown beamforming type.\");\n    }\n    nrHelper->SetBeamformingHelper(beamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    Config::SetDefault(\"ns3::NrUePhy::EnableUplinkPowerControl\", BooleanValue(false));\n\n    /*\n     * Configure the spectrum division: single operational band, containing single\n     * component carrier, which contains a single bandwidth part.\n     *\n     * |------------------------Band-------------------------|\n     * |-------------------------CC--------------------------|\n     * |-------------------------BWP-------------------------|\n     *\n     */\n    CcBwpCreator ccBwpCreator;\n    // Create the configuration for the CcBwpHelper. SimpleOperationBandConf creates a single BWP\n    // per CC\n    CcBwpCreator::SimpleOperationBandConf bandConf(m_centralFrequency,\n                                                   m_bandwidth,\n                                                   m_numCcPerBand,\n                                                   m_deployScenario);\n    // By using the configuration created, make the operation band\n    OperationBandInfo band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);\n    nrHelper->InitializeOperationBand(&band);\n    BandwidthPartInfoPtrVector allBwps = CcBwpCreator::GetAllBwps({band});\n\n    // Configure antenna of gNb\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(4));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(8));\n    // Antenna element type for gNBs\n    if (m_gnbAntennaModel == \"Iso\")\n    {\n        nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                         PointerValue(CreateObject<IsotropicAntennaModel>()));\n    }\n    else\n    {\n        nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                         PointerValue(CreateObject<ThreeGppAntennaModel>()));\n    }\n\n    // Configure antenna of UE\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(2));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(4));\n    // Antenna element type for UEs\n    if (m_ueAntennaModel == \"Iso\")\n    {\n        nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                        PointerValue(CreateObject<IsotropicAntennaModel>()));\n    }\n    else\n    {\n        nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                        PointerValue(CreateObject<ThreeGppAntennaModel>()));\n    }\n    // configure schedulers\n    nrHelper->SetSchedulerAttribute(\"SrsSymbols\", UintegerValue(1));\n\n    // Install nr net devices\n    NetDeviceContainer gNbDev = nrHelper->InstallGnbDevice(gNbNode, allBwps);\n    NetDeviceContainer ueNetDev = nrHelper->InstallUeDevice(ueNode, allBwps);\n\n    int64_t randomStream = m_rngRun;\n    randomStream += nrHelper->AssignStreams(gNbDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);\n\n    for (uint32_t i = 0; i < gNbDev.GetN(); i++)\n    {\n        nrHelper->GetGnbPhy(gNbDev.Get(i), 0)\n            ->SetAttribute(\"Numerology\", UintegerValue(m_numerology));\n        nrHelper->GetGnbPhy(gNbDev.Get(i), 0)->SetAttribute(\"TxPower\", DoubleValue(m_gNbTxPower));\n    }\n    for (uint32_t j = 0; j < ueNetDev.GetN(); j++)\n    {\n        nrHelper->GetUePhy(ueNetDev.Get(j), 0)->SetAttribute(\"TxPower\", DoubleValue(m_ueTxPower));\n    }\n\n    // Update configuration\n    for (auto it = gNbDev.Begin(); it != gNbDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    // Create the internet and install the IP stack on the UEs, get SGW/PGW and create a single\n    // RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.000)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n\n    // Configure routing\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(ueNode);\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));\n\n    // Set the default gateway for the UE\n    for (uint32_t j = 0; j < ueNode.GetN(); ++j)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(ueNode.Get(j)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // Attach UE to gNB\n    nrHelper->AttachToEnb(ueNetDev.Get(0), gNbDev.Get(0));\n\n    // Install UDP downlink applications\n    ApplicationContainer clientAppDl;\n    ApplicationContainer serverAppDl;\n    CreateDlTrafficApplications(clientAppDl, serverAppDl, ueNode, remoteHost, ueNetDev, ueIpIface);\n\n    // Connect traces to our listener functions\n    for (uint32_t i = 0; i < ueNetDev.GetN(); i++)\n    {\n        Ptr<NrSpectrumPhy> ue1SpectrumPhy =\n            DynamicCast<NrUeNetDevice>(ueNetDev.Get(i))->GetPhy(0)->GetSpectrumPhy();\n        ue1SpectrumPhy->TraceConnectWithoutContext(\"RxPacketTraceUe\",\n                                                   MakeBoundCallback(&UeReceptionTrace, this));\n        Ptr<NrInterference> ue1SpectrumPhyInterference = ue1SpectrumPhy->GetNrInterference();\n        NS_ABORT_IF(!ue1SpectrumPhyInterference);\n    }\n\n    Simulator::Stop(m_simTime);\n    Simulator::Run();\n    Simulator::Destroy();\n}\n\nint\nmain(int argc, char* argv[])\n{\n    // simulation configuration parameters\n    double deltaX = 10.0;\n    double deltaY = 10.0;\n    std::string algType = \"Real\";\n    std::string realTriggerEvent =\n        \"SrsCount\"; // what will be the trigger event to update the beamforming vectors, only used\n                    // when --algType=\"Real\"\n    uint32_t idealPeriodicity = 10; // how often will be updated the beamforming vectors, only used\n                                    // when --algType=\"Ideal\", in [ms]\n    uint64_t rngRun = 1;\n    uint16_t numerology = 2;\n    std::string gnbAntenna = \"Iso\";\n    std::string ueAntenna = \"Iso\";\n    double ueTxPower = 1;\n    std::string scenario = \"Uma\";\n\n    // parameters for saving the output\n    std::string resultsDir = \".\";\n    std::string simTag = \"\";\n    std::string dbName = \"realistic-beamforming.db\";\n    std::string tableName = \"results\";\n\n    CttcRealisticBeamforming::BeamformingMethod beamformingType;\n    RealisticBfManager::TriggerEvent triggerEventEnum = RealisticBfManager::SRS_COUNT;\n    CommandLine cmd(__FILE__);\n\n    cmd.AddValue(\"deltaX\",\n                 \"Determines X coordinate of UE wrt. to gNB X coordinate [meters].\",\n                 deltaX);\n    cmd.AddValue(\"deltaY\",\n                 \"Determines Y coordinate of UE wrt. to gNB Y coordinate [meters].\",\n                 deltaY);\n    cmd.AddValue(\"algType\", \"Algorithm type to be used. Can be: 'Ideal' or 'Real'.\", algType);\n    cmd.AddValue(\n        \"realTriggerEvent\",\n        \"In the case of the realistic beafmorming (algType=\\\"Real\\\") it defines when the \"\n        \"beamforming \"\n        \"vectors will be updated: upon each SRS reception but with a certain delay, or after \"\n        \"certain number of SRSs.\"\n        \"For the first option the parameter should be configured with 'DelayedUpdate' and for the \"\n        \"second option the value to be configured is 'SrsCount'\",\n        realTriggerEvent);\n    cmd.AddValue(\n        \"idealPeriodicity\",\n        \"In the case of the ideal beamforminng (algType=\\\"Ideal\\\") it defines how often the \"\n        \"beamforming vectors will be updated in milli seconds [ms].\",\n        idealPeriodicity);\n    cmd.AddValue(\"rngRun\", \"Rng run random number.\", rngRun);\n    cmd.AddValue(\"numerology\", \"Numerology to be used.\", numerology);\n    cmd.AddValue(\"gnbAntenna\", \"Configure antenna elements at gNb: Iso or 3gpp\", gnbAntenna);\n    cmd.AddValue(\"ueAntenna\", \"Configure antenna elements at UE: Iso or 3gpp\", ueAntenna);\n    cmd.AddValue(\"scenario\", \"Deployment scenario: Uma, Umi, Inh\", scenario);\n    cmd.AddValue(\"uePower\", \"Tx power to be used by the UE [dBm].\", ueTxPower);\n    // output command line parameters\n    cmd.AddValue(\"resultsDir\", \"Directory where to store the simulation results.\", resultsDir);\n    cmd.AddValue(\"simTag\",\n                 \"Tag to be appended to output filenames to distinguish simulation campaigns.\",\n                 simTag);\n    cmd.AddValue(\"dbName\", \"Database name.\", dbName);\n    cmd.AddValue(\"tableName\", \"Table name.\", tableName);\n    cmd.Parse(argc, argv);\n\n    if (algType == \"Ideal\")\n    {\n        beamformingType = CttcRealisticBeamforming::IDEAL;\n    }\n    else if (algType == \"Real\")\n    {\n        beamformingType = CttcRealisticBeamforming::REALISTIC;\n\n        if (realTriggerEvent == \"SrsCount\")\n        {\n            triggerEventEnum = RealisticBfManager::SRS_COUNT;\n        }\n        else if (realTriggerEvent == \"DelayedUpdate\")\n        {\n            triggerEventEnum = RealisticBfManager::DELAYED_UPDATE;\n        }\n        else\n        {\n            NS_ABORT_MSG(\n                \"Not supported trigger event for the realistic type of beamforming:\" << algType);\n        }\n    }\n    else\n    {\n        NS_ABORT_MSG(\"Not supported value for algType:\" << algType);\n    }\n\n    CttcRealisticBeamforming simpleBeamformingScenario;\n    simpleBeamformingScenario.Configure(deltaX,\n                                        deltaY,\n                                        beamformingType,\n                                        triggerEventEnum,\n                                        idealPeriodicity,\n                                        rngRun,\n                                        numerology,\n                                        gnbAntenna,\n                                        ueAntenna,\n                                        scenario,\n                                        ueTxPower,\n                                        resultsDir,\n                                        simTag,\n                                        dbName,\n                                        tableName);\n    simpleBeamformingScenario.PrepareDatabase();\n    simpleBeamformingScenario.PrepareOutputFiles();\n    simpleBeamformingScenario.RunSimulation();\n    simpleBeamformingScenario.PrintResultsToDatabase();\n    simpleBeamformingScenario.PrintResultsToFiles();\n}\n"
    },
    {
      "file_path": "examples/rem-beam-example.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2020 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n/**\n * \\file rem-beam-example.cc\n * \\ingroup examples\n * \\brief Rem beam configuration example\n *\n * This is a simple example which can be used to test different configurations of\n * gNB antenna array parameters and visualize its radiation through REM map.\n * Parameters that can be provided as input through the command line to configure\n * antenna array and its beamforming vector are:\n *  - numRowsGnb (number of rows of antenna array)\n *  - numColumnsGnb (number of columns of antenna array)\n *  - sector (sector with which will be created the beamforming vector, see\n *   CreateDirectionalBfv function)\n *  - theta (elevation that will be used to configure the beamforming vector.\n *\n * The rest of parameters are for REM map configuration, such as parameters for\n * resolution and REM area.\n *\n * ./ns3 run \"rem-beam-example\"\n *\n * The output of this example are REM csv files from which REM figures can be\n * generated with the following command:\n * \\code{.unparsed}\n * $  gnuplot -p nr-rem-{simTag}-gnbs.txt nr-rem-{simTag}-ues.txt nr-rem-{simTag}-buildings.txt\n *nr-rem-{simTag}-plot-rem.gnuplot \\endcode\n *\n * If no simTag is specified then to plot run the following command:\n *\n *\\code{.unparsed}\n * gnuplot -p nr-rem--gnbs.txt nr-rem--ues.txt nr-rem--buildings.txt nr-rem--plot-rem.gnuplot\n * \\endcode\n *\n * The following files will be generated (in the root project folder if not specified\n * differently): nr-rem--sinr.png, nr-rem--snr.png and nr-rem--ipsd.png\n *\n */\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/config-store.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-helper.h\"\n#include \"ns3/nr-module.h\"\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    // gnb antenna parameters\n    uint32_t numRowsGnb = 1;\n    uint32_t numColumnsGnb = 1;\n    uint16_t sector = 0;\n    double theta = 60;\n    double simTime = 1;\n\n    // Rem parameters\n    double xMin = -1000.0;\n    double xMax = 1000.0;\n    uint16_t xRes = 100;\n    double yMin = -1000.0;\n    double yMax = 1000.0;\n    uint16_t yRes = 100;\n    std::string simTag = \"\";\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"simTag\", \"The simTag to be used for REM files creation\", simTag);\n    cmd.AddValue(\"numRowsGnb\", \"Number of rows for the gNB antenna\", numRowsGnb);\n    cmd.AddValue(\"numColumnsGnb\", \"Number of columns for the gNB antenna\", numColumnsGnb);\n    cmd.AddValue(\"sector\", \"sector to be configured for\", sector);\n    cmd.AddValue(\"theta\", \"thea angle to be configured\", theta);\n    cmd.AddValue(\"xMin\", \"The min x coordinate of the rem map\", xMin);\n    cmd.AddValue(\"xMax\", \"The max x coordinate of the rem map\", xMax);\n    cmd.AddValue(\"xRes\", \"The resolution on the x axis of the rem map\", xRes);\n    cmd.AddValue(\"yMin\", \"The min y coordinate of the rem map\", yMin);\n    cmd.AddValue(\"yMax\", \"The max y coordinate of the rem map\", yMax);\n    cmd.AddValue(\"yRes\", \"The resolution on the y axis of the rem map\", yRes);\n\n    cmd.Parse(argc, argv);\n\n    // create gNB and UE\n    NodeContainer gnbNodes;\n    NodeContainer ueNodes;\n    gnbNodes.Create(1);\n    ueNodes.Create(1);\n\n    // install mobility and initilize positions\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(gnbNodes);\n    gnbNodes.Get(0)->GetObject<MobilityModel>()->SetPosition(Vector(0, 0, 10));\n    mobility.Install(ueNodes);\n    ueNodes.Get(0)->GetObject<MobilityModel>()->SetPosition(Vector(10, 10, 1.5));\n\n    // Create and configure helpers\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    idealBeamformingHelper->SetAttribute(\"BeamformingMethod\",\n                                         TypeIdValue(DirectPathQuasiOmniBeamforming::GetTypeId()));\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    /*\n     *  Create spectrum configuration: a single operational band with 1 CC and 1 BWP.\n     *\n     * |---------------Band---------------|\n     * |---------------CC-----------------|\n     * |---------------BWP----------------|\n     */\n    BandwidthPartInfoPtrVector singleBwp;\n    CcBwpCreator ccBwpCreator;\n    const uint8_t numCcPerBand = 1;\n\n    CcBwpCreator::SimpleOperationBandConf bandConf(2e9, 20e6, numCcPerBand);\n    OperationBandInfo band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);\n\n    // Initialize channel and pathloss, plus other things inside band.\n    Config::SetDefault(\"ns3::ThreeGppChannelModel::UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetChannelConditionModelAttribute(\"UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n    nrHelper->InitializeOperationBand(&band);\n    singleBwp = CcBwpCreator::GetAllBwps({band});\n\n    // Antennas for the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(1));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(1));\n    nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                    PointerValue(CreateObject<IsotropicAntennaModel>()));\n\n    // Configuration of phy and antenna for the gNbs\n    nrHelper->SetGnbPhyAttribute(\"TxPower\", DoubleValue(10));\n    nrHelper->SetGnbPhyAttribute(\"Numerology\", UintegerValue(0));\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(numRowsGnb));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(numColumnsGnb));\n    nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                     PointerValue(CreateObject<ThreeGppAntennaModel>()));\n\n    // install nr net devices\n    NetDeviceContainer gnbNetDev = nrHelper->InstallGnbDevice(gnbNodes, singleBwp);\n    NetDeviceContainer ueNetDev = nrHelper->InstallUeDevice(ueNodes, singleBwp);\n\n    int64_t randomStream = 1;\n    randomStream += nrHelper->AssignStreams(gnbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);\n\n    // this is probably not necessary, since we did not update configuration after installation\n    DynamicCast<NrGnbNetDevice>(gnbNetDev.Get(0))->UpdateConfig();\n    DynamicCast<NrUeNetDevice>(ueNetDev.Get(0))->UpdateConfig();\n\n    // install the IP stack on the UEs, this is needed to allow attachment\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));\n\n    // we need to attach UEs to gNB so that they obtain the same configuration of channel as gNB\n    nrHelper->AttachToEnb(ueNetDev.Get(0), gnbNetDev.Get(0));\n\n    // configure REM parameters\n    Ptr<NrRadioEnvironmentMapHelper> remHelper = CreateObject<NrRadioEnvironmentMapHelper>();\n    remHelper->SetMinX(xMin);\n    remHelper->SetMaxX(xMax);\n    remHelper->SetResX(xRes);\n    remHelper->SetMinY(yMin);\n    remHelper->SetMaxY(yMax);\n    remHelper->SetResY(yRes);\n    remHelper->SetSimTag(simTag);\n    remHelper->SetRemMode(NrRadioEnvironmentMapHelper::BEAM_SHAPE);\n\n    // configure beam that will be shown in REM map\n    DynamicCast<NrGnbNetDevice>(gnbNetDev.Get(0))\n        ->GetPhy(0)\n        ->GetSpectrumPhy(0)\n        ->GetBeamManager()\n        ->SetSector(sector, theta);\n    DynamicCast<NrUeNetDevice>(ueNetDev.Get(0))\n        ->GetPhy(0)\n        ->GetSpectrumPhy(0)\n        ->GetBeamManager()\n        ->ChangeToQuasiOmniBeamformingVector();\n    remHelper->CreateRem(gnbNetDev, ueNetDev.Get(0), 0);\n\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/rem-example.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2020 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n/**\n * \\file rem-example.cc\n * \\ingroup examples\n * \\brief REM Creation Example\n *\n * This example describes how to setup a simulation using NrRadioEnvironmentMapHelper.\n *\n * We provide a number of simulation parameters that can be configured in the\n * command line, such as the number of UEs per cell or the number of rows and\n * columns of the gNB and Ue antennas.\n * Please have a look at the possible parameters to know what you can configure\n * through the command line.\n * The user can also specify the type of REM map (BeamShape/CoverageArea/UeCoverage)\n * he wishes to generate with some of the following commands:\n * \\code{.unparsed}\n *  $ ./ns3 run \"rem-example --simTag=d --remMode=CoverageArea\"\n *  $ ./ns3 run \"rem-example --simTag=u --remMode=UeCoverage\"\n *  $ ./ns3 run \"rem-example --simTag=b1 --remMode=BeamShape --typeOfRem=DlRem\"\n *  $ ./ns3 run \"rem-example --simTag=b2 --remMode=BeamShape --typeOfRem=UlRem\"\n * \\endcode\n *\n * DL or UL REM map can be selected by passing to the rem helper the desired\n * transmitting device(s) (RTD(s)) and receiving device (RRD), which for the DL\n * case correspond to gNB(s) and UE and for the UL case to UE(s) and gNB.\n *\n * The output of the REM includes a map with the SNR values, a map with the SINR\n * and a map with IPSD values (aggregated rx Power in each rem point).\n * Note that in case there is only one gNB configured, the SNR/SINR maps will be the same.\n *\n * The output of this example are REM csv files from which can be generated REM\n * figures with the following command:\n * \\code{.unparsed}\n * $ gnuplot -p nr-rem-{simTag}-gnbs.txt nr-rem-{simTag}-ues.txt nr-rem-{simTag}-buildings.txt\n * nr-rem-{simTag}-plot-rem.gnuplot \\endcode\n *\n * If no simTag is specified then to plot run the following command:\n *\n * \\code{.unparsed}\n * $ gnuplot -p nr-rem--gnbs.txt nr-rem--ues.txt nr-rem--buildings.txt nr-rem--plot-rem.gnuplot\n * \\endcode\n *\n * And the following files will be generated (in the root project folder if not specified\n * differently): nr-rem--sinr.png, nr-rem--snr.png and nr-rem--ipsd.png\n *\n */\n\n#include \"ns3/antenna-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nr-helper.h\"\n#include \"ns3/nr-mac-scheduler-tdma-rr.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/nr-point-to-point-epc-helper.h\"\n#include \"ns3/point-to-point-helper.h\"\n#include <ns3/buildings-module.h>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    std::string remMode = \"CoverageArea\";\n    std::string simTag = \"\";\n\n    std::string scenario = \"UMa\"; // scenario\n    std::string beamforming =\n        \"dir-dir\"; // beamforming at gNB and UE, the first is gNB and the second is UE\n    enum BandwidthPartInfo::Scenario scenarioEnum = BandwidthPartInfo::UMa;\n\n    uint16_t gNbNum = 1;\n    uint16_t ueNumPergNb = 1;\n    std::string deploymentScenario = \"SingleGnb\";\n    std::string typeOfRem = \"DlRem\";\n\n    double gNB1x = 0.0;\n    double gNB1y = 0.0;\n    double gNB2x = -10.0;\n    double gNB2y = -15.0;\n\n    double ue1x = 10.0;\n    double ue1y = 10.0;\n    double ue2x = 50.0;\n    double ue2y = -40.0;\n\n    double frequency = 2e9;  // 28e9\n    double bandwidth = 20e6; // 100e6\n    uint16_t numerology = 0;\n    double txPower = 1; // 4\n\n    // Antenna Parameters\n    double hBS; // Depend on the scenario (no input parameters)\n    double hUT;\n    uint32_t numRowsUe = 1;     // 2\n    uint32_t numColumnsUe = 1;  // 2\n    uint32_t numRowsGnb = 1;    // 4\n    uint32_t numColumnsGnb = 1; // 4\n    bool isoUe = true;\n    bool isoGnb = false; // false\n\n    double simTime = 1; // in seconds\n    bool logging = false;\n    bool enableTraces = false;\n\n    // building parameters in case of buildings addition\n    bool enableBuildings = false; // Depends on the scenario (no input parameter)\n    uint32_t numOfBuildings = 1;\n    uint32_t apartmentsX = 2;\n    uint32_t nFloors = 1;\n\n    // Rem parameters\n    double xMin = -40.0;\n    double xMax = 80.0;\n    uint16_t xRes = 50;\n    double yMin = -70.0;\n    double yMax = 50.0;\n    uint16_t yRes = 50;\n    double z = 1.5;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"remMode\",\n                 \"What type of REM map to use: BeamShape, CoverageArea, UeCoverage.\"\n                 \"BeamShape shows beams that are configured in a user's script. \"\n                 \"Coverage area is used to show worst-case SINR and best-case SNR maps \"\n                 \"considering that at each point of the map the best beam is used \"\n                 \"towards that point from the serving gNB and also of all the interfering\"\n                 \"gNBs in the case of worst-case SINR.\"\n                 \"UeCoverage is similar to the previous, just that it is showing the \"\n                 \"uplink coverage.\",\n                 remMode);\n    cmd.AddValue(\"simTag\",\n                 \"Simulation string tag that will be concatenated to output file names\",\n                 simTag);\n    cmd.AddValue(\"scenario\",\n                 \"The scenario for the simulation. Choose among 'RMa', 'UMa', \"\n                 \"'UMi-StreetCanyon', 'InH-OfficeMixed', 'InH-OfficeOpen'\"\n                 \"'UMa-Buildings', 'UMi-Buildings'.\",\n                 scenario);\n    cmd.AddValue(\"gNbNum\", \"The number of gNbs in multiple-ue topology\", gNbNum);\n    cmd.AddValue(\"ueNumPergNb\", \"The number of UE per gNb in multiple-ue topology\", ueNumPergNb);\n    cmd.AddValue(\"gNB1x\", \"gNb 1 x position\", gNB1x);\n    cmd.AddValue(\"gNB1y\", \"gNb 1 y position\", gNB1y);\n    cmd.AddValue(\"gNB2x\", \"gNb 2 x position\", gNB2x);\n    cmd.AddValue(\"gNB2y\", \"gNb 2 y position\", gNB2y);\n    cmd.AddValue(\"ue1x\", \"ue 1 x position\", ue1x);\n    cmd.AddValue(\"ue1y\", \"ue 1 y position\", ue1y);\n    cmd.AddValue(\"ue2x\", \"ue 2 x position\", ue2x);\n    cmd.AddValue(\"ue2y\", \"ue 2 y position\", ue2y);\n    cmd.AddValue(\"deploymentScenario\",\n                 \"The deployment scenario for the simulation. Choose among \"\n                 \"'SingleGnb', 'TwoGnbs'.\",\n                 deploymentScenario);\n    cmd.AddValue(\n        \"typeOfRem\",\n        \"The type of Rem to generate (DL or UL) in the case of BeamShape option. Choose among \"\n        \"'DlRem', 'UlRem'.\",\n        typeOfRem);\n    cmd.AddValue(\"frequency\", \"The central carrier frequency in Hz.\", frequency);\n    cmd.AddValue(\"bandwidth\", \"The system bandwidth to be used\", bandwidth);\n    cmd.AddValue(\"numerology\", \"The numerology to be used\", numerology);\n    cmd.AddValue(\"txPower\",\n                 \"total tx power that will be proportionally assigned to\"\n                 \" bands, CCs and bandwidth parts depending on each BWP bandwidth \",\n                 txPower);\n    cmd.AddValue(\"numRowsUe\", \"Number of rows for the UE antenna\", numRowsUe);\n    cmd.AddValue(\"numColumnsUe\", \"Number of columns for the UE antenna\", numColumnsUe);\n    cmd.AddValue(\"isoUe\",\n                 \"If true (set to 1), use an isotropic radiation pattern in the Ue \",\n                 isoUe);\n    cmd.AddValue(\"numRowsGnb\", \"Number of rows for the gNB antenna\", numRowsGnb);\n    cmd.AddValue(\"numColumnsGnb\", \"Number of columns for the gNB antenna\", numColumnsGnb);\n    cmd.AddValue(\"isoGnb\",\n                 \"If true (set to 1), use an isotropic radiation pattern in the gNB \",\n                 isoGnb);\n    cmd.AddValue(\"numOfBuildings\",\n                 \"The number of Buildings to deploy in the scenario\",\n                 numOfBuildings);\n    cmd.AddValue(\"apartmentsX\", \"The number of apartments inside a building\", apartmentsX);\n    cmd.AddValue(\"nFloors\", \"The number of floors of a building\", nFloors);\n    cmd.AddValue(\"beamforming\",\n                 \"If dir-dir configure direct-path at both gNB and UE; \"\n                 \"if dir-omni configure direct-path at gNB and quasi-omni at UE;\"\n                 \"if omni-dir configure quasi-omni at gNB and direct-path at UE;\",\n                 beamforming);\n    cmd.AddValue(\"logging\",\n                 \"Enable logging\"\n                 \"another option is by exporting the NS_LOG environment variable\",\n                 logging);\n    cmd.AddValue(\"xMin\", \"The min x coordinate of the rem map\", xMin);\n    cmd.AddValue(\"xMax\", \"The max x coordinate of the rem map\", xMax);\n    cmd.AddValue(\"xRes\", \"The resolution on the x axis of the rem map\", xRes);\n    cmd.AddValue(\"yMin\", \"The min y coordinate of the rem map\", yMin);\n    cmd.AddValue(\"yMax\", \"The max y coordinate of the rem map\", yMax);\n    cmd.AddValue(\"yRes\", \"The resolution on the y axis of the rem map\", yRes);\n    cmd.AddValue(\"z\", \"The z coordinate of the rem map\", z);\n\n    cmd.Parse(argc, argv);\n\n    // enable logging\n    if (logging)\n    {\n        // LogComponentEnable (\"ThreeGppSpectrumPropagationLossModel\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"ThreeGppPropagationLossModel\", LOG_LEVEL_ALL);\n        // LogComponentEnable (\"ThreeGppChannelModel\", LOG_LEVEL_ALL);\n        // LogComponentEnable (\"ChannelConditionModel\", LOG_LEVEL_ALL);\n        // LogComponentEnable (\"UdpClient\", LOG_LEVEL_INFO);\n        // LogComponentEnable (\"UdpServer\", LOG_LEVEL_INFO);\n        // LogComponentEnable (\"LteRlcUm\", LOG_LEVEL_LOGIC);\n        // LogComponentEnable (\"LtePdcp\", LOG_LEVEL_INFO);\n    }\n\n    /*\n     * Default values for the simulation. We are progressively removing all\n     * the instances of SetDefault, but we need it for legacy code (LTE)\n     */\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(999999999));\n\n    // set mobile device and base station antenna heights in meters, according to the chosen\n    // scenario\n    if (scenario == \"RMa\")\n    {\n        hBS = 35;\n        hUT = 1.5;\n        scenarioEnum = BandwidthPartInfo::RMa;\n    }\n    else if (scenario == \"UMa\")\n    {\n        // hBS = 25;\n        hBS = 1.5;\n        hUT = 1.5;\n        scenarioEnum = BandwidthPartInfo::UMa;\n    }\n    else if (scenario == \"UMa-Buildings\")\n    {\n        hBS = 1.5; // 25\n        hUT = 1.5;\n        scenarioEnum = BandwidthPartInfo::UMa_Buildings;\n        enableBuildings = true;\n    }\n    else if (scenario == \"UMi-StreetCanyon\")\n    {\n        hBS = 10;\n        hUT = 1.5;\n        scenarioEnum = BandwidthPartInfo::UMi_StreetCanyon;\n    }\n    else if (scenario == \"UMi-Buildings\")\n    {\n        hBS = 10;\n        hUT = 1.5;\n        scenarioEnum = BandwidthPartInfo::UMi_Buildings;\n        enableBuildings = true;\n    }\n    else if (scenario == \"InH-OfficeMixed\")\n    {\n        hBS = 3;\n        hUT = 1;\n        scenarioEnum = BandwidthPartInfo::InH_OfficeMixed;\n    }\n    else if (scenario == \"InH-OfficeOpen\")\n    {\n        hBS = 3;\n        hUT = 1;\n        scenarioEnum = BandwidthPartInfo::InH_OfficeOpen;\n    }\n    else\n    {\n        NS_ABORT_MSG(\"Scenario not supported. Choose among 'RMa', 'UMa', \"\n                     \"'UMi-StreetCanyon', 'InH-OfficeMixed', 'InH-OfficeOpen',\"\n                     \"'UMa-Buildings', and 'UMi-Buildings'.\");\n    }\n\n    if (deploymentScenario == \"SingleGnb\")\n    {\n        gNbNum = 1;\n        ueNumPergNb = 1;\n    }\n    else if (deploymentScenario == \"TwoGnbs\")\n    {\n        gNbNum = 2;\n        ueNumPergNb = 1;\n    }\n    else if (deploymentScenario == \"FourGnbs\")\n    {\n        gNbNum = 4;\n        ueNumPergNb = 1;\n    }\n    else\n    {\n        NS_ABORT_MSG(\"Deployment scenario not supported. \"\n                     \"Choose among 'SingleGnb', 'TwoGnbs'.\");\n    }\n\n    double offset = 80;\n\n    // create base stations and mobile terminals\n    NodeContainer gnbNodes;\n    NodeContainer ueNodes;\n    gnbNodes.Create(gNbNum);\n    ueNodes.Create(ueNumPergNb * gNbNum);\n\n    // position the base stations\n    Ptr<ListPositionAllocator> gnbPositionAlloc = CreateObject<ListPositionAllocator>();\n    gnbPositionAlloc->Add(Vector(gNB1x, gNB1y, hBS));\n    if (deploymentScenario == \"TwoGnbs\")\n    {\n        gnbPositionAlloc->Add(Vector(gNB2x, gNB2y, hBS));\n    }\n    if (deploymentScenario == \"FourGnbs\")\n    {\n        gnbPositionAlloc->Add(Vector(gNB2x, gNB2y, hBS));\n        gnbPositionAlloc->Add(Vector(gNB1x + offset, gNB1y, hBS));\n        gnbPositionAlloc->Add(Vector(gNB2x + offset, gNB2y, hBS));\n    }\n\n    MobilityHelper gnbMobility;\n    gnbMobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    gnbMobility.SetPositionAllocator(gnbPositionAlloc);\n    gnbMobility.Install(gnbNodes);\n\n    // position the mobile terminals\n    MobilityHelper ueMobility;\n    ueMobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    ueMobility.Install(ueNodes);\n\n    ueNodes.Get(0)->GetObject<MobilityModel>()->SetPosition(Vector(ue1x, ue1y, hUT));\n    if (deploymentScenario == \"TwoGnbs\")\n    {\n        ueNodes.Get(1)->GetObject<MobilityModel>()->SetPosition(Vector(ue2x, ue2y, hUT));\n    }\n\n    if (deploymentScenario == \"FourGnbs\")\n    {\n        ueNodes.Get(1)->GetObject<MobilityModel>()->SetPosition(Vector(ue2x, ue2y, hUT));\n        ueNodes.Get(2)->GetObject<MobilityModel>()->SetPosition(Vector(ue1x + offset, ue1y, hUT));\n        ueNodes.Get(3)->GetObject<MobilityModel>()->SetPosition(Vector(ue2x + offset, ue2y, hUT));\n    }\n\n    if (enableBuildings)\n    {\n        Ptr<GridBuildingAllocator> gridBuildingAllocator;\n        gridBuildingAllocator = CreateObject<GridBuildingAllocator>();\n        gridBuildingAllocator->SetAttribute(\"GridWidth\", UintegerValue(numOfBuildings));\n        gridBuildingAllocator->SetAttribute(\"LengthX\", DoubleValue(2 * apartmentsX));\n        gridBuildingAllocator->SetAttribute(\"LengthY\", DoubleValue(10));\n        gridBuildingAllocator->SetAttribute(\"DeltaX\", DoubleValue(10));\n        gridBuildingAllocator->SetAttribute(\"DeltaY\", DoubleValue(10));\n        gridBuildingAllocator->SetAttribute(\"Height\", DoubleValue(3 * nFloors));\n        gridBuildingAllocator->SetBuildingAttribute(\"NRoomsX\", UintegerValue(apartmentsX));\n        gridBuildingAllocator->SetBuildingAttribute(\"NRoomsY\", UintegerValue(2));\n        gridBuildingAllocator->SetBuildingAttribute(\"NFloors\", UintegerValue(nFloors));\n        gridBuildingAllocator->SetAttribute(\"MinX\", DoubleValue(10));\n        gridBuildingAllocator->SetAttribute(\"MinY\", DoubleValue(10));\n        gridBuildingAllocator->Create(numOfBuildings);\n\n        BuildingsHelper::Install(gnbNodes);\n        BuildingsHelper::Install(ueNodes);\n    }\n\n    /*\n     * Create NR simulation helpers\n     */\n    Ptr<NrPointToPointEpcHelper> epcHelper = CreateObject<NrPointToPointEpcHelper>();\n    Ptr<IdealBeamformingHelper> idealBeamformingHelper = CreateObject<IdealBeamformingHelper>();\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n\n    nrHelper->SetBeamformingHelper(idealBeamformingHelper);\n    nrHelper->SetEpcHelper(epcHelper);\n\n    /*\n     * Spectrum configuration:\n     * We create a single operational band with 1 CC and 1 BWP.\n     *\n     * |---------------Band---------------|\n     * |---------------CC-----------------|\n     * |---------------BWP----------------|\n     */\n    BandwidthPartInfoPtrVector allBwps;\n    CcBwpCreator ccBwpCreator;\n    const uint8_t numCcPerBand = 1;\n\n    CcBwpCreator::SimpleOperationBandConf bandConf(frequency,\n                                                   bandwidth,\n                                                   numCcPerBand,\n                                                   scenarioEnum);\n    OperationBandInfo band = ccBwpCreator.CreateOperationBandContiguousCc(bandConf);\n\n    // Initialize channel and pathloss, plus other things inside band.\n    Config::SetDefault(\"ns3::ThreeGppChannelModel::UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetChannelConditionModelAttribute(\"UpdatePeriod\", TimeValue(MilliSeconds(0)));\n    nrHelper->SetPathlossAttribute(\"ShadowingEnabled\", BooleanValue(false));\n\n    nrHelper->InitializeOperationBand(&band);\n    allBwps = CcBwpCreator::GetAllBwps({band});\n\n    // Configure beamforming method\n    if (beamforming == \"dir-dir\")\n    {\n        idealBeamformingHelper->SetAttribute(\n            \"BeamformingMethod\",\n            TypeIdValue(DirectPathBeamforming::GetTypeId())); // dir at gNB, dir at UE\n    }\n    else if (beamforming == \"dir-omni\")\n    {\n        idealBeamformingHelper->SetAttribute(\n            \"BeamformingMethod\",\n            TypeIdValue(DirectPathQuasiOmniBeamforming::GetTypeId())); // dir at gNB, q-omni at UE\n    }\n    else if (beamforming == \"omni-dir\")\n    {\n        idealBeamformingHelper->SetAttribute(\n            \"BeamformingMethod\",\n            TypeIdValue(QuasiOmniDirectPathBeamforming::GetTypeId())); // q-omni at gNB, dir at UE\n    }\n    else if (beamforming == \"search-omni\")\n    {\n        idealBeamformingHelper->SetAttribute(\n            \"BeamformingMethod\",\n            TypeIdValue(CellScanQuasiOmniBeamforming::GetTypeId())); // q-omni at gNB, dir at UE\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Beamforming does not exist:\" << beamforming);\n    }\n\n    epcHelper->SetAttribute(\"S1uLinkDelay\", TimeValue(MilliSeconds(0)));\n\n    // Antennas for the UEs\n    nrHelper->SetUeAntennaAttribute(\"NumRows\", UintegerValue(numRowsUe));\n    nrHelper->SetUeAntennaAttribute(\"NumColumns\", UintegerValue(numColumnsUe));\n    // Antenna element type for UEs\n    if (isoUe)\n    {\n        nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                        PointerValue(CreateObject<IsotropicAntennaModel>()));\n    }\n    else\n    {\n        nrHelper->SetUeAntennaAttribute(\"AntennaElement\",\n                                        PointerValue(CreateObject<ThreeGppAntennaModel>()));\n    }\n\n    // Antennas for the gNbs\n    nrHelper->SetGnbAntennaAttribute(\"NumRows\", UintegerValue(numRowsGnb));\n    nrHelper->SetGnbAntennaAttribute(\"NumColumns\", UintegerValue(numColumnsGnb));\n    // Antenna element type for gNBs\n    if (isoGnb)\n    {\n        nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                         PointerValue(CreateObject<IsotropicAntennaModel>()));\n    }\n    else\n    {\n        nrHelper->SetGnbAntennaAttribute(\"AntennaElement\",\n                                         PointerValue(CreateObject<ThreeGppAntennaModel>()));\n    }\n\n    // install nr net devices\n    NetDeviceContainer gnbNetDev = nrHelper->InstallGnbDevice(gnbNodes, allBwps);\n    NetDeviceContainer ueNetDev = nrHelper->InstallUeDevice(ueNodes, allBwps);\n\n    int64_t randomStream = 1;\n    randomStream += nrHelper->AssignStreams(gnbNetDev, randomStream);\n    randomStream += nrHelper->AssignStreams(ueNetDev, randomStream);\n\n    for (uint32_t i = 0; i < gNbNum; ++i)\n    {\n        nrHelper->GetGnbPhy(gnbNetDev.Get(i), 0)->SetTxPower(txPower);\n        nrHelper->GetGnbPhy(gnbNetDev.Get(i), 0)\n            ->SetAttribute(\"Numerology\", UintegerValue(numerology));\n    }\n\n    // When all the configuration is done, explicitly call UpdateConfig ()\n    for (auto it = gnbNetDev.Begin(); it != gnbNetDev.End(); ++it)\n    {\n        DynamicCast<NrGnbNetDevice>(*it)->UpdateConfig();\n    }\n\n    for (auto it = ueNetDev.Begin(); it != ueNetDev.End(); ++it)\n    {\n        DynamicCast<NrUeNetDevice>(*it)->UpdateConfig();\n    }\n\n    // create the internet and install the IP stack on the UEs\n    // get SGW/PGW and create a single RemoteHost\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // connect a remoteHost to pgw. Setup routing too\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(2500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.010)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n    internet.Install(ueNodes);\n\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueNetDev));\n\n    // assign IP address to UEs, and install UDP downlink applications\n    uint16_t dlPort = 1234;\n    ApplicationContainer clientApps;\n    ApplicationContainer serverApps;\n    for (uint32_t u = 0; u < ueNodes.GetN(); ++u)\n    {\n        Ptr<Node> ueNode = ueNodes.Get(u);\n        // Set the default gateway for the UE\n        Ptr<Ipv4StaticRouting> ueStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(ueNode->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n\n        UdpServerHelper dlPacketSinkHelper(dlPort);\n        serverApps.Add(dlPacketSinkHelper.Install(ueNodes.Get(u)));\n\n        UdpClientHelper dlClient(ueIpIface.GetAddress(u), dlPort);\n        dlClient.SetAttribute(\"Interval\", TimeValue(MicroSeconds(1)));\n        // dlClient.SetAttribute (\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n        dlClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n        dlClient.SetAttribute(\"PacketSize\", UintegerValue(1500));\n        clientApps.Add(dlClient.Install(remoteHost));\n    }\n\n    // attach UEs to the closest gNB\n    nrHelper->AttachToEnb(ueNetDev.Get(0), gnbNetDev.Get(0));\n\n    if (deploymentScenario == \"TwoGnbs\")\n    {\n        nrHelper->AttachToEnb(ueNetDev.Get(1), gnbNetDev.Get(1));\n    }\n\n    if (deploymentScenario == \"FourGnbs\")\n    {\n        nrHelper->AttachToEnb(ueNetDev.Get(1), gnbNetDev.Get(1));\n        nrHelper->AttachToEnb(ueNetDev.Get(2), gnbNetDev.Get(2));\n        nrHelper->AttachToEnb(ueNetDev.Get(3), gnbNetDev.Get(3));\n    }\n\n    // start server and client apps\n    serverApps.Start(Seconds(0.4));\n    clientApps.Start(Seconds(0.4));\n    serverApps.Stop(Seconds(simTime));\n    clientApps.Stop(Seconds(simTime - 0.2));\n\n    // enable the traces provided by the nr module\n    if (enableTraces)\n    {\n        nrHelper->EnableTraces();\n    }\n\n    uint16_t remBwpId = 0;\n    // Radio Environment Map Generation for ccId 0\n    Ptr<NrRadioEnvironmentMapHelper> remHelper = CreateObject<NrRadioEnvironmentMapHelper>();\n    remHelper->SetMinX(xMin);\n    remHelper->SetMaxX(xMax);\n    remHelper->SetResX(xRes);\n    remHelper->SetMinY(yMin);\n    remHelper->SetMaxY(yMax);\n    remHelper->SetResY(yRes);\n    remHelper->SetZ(z);\n    remHelper->SetSimTag(simTag);\n\n    gnbNetDev.Get(0)\n        ->GetObject<NrGnbNetDevice>()\n        ->GetPhy(remBwpId)\n        ->GetSpectrumPhy(0)\n        ->GetBeamManager()\n        ->ChangeBeamformingVector(ueNetDev.Get(0));\n\n    if (deploymentScenario == \"TwoGnbs\")\n    {\n        gnbNetDev.Get(1)\n            ->GetObject<NrGnbNetDevice>()\n            ->GetPhy(remBwpId)\n            ->GetSpectrumPhy(0)\n            ->GetBeamManager()\n            ->ChangeBeamformingVector(ueNetDev.Get(1));\n    }\n\n    if (deploymentScenario == \"FourGnbs\")\n    {\n        gnbNetDev.Get(1)\n            ->GetObject<NrGnbNetDevice>()\n            ->GetPhy(remBwpId)\n            ->GetSpectrumPhy(0)\n            ->GetBeamManager()\n            ->ChangeBeamformingVector(ueNetDev.Get(1));\n        gnbNetDev.Get(2)\n            ->GetObject<NrGnbNetDevice>()\n            ->GetPhy(remBwpId)\n            ->GetSpectrumPhy(0)\n            ->GetBeamManager()\n            ->ChangeBeamformingVector(ueNetDev.Get(2));\n        gnbNetDev.Get(3)\n            ->GetObject<NrGnbNetDevice>()\n            ->GetPhy(remBwpId)\n            ->GetSpectrumPhy(0)\n            ->GetBeamManager()\n            ->ChangeBeamformingVector(ueNetDev.Get(3));\n    }\n\n    if (remMode == \"BeamShape\")\n    {\n        remHelper->SetRemMode(NrRadioEnvironmentMapHelper::BEAM_SHAPE);\n\n        if (typeOfRem == \"DlRem\")\n        {\n            remHelper->CreateRem(gnbNetDev, ueNetDev.Get(0), remBwpId);\n        }\n        else if (typeOfRem == \"UlRem\")\n        {\n            remHelper->CreateRem(ueNetDev, gnbNetDev.Get(0), remBwpId);\n        }\n        else\n        {\n            NS_ABORT_MSG(\"typeOfRem not supported. \"\n                         \"Choose among 'DlRem', 'UlRem'.\");\n        }\n    }\n    else if (remMode == \"CoverageArea\")\n    {\n        remHelper->SetRemMode(NrRadioEnvironmentMapHelper::COVERAGE_AREA);\n        remHelper->CreateRem(gnbNetDev, ueNetDev.Get(0), remBwpId);\n    }\n    else if (remMode == \"UeCoverage\")\n    {\n        remHelper->SetRemMode(NrRadioEnvironmentMapHelper::UE_COVERAGE);\n        remHelper->CreateRem(ueNetDev, gnbNetDev.Get(0), remBwpId);\n    }\n    else\n    {\n        NS_ABORT_MSG(\"Not supported remMode.\");\n    }\n\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/traffic-generator-example.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n\n// Copyright (c) 2022 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n// Copyright (c) 2023 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n//\n// SPDX-License-Identifier: GPL-2.0-only\n\n/**\n * \\file traffic-generator.cc\n * \\ingroup examples\n * \\brief Traffic generator example\n */\n\n#include \"ns3/core-module.h\"\n#include <ns3/abort.h>\n#include <ns3/config.h>\n#include <ns3/inet-socket-address.h>\n#include <ns3/internet-stack-helper.h>\n#include <ns3/ipv4-address-helper.h>\n#include <ns3/ipv4-global-routing-helper.h>\n#include <ns3/log.h>\n#include <ns3/packet-sink-helper.h>\n#include <ns3/packet-sink.h>\n#include <ns3/ping-helper.h>\n#include <ns3/simple-channel.h>\n#include <ns3/simple-net-device.h>\n#include <ns3/simulator.h>\n#include <ns3/string.h>\n#include <ns3/test.h>\n#include <ns3/traffic-generator-ftp-single.h>\n#include <ns3/traffic-generator-helper.h>\n#include <ns3/traffic-generator-ngmn-ftp-multi.h>\n#include <ns3/traffic-generator-ngmn-gaming.h>\n#include <ns3/traffic-generator-ngmn-video.h>\n#include <ns3/traffic-generator-ngmn-voip.h>\n#include <ns3/uinteger.h>\n\n#include <fstream>\n#include <list>\n#include <ostream>\n\nusing namespace ns3;\n\nenum TrafficType\n{\n    NGMN_FTP,\n    NGMN_VIDEO,\n    NGMN_GAMING,\n    NGMN_VOIP\n};\n\nstatic inline std::istream&\noperator>>(std::istream& is, TrafficType& item)\n{\n    uint32_t inputValue;\n    is >> inputValue;\n    item = (TrafficType)inputValue;\n    return is;\n}\n\nTypeId\nGetTypeId(const TrafficType& item)\n{\n    switch (item)\n    {\n    case NGMN_FTP:\n        return TrafficGeneratorNgmnFtpMulti::GetTypeId();\n    case NGMN_VIDEO:\n        return TrafficGeneratorNgmnVideo::GetTypeId();\n    case NGMN_GAMING:\n        return TrafficGeneratorNgmnGaming::GetTypeId();\n    case NGMN_VOIP:\n        return TrafficGeneratorNgmnVoip::GetTypeId();\n    default:\n        NS_ABORT_MSG(\"Unknown traffic type\");\n    };\n}\n\nstd::string\nGetName(const TrafficType& item)\n{\n    switch (item)\n    {\n    case NGMN_FTP:\n        return \"ftp\";\n    case NGMN_VIDEO:\n        return \"video\";\n    case NGMN_GAMING:\n        return \"gaming\";\n    case NGMN_VOIP:\n        return \"voip\";\n    default:\n        NS_ABORT_MSG(\"Unknown traffic type\");\n    };\n}\n\nvoid\nWriteBytesSent(Ptr<TrafficGenerator> trafficGenerator,\n               uint64_t* previousBytesSent,\n               uint64_t* previousWindowBytesSent,\n               enum TrafficType trafficType,\n               std::ofstream* outFileTx)\n{\n    uint64_t totalBytesSent = trafficGenerator->GetTotalBytes();\n    (*outFileTx) << \"\\n\"\n                 << Simulator::Now().GetMilliSeconds() << \"\\t\" << *previousWindowBytesSent\n                 << std::endl;\n    (*outFileTx) << \"\\n\"\n                 << Simulator::Now().GetMilliSeconds() << \"\\t\"\n                 << totalBytesSent - *previousBytesSent << std::endl;\n\n    *previousWindowBytesSent = totalBytesSent - *previousBytesSent;\n    *previousBytesSent = totalBytesSent;\n};\n\nvoid\nWriteBytesReceived(Ptr<PacketSink> packetSink, uint64_t* previousBytesReceived)\n{\n    uint64_t totalBytesReceived = packetSink->GetTotalRx();\n    *previousBytesReceived = totalBytesReceived;\n};\n\nint\nmain(int argc, char* argv[])\n{\n    enum TrafficType trafficType = NGMN_FTP;\n    bool useUdp = false;\n    uint32_t measWindowMs = 10;\n    uint32_t appStartMs = 500;\n    uint32_t appDurationMs = 100;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"trafficType\",\n                 \"The traffic type to be configured. Currently the following options are \"\n                 \"available: 0 (ftp), 1 (video), 2 (gaming) and 3 (voip).\",\n                 trafficType);\n    cmd.AddValue(\"useUdp\",\n                 \"if true, the NGMN applications will run over UDP connection, otherwise a TCP \"\n                 \"connection will be used. \",\n                 useUdp);\n    cmd.AddValue(\"appStartMs\", \"Application start time in ms, greater than 500\", appStartMs);\n    cmd.AddValue(\"appDurationMs\",\n                 \"Application duration time in ms, greater than 100\",\n                 appDurationMs);\n    cmd.AddValue(\"measWindowMs\", \"Measurement window time in ms, greathen than 10\", measWindowMs);\n\n    cmd.Parse(argc, argv);\n\n    NS_ASSERT(appStartMs >= 500);\n    NS_ASSERT(appDurationMs >= 100);\n    NS_ASSERT(measWindowMs >= 10);\n\n    // configure the transport protocol to be used\n    std::string transportProtocol;\n    if (useUdp)\n    {\n        transportProtocol = \"ns3::UdpSocketFactory\";\n    }\n    else\n    {\n        transportProtocol = \"ns3::TcpSocketFactory\";\n    }\n\n    NodeContainer nodes;\n    nodes.Create(2);\n    InternetStackHelper internet;\n    internet.Install(nodes);\n    // link the two nodes\n    Ptr<SimpleNetDevice> txDev = CreateObject<SimpleNetDevice>();\n    Ptr<SimpleNetDevice> rxDev = CreateObject<SimpleNetDevice>();\n    nodes.Get(0)->AddDevice(txDev);\n    nodes.Get(1)->AddDevice(rxDev);\n    Ptr<SimpleChannel> channel1 = CreateObject<SimpleChannel>();\n    rxDev->SetChannel(channel1);\n    txDev->SetChannel(channel1);\n    NetDeviceContainer devices;\n    devices.Add(txDev);\n    devices.Add(rxDev);\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipv4Interfaces = ipv4.Assign(devices);\n\n    // install the packet sink at the receiver node\n    uint16_t port = 4000;\n    InetSocketAddress rxAddress(Ipv4Address::GetAny(), port);\n\n    PacketSinkHelper packetSinkHelper(transportProtocol, rxAddress);\n\n    // install the application on the rx device\n    ApplicationContainer sinkApplication = packetSinkHelper.Install(nodes.Get(1));\n    sinkApplication.Start(MilliSeconds(appStartMs));\n    sinkApplication.Stop(MilliSeconds(appStartMs + appDurationMs));\n\n    // install the traffic generator at the transmitter node\n    TrafficGeneratorHelper trafficGeneratorHelper(\n        transportProtocol,\n        InetSocketAddress(ipv4Interfaces.GetAddress(1, 0), port),\n        GetTypeId(trafficType));\n\n    ApplicationContainer generatorApplication = trafficGeneratorHelper.Install(nodes.Get(0));\n    generatorApplication.Start(MilliSeconds(appStartMs));\n    generatorApplication.Stop(MilliSeconds(appStartMs + appDurationMs));\n\n    // Seed the ARP cache by pinging early in the simulation\n    // This is a workaround until a static ARP capability is provided\n    PingHelper pingHelper(ipv4Interfaces.GetAddress(1, 0));\n    ApplicationContainer pingApps = pingHelper.Install(nodes.Get(0));\n    pingApps.Start(MilliSeconds(10));\n    pingApps.Stop(MilliSeconds(500));\n\n    Ptr<TrafficGenerator> trafficGenerator =\n        generatorApplication.Get(0)->GetObject<TrafficGenerator>();\n    Ptr<PacketSink> packetSink = sinkApplication.Get(0)->GetObject<PacketSink>();\n\n    uint64_t previousBytesSent = 0;\n    uint64_t previousBytesReceived = 0;\n    uint64_t previousWindowBytesSent = 0;\n\n    std::ofstream outFileTx;\n    std::string txFileName = \"tx-\" + GetName(trafficType) + \".csv\";\n    outFileTx.open(txFileName.c_str(), std::ios_base::out);\n    ;\n    NS_ABORT_MSG_IF(!outFileTx.is_open(), \"Can't open file \" << txFileName);\n    outFileTx.setf(std::ios_base::fixed);\n\n    for (uint32_t i = appStartMs; i < appStartMs + appDurationMs; i = i + measWindowMs)\n    {\n        Simulator::Schedule(MilliSeconds(i),\n                            &WriteBytesSent,\n                            trafficGenerator,\n                            &previousBytesSent,\n                            &previousWindowBytesSent,\n                            trafficType,\n                            &outFileTx);\n        Simulator::Schedule(MilliSeconds(i),\n                            &WriteBytesReceived,\n                            packetSink,\n                            &previousBytesReceived);\n    }\n\n    Simulator::Stop(MilliSeconds(appStartMs + appDurationMs));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    outFileTx.close();\n    std::cout << \"\\n Traffic generator example finished. Results written into \" << txFileName\n              << \" file in the ns-3-dev root directory.\" << std::endl;\n\n    return 0;\n}\n"
    }
  ]
}