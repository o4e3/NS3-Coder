{
  "repo_name": "cisco/ns3-rmcat",
  "github_url": "https://github.com/cisco/ns3-rmcat",
  "readme": ".. contents::\n\nns3-rmcat Documentation\n----------------------------\n\n.. heading hierarchy:\n   ------------- Chapter\n   ************* Section (#.#)\n   ============= Subsection (#.#.#)\n   ############# Paragraph (no number)\n\nns3-rmcat is an `ns3 <https://www.nsnam.org/release/ns-allinone-3.26.tar.bz2>`_ module (Currently ns-3.26 is supported) used for `IETF RMCAT <https://datatracker.ietf.org/wg/rmcat/charter/>`_ candidate algorithm testing.\n\nIt can be used in one of these ways:\n\n1. As complementary tests for the unit test and integration test in emulator environment.\n\n2. Algorithm tuning. It's easier to support different topologies using ns3, as ns3 provides sophisticated LTE and WiFi models, which make it easier to peek the internals than a real world system and emulator testbed.\n\n3. Algorithm comparison. Simulation testbed is more reproducible than real world test and emulator testbed. The different candidate algorithms can be easily switched, thus making side-by-side comparison of different algorithms an easy and fair task.\n\n\nModel\n*****************\n\nThe model for real-time media congestion is documented at `\"Framework for Real-time Media Congestion Avoidance Techniques\" <https://tools.ietf.org/html/draft-zhu-rmcat-framework-00>`_, and ns3-rmcat is a simplified implementation focussing on evaluation of real-time media congestion control algorithms in a simulation environment.\n\nns3-rmcat defines ns3 applications (see `model/apps <model/apps>`_) running on different network topologies. These ns3 applications send fake video codec data (`model/syncodecs <model/syncodecs>`_, more on `syncodecs <https://github.com/cisco/syncodecs>`_), according to the congestion control algorithm under test.\n\nThe sender application, ``RmcatSender``, sends fake video codec data in media packets to the receiver application, ``RmcatReceiver``. ``RmcatReceiver`` gets the sequence of packets and takes reception timestamp information, and sends it back to ``RmcatSender`` in feedback packets. The (sender-based) congestion control algorithm running on ``RmcatSender`` processes the feedback information (see `model/congestion-control <model/congestion-control>`_), to get bandwidth estimation. The sender application then uses this bandwidth estimation to control the fake video encoder by adjusting its target video bitrate.\n\nDifferent topologies (see `model/topo <model/topo>`_) are currently supported, currently only point-to-point wired topology and WIFI topologies are used. We will add LTE support later.\n\nTestcases\n*****************\n\nThe test cases are in `test/rmcat-wired-test-suite <test/rmcat-wired-test-suite.cc>`_ and `test/rmcat-wifi-test-suite <test/rmcat-wifi-test-suite.cc>`_; and currently organized in three test suites:\n\n  - `rmcat-wifi <https://datatracker.ietf.org/doc/draft-ietf-rmcat-eval-test/?include_text=1>`_\n\n  - `rmcat-wired <https://datatracker.ietf.org/doc/draft-fu-rmcat-wifi-test-case/?include_text=1>`_\n\n  - rmcat-wired-vparam, which is based on some of the wired test cases, but varying other parameters such as bottleneck bandwidth, propagation delay, etc.\n\n`LTE <https://datatracker.ietf.org/doc/draft-ietf-rmcat-wireless-tests/?include_text=1>`_ test case are not implemented yet.\n\nExamples\n*****************\n\n`examples <examples>`_ is provided as an application template for experimenting new test cases and algorithm changes.\n\nWrite your own congestion control algorithm\n***************************************************\n\nYou can create your own congestion control algorithm by inheriting from  `SenderBasedController <model/congestion-control/sender-based-controller.h#L85>`_, `DummyController <model/congestion-control/dummy-controller.h#L39>`_ is an example which just prints the packet loss, queuing delay and receive rate without doing any congestion control: the bandwidth estimation is hard-coded.\n\nTo reuse the plotting tool, the following logs are expected to be written (see `NadaController <model/congestion-control/nada-controller.cc>`_, `process_test_logs.py <tools/process_test_logs.py>`_):\n\n::\n\n    # rmcat flow 0, this is the flow id, SenderBasedController::m_id\n    # ts, current timestamp when receving the rmcat feedback in millionseconds\n    # loglen, packet history size, SenderBasedController::m_packetHistory.size()\n    # qdel, queuing delay, SenderBasedController::getCurrentQdelay()\n    # rtt, round trip time, SenderBasedController::getCurrentRTT()\n    # ploss, packet loss count in last 500 ms, SenderBasedController::getPktLossInfo()\n    # plr, packet loss ratio, SenderBasedController::getPktLossInfo()\n    # xcurr, aggregated congestion signal that accounts for queuing delay, ECN\n    # rrate, current receive rate in bps, SenderBasedController::getCurrentRecvRate()\n    # srate, current estimated available bandwidth in bps\n    # avgint, average inter-loss interval in packets, SenderBasedController::getLossIntervalInfo()\n    # curint, most recent (currently growing) inter-loss interval in packets, SenderBasedController::getLossIntervalInfo()\n\n    rmcat_0 ts: 158114 loglen: 60 qdel: 286 rtt: 386 ploss: 0 plr: 0.00 xcurr: 4.72 rrate: 863655.56 srate: 916165.81 avgint: 437.10 curint: 997\n\n\nUsage\n*****************\n\n1. Download ns3 (ns-3.26 is currently supported, other version may also work but are untested).\n\n2. Git clone ns3-rmcat into ``ns-3.xx/src``. Initialize syncodecs submodule (``git submodule update --init --recursive``)\n\n3. configure the workspace, ``CXXFLAGS=\"-std=c++11 -Wall -Werror -Wno-potentially-evaluated-expression -Wno-unused-local-typedefs\" ./waf configure --enable-examples --enable-tests``.\n\n4. build, ``./waf build``\n\n5. run tests, ``./test.py -s rmcat-wired -w rmcat.html -r``, where ``rmcat.html`` is the test report.\n\n7. [optional] run examples, ``./waf --run \"rmcat-example --log\"``, ``--log`` will turn on RmcatSender/RmcatReceiver logs for debugging.\n\n8. draw the plots (need to install the python module `matplotlib <https://matplotlib.org/>`_), ``python src/ns3-rmcat/tools/process_test_logs.py testpy-output/2017-08-11-18-52-15-CUT; python src/ns3-rmcat/tools/plot_tests.py testpy-output/2017-08-11-18-52-15-CUT``\n\nYou can also use `test.csh <tools/test.csh>`_ to run the testcases and the plot scripts in one shot. If you do so, logs with testcase names will be located in the \"testpy-output/[CURRENT UTC TIME]\" directory, if none specified.\n\n::\n\n    # run from ns3 root directory: ns-3.xx/\n    #\n    # Example:\n    # ./src/ns3-rmcat/tools/test.csh wired 2017-07-21-rmcat-wired\n    # ./src/ns3-rmcat/tools/test.csh vparam 2017-07-21-rmcat-wired-vparam\n    # ./src/ns3-rmcat/tools/test.csh wifi 2017-07-21-rmcat-wifi\n    #\n    # The second parameter, output directory, is optional. If not specified,\n    # the script will use a folder with a name based on current GMT time\n\n\nNote that in ns-3.26, the testing script (test.py) only works with python2. So one may want to point the python alias to python to ensure that the `test.csh` script runs out of box:\n\n::\n    alias python=python2.7.3\n::\n\nAlternatively, you can use `test_v2.csh <tools/test_v2.csh>`_ to explicitly invoke python2 for running the testing script and python3 for running the processing and plotting scripts.  The latter works with both python2 and python3.\n\n\nTroubleshooting\n*****************\n\nTo build ns-3.26 on newer compilers: see tips `here <https://www.nsnam.org/wiki/HOWTO_build_old_versions_of_ns-3_on_newer_compilers>`_. To disable warnings from breaking your build, do the following:\n::\n\n      CXXFLAGS=\"-Wall\" ./waf configure\n      ./waf -vv\n::\n\n\n\nTo debug \"rmcat-wired\" test suite:\n\n::\n\n    ./waf --command-template=\"gdb %s\" --run \"test-runner\"\n    r --assert-on-failure --suite=rmcat-wired\n\nTo debug rmcat example, enter ns3 source directory:\n\n::\n\n    ./waf --command-template=\"gdb %s\" --run src/ns3-rmcat/examples/rmcat-example\n\nFuture work\n**********************************\n\nAdding LTE topology and test cases\n\nAdd support for ECN marking\n\nEncapsulate Sender's rate shaping buffer in a C++ interface or class\n\nWired test cases: implement time-varying bottleneck capacity by changing the physical link properties\n",
  "examples": [
    {
      "file_path": "examples/rmcat-example.cc",
      "code": "/******************************************************************************\n * Copyright 2016-2017 cisco Systems, Inc.                                    *\n *                                                                            *\n * Licensed under the Apache License, Version 2.0 (the \"License\");            *\n * you may not use this file except in compliance with the License.           *\n * You may obtain a copy of the License at                                    *\n *                                                                            *\n *     http://www.apache.org/licenses/LICENSE-2.0                             *\n *                                                                            *\n * Unless required by applicable law or agreed to in writing, software        *\n * distributed under the License is distributed on an \"AS IS\" BASIS,          *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *\n * See the License for the specific language governing permissions and        *\n * limitations under the License.                                             *\n ******************************************************************************/\n\n/**\n * @file\n * Simple example demonstrating the usage of the rmcat ns3 module, using:\n *  - NADA as controller for rmcat flows\n *  - Statistics-based traffic source as codec\n *  - [Optionally] TCP flows\n *  - [Optionally] UDP flows\n *\n * @version 0.1.1\n * @author Jiantao Fu\n * @author Sergio Mena\n * @author Xiaoqing Zhu\n */\n\n#include \"ns3/nada-controller.h\"\n#include \"ns3/rmcat-sender.h\"\n#include \"ns3/rmcat-receiver.h\"\n#include \"ns3/rmcat-constants.h\"\n#include \"ns3/point-to-point-helper.h\"\n#include \"ns3/data-rate.h\"\n#include \"ns3/bulk-send-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/traffic-control-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/core-module.h\"\n\nconst uint32_t RMCAT_DEFAULT_RMIN  =  150000;  // in bps: 150Kbps\nconst uint32_t RMCAT_DEFAULT_RMAX  = 1500000;  // in bps: 1.5Mbps\nconst uint32_t RMCAT_DEFAULT_RINIT =  150000;  // in bps: 150Kbps\n\nconst uint32_t TOPO_DEFAULT_BW     = 1000000;    // in bps: 1Mbps\nconst uint32_t TOPO_DEFAULT_PDELAY =      50;    // in ms:   50ms\nconst uint32_t TOPO_DEFAULT_QDELAY =     300;    // in ms:  300ms\n\nusing namespace ns3;\n\nstatic NodeContainer BuildExampleTopo (uint64_t bps,\n                                       uint32_t msDelay,\n                                       uint32_t msQdelay)\n{\n    NodeContainer nodes;\n    nodes.Create (2);\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute (\"DataRate\", DataRateValue  (DataRate (bps)));\n    pointToPoint.SetChannelAttribute (\"Delay\", TimeValue (MilliSeconds (msDelay)));\n    auto bufSize = std::max<uint32_t> (DEFAULT_PACKET_SIZE, bps * msQdelay / 8000);\n    pointToPoint.SetQueue (\"ns3::DropTailQueue\",\n                           \"Mode\", StringValue (\"QUEUE_MODE_BYTES\"),\n                           \"MaxBytes\", UintegerValue (bufSize));\n    NetDeviceContainer devices = pointToPoint.Install (nodes);\n\n    InternetStackHelper stack;\n    stack.Install (nodes);\n    Ipv4AddressHelper address;\n    address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n    address.Assign (devices);\n\n    // Uncomment to capture simulated traffic\n    // pointToPoint.EnablePcapAll (\"rmcat-example\");\n\n    // disable tc for now, some bug in ns3 causes extra delay\n    TrafficControlHelper tch;\n    tch.Uninstall (devices);\n\n    return nodes;\n}\n\nstatic void InstallTCP (Ptr<Node> sender,\n                        Ptr<Node> receiver,\n                        uint16_t port,\n                        float startTime,\n                        float stopTime)\n{\n    // configure TCP source/sender/client\n    auto serverAddr = receiver->GetObject<Ipv4> ()->GetAddress (1,0).GetLocal ();\n    BulkSendHelper source{\"ns3::TcpSocketFactory\",\n                           InetSocketAddress{serverAddr, port}};\n    // Set the amount of data to send in bytes. Zero is unlimited.\n    source.SetAttribute (\"MaxBytes\", UintegerValue (0));\n    source.SetAttribute (\"SendSize\", UintegerValue (DEFAULT_PACKET_SIZE));\n\n    auto clientApps = source.Install (sender);\n    clientApps.Start (Seconds (startTime));\n    clientApps.Stop (Seconds (stopTime));\n\n    // configure TCP sink/receiver/server\n    PacketSinkHelper sink{\"ns3::TcpSocketFactory\",\n                           InetSocketAddress{Ipv4Address::GetAny (), port}};\n    auto serverApps = sink.Install (receiver);\n    serverApps.Start (Seconds (startTime));\n    serverApps.Stop (Seconds (stopTime));\n\n}\n\nstatic Time GetIntervalFromBitrate (uint64_t bitrate, uint32_t packetSize)\n{\n    if (bitrate == 0u) {\n        return Time::Max ();\n    }\n    const auto secs = static_cast<double> (packetSize + IPV4_UDP_OVERHEAD) /\n                            (static_cast<double> (bitrate) / 8. );\n    return Seconds (secs);\n}\n\nstatic void InstallUDP (Ptr<Node> sender,\n                        Ptr<Node> receiver,\n                        uint16_t serverPort,\n                        uint64_t bitrate,\n                        uint32_t packetSize,\n                        uint32_t startTime,\n                        uint32_t stopTime)\n{\n    // configure UDP source/sender/client\n    auto serverAddr = receiver->GetObject<Ipv4> ()->GetAddress (1,0).GetLocal ();\n    const auto interPacketInterval = GetIntervalFromBitrate (bitrate, packetSize);\n    uint32_t maxPacketCount = 0XFFFFFFFF;\n    UdpClientHelper client{serverAddr, serverPort};\n    client.SetAttribute (\"MaxPackets\", UintegerValue (maxPacketCount));\n    client.SetAttribute (\"Interval\", TimeValue (interPacketInterval));\n    client.SetAttribute (\"PacketSize\", UintegerValue (packetSize));\n\n    auto clientApps = client.Install (sender);\n    clientApps.Start (Seconds (startTime));\n    clientApps.Stop (Seconds (stopTime));\n\n    // configure TCP sink/receiver/server\n    UdpServerHelper server{serverPort};\n    auto serverApps = server.Install (receiver);\n    serverApps.Start (Seconds (startTime));\n    serverApps.Stop (Seconds (stopTime));\n}\n\nstatic void InstallApps (bool nada,\n                         Ptr<Node> sender,\n                         Ptr<Node> receiver,\n                         uint16_t port,\n                         float initBw,\n                         float minBw,\n                         float maxBw,\n                         float startTime,\n                         float stopTime)\n{\n    Ptr<RmcatSender> sendApp = CreateObject<RmcatSender> ();\n    Ptr<RmcatReceiver> recvApp = CreateObject<RmcatReceiver> ();\n    sender->AddApplication (sendApp);\n    receiver->AddApplication (recvApp);\n\n    if (nada) {\n        sendApp->SetController (std::make_shared<rmcat::NadaController> ());\n    }\n    Ptr<Ipv4> ipv4 = receiver->GetObject<Ipv4> ();\n    Ipv4Address receiverIp = ipv4->GetAddress (1, 0).GetLocal ();\n    sendApp->Setup (receiverIp, port); // initBw, minBw, maxBw);\n\n    const auto fps = 25.;\n    auto innerCodec = new syncodecs::StatisticsCodec{fps};\n    auto codec = new syncodecs::ShapedPacketizer{innerCodec, DEFAULT_PACKET_SIZE};\n    sendApp->SetCodec (std::shared_ptr<syncodecs::Codec>{codec});\n\n    recvApp->Setup (port);\n\n    sendApp->SetStartTime (Seconds (startTime));\n    sendApp->SetStopTime (Seconds (stopTime));\n\n    recvApp->SetStartTime (Seconds (startTime));\n    recvApp->SetStopTime (Seconds (stopTime));\n}\n\nint main (int argc, char *argv[])\n{\n    int nRmcat = 1;\n    int nTcp = 0;\n    int nUdp = 0;\n    bool log = false;\n    bool nada = true;\n    std::string strArg  = \"strArg default\";\n\n    CommandLine cmd;\n    cmd.AddValue (\"rmcat\", \"Number of RMCAT (NADA) flows\", nRmcat);\n    cmd.AddValue (\"tcp\", \"Number of TCP flows\", nTcp);\n    cmd.AddValue (\"udp\", \"Number of UDP flows\", nUdp);\n    cmd.AddValue (\"log\", \"Turn on logs\", log);\n    cmd.AddValue (\"nada\", \"true: use NADA, false: use dummy\", nada);\n    cmd.Parse (argc, argv);\n\n    if (log) {\n        LogComponentEnable (\"RmcatSender\", LOG_INFO);\n        LogComponentEnable (\"RmcatReceiver\", LOG_INFO);\n        LogComponentEnable (\"Packet\", LOG_FUNCTION);\n    }\n\n    // configure default TCP parameters\n    Config::SetDefault (\"ns3::TcpSocket::DelAckCount\", UintegerValue (0));\n    Config::SetDefault (\"ns3::TcpL4Protocol::SocketType\", StringValue (\"ns3::TcpNewReno\"));\n    Config::SetDefault (\"ns3::TcpSocket::SegmentSize\", UintegerValue (1000));\n\n    const uint64_t linkBw   = TOPO_DEFAULT_BW;\n    const uint32_t msDelay  = TOPO_DEFAULT_PDELAY;\n    const uint32_t msQDelay = TOPO_DEFAULT_QDELAY;\n\n    const float minBw =  RMCAT_DEFAULT_RMIN;\n    const float maxBw =  RMCAT_DEFAULT_RMAX;\n    const float initBw = RMCAT_DEFAULT_RINIT;\n\n    const float endTime = 300.;\n\n    NodeContainer nodes = BuildExampleTopo (linkBw, msDelay, msQDelay);\n\n    int port = 8000;\n    nRmcat = std::max<int> (0, nRmcat); // No negative RMCAT flows\n    for (size_t i = 0; i < (unsigned int) nRmcat; ++i) {\n        auto start = 10. * i;\n        auto end = std::max (start + 1., endTime - start);\n        InstallApps (nada, nodes.Get (0), nodes.Get (1), port++,\n                     initBw, minBw, maxBw, start, end);\n    }\n\n    nTcp = std::max<int> (0, nTcp); // No negative TCP flows\n    for (size_t i = 0; i < (unsigned int) nTcp; ++i) {\n        auto start = 17. * i;\n        auto end = std::max (start + 1., endTime - start);\n        InstallTCP (nodes.Get (0), nodes.Get (1), port++, start, end);\n    }\n\n    // UDP parameters\n    const uint64_t bandwidth = RMCAT_DEFAULT_RMAX / 4;\n    const uint32_t pktSize = DEFAULT_PACKET_SIZE;\n\n    nUdp = std::max<int> (0, nUdp); // No negative UDP flows\n    for (size_t i = 0; i < (unsigned int) nUdp; ++i) {\n        auto start = 23. * i;\n        auto end = std::max (start + 1., endTime - start);\n        InstallUDP (nodes.Get (0), nodes.Get (1), port++,\n                    bandwidth, pktSize, start, end);\n    }\n\n    std::cout << \"Running Simulation...\" << std::endl;\n    Simulator::Stop (Seconds (endTime));\n    Simulator::Run ();\n    Simulator::Destroy ();\n    std::cout << \"Done\" << std::endl;\n\n    return 0;\n}\n"
    }
  ]
}