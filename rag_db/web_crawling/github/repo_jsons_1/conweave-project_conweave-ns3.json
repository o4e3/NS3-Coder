{
  "repo_name": "conweave-project/conweave-ns3",
  "github_url": "https://github.com/conweave-project/conweave-ns3",
  "readme": "# NS-3 Simulator for RDMA Network Load Balancing\n\nThis is a Github repository for the SIGCOMM'23 paper \"[Network Load Balancing with In-network Reordering Support for RDMA](https://doi.org/10.1145/3603269.3604849)\".\n\nWe describe how to run this repository either on docker or using your local machine with `ubuntu:20.04`. \n\n\n## Run with Docker\n\n#### Docker Engine\nFor Ubuntu, following the installation guide [here](https://docs.docker.com/engine/install/ubuntu/) and make sure to apply the necessary post-install [steps](https://docs.docker.com/engine/install/linux-postinstall/).\nEventually, you should be able to launch the `hello-world` Docker container without the `sudo` command: `docker run hello-world`.\n\n#### 0. Prerequisites\nFirst, you do all these:\n\n```shell\nwget https://www.nsnam.org/releases/ns-allinone-3.19.tar.bz2\ntar -xvf ns-allinone-3.19.tar.bz2\ncd ns-allinone-3.19\nrm -rf ns-3.19\ngit clone https://github.com/conweave-project/conweave-ns3.git ns-3.19\n```\n\n#### 1. Create a Dockerfile\nHere, `ns-allinone-3.19` will be your root directory.\n\nCreate a Dockerfile at the root directory with the following:\n```shell\nFROM ubuntu:20.04\nARG DEBIAN_FRONTEND=noninteractive\n\nRUN apt update && apt install -y gnuplot python python3 python3-pip build-essential libgtk-3-0 bzip2 wget git && rm -rf /var/lib/apt/lists/* && pip3 install numpy matplotlib cycler\nWORKDIR /root\n```\n\nThen, you do this: \n```shell\ndocker build -t cw-sim:sigcomm23ae .\n```\n\nOnce the container is built, do this from the root directory:\n```shell\ndocker run -it -v $(pwd):/root cw-sim:sigcomm23ae bash -c \"cd ns-3.19; ./waf configure --build-profile=optimized; ./waf\"\n```\n\nThis should build everything necessary for the simulator.\n\n#### 2. Run\nOne can always just run the container: \n```shell\ndocker run -it --name cw-sim -v $(pwd):/root cw-sim:sigcomm23ae \ncd ns-3.19;\n./autorun.sh\n```\n\nThat will run `0.1 second` simulation of 8 experiments which are a part of Figure 12 and 13 in the paper.\nIn the script, you can easily change the network load (e.g., `50%`), runtime (e.g., `0.1s`), or topology (e.g., `leaf-spine`).\nTo plot the FCT graph, see below or refer to the script `./analysis/plot_fct.py`.\nTo plot the Queue Usage graph, see below or refer to the script `./analysis/plot_queue.py`.\n\n:exclamation: **To run processes in background**, use the commands:\n```shell\ndocker run -dit --name cw-sim -v $(pwd):/root cw-sim:sigcomm23ae \ndocker exec -it cw-sim /bin/bash\n\nroot@252578ceff68:~# cd ns-3.19/\nroot@252578ceff68:~/ns-3.19# ./autorun.sh\nRunning RDMA Network Load Balancing Simulations (leaf-spine topology)\n\n----------------------------------\nTOPOLOGY: leaf_spine_128_100G_OS2\nNETWORK LOAD: 50\nTIME: 0.1\n----------------------------------\n\nRun Lossless RDMA experiments...\nRun IRN RDMA experiments...\nRuning all in parallel. Check the processors running on background!\nroot@252578ceff68:~/ns-3.19# exit\nexit\n```\n\n#### 3. Plot\nYou can easily plot the results using the following command:\n```shell\npython3 ./analysis/plot_fct.py\npython3 ./analysis/plot_queue.py\npython3 ./analysis/plot_uplink.py\n```\n\nSee below for details of output results.\n\n\n\n\n---\n\n## Run NS-3 on Ubuntu 20.04\n#### 0. Prerequisites\nWe tested the simulator on Ubuntu 20.04, but latest versions of Ubuntu should also work.\n```shell\nsudo apt install build-essential python3 libgtk-3-0 bzip2\n```\nFor plotting, we use `numpy`, `matplotlib`, and `cycler` for python3:\n```shell\npython3 -m pip install numpy matplotlib cycler\n```\n\n\n#### 1. Configure & Build\n```shell\nwget https://www.nsnam.org/releases/ns-allinone-3.19.tar.bz2\ntar -xvf ns-allinone-3.19.tar.bz2\ncd ns-allinone-3.19\nrm -rf ns-3.19\ngit clone https://github.com/conweave-project/conweave-ns3.git ns-3.19\ncd ns-3.19\n./waf configure --build-profile=optimized\n./waf\n```\n\n\n#### 2. Simulation\n##### Run\nYou can reproduce the simulation results of Figure 12 and 13 (FCT slowdown), Figure 16 (Queue usage per switch) by running the script:\n```shell\n./autorun.sh\n```\n\nIn the script, you can easily change the network load (e.g., `50%`), runtime (e.g., `0.1s`), or topology (e.g., `leaf-spine`).\nThis takes a few hours, and requires 8 CPU cores and 10G RAM.\nNote that we do not run `DRILL` since it takes too much time due to many out-of-order packets.\n\n\nIf you want to run the simulation individually, try this command:\n```shell\npython3 ./run.py --h\n```\n\nIt first calls a traffic generator `./traffic_gen/traffic_gen.py` to create an input trace.\nThen, it runs NS-3 simulation script `./scratch/network-load-balance.cc`. \nLastly, it runs FCT analyzer `./fctAnalysis.py` and switch resource analyzer `./queueAnalysis.py`. \n\n\n##### Plot\nYou can easily plot the results using the following command:\n```shell\npython3 ./analysis/plot_fct.py\npython3 ./analysis/plot_queue.py\npython3 ./analysis/plot_uplink.py\n```\n\nThe outcome figures are located at `./analysis/figures`. \n1. The script requires input parameters such as `-sT` and `-fT` which indicate the time window to analyze the fct result. \nBy default, it assuems to use `0.1 second` runtime. \n2. `plot_fct.py` plots the Average and 99-percentile FCT result and give comparisons between frameworks. It excludes `5ms` of warm-up and `50ms` of cool-down period in measurements. You can control these numbers in `run.py`:\n```python\nfct_analysis_time_limit_begin = int(flowgen_start_time * 1e9) + int(0.005 * 1e9)  # warmup\nfct_analysistime_limit_end = int(flowgen_stop_time * 1e9) + int(0.05 * 1e9)  # extra term\n```\nor, directly put parameters into `plot_fct.py`. Use `-h` for details. \n3. `plot_queue.py` plots the CDF of queue volume usage per switch for ConWeave. It excludes `5ms` of warm-up period, and cool-down period is not used as it would _underestimate_ the overhead. Similarly, you can control this number in `run.py`:\n```python\nqueue_analysis_time_limit_begin = int(flowgen_start_time * 1e9) + int(0.005 * 1e9)  # warmup\nqueue_analysistime_limit_end = int(flowgen_stop_time * 1e9) # no extra term!!\n```\nor, directly put parameters into `plot_queue.py`. Use `-h` for details. \n4. `plot_uplink.py` plots the load balance efficiency with ToR uplink utility. By default, it captures uplink throughputs for every `100\u00b5s` and measure the variations. It excludes `5ms` of warm-up and `50ms` of cool-down period in measurements. \nOr, directly put parameters into `plot_uplink.py`. Use `-h` for details. \n\n##### Output\nAs well as above figures, other results are located at `./mix/output`, such as uplink usage (Figure 14), queue number usage per port (Figure 15), etc.\n\n* At `./mix/output`, several raw data is stored such as \n  * Flow Completion Time (`XXX_out_fct.txt`), - Figure 12, 13\n  * PFC generation (`XXX_out_pfc.txt`), \n  * Uplink's utility (`XXX_out_uplink.txt`), - Figure 14\n  * Number of connections (`XXX_out_conn.txt`), \n  * Congestion Notification Packet (`XXX_out_cnp.txt`).\n  * CDF of number of queues usage per egress port (`XXX_out_voq_per_dst_cdf.txt`). - Figure 15 \n  * CDF of total queue memory overhead per switch (`XXX_out_voq_cdf.txt`). - Figure 16\n  \n* Each run of simulation creates a repository in `./mix/output` with simulation ID (10-digit number).\n* Inside the folder, you can check the simulation config `config.txt` and output log `config.log`. \n* The output files include post-processed files such as CDF results.\n* The history of simulations will be recorded in `./mix/.history`. \n\n##### Topology\nTo evaluate on fat-tree (K=8) topology, you can simply change the `TOPOLOGY` variable in `autorun.sh` to `fat_k8_100G_OS2`:\n```shell\nTOPOLOGY=\"leaf_spine_128_100G_OS2\" # or, fat_k8_100G_OS2\n```\n\n##### Clean up\nTo clean all data of previous simulation results, you can run the command:\n```shell\n./cleanup.sh\n```\n\n#### ConWeave Parameters\nWe include ConWeave's parameter values into `./run.py` based on flow control model and topology.  \n\n\n### Simulator Structure\nMost implementations of network load balancing are located in the directory `./src/point-to-point/model`.\n\n* `switch-node.h/cc`: Switching logic that includes a default multi-path routing protocol (e.g., ECMP) and DRILL.\n* `switch-mmu.h/cc`: Ingress/egress admission control and PFC.\n* `conga-routing.h/cc`: Conga routing protocol.\n* `letflow-routing.h/cc`: Letflow routing protocol.\n* `conweave-routing.h/cc`: ConWeave routing protocol.\n* `conweave-voq.h/cc`: ConWeave in-network reordering buffer.\n* `settings.h/cc`: Global variables for logging and debugging.\n* `rdma-hw.h/cc`: RDMA-enable NIC behavior model.\n\n<b> RNIC behavior model to out-of-order packet arrival </b>\nAs disussed in the paper, we observe that RNIC reacts to even a single out-of-order packet sensitively by sending CNP packet.\nHowever, existing RDMA-NS3 simulator (HPCC, DCQCN, TLT-RDMA, etc) did not account for this.\nIn this simulator, we implemented that behavior in `rdma-hw.cc`.\n\n\n## Citation\nIf you find this repository useful in your research, please consider citing:\n```\n@inproceedings{song2023conweave,\n  title={Network Load Balancing with In-network Reordering Support for RDMA},\n  author={Song, Cha Hwan and Khooi, Xin Zhe and Joshi, Raj and Choi, Inho and Li, Jialin and Chan, Mun Choon},\n  booktitle={Proceedings of SIGCOMM},\n  year={2023}\n}\n```\n\n## Credit\nThis code repository is based on [https://github.com/alibaba-edu/High-Precision-Congestion-Control](https://github.com/alibaba-edu/High-Precision-Congestion-Control) for Mellanox Connect-X based RDMA-enabled NIC implementation, and [https://github.com/kaist-ina/ns3-tlt-rdma-public.git](https://github.com/kaist-ina/ns3-tlt-rdma-public.git) for Broadcom switch's shared buffer model and IRN implementation.\n\n```\nMIT License\n\nCopyright (c) 2023 National University of Singapore\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```\n",
  "examples": []
}