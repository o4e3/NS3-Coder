{
  "repo_name": "named-data-ndnSIM/ndnSIM",
  "github_url": "https://github.com/named-data-ndnSIM/ndnSIM",
  "readme": "ndnSIM\n======\n\n[![Build Status](https://travis-ci.org/named-data-ndnSIM/ndnSIM.svg)](https://travis-ci.org/named-data-ndnSIM/ndnSIM)\n\nA new release of [NS-3 based Named Data Networking (NDN) simulator](http://ndnsim.net/)\nwent through extensive refactoring and rewriting.  The key new features of the new\nversion:\n\n- [NDN Packet Specification](http://named-data.net/doc/NDN-packet-spec/current/)\n\n- ndnSIM uses implementation of basic NDN primitives from\n  [ndn-cxx library (NDN C++ library with eXperimental eXtensions)](http://named-data.net/doc/ndn-cxx/)\n\n  Based on version `0.7.0`\n\n- All NDN forwarding and management is implemented directly using source code of\n  [Named Data Networking Forwarding Daemon (NFD)](http://named-data.net/doc/NFD/)\n\n  Based on version `0.7.0`\n\n- Allows [simulation of real applications](http://ndnsim.net/guide-to-simulate-real-apps.html)\n  written against ndn-cxx library\n\n- Requires a modified version of NS-3 based on version `ns-3.30.1`\n\n[ndnSIM documentation](http://ndnsim.net)\n---------------------------------------------\n\nFor more information, including downloading and compilation instruction, please refer to\nhttp://ndnsim.net or documentation in `docs/` folder.\n",
  "examples": [
    {
      "file_path": "examples/lfid.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2019  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n#include \"ns3/command-line.h\"\n#include \"ns3/double.h\"\n#include \"ns3/names.h\"\n#include \"ns3/point-to-point-channel.h\"\n#include \"ns3/uinteger.h\"\n\n#include \"ns3/ndnSIM/helper/ndn-app-helper.hpp\"\n#include \"ns3/ndnSIM/helper/ndn-global-routing-helper.hpp\"\n#include \"ns3/ndnSIM/helper/ndn-stack-helper.hpp\"\n#include \"ns3/ndnSIM/helper/ndn-strategy-choice-helper.hpp\"\n#include \"ns3/ndnSIM/model/ndn-l3-protocol.hpp\"\n#include \"ns3/ndnSIM/model/ndn-net-device-transport.hpp\"\n//#include \"ns3/ndnSIM/NFD/daemon/fw/random-strategy.hpp\"\n#include \"ns3/ndnSIM/NFD/daemon/fw/best-route-strategy.hpp\"\n#include \"ns3/ndnSIM/utils/topology/annotated-topology-reader.hpp\"\n\nnamespace ns3 {\n\nvoid\ndisplayRoutes(const NodeContainer& allNodes, const std::string& prefix)\n{\n  for (const auto& n : allNodes) {\n    const auto& fib = n->GetObject<ndn::L3Protocol>()->getForwarder()->getFib();\n    const auto& e = fib.findLongestPrefixMatch(prefix);\n\n    std::cout << \"Node \" << n->GetId() << \", prefix: \" << prefix << \"\\n\";\n\n    for (const auto& nh : e.getNextHops()) {\n      // Get remote nodeId from face:\n      const auto transport = dynamic_cast<ndn::NetDeviceTransport*>(nh.getFace().getTransport());\n      if (transport == nullptr)\n        continue;\n\n      const auto nd1 = transport->GetNetDevice()->GetObject<PointToPointNetDevice>();\n      if (nd1 == nullptr)\n        continue;\n\n      const auto ppChannel = DynamicCast<PointToPointChannel>(nd1->GetChannel());\n      if (ppChannel == nullptr)\n        continue;\n\n      auto nd2 = ppChannel->GetDevice(0);\n      if (nd2->GetNode() == n)\n        nd2 = ppChannel->GetDevice(1);\n\n      std::cout << \"    NextHop: \" << nd2->GetNode()->GetId() << \", cost: \" << nh.getCost() << \"\\n\";\n    }\n    std::cout << \"\\n\";\n  }\n}\n\nint\nmain(int argc, char* argv[])\n{\n  bool grid = false; // Use grid topology?\n  std::string routing = \"lfid\";\n  CommandLine cmd;\n  cmd.AddValue(\"grid\", \"use grid topology (instead of abilene)\", grid);\n  cmd.AddValue(\"routing\", \"which route computation to use (lfid, sp, allroutes)\", routing);\n  cmd.Parse(argc, argv);\n\n  std::string topoName = \"abilene\";\n  if (grid) {\n    topoName = \"grid\";\n  }\n\n  std::cout << \"Using \" << topoName << \" topology\\n\\n\";\n\n  AnnotatedTopologyReader topologyReader{};\n  topologyReader.SetFileName(\"src/ndnSIM/examples/topologies/topo-\" + topoName + \".txt\");\n  topologyReader.Read();\n\n  ndn::StackHelper stackHelper{};\n  stackHelper.InstallAll();\n\n  // IMPORTANT: Has to be run after StackHelper!\n  topologyReader.ApplyOspfMetric();\n\n  const std::string prefix{\"/prefix\"};\n\n  Ptr<Node> consumerN = Names::Find<Node>(\"router0\");\n  Ptr<Node> producerN = Names::Find<Node>(\"producer\");\n  NS_ABORT_MSG_UNLESS(consumerN && producerN, \"consumer or producer name does not exist in topo file!\");\n\n  ndn::GlobalRoutingHelper routingHelper;\n  routingHelper.InstallAll(); // Fills GlobalRouter with incidencies.\n  routingHelper.AddOrigin(prefix, producerN);\n\n  if (routing == \"lfid\") {\n    routingHelper.CalculateLfidRoutes();\n  }\n  else if (routing == \"sp\") {\n    routingHelper.CalculateRoutes();\n  }\n  else if (routing == \"allroutes\") {\n    routingHelper.CalculateAllPossibleRoutes();\n  }\n  else {\n    NS_FATAL_ERROR(\"Unknown route calculation! Use --routing {lfid|sp|allroutes}\");\n  }\n\n  // IMPORTANT: Some strategy needs to be installed for displayRoutes() to work.\n  ndn::StrategyChoiceHelper strategyHelper;\n  strategyHelper.InstallAll<nfd::fw::BestRouteStrategy>(\"/\");\n\n  // TODO: Needs RandomStrategy for test to work!\n  // Uncomment after NFD version has been updated.\n  //  strategyHelper.InstallAll<nfd::fw::RandomStrategy>(\"/\");\n\n  displayRoutes(topologyReader.GetNodes(), prefix);\n\n  // Installing applications\n  ndn::AppHelper consumerHelperX{\"ns3::ndn::ConsumerCbr\"};\n  consumerHelperX.SetPrefix(prefix);\n  consumerHelperX.SetAttribute(\"Frequency\", DoubleValue(100.0));\n  consumerHelperX.Install(consumerN);\n\n  ndn::AppHelper producerHelper0{\"ns3::ndn::Producer\"};\n  producerHelper0.SetPrefix(prefix);\n  producerHelper0.Install(producerN);\n\n  Simulator::Stop(Seconds(30));\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-congestion-alt-topo-plugin.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-congestion-alt-topo-plugin.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nnamespace ns3 {\n\n/**\n *\n *   /------\\ 0                                                 0 /------\\\n *   |  c1  |<-----+                                       +----->|  p1  |\n *   \\------/       \\                                     /       \\------/\n *                   \\              /-----\\              /\n *   /------\\ 0       \\         +==>| r12 |<==+         /       0 /------\\\n *   |  c2  |<--+      \\       /    \\-----/    \\       /      +-->|  p2  |\n *   \\------/    \\      \\     |                 |     /      /    \\------/\n *                \\      |    |   1Mbps links   |    |      /\n *                 \\  1  v0   v5               1v   2v  3  /\n *                  +->/------\\                 /------\\<-+\n *                    2|  r1  |<===============>|  r2  |4\n *                  +->\\------/4               0\\------/<-+\n *                 /    3^                           ^5    \\\n *                /      |                           |      \\\n *   /------\\ 0  /      /                             \\      \\  0 /------\\\n *   |  c3  |<--+      /                               \\      +-->|  p3  |\n *   \\------/         /                                 \\         \\------/\n *                   /     \"All consumer-router and\"     \\\n *   /------\\ 0     /      \"router-producer links are\"    \\    0 /------\\\n *   |  c4  |<-----+       \"10Mbps\"                        +---->|  p4  |\n *   \\------/                                                    \\------/\n *\n *   \"Numbers near nodes denote face IDs. Face ID is assigned based on the order of link\"\n *   \"definitions in the topology file\"\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     NS_LOG=ndn.Consumer:ndn.Producer ./waf --run=ndn-congestion-alt-topo-plugin\n */\n\nint\nmain(int argc, char* argv[])\n{\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  AnnotatedTopologyReader topologyReader(\"\", 1);\n  topologyReader.SetFileName(\"src/ndnSIM/examples/topologies/topo-11-node-two-bottlenecks.txt\");\n  topologyReader.Read();\n\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.setPolicy(\"nfd::cs::lru\");\n  ndnHelper.setCsSize(1);\n  ndnHelper.InstallAll();\n\n  // Set BestRoute strategy\n  ndn::StrategyChoiceHelper::InstallAll(\"/\", \"/localhost/nfd/strategy/best-route\");\n\n  // Getting containers for the consumer/producer\n  Ptr<Node> consumers[4] = {Names::Find<Node>(\"c1\"), Names::Find<Node>(\"c2\"),\n                            Names::Find<Node>(\"c3\"), Names::Find<Node>(\"c4\")};\n  Ptr<Node> producers[4] = {Names::Find<Node>(\"p1\"), Names::Find<Node>(\"p2\"),\n                            Names::Find<Node>(\"p3\"), Names::Find<Node>(\"p4\")};\n\n  if (consumers[0] == 0 || consumers[1] == 0 || consumers[2] == 0 || consumers[3] == 0\n      || producers[0] == 0 || producers[1] == 0 || producers[2] == 0 || producers[3] == 0) {\n    NS_FATAL_ERROR(\"Error in topology: one nodes c1, c2, c3, c4, p1, p2, p3, or p4 is missing\");\n  }\n\n  for (int i = 0; i < 4; i++) {\n    std::string prefix = \"/data/\" + Names::FindName(producers[i]);\n\n    /////////////////////////////////////////////////////////////////////////////////\n    // install consumer app on consumer node c_i to request data from producer p_i //\n    /////////////////////////////////////////////////////////////////////////////////\n\n    ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n    consumerHelper.SetAttribute(\"Frequency\", StringValue(\"10\")); // 100 interests a second\n\n    consumerHelper.SetPrefix(prefix);\n    ApplicationContainer consumer = consumerHelper.Install(consumers[i]);\n    consumer.Start(Seconds(i));     // start consumers at 0s, 1s, 2s, 3s\n    consumer.Stop(Seconds(19 - i)); // stop consumers at 19s, 18s, 17s, 16s\n\n    ///////////////////////////////////////////////\n    // install producer app on producer node p_i //\n    ///////////////////////////////////////////////\n\n    ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n    producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n\n    // install producer that will satisfy Interests in /dst1 namespace\n    producerHelper.SetPrefix(prefix);\n    ApplicationContainer producer = producerHelper.Install(producers[i]);\n    // when Start/Stop time is not specified, the application is running throughout the simulation\n  }\n\n  // Manually configure FIB routes\n  ndn::FibHelper::AddRoute(\"c1\", \"/data\", \"n1\", 1); // link to n1\n  ndn::FibHelper::AddRoute(\"c2\", \"/data\", \"n1\", 1); // link to n1\n  ndn::FibHelper::AddRoute(\"c3\", \"/data\", \"n1\", 1); // link to n1\n  ndn::FibHelper::AddRoute(\"c4\", \"/data\", \"n1\", 1); // link to n1\n\n  ndn::FibHelper::AddRoute(\"n1\", \"/data\", \"n2\", 1);  // link to n2\n  ndn::FibHelper::AddRoute(\"n1\", \"/data\", \"n12\", 2); // link to n12\n\n  ndn::FibHelper::AddRoute(\"n12\", \"/data\", \"n2\", 1); // link to n2\n\n  ndn::FibHelper::AddRoute(\"n2\", \"/data/p1\", \"p1\", 1); // link to p1\n  ndn::FibHelper::AddRoute(\"n2\", \"/data/p2\", \"p2\", 1); // link to p2\n  ndn::FibHelper::AddRoute(\"n2\", \"/data/p3\", \"p3\", 1); // link to p3\n  ndn::FibHelper::AddRoute(\"n2\", \"/data/p4\", \"p4\", 1); // link to p4\n\n  // Schedule simulation time and run the simulation\n  Simulator::Stop(Seconds(20.0));\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-congestion-topo-plugin.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-congestion-topo-plugin.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nnamespace ns3 {\n\n/**\n * This scenario simulates a grid topology (using topology reader module)\n *\n *   /------\\                                                    /------\\\n *   | Src1 |<--+                                            +-->| Dst1 |\n *   \\------/    \\                                          /    \\------/\n *                \\                                        /\n *                 +-->/------\\   \"bottleneck\"  /------\\<-+\n *                     | Rtr1 |<===============>| Rtr2 |\n *                 +-->\\------/                 \\------/<-+\n *                /                                        \\\n *   /------\\    /                                          \\    /------\\\n *   | Src2 |<--+                                            +-->| Dst2 |\n *   \\------/                                                    \\------/\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     NS_LOG=ndn.Consumer:ndn.Producer ./waf --run=ndn-congestion-topo-plugin\n */\n\nint\nmain(int argc, char* argv[])\n{\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  AnnotatedTopologyReader topologyReader(\"\", 25);\n  topologyReader.SetFileName(\"src/ndnSIM/examples/topologies/topo-6-node.txt\");\n  topologyReader.Read();\n\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.setPolicy(\"nfd::cs::lru\");\n  ndnHelper.setCsSize(10000);\n  ndnHelper.InstallAll();\n\n  // Choosing forwarding strategy\n  ndn::StrategyChoiceHelper::InstallAll(\"/prefix\", \"/localhost/nfd/strategy/best-route\");\n\n  // Installing global routing interface on all nodes\n  ndn::GlobalRoutingHelper ndnGlobalRoutingHelper;\n  ndnGlobalRoutingHelper.InstallAll();\n\n  // Getting containers for the consumer/producer\n  Ptr<Node> consumer1 = Names::Find<Node>(\"Src1\");\n  Ptr<Node> consumer2 = Names::Find<Node>(\"Src2\");\n\n  Ptr<Node> producer1 = Names::Find<Node>(\"Dst1\");\n  Ptr<Node> producer2 = Names::Find<Node>(\"Dst2\");\n\n  ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n  consumerHelper.SetAttribute(\"Frequency\", StringValue(\"100\")); // 100 interests a second\n\n  // on the first consumer node install a Consumer application\n  // that will express interests in /dst1 namespace\n  consumerHelper.SetPrefix(\"/dst1\");\n  consumerHelper.Install(consumer1);\n\n  // on the second consumer node install a Consumer application\n  // that will express interests in /dst2 namespace\n  consumerHelper.SetPrefix(\"/dst2\");\n  consumerHelper.Install(consumer2);\n\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n\n  // Register /dst1 prefix with global routing controller and\n  // install producer that will satisfy Interests in /dst1 namespace\n  ndnGlobalRoutingHelper.AddOrigins(\"/dst1\", producer1);\n  producerHelper.SetPrefix(\"/dst1\");\n  producerHelper.Install(producer1);\n\n  // Register /dst2 prefix with global routing controller and\n  // install producer that will satisfy Interests in /dst2 namespace\n  ndnGlobalRoutingHelper.AddOrigins(\"/dst2\", producer2);\n  producerHelper.SetPrefix(\"/dst2\");\n  producerHelper.Install(producer2);\n\n  // Calculate and install FIBs\n  ndn::GlobalRoutingHelper::CalculateRoutes();\n\n  Simulator::Stop(Seconds(20.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-csma.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-csma.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nnamespace ns3 {\n\n/**\n * This scenario simulates a very simple network topology:\n *\n *                            CSMA bus (1Mbps, 10ms)\n *           +--------------------------+--------------------------+\n *           |                          |                          |\n *\n *      +----------+                +--------+                +----------+\n *      | consumer |                | router |                | producer |\n *      +----------+                +--------+                +----------+\n *\n *\n * Consumer requests data from producer with frequency 10 interests per second\n * (interests contain constantly increasing sequence number).\n *\n * For every received interest, producer replies with a data packet, containing\n * 1024 bytes of virtual payload.\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     NS_LOG=ndn.Consumer:ndn.Producer ./waf --run=ndn-csma\n */\n\nint\nmain(int argc, char* argv[])\n{\n  // setting default parameters for PointToPoint links and channels\n  Config::SetDefault(\"ns3::CsmaChannel::DataRate\", StringValue(\"1Mbps\"));\n  Config::SetDefault(\"ns3::CsmaChannel::Delay\", StringValue(\"10ms\"));\n  Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\", StringValue(\"20p\"));\n\n  // Read optional command-line parameters (e.g., enable visualizer with ./waf --run=<> --visualize\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  // Creating nodes\n  NodeContainer nodes;\n  nodes.Create(3);\n\n  // Connecting nodes using two links\n  CsmaHelper csma;\n  csma.Install(nodes);\n\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.SetDefaultRoutes(true);\n  ndnHelper.InstallAll();\n\n  // Installing applications\n\n  // Consumer\n  ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n  // Consumer will request /prefix/0, /prefix/1, ...\n  consumerHelper.SetPrefix(\"/prefix\");\n  consumerHelper.SetAttribute(\"Frequency\", StringValue(\"10\")); // 10 interests a second\n  consumerHelper.Install(nodes.Get(0));                        // first node\n\n  // Producer\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  // Producer will reply to all requests starting with /prefix\n  producerHelper.SetPrefix(\"/prefix\");\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n  producerHelper.Install(nodes.Get(2)); // last node\n\n  Simulator::Stop(Seconds(20.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-custom-apps.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-custom-apps.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nnamespace ns3 {\n\n/**\n * This scenario simulates a one-node two-custom-app scenario:\n *\n *   +------+ <-----> (CustomApp)\n *   | Node |\n *   +------+ <-----> (Hijacker)\n *\n *     NS_LOG=CustomApp ./waf --run=ndn-custom-apps\n */\nint\nmain(int argc, char* argv[])\n{\n  // Read optional command-line parameters (e.g., enable visualizer with ./waf --run=<> --visualize\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  // Creating nodes\n  Ptr<Node> node = CreateObject<Node>();\n\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.SetDefaultRoutes(true);\n  ndnHelper.InstallAll();\n\n  // App1\n  ndn::AppHelper app1(\"CustomApp\");\n  app1.Install(node);\n\n  // App2\n  ndn::AppHelper app2(\"Hijacker\");\n  app2.Install(node); // last node\n\n  Simulator::Stop(Seconds(20.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-cxx-simple.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n#include \"ndn-cxx-simple/real-app.hpp\"\n#include \"ndn-cxx-simple/real-app-starter.hpp\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nnamespace ns3 {\n\nNS_OBJECT_ENSURE_REGISTERED(RealAppStarter);\n\nint\nmain(int argc, char* argv[])\n{\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  Ptr<Node> node = CreateObject<Node>();\n\n  ndn::StackHelper ndnHelper;\n  ndnHelper.Install(node);\n\n  ndn::AppHelper appHelper(\"RealAppStarter\");\n  appHelper.Install(node)\n    .Start(Seconds(6.5));\n\n  Simulator::Stop(Seconds(20.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-different-strategy-per-prefix.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-different-strategy-per-prefix.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/point-to-point-layout-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nusing namespace ns3;\nusing ns3::ndn::StackHelper;\nusing ns3::ndn::AppHelper;\nusing ns3::ndn::GlobalRoutingHelper;\nusing ns3::ndn::StrategyChoiceHelper;\n\n/**\n * This scenario simulates a grid topology (using PointToPointGrid module)\n *\n * In this scenario, thanks to NFD, we can choose a different forwarding\n * strategy for each prefix in each node.\n *\n * (consumer) -- ( ) -- (producer)\n *     |          |         |\n *    ( ) ------ ( ) ----- ( )\n *     |          |         |\n * (consumer) -- ( ) -- (producer)\n *\n * All links are 1Mbps with propagation 10ms delay.\n *\n * FIB is populated using NdnGlobalRoutingHelper.\n *\n * Consumer requests data from producer with frequency 100 interests per second\n * (interests contain constantly increasing sequence number).\n *\n * For every received interest, producer replies with a data packet, containing\n * 1024 bytes of virtual payload.\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     NS_LOG=ndn.Consumer:ndn.Producer ./waf --run=ndn-different-strategy-per-prefix\n */\n\nint\nmain(int argc, char* argv[])\n{\n  // Setting default parameters for PointToPoint links and channels\n  Config::SetDefault(\"ns3::PointToPointNetDevice::DataRate\", StringValue(\"1Mbps\"));\n  Config::SetDefault(\"ns3::PointToPointChannel::Delay\", StringValue(\"10ms\"));\n  Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\", StringValue(\"10p\"));\n\n  // Read optional command-line parameters\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  // Creating 3x3 topology\n  PointToPointHelper p2p;\n  PointToPointGridHelper grid(3, 3, p2p);\n  grid.BoundingBox(100, 100, 200, 200);\n\n  // Install NDN stack on all nodes\n  StackHelper ndnHelper;\n  ndnHelper.InstallAll();\n\n  // Installing global routing interface on all nodes\n  GlobalRoutingHelper ndnGlobalRoutingHelper;\n  ndnGlobalRoutingHelper.InstallAll();\n\n  // Getting pointers to the producer/consumer nodes\n  Ptr<Node> producer1 = grid.GetNode(2, 2);\n  Ptr<Node> producer2 = grid.GetNode(0, 2);\n  Ptr<Node> consumer1 = grid.GetNode(0, 0);\n  Ptr<Node> consumer2 = grid.GetNode(2, 0);\n\n  // Define two name prefixes\n  std::string prefix1 = \"/prefix1\";\n  std::string prefix2 = \"/prefix2\";\n\n  // Install different forwarding strategies for prefix1, prefix2\n  StrategyChoiceHelper::InstallAll(prefix1, \"/localhost/nfd/strategy/multicast\");\n  StrategyChoiceHelper::InstallAll(prefix2, \"/localhost/nfd/strategy/best-route\");\n\n  // Install NDN applications\n  AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n  consumerHelper.SetPrefix(prefix1);\n  consumerHelper.SetAttribute(\"Frequency\", StringValue(\"100\")); // 100 interests a second\n  consumerHelper.Install(consumer1);\n\n  consumerHelper.SetPrefix(prefix2);\n  consumerHelper.Install(consumer2);\n\n  AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetPrefix(prefix1);\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n  producerHelper.Install(producer1);\n\n  producerHelper.SetPrefix(prefix2);\n  producerHelper.Install(producer2);\n\n  // Add /prefix1 and /prefix2 origins to ndn::GlobalRouter\n  ndnGlobalRoutingHelper.AddOrigins(prefix1, producer1);\n  ndnGlobalRoutingHelper.AddOrigins(prefix2, producer2);\n\n  // Calculate and install FIBs\n  GlobalRoutingHelper::CalculateRoutes();\n\n  Simulator::Stop(Seconds(20.0));\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/ndn-grid-multiple-strategies.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-grid-multiple-strategies.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/point-to-point-layout-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nusing namespace ns3;\nusing ns3::ndn::StackHelper;\nusing ns3::ndn::AppHelper;\nusing ns3::ndn::GlobalRoutingHelper;\nusing ns3::ndn::StrategyChoiceHelper;\n\n/**\n * This scenario simulates a grid topology (using PointToPointGrid module)\n *\n * The first six nodes use the best route forwarding strategy, whereas\n * the three remaining nodes use the multicast forwarding strategy.\n *\n * (consumer) -- ( ) ----- ( )\n *     |          |         |\n *    ( ) ------ ( ) ----- ( )\n *     |          |         |\n *    ( ) ------ ( ) -- (producer)\n *\n * All links are 1Mbps with propagation 10ms delay.\n *\n * FIB is populated using NdnGlobalRoutingHelper.\n *\n * Consumer requests data from producer with frequency 100 interests per second\n * (interests contain constantly increasing sequence number).\n *\n * For every received interest, producer replies with a data packet, containing\n * 1024 bytes of virtual payload.\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     NS_LOG=ndn.Consumer:ndn.Producer ./waf --run=ndn-multiple-strategies\n */\n\nint\nmain(int argc, char* argv[])\n{\n  // Setting default parameters for PointToPoint links and channels\n  Config::SetDefault(\"ns3::PointToPointNetDevice::DataRate\", StringValue(\"1Mbps\"));\n  Config::SetDefault(\"ns3::PointToPointChannel::Delay\", StringValue(\"10ms\"));\n  Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\", StringValue(\"10p\"));\n\n  // Read optional command-line parameters (e.g., enable visualizer with ./waf --run=<> --visualize\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  // Creating 3x3 topology\n  PointToPointHelper p2p;\n  PointToPointGridHelper grid(3, 3, p2p);\n  grid.BoundingBox(100, 100, 200, 200);\n\n  // Install NDN stack on all nodes\n  StackHelper ndnHelper;\n  ndnHelper.InstallAll();\n\n  // Installing global routing interface on all nodes\n  GlobalRoutingHelper ndnGlobalRoutingHelper;\n  ndnGlobalRoutingHelper.InstallAll();\n\n  // Getting containers for the consumer/producer\n  Ptr<Node> producer = grid.GetNode(2, 2);\n  NodeContainer consumerNodes;\n  consumerNodes.Add(grid.GetNode(0, 0));\n\n  // Install NDN applications\n  std::string prefix = \"/prefix\";\n\n  // Install different forwarding strategies\n  for (int row = 0; row < 3; row++) {\n    for (int column = 0; column < 3; column++) {\n      if (row < 2)\n        StrategyChoiceHelper::Install(grid.GetNode(row, column), \"/prefix\",\n                                      \"/localhost/nfd/strategy/best-route\");\n      else\n        StrategyChoiceHelper::Install(grid.GetNode(row, column), \"/prefix\",\n                                      \"/localhost/nfd/strategy/multicast\");\n    }\n  }\n\n  AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n  consumerHelper.SetPrefix(prefix);\n  consumerHelper.SetAttribute(\"Frequency\", StringValue(\"100\")); // 100 interests a second\n  consumerHelper.Install(consumerNodes);\n\n  AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetPrefix(prefix);\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n  producerHelper.Install(producer);\n\n  // Add /prefix origins to ndn::GlobalRouter\n  ndnGlobalRoutingHelper.AddOrigins(prefix, producer);\n\n  // Calculate and install FIBs\n  GlobalRoutingHelper::CalculateRoutes();\n\n  Simulator::Stop(Seconds(20.0));\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/ndn-grid-topo-plugin-loss.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-grid-topo-plugin-loss.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nnamespace ns3 {\n\n/**\n * This scenario simulates a grid topology (using topology reader module)\n *\n * (consumer) -- ( ) ----- ( )\n *     |          |         |\n *    ( ) ------ ( ) ----- ( )\n *     |          |         |\n *    ( ) ------ ( ) -- (producer)\n *\n * All links are 1Mbps with propagation 10ms delay.\n *\n * FIB is populated using NdnGlobalRoutingHelper.\n *\n * Consumer requests data from producer with frequency 10 interests per second\n * (interests contain constantly increasing sequence number).\n *\n * For every received interest, producer replies with a data packet, containing\n * 1024 bytes of virtual payload.\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     NS_LOG=ndn.Consumer:ndn.Producer ./waf --run=ndn-grid-topo-plugin\n */\n\nint\nmain(int argc, char* argv[])\n{\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  AnnotatedTopologyReader topologyReader(\"\", 25);\n  topologyReader.SetFileName(\"src/ndnSIM/examples/topologies/topo-grid-3x3-loss.txt\");\n  topologyReader.Read();\n\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.InstallAll();\n\n  ndn::StrategyChoiceHelper::InstallAll(\"/\", \"ndn:/localhost/nfd/strategy/best-route\");\n\n  // Installing global routing interface on all nodes\n  ndn::GlobalRoutingHelper ndnGlobalRoutingHelper;\n  ndnGlobalRoutingHelper.InstallAll();\n\n  // Getting containers for the consumer/producer\n  Ptr<Node> producer = Names::Find<Node>(\"Node8\");\n  NodeContainer consumerNodes;\n  consumerNodes.Add(Names::Find<Node>(\"Node0\"));\n\n  // Install NDN applications\n  std::string prefix = \"/prefix\";\n\n  ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n  consumerHelper.SetPrefix(prefix);\n  consumerHelper.SetAttribute(\"Frequency\", StringValue(\"100\")); // 100 interests a second\n  consumerHelper.Install(consumerNodes);\n\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetPrefix(prefix);\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n  producerHelper.Install(producer);\n\n  // Add /prefix origins to ndn::GlobalRouter\n  ndnGlobalRoutingHelper.AddOrigins(prefix, producer);\n\n  // Calculate and install FIBs\n  ndn::GlobalRoutingHelper::CalculateRoutes();\n\n  Simulator::Stop(Seconds(20.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-grid-topo-plugin-red-queues.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-grid-topo-plugin-red-queues.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nnamespace ns3 {\n\n/**\n * This scenario simulates a grid topology (using topology reader module)\n *\n * (consumer) -- ( ) ----- ( )\n *     |          |         |\n *    ( ) ------ ( ) ----- ( )\n *     |          |         |\n *    ( ) ------ ( ) -- (producer)\n *\n * All links are 1Mbps with propagation 10ms delay.\n *\n * FIB is populated using ndn::GlobalRoutingHelper.\n *\n * Consumer requests data from producer with frequency 10 interests per second\n * (interests contain constantly increasing sequence number).\n *\n * For every received interest, producer replies with a data packet, containing\n * 1024 bytes of virtual payload.\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     NS_LOG=ndn.Consumer:ndn.Producer ./waf --run=ndn-grid-topo-plugin\n */\n\nint\nmain(int argc, char* argv[])\n{\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  AnnotatedTopologyReader topologyReader(\"\", 25);\n  topologyReader.SetFileName(\"src/ndnSIM/examples/topologies/topo-grid-3x3-red-queues.txt\");\n  topologyReader.Read();\n\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.InstallAll();\n\n  ndn::StrategyChoiceHelper::InstallAll(\"/\", \"ndn:/localhost/nfd/strategy/best-route\");\n\n  // Installing global routing interface on all nodes\n  ndn::GlobalRoutingHelper ndnGlobalRoutingHelper;\n  ndnGlobalRoutingHelper.InstallAll();\n\n  // Getting containers for the consumer/producer\n  Ptr<Node> producer = Names::Find<Node>(\"Node8\");\n  NodeContainer consumerNodes;\n  consumerNodes.Add(Names::Find<Node>(\"Node0\"));\n\n  // Install NDN applications\n  std::string prefix = \"/prefix\";\n\n  ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n  consumerHelper.SetPrefix(prefix);\n  consumerHelper.SetAttribute(\"Frequency\", StringValue(\"100\")); // 100 interests a second\n  consumerHelper.Install(consumerNodes);\n\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetPrefix(prefix);\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n  producerHelper.Install(producer);\n\n  // Add /prefix origins to ndn::GlobalRouter\n  ndnGlobalRoutingHelper.AddOrigins(prefix, producer);\n\n  // Calculate and install FIBs\n  ndn::GlobalRoutingHelper::CalculateRoutes();\n\n  Simulator::Stop(Seconds(20.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-grid-topo-plugin.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-grid-topo-plugin.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nnamespace ns3 {\n\n/**\n * This scenario simulates a grid topology (using topology reader module)\n *\n * (consumer) -- ( ) ----- ( )\n *     |          |         |\n *    ( ) ------ ( ) ----- ( )\n *     |          |         |\n *    ( ) ------ ( ) -- (producer)\n *\n * All links are 1Mbps with propagation 10ms delay.\n *\n * FIB is populated using NdnGlobalRoutingHelper.\n *\n * Consumer requests data from producer with frequency 10 interests per second\n * (interests contain constantly increasing sequence number).\n *\n * For every received interest, producer replies with a data packet, containing\n * 1024 bytes of virtual payload.\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     NS_LOG=ndn.Consumer:ndn.Producer ./waf --run=ndn-grid-topo-plugin\n */\n\nint\nmain(int argc, char* argv[])\n{\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  AnnotatedTopologyReader topologyReader(\"\", 25);\n  topologyReader.SetFileName(\"src/ndnSIM/examples/topologies/topo-grid-3x3.txt\");\n  topologyReader.Read();\n\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.InstallAll();\n\n  // Set BestRoute strategy\n  ndn::StrategyChoiceHelper::InstallAll(\"/\", \"/localhost/nfd/strategy/best-route\");\n\n  // Installing global routing interface on all nodes\n  ndn::GlobalRoutingHelper ndnGlobalRoutingHelper;\n  ndnGlobalRoutingHelper.InstallAll();\n\n  // Getting containers for the consumer/producer\n  Ptr<Node> producer = Names::Find<Node>(\"Node8\");\n  NodeContainer consumerNodes;\n  consumerNodes.Add(Names::Find<Node>(\"Node0\"));\n\n  // Install NDN applications\n  std::string prefix = \"/prefix\";\n\n  ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n  consumerHelper.SetPrefix(prefix);\n  consumerHelper.SetAttribute(\"Frequency\", StringValue(\"100\")); // 100 interests a second\n  consumerHelper.Install(consumerNodes);\n\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetPrefix(prefix);\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n  producerHelper.Install(producer);\n\n  // Add /prefix origins to ndn::GlobalRouter\n  ndnGlobalRoutingHelper.AddOrigins(prefix, producer);\n\n  // Calculate and install FIBs\n  ndn::GlobalRoutingHelper::CalculateRoutes();\n\n  Simulator::Stop(Seconds(20.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-grid.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-grid.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/point-to-point-layout-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nnamespace ns3 {\n\n/**\n * This scenario simulates a grid topology (using PointToPointGrid module)\n *\n * (consumer) -- ( ) ----- ( )\n *     |          |         |\n *    ( ) ------ ( ) ----- ( )\n *     |          |         |\n *    ( ) ------ ( ) -- (producer)\n *\n * All links are 1Mbps with propagation 10ms delay.\n *\n * FIB is populated using NdnGlobalRoutingHelper.\n *\n * Consumer requests data from producer with frequency 100 interests per second\n * (interests contain constantly increasing sequence number).\n *\n * For every received interest, producer replies with a data packet, containing\n * 1024 bytes of virtual payload.\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     NS_LOG=ndn.Consumer:ndn.Producer ./waf --run=ndn-grid\n */\n\nint\nmain(int argc, char* argv[])\n{\n  // Setting default parameters for PointToPoint links and channels\n  Config::SetDefault(\"ns3::PointToPointNetDevice::DataRate\", StringValue(\"1Mbps\"));\n  Config::SetDefault(\"ns3::PointToPointChannel::Delay\", StringValue(\"10ms\"));\n  Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\", StringValue(\"10p\"));\n\n  // Read optional command-line parameters (e.g., enable visualizer with ./waf --run=<> --visualize\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  // Creating 3x3 topology\n  PointToPointHelper p2p;\n  PointToPointGridHelper grid(3, 3, p2p);\n  grid.BoundingBox(100, 100, 200, 200);\n\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.InstallAll();\n\n  // Set BestRoute strategy\n  ndn::StrategyChoiceHelper::InstallAll(\"/\", \"/localhost/nfd/strategy/best-route\");\n\n  // Installing global routing interface on all nodes\n  ndn::GlobalRoutingHelper ndnGlobalRoutingHelper;\n  ndnGlobalRoutingHelper.InstallAll();\n\n  // Getting containers for the consumer/producer\n  Ptr<Node> producer = grid.GetNode(2, 2);\n  NodeContainer consumerNodes;\n  consumerNodes.Add(grid.GetNode(0, 0));\n\n  // Install NDN applications\n  std::string prefix = \"/prefix\";\n\n  ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n  consumerHelper.SetPrefix(prefix);\n  consumerHelper.SetAttribute(\"Frequency\", StringValue(\"100\")); // 100 interests a second\n  consumerHelper.Install(consumerNodes);\n\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetPrefix(prefix);\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n  producerHelper.Install(producer);\n\n  // Add /prefix origins to ndn::GlobalRouter\n  ndnGlobalRoutingHelper.AddOrigins(prefix, producer);\n\n  // Calculate and install FIBs\n  ndn::GlobalRoutingHelper::CalculateRoutes();\n\n  Simulator::Stop(Seconds(20.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-grid.py",
      "code": "## -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-\n#\n# Copyright (c) 2011-2015  Regents of the University of California.\n#\n# This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n# contributors.\n#\n# ndnSIM is free software: you can redistribute it and/or modify it under the terms\n# of the GNU General Public License as published by the Free Software Foundation,\n# either version 3 of the License, or (at your option) any later version.\n#\n# ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License along with\n# ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n#\n\n# ndn-grid.py\n\nfrom ns.core import *\nfrom ns.network import *\nfrom ns.point_to_point import *\nfrom ns.point_to_point_layout import *\nfrom ns.ndnSIM import *\n\n#\n# This scenario simulates a grid topology (using PointToPointGrid module)\n#\n# (consumer) -- ( ) ----- ( )\n#     |          |         |\n#    ( ) ------ ( ) ----- ( )\n#     |          |         |\n#    ( ) ------ ( ) -- (producer)\n#\n# All links are 1Mbps with propagation 10ms delay.\n#\n# FIB is populated using NdnGlobalRoutingHelper.\n#\n# Consumer requests data from producer with frequency 100 interests per second\n# (interests contain constantly increasing sequence number).\n#\n# For every received interest, producer replies with a data packet, containing\n# 1024 bytes of virtual payload.\n#\n# To run scenario and see what is happening, use the following command:\n#\n#     NS_LOG=ndn.Consumer:ndn.Producer ./waf --pyrun=src/ndnSIM/examples/ndn-grid.py\n#\n\nConfig.SetDefault(\"ns3::PointToPointNetDevice::DataRate\", StringValue(\"10Mbps\"))\nConfig.SetDefault(\"ns3::PointToPointChannel::Delay\", StringValue(\"10ms\"))\nConfig::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\", StringValue(\"20p\"))\n\nimport sys; cmd = CommandLine(); cmd.Parse(sys.argv);\n\np2p = PointToPointHelper ()\ngrid = PointToPointGridHelper (3,3,p2p)\ngrid.BoundingBox(100,100,200,200)\n\n#######################################################\n\nndnHelper = ndn.StackHelper()\nndnHelper.InstallAll();\n\n\n# Getting containers for the consumer/producer\nproducer = grid.GetNode(2, 2)\nconsumerNodes = NodeContainer()\nconsumerNodes.Add(grid.GetNode(0,0))\n\n\ncHelper = ndn.AppHelper(\"ns3::ndn::ConsumerCbr\")\ncHelper.SetPrefix(\"/prefix\")\ncHelper.SetAttribute(\"Frequency\", StringValue(\"10\"))\nout = cHelper.Install(consumerNodes)\n\npHelper = ndn.AppHelper(\"ns3::ndn::Producer\")\npHelper.SetPrefix(\"/prefix\")\npHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\npHelper.Install(producer)\n\nndnGlobalRoutingHelper = ndn.GlobalRoutingHelper()\nndnGlobalRoutingHelper.InstallAll()\n\n# Add /prefix origins to ndn::GlobalRouter\nndnGlobalRoutingHelper.AddOrigin(\"/prefix\", producer)\n\n# Calculate and install FIBs\nndnGlobalRoutingHelper.CalculateRoutes()\n\n\n# #######################################################\n\nSimulator.Stop(Seconds(20.0))\nSimulator.Run()\n\n# # To access FIB, PIT, CS, uncomment the following lines\n\n# l3Protocol = ndn.L3Protocol.getL3Protocol(grid.GetNode(0,0))\n# forwarder = l3Protocol.getForwarder()\n\n# fib = forwarder.getFib()\n# print \"Contents of FIB (%d):\" % fib.size()\n# for i in fib:\n#     print \" - %s:\" % i.getPrefix()\n#     for nh in i.getNextHops():\n#         print \"    - %s%d (cost: %d)\" % (nh.getFace(), nh.getFace().getId(), nh.getCost())\n\n# pit = forwarder.getPit()\n# print \"Contents of PIT (%d):\" % pit.size()\n# for i in pit:\n#     print \" - %s\" % i.getName()\n\n# cs = forwarder.getCs()\n# print \"Contents of CS (%d):\" % cs.size()\n# for i in cs:\n#     print \" - %s\" % i.getName()\n\nSimulator.Destroy()\n\n# # or run using the visualizer\n# import visualizer\n# visualizer.start()\n"
    },
    {
      "file_path": "examples/ndn-load-balancer.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-load-balancer.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\n#include \"ndn-load-balancer/random-load-balancer-strategy.hpp\"\n\nusing namespace ns3;\n\n/**\n * This scenario simulates a load balancer topology (using topology reader module)\n *\n *               ( ) ----- ( ) ---- (consumer)\n *                |\n *        ------ ( ) -----\n *        |               |\n *    (producer) ---- (producer)\n *\n * All links are 1Mbps with propagation 10ms delay.\n *\n * FIB is populated using NdnGlobalRoutingHelper.\n *\n * Consumer requests data from the two producers with frequency 10 interests per\n * second (interests contain constantly increasing sequence number).\n *\n * For every received interest, a load balancing operation is performed\n * (based on a custom forwarding strategy) and the selected producer\n * replies with a data packet, containing 1024 bytes of virtual payload.\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     NS_LOG=ndn.Consumer:ndn.Producer ./waf --run=ndn-load-balancer\n */\n\nusing ns3::ndn::StackHelper;\nusing ns3::ndn::AppHelper;\nusing ns3::ndn::GlobalRoutingHelper;\nusing ns3::ndn::StrategyChoiceHelper;\nusing ns3::AnnotatedTopologyReader;\n\nint\nmain(int argc, char* argv[])\n{\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  AnnotatedTopologyReader topologyReader(\"\", 25);\n  topologyReader.SetFileName(\"src/ndnSIM/examples/topologies/topo-load-balancer.txt\");\n  topologyReader.Read();\n\n  // Install NDN stack on all nodes\n  StackHelper ndnHelper;\n  ndnHelper.InstallAll();\n\n  // Installing global routing interface on all nodes\n  GlobalRoutingHelper ndnGlobalRoutingHelper;\n  ndnGlobalRoutingHelper.InstallAll();\n\n  // Getting containers for the consumer/producer\n  Ptr<Node> producer1 = Names::Find<Node>(\"UCLA-1\");\n  Ptr<Node> producer2 = Names::Find<Node>(\"UCLA-2\");\n  NodeContainer consumerNodes;\n  consumerNodes.Add(Names::Find<Node>(\"CSU-1\"));\n\n  // Install NDN applications\n  std::string prefix = \"/ucla/hello\";\n\n  // Install random-load-balancer forwarding strategy in\n  // node UCLA-HUB\n  StrategyChoiceHelper::Install<nfd::fw::RandomLoadBalancerStrategy>(Names::Find<Node>(\"UCLA-HUB\"),\n                                                                     prefix);\n\n  AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n  consumerHelper.SetPrefix(prefix);\n  consumerHelper.SetAttribute(\"Frequency\", StringValue(\"100\")); // 100 interests a second\n  consumerHelper.Install(consumerNodes);\n\n  AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetPrefix(prefix);\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n  producerHelper.Install(producer1);\n  producerHelper.Install(producer2);\n\n  // Add /prefix origins to ndn::GlobalRouter\n  ndnGlobalRoutingHelper.AddOrigins(prefix, producer1);\n  ndnGlobalRoutingHelper.AddOrigins(prefix, producer2);\n\n  // Calculate and install FIBs\n  GlobalRoutingHelper::CalculateRoutes();\n\n  Simulator::Stop(Seconds(1.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/ndn-simple-for-nrt-helper.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2016  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\n/**\n * This scenario simulates a very simple network topology:\n *\n *\n *\n *                             ----------------------------- (Producer)\n *                            /                                   |\n *                           /                                    |\n *    (Consumer) ------ (Non-Producer-Region Router) ----- (Produer-Region-Network Router)\n *                                                                |\n *                                                                |\n *                                                               ( )\n *\n *\n *\n *\n * Consumer sends interest with Link object attatched. Non-Producer-Region Router will\n * forward the interest based on Forwarding Hint(dalegationName in Link object) toward\n * delegationName direction because the router is not in\n * ProducerRegion. Producer-Region-Network checks incomming interests and finds out the\n * interest has reached ProducerRegion, thus the router will forward the incoming interest\n * based on interestName.\n *\n * For every received interest, producer replies with a data packet, containing 1024 bytes\n * of virtual payload.\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     NS_LOG=nfd.Forwarder=logic ./waf --run=ndn-simple-for-nrt-helper\n */\n\nnamespace ns3 {\n\nint\nmain(int argc, char* argv[])\n{\n  // setting default parameters for PointToPoint links and channels\n  Config::SetDefault(\"ns3::PointToPointNetDevice::DataRate\", StringValue(\"1Mbps\"));\n  Config::SetDefault(\"ns3::PointToPointChannel::Delay\", StringValue(\"10ms\"));\n  Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\", StringValue(\"20p\"));\n\n  // Read optional command-line parameters (e.g., enable visualizer with ./waf --run=<> --visualize\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  // Creating nodes\n  Ptr<Node> consumer = CreateObject<Node>();\n  Ptr<Node> intRouter = CreateObject<Node>();\n  NodeContainer uclaRegion;\n  uclaRegion.Create(3);\n\n  // Connecting nodes using two links\n  PointToPointHelper p2p;\n  p2p.Install(consumer, intRouter);\n  p2p.Install(intRouter, uclaRegion.Get(0));\n  p2p.Install(intRouter, uclaRegion.Get(1));\n  p2p.Install(uclaRegion.Get(0), uclaRegion.Get(1));\n  p2p.Install(uclaRegion.Get(1), uclaRegion.Get(2));\n\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.SetDefaultRoutes(true);\n  ndnHelper.InstallAll();\n\n  // Install Routes Manually\n  ndn::FibHelper::AddRoute(intRouter, ndn::Name(\"/ucla\"), uclaRegion.Get(1), 1);\n\n  // Configure NetworkRegionTable\n  ndn::NetworkRegionTableHelper::AddRegionName(uclaRegion, ndn::Name(\"/ucla\"));\n\n  // Installing applications\n\n  // Consumer\n  ndn::AppHelper requesterHelper(\"RequesterApp\");\n  requesterHelper.SetAttribute(\"Name\", StringValue(\"/ndnSIM/someData\"));\n  requesterHelper.SetAttribute(\"Delegation\", StringValue(\"/ucla1\"));\n  requesterHelper.Install(consumer).Start(Seconds(1));\n\n  requesterHelper.SetAttribute(\"Name\", StringValue(\"/ndnSIM/anotherData\"));\n  requesterHelper.Install(consumer).Start(Seconds(2));\n\n  requesterHelper.SetAttribute(\"Name\", StringValue(\"/ndnSIM/yetAnotherData\"));\n  requesterHelper.SetAttribute(\"Delegation\", StringValue(\"/non-existing\"));\n  requesterHelper.Install(consumer).Start(Seconds(3));\n\n  // Producer\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetPrefix(\"/ndnSIM\");\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n  producerHelper.Install(uclaRegion.Get(0));\n\n  Simulator::Stop(Seconds(20.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-simple-mpi.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-simple-mpi.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n#include \"ns3/mpi-interface.h\"\n\n#ifdef NS3_MPI\n#include <mpi.h>\n#else\n#error \"ndn-simple-mpi scenario can be compiled only if NS3_MPI is enabled\"\n#endif\n\nnamespace ns3 {\n\n/**\n * This scenario simulates a very simple network topology using mpi:\n *\n *\n *      +----------+     1 Mbps     +----------+\n *      | consumer | <------------> | producer |\n *      +----------+      10ms      +----------+\n *\n *\n * Consumer requests data from producer with frequency 10 interests per second\n * (interests contain constantly increasing sequence number).\n *\n * For every received interest, producer replies with a data packet, containing\n * 1024 bytes of virtual payload.\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     NS_LOG=ndn.Consumer:ndn.Producer mpirun -np 2 ./waf --run=ndn-simple-mpi\n *\n * The default parallel synchronization strategy implemented in the\n * DistributedSimulatorImpl class is based on a globally synchronized algorithm\n * using an MPI collective operation to synchronize simulation time across all LPs.\n * A second synchronization strategy based on local communication and null messages\n * is implemented in the NullMessageSimulatorImpl class, For the null message strategy\n * the global all to all gather is not required; LPs only need to communication with\n * LPs that have shared point-to-point links. The algorithm to use is controlled by\n * which the ns-3 global value SimulatorImplementationType.\n *\n * The strategy can be selected according to the value of nullmsg. If nullmsg is true,\n * then the local communication strategy is selected. If nullmsg is false, then the\n * globally synchronized strategy is selected. This parameter can be passed either\n * as a command line argument or by directly modifying the simulation scenario.\n *\n */\n\nint\nmain(int argc, char* argv[])\n{\n  // setting default parameters for PointToPoint links and channels\n  Config::SetDefault(\"ns3::PointToPointNetDevice::DataRate\", StringValue(\"1Gbps\"));\n  Config::SetDefault(\"ns3::PointToPointChannel::Delay\", StringValue(\"1ms\"));\n  Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\", StringValue(\"10p\"));\n\n  bool nullmsg = false;\n\n  // Read optional command-line parameters (e.g., enable visualizer with ./waf --run=<> --visualize\n  CommandLine cmd;\n  cmd.AddValue(\"nullmsg\", \"Enable the use of null-message synchronization\", nullmsg);\n  cmd.Parse(argc, argv);\n\n  // Distributed simulation setup; by default use granted time window algorithm.\n  if (nullmsg) {\n    GlobalValue::Bind(\"SimulatorImplementationType\",\n                      StringValue(\"ns3::NullMessageSimulatorImpl\"));\n  }\n  else {\n    GlobalValue::Bind(\"SimulatorImplementationType\",\n                      StringValue(\"ns3::DistributedSimulatorImpl\"));\n  }\n\n  // Enable parallel simulator with the command line arguments\n  MpiInterface::Enable(&argc, &argv);\n\n  uint32_t systemId = MpiInterface::GetSystemId();\n  uint32_t systemCount = MpiInterface::GetSize();\n\n  if (systemCount != 2)  {\n    std::cout << \"Simulation will run on a single processor only\" << std::endl\n              << \"To run using MPI, run\" << std::endl\n              << \"  mpirun -np 2 ./waf --run=ndn-simple-mpi\" << std::endl;\n  }\n\n  // Creating nodes\n\n  // consumer node is associated with system id 0\n  Ptr<Node> node1 = CreateObject<Node>(0);\n\n  // producer node is associated with system id 1 (or 0 when running on single CPU)\n  Ptr<Node> node2 = CreateObject<Node>(systemCount == 2 ? 1 : 0);\n\n  // Connecting nodes using a link\n  PointToPointHelper p2p;\n  p2p.Install(node1, node2);\n\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.InstallAll();\n\n  ndn::FibHelper::AddRoute(node1, \"/prefix/1\", node2, 1);\n  ndn::FibHelper::AddRoute(node2, \"/prefix/2\", node1, 1);\n\n  // Installing applications\n  ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n  consumerHelper.SetAttribute(\"Frequency\", StringValue(\"100\")); // 10 interests a second\n\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n\n  // Run consumer application on the first processor only (if running on 2 CPUs)\n  if (systemCount != 2 || systemId == 0) {\n    consumerHelper.SetPrefix(\"/prefix/1\"); // request /prefix/1/*\n    consumerHelper.Install(node1);\n\n    producerHelper.SetPrefix(\"/prefix/2\"); // serve /prefix/2/*\n    producerHelper.Install(node1);\n\n    ndn::L3RateTracer::Install(node1, \"node1.txt\", Seconds(0.5));\n  }\n\n  // Run consumer application on the second processor only (if running on 2 CPUs)\n  if (systemCount != 2 || systemId == 1) {\n    // Producer\n    consumerHelper.SetPrefix(\"/prefix/2\"); // request /prefix/2/*\n    consumerHelper.Install(node2);\n\n    producerHelper.SetPrefix(\"/prefix/1\"); // serve /prefix/1/*\n    producerHelper.Install(node2);\n\n    ndn::L3RateTracer::Install(node2, \"node2.txt\", Seconds(0.5));\n  }\n\n  Simulator::Stop(Seconds(400.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  MpiInterface::Disable();\n  return 0;\n}\n\n} // namespace ns3\n\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-simple-wifi.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include \"ns3/ndnSIM-module.h\"\n\nusing namespace std;\nnamespace ns3 {\n\nNS_LOG_COMPONENT_DEFINE(\"ndn.WifiExample\");\n\n//\n// DISCLAIMER:  Note that this is an extremely simple example, containing just 2 wifi nodes\n// communicating directly over AdHoc channel.\n//\n\n// Ptr<ndn::NetDeviceFace>\n// MyNetDeviceFaceCallback (Ptr<Node> node, Ptr<ndn::L3Protocol> ndn, Ptr<NetDevice> device)\n// {\n//   // NS_LOG_DEBUG (\"Create custom network device \" << node->GetId ());\n//   Ptr<ndn::NetDeviceFace> face = CreateObject<ndn::MyNetDeviceFace> (node, device);\n//   ndn->AddFace (face);\n//   return face;\n// }\n\nint\nmain(int argc, char* argv[])\n{\n  // disable fragmentation\n  Config::SetDefault(\"ns3::WifiRemoteStationManager::FragmentationThreshold\", StringValue(\"2200\"));\n  Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"2200\"));\n  Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\",\n                     StringValue(\"OfdmRate24Mbps\"));\n\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  //////////////////////\n  //////////////////////\n  //////////////////////\n  WifiHelper wifi;\n  // wifi.SetRemoteStationManager (\"ns3::AarfWifiManager\");\n  wifi.SetStandard(WIFI_STANDARD_80211a);\n  wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\", \"DataMode\",\n                               StringValue(\"OfdmRate24Mbps\"));\n\n  YansWifiChannelHelper wifiChannel;\n  wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n  wifiChannel.AddPropagationLoss(\"ns3::ThreeLogDistancePropagationLossModel\");\n  wifiChannel.AddPropagationLoss(\"ns3::NakagamiPropagationLossModel\");\n\n  YansWifiPhyHelper wifiPhyHelper;\n  wifiPhyHelper.SetChannel(wifiChannel.Create());\n  wifiPhyHelper.Set(\"TxPowerStart\", DoubleValue(5));\n  wifiPhyHelper.Set(\"TxPowerEnd\", DoubleValue(5));\n\n  WifiMacHelper wifiMacHelper;\n  wifiMacHelper.SetType(\"ns3::AdhocWifiMac\");\n\n  Ptr<UniformRandomVariable> randomizer = CreateObject<UniformRandomVariable>();\n  randomizer->SetAttribute(\"Min\", DoubleValue(10));\n  randomizer->SetAttribute(\"Max\", DoubleValue(100));\n\n  MobilityHelper mobility;\n  mobility.SetPositionAllocator(\"ns3::RandomBoxPositionAllocator\", \"X\", PointerValue(randomizer),\n                                \"Y\", PointerValue(randomizer), \"Z\", PointerValue(randomizer));\n\n  mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n  NodeContainer nodes;\n  nodes.Create(2);\n\n  ////////////////\n  // 1. Install Wifi\n  NetDeviceContainer wifiNetDevices = wifi.Install(wifiPhyHelper, wifiMacHelper, nodes);\n\n  // 2. Install Mobility model\n  mobility.Install(nodes);\n\n  // 3. Install NDN stack\n  NS_LOG_INFO(\"Installing NDN stack\");\n  ndn::StackHelper ndnHelper;\n  // ndnHelper.AddNetDeviceFaceCreateCallback (WifiNetDevice::GetTypeId (), MakeCallback\n  // (MyNetDeviceFaceCallback));\n  ndnHelper.setPolicy(\"nfd::cs::lru\");\n  ndnHelper.setCsSize(1000);\n  ndnHelper.SetDefaultRoutes(true);\n  ndnHelper.Install(nodes);\n\n  // Set BestRoute strategy\n  ndn::StrategyChoiceHelper::Install(nodes, \"/\", \"/localhost/nfd/strategy/best-route\");\n\n  // 4. Set up applications\n  NS_LOG_INFO(\"Installing Applications\");\n\n  ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n  consumerHelper.SetPrefix(\"/test/prefix\");\n  consumerHelper.SetAttribute(\"Frequency\", DoubleValue(10.0));\n  consumerHelper.Install(nodes.Get(0));\n\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetPrefix(\"/\");\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1200\"));\n  producerHelper.Install(nodes.Get(1));\n\n  ////////////////\n\n  Simulator::Stop(Seconds(30.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-simple-with-content-freshness.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-simple-with-content-freshness.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nnamespace ns3 {\n\n/**\n * This scenario simulates a very simple network topology:\n *\n *\n *      +----------+     1Mbps      +--------+     1Mbps      +----------+\n *      | consumer | <------------> | router | <------------> | producer |\n *      +----------+         10ms   +--------+          10ms  +----------+\n *\n * This scenario demonstrates how to use content store that responds to Freshness parameter set in\n * data packets.  In other words, if the producer set FreshnessPeriod field to 2 seconds, the\n * corresponding data packet will not be considered fresh for more than 2 seconds (can be cached\n * for a shorter time, if entry is evicted earlier)\n *\n *     NS_LOG=OneInterestRequester ./waf --run ndn-simple-with-content-freshness\n */\n\nint\nmain(int argc, char* argv[])\n{\n  // setting default parameters for PointToPoint links and channels\n  Config::SetDefault(\"ns3::PointToPointNetDevice::DataRate\", StringValue(\"1Mbps\"));\n  Config::SetDefault(\"ns3::PointToPointChannel::Delay\", StringValue(\"10ms\"));\n  Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\", StringValue(\"20p\"));\n\n  // Read optional command-line parameters (e.g., enable visualizer with ./waf --run=<> --visualize\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  // Creating nodes\n  NodeContainer nodes;\n  nodes.Create(3);\n\n  // Connecting nodes using two links\n  PointToPointHelper p2p;\n  p2p.Install(nodes.Get(0), nodes.Get(1));\n  p2p.Install(nodes.Get(1), nodes.Get(2));\n\n  // Install Ndn stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.SetDefaultRoutes(true);\n  ndnHelper.setCsSize(2); // allow just 2 entries to be cached\n  ndnHelper.setPolicy(\"nfd::cs::lru\");\n  ndnHelper.InstallAll();\n\n  // Installing applications\n\n  // Consumer\n  ndn::AppHelper consumerHelper(\"OneInterestRequester\");\n\n  // /*\n  //   1) at time 1 second requests Data from a producer that does not specify freshness\n  //   2) at time 10 seconds requests the same Data packet as client 1\n\n  //   3) at time 2 seconds requests Data from a producer that specifies freshness set to 2 seconds\n  //   4) at time 12 seconds requests the same Data packet as client 3\n\n  //   Expectation:\n  //   Interests from 1, 3 and 4 will reach producers\n  //   Interset from 2 will be served from cache\n  //  */\n\n  consumerHelper.SetPrefix(\"/no-freshness\");\n  consumerHelper.Install(nodes.Get(0)).Start(Seconds(1));\n  consumerHelper.Install(nodes.Get(0)).Start(Seconds(10));\n\n  consumerHelper.SetPrefix(\"/with-freshness\");\n  consumerHelper.Install(nodes.Get(0)).Start(Seconds(2));\n  consumerHelper.Install(nodes.Get(0)).Start(Seconds(12));\n\n  // Producer\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n\n  producerHelper.SetAttribute(\"Freshness\", TimeValue(Years(100))); // freshness long enough\n  producerHelper.SetPrefix(\"/no-freshness\");\n  producerHelper.Install(nodes.Get(2)); // last node\n\n  producerHelper.SetAttribute(\"Freshness\", TimeValue(Seconds(2.0))); // freshness 2 seconds (!!!\n                                                                     // freshness granularity is 1\n                                                                     // seconds !!!)\n  producerHelper.SetPrefix(\"/with-freshness\");\n  producerHelper.Install(nodes.Get(2)); // last node\n\n  Simulator::Stop(Seconds(30.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-simple-with-link-failure.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-simple-with-link-failure.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\n// for LinkStatusControl::FailLinks and LinkStatusControl::UpLinks\n#include \"ns3/ndnSIM/helper/ndn-link-control-helper.hpp\"\n\nnamespace ns3 {\n\n/**\n * This scenario simulates a very simple network topology:\n *\n *\n *      +----------+     1Mbps      +--------+     1Mbps      +----------+\n *      | consumer | <------------> | router | <------------> | producer |\n *      +----------+         10ms   +--------+          10ms  +----------+\n *\n *\n * Consumer requests data from producer with frequency 10 interests per second\n * (interests contain constantly increasing sequence number).\n *\n * For every received interest, producer replies with a data packet, containing\n * 1024 bytes of virtual payload.\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     NS_LOG=ndn.Consumer:ndn.Producer ./waf --run=ndn-simple-with-link-failure\n */\n\nint\nmain(int argc, char* argv[])\n{\n  // setting default parameters for PointToPoint links and channels\n  Config::SetDefault(\"ns3::PointToPointNetDevice::DataRate\", StringValue(\"1Mbps\"));\n  Config::SetDefault(\"ns3::PointToPointChannel::Delay\", StringValue(\"10ms\"));\n  Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\", StringValue(\"20p\"));\n\n  // Read optional command-line parameters (e.g., enable visualizer with ./waf --run=<> --visualize\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  // Creating nodes\n  NodeContainer nodes;\n  nodes.Create(3);\n\n  // Connecting nodes using two links\n  PointToPointHelper p2p;\n  p2p.Install(nodes.Get(0), nodes.Get(1));\n  p2p.Install(nodes.Get(1), nodes.Get(2));\n\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.SetDefaultRoutes(true);\n  ndnHelper.InstallAll();\n\n  // Installing applications\n\n  // Consumer\n  ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n  // Consumer will request /prefix/0, /prefix/1, ...\n  consumerHelper.SetPrefix(\"/prefix\");\n  consumerHelper.SetAttribute(\"Frequency\", StringValue(\"10\")); // 10 interests a second\n  consumerHelper.Install(nodes.Get(0));                        // first node\n\n  // Producer\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  // Producer will reply to all requests starting with /prefix\n  producerHelper.SetPrefix(\"/prefix\");\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n  producerHelper.Install(nodes.Get(2)); // last node\n\n  // The failure of the link connecting consumer and router will start from seconds 10.0 to 15.0\n  Simulator::Schedule(Seconds(10.0), ndn::LinkControlHelper::FailLink, nodes.Get(0), nodes.Get(1));\n  Simulator::Schedule(Seconds(15.0), ndn::LinkControlHelper::UpLink, nodes.Get(0), nodes.Get(1));\n\n  Simulator::Stop(Seconds(20.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-simple-with-pcap.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-simple-with-pcap.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\n/**\n * This scenario demonstrates how to dump raw NDN packets into tcpdump-format\n *\n * Run scenario:\n *\n *     ./waf --run ndn-simple-with-pcap\n *\n * After simulation finishes, it produces `ndn-simple-trace.pcap` that can be read\n * using tcpdump or ndndump tools:\n *\n *    ndndump -r ndn-simple-trace.pcap not ip\n *    tcpdump -r ndn-simple-trace.pcap\n */\n\nnamespace ns3 {\n\nclass PcapWriter {\npublic:\n  PcapWriter(const std::string& file)\n  {\n    PcapHelper helper;\n    m_pcap = helper.CreateFile(file, std::ios::out, PcapHelper::DLT_PPP);\n  }\n\n  void\n  TracePacket(Ptr<const Packet> packet)\n  {\n    static PppHeader pppHeader;\n    pppHeader.SetProtocol(0x0077);\n\n    m_pcap->Write(Simulator::Now(), pppHeader, packet);\n  }\n\nprivate:\n  Ptr<PcapFileWrapper> m_pcap;\n};\n\nint\nmain(int argc, char* argv[])\n{\n  // setting default parameters for PointToPoint links and channels\n  Config::SetDefault(\"ns3::PointToPointNetDevice::DataRate\", StringValue(\"1Mbps\"));\n  Config::SetDefault(\"ns3::PointToPointChannel::Delay\", StringValue(\"10ms\"));\n  Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\", StringValue(\"20p\"));\n\n  // Read optional command-line parameters (e.g., enable visualizer with ./waf --run=<> --visualize\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  // Creating nodes\n  NodeContainer nodes;\n  nodes.Create(3);\n\n  // Connecting nodes using two links\n  PointToPointHelper p2p;\n  p2p.Install(nodes.Get(0), nodes.Get(1));\n  p2p.Install(nodes.Get(1), nodes.Get(2));\n\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.SetDefaultRoutes(true);\n  ndnHelper.InstallAll();\n\n  // Installing applications\n\n  // Consumer\n  ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n  // Consumer will request /prefix/0, /prefix/1, ...\n  consumerHelper.SetPrefix(\"/prefix\");\n  consumerHelper.SetAttribute(\"Frequency\", StringValue(\"10\")); // 10 interests a second\n  consumerHelper.Install(nodes.Get(0));                        // first node\n\n  // Producer\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  // Producer will reply to all requests starting with /prefix\n  producerHelper.SetPrefix(\"/prefix\");\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n  producerHelper.SetAttribute(\"Signature\", UintegerValue(100));\n  producerHelper.SetAttribute(\"KeyLocator\", StringValue(\"/unique/key/locator\"));\n  producerHelper.Install(nodes.Get(2)); // last node\n\n  PcapWriter trace(\"ndn-simple-trace.pcap\");\n  Config::ConnectWithoutContext(\"/NodeList/*/DeviceList/*/$ns3::PointToPointNetDevice/MacTx\",\n                                MakeCallback(&PcapWriter::TracePacket, &trace));\n\n  Simulator::Stop(Seconds(20.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-simple.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-simple.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nnamespace ns3 {\n\n/**\n * This scenario simulates a very simple network topology:\n *\n *\n *      +----------+     1Mbps      +--------+     1Mbps      +----------+\n *      | consumer | <------------> | router | <------------> | producer |\n *      +----------+         10ms   +--------+          10ms  +----------+\n *\n *\n * Consumer requests data from producer with frequency 10 interests per second\n * (interests contain constantly increasing sequence number).\n *\n * For every received interest, producer replies with a data packet, containing\n * 1024 bytes of virtual payload.\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     NS_LOG=ndn.Consumer:ndn.Producer ./waf --run=ndn-simple\n */\n\nint\nmain(int argc, char* argv[])\n{\n  // setting default parameters for PointToPoint links and channels\n  Config::SetDefault(\"ns3::PointToPointNetDevice::DataRate\", StringValue(\"1Mbps\"));\n  Config::SetDefault(\"ns3::PointToPointChannel::Delay\", StringValue(\"10ms\"));\n  Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\", StringValue(\"20p\"));\n\n  // Read optional command-line parameters (e.g., enable visualizer with ./waf --run=<> --visualize\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  // Creating nodes\n  NodeContainer nodes;\n  nodes.Create(3);\n\n  // Connecting nodes using two links\n  PointToPointHelper p2p;\n  p2p.Install(nodes.Get(0), nodes.Get(1));\n  p2p.Install(nodes.Get(1), nodes.Get(2));\n\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.SetDefaultRoutes(true);\n  ndnHelper.InstallAll();\n\n  // Choosing forwarding strategy\n  ndn::StrategyChoiceHelper::InstallAll(\"/prefix\", \"/localhost/nfd/strategy/multicast\");\n\n  // Installing applications\n\n  // Consumer\n  ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n  // Consumer will request /prefix/0, /prefix/1, ...\n  consumerHelper.SetPrefix(\"/prefix\");\n  consumerHelper.SetAttribute(\"Frequency\", StringValue(\"10\")); // 10 interests a second\n  auto apps = consumerHelper.Install(nodes.Get(0));                        // first node\n  apps.Stop(Seconds(10.0)); // stop the consumer app at 10 seconds mark\n\n  // Producer\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  // Producer will reply to all requests starting with /prefix\n  producerHelper.SetPrefix(\"/prefix\");\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n  producerHelper.Install(nodes.Get(2)); // last node\n\n  Simulator::Stop(Seconds(20.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-simple.py",
      "code": "## -*- Mode: python; py-indent-offset: 4; indent-tabs-mode: nil; coding: utf-8; -*-\n#\n# Copyright (c) 2011-2015  Regents of the University of California.\n#\n# This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n# contributors.\n#\n# ndnSIM is free software: you can redistribute it and/or modify it under the terms\n# of the GNU General Public License as published by the Free Software Foundation,\n# either version 3 of the License, or (at your option) any later version.\n#\n# ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License along with\n# ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n#\n\n# ndn-simple.py\n\nfrom ns.core import *\nfrom ns.network import *\nfrom ns.point_to_point import *\nfrom ns.ndnSIM import *\n\n#\n# This scenario simulates a very simple network topology:\n#\n#\n#      +----------+     1Mbps      +--------+     1Mbps      +----------+\n#      | consumer | <------------> | router | <------------> | producer |\n#      +----------+         10ms   +--------+          10ms  +----------+\n#\n#\n# Consumer requests data from producer with frequency 10 interests per second\n# (interests contain constantly increasing sequence number).\n#\n# For every received interest, producer replies with a data packet, containing\n# 1024 bytes of virtual payload.\n#\n# To run scenario and see what is happening, use the following command:\n#\n#     NS_LOG=ndn.Consumer:ndn.Producer ./waf --pyrun=src/ndnSIM/examples/ndn-simple.py\n#\n\n# Set default parameters for PointToPoint links and channels\nConfig.SetDefault(\"ns3::PointToPointNetDevice::DataRate\", StringValue(\"10Mbps\"))\nConfig.SetDefault(\"ns3::PointToPointChannel::Delay\", StringValue(\"10ms\"))\nConfig.SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\", StringValue(\"20p\"))\n\n# Read optional command-line parameters (e.g., enable visualizer with ./waf --pyrun=<> --visualize\nimport sys; cmd = CommandLine(); cmd.Parse(sys.argv);\n\n# Creating nodes\nnodes = NodeContainer()\nnodes.Create(3)\n\n# Connecting nodes using two links\np2p = PointToPointHelper()\np2p.Install(nodes.Get(0), nodes.Get(1))\np2p.Install(nodes.Get(1), nodes.Get(2))\n\n# Install NDN stack on all nodes\nndnHelper = ndn.StackHelper()\nndnHelper.SetDefaultRoutes(True)\nndnHelper.InstallAll()\n\n# Choosing forwarding strategy\nndn.StrategyChoiceHelper.InstallAll(\"/prefix\", \"/localhost/nfd/strategy/multicast\")\n\n# Installing applications\n\n# Consumer\nconsumerHelper = ndn.AppHelper(\"ns3::ndn::ConsumerCbr\")\n# Consumer will request /prefix/0, /prefix/1, ...\nconsumerHelper.SetPrefix(\"/prefix\")\nconsumerHelper.SetAttribute(\"Frequency\", StringValue(\"10\")) # 10 interests a second\nconsumerHelper.Install(nodes.Get(0))                        # first node\n\n# Producer\nproducerHelper = ndn.AppHelper(\"ns3::ndn::Producer\")\n# Producer will reply to all requests starting with /prefix\nproducerHelper.SetPrefix(\"/prefix\")\nproducerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"))\nproducerHelper.Install(nodes.Get(2)) # last node\n\nSimulator.Stop(Seconds(20.0))\n\nSimulator.Run()\nSimulator.Destroy()\n"
    },
    {
      "file_path": "examples/ndn-tree-app-delay-tracer.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-tree-app-delay-tracer.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nnamespace ns3 {\n\n/**\n * This scenario simulates a tree topology (using topology reader module)\n *\n *    /------\\      /------\\      /------\\      /------\\\n *    |leaf-1|      |leaf-2|      |leaf-3|      |leaf-4|\n *    \\------/      \\------/      \\------/      \\------/\n *         ^          ^                ^           ^\n *         |          |                |           |\n *          \\        /                  \\         /\n *           \\      /                    \\       /    10Mbps / 1ms\n *            \\    /                      \\     /\n *             |  |                        |   |\n *             v  v                        v   v\n *          /-------\\                    /-------\\\n *          | rtr-1 |                    | rtr-2 |\n *          \\-------/                    \\-------/\n *                ^                        ^\n *                |                        |\n *                 \\                      /  10 Mpbs / 1ms\n *                  +--------+  +--------+\n *                           |  |\n *                           v  v\n *                        /--------\\\n *                        |  root  |\n *                        \\--------/\n *\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     ./waf --run=ndn-tree-app-delay-tracer\n */\n\nint\nmain(int argc, char* argv[])\n{\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  AnnotatedTopologyReader topologyReader(\"\", 1);\n  topologyReader.SetFileName(\"src/ndnSIM/examples/topologies/topo-tree.txt\");\n  topologyReader.Read();\n\n  // Install CCNx stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.InstallAll();\n\n  // Choosing forwarding strategy\n  ndn::StrategyChoiceHelper::InstallAll(\"/prefix\", \"/localhost/nfd/strategy/best-route\");\n\n  // Installing global routing interface on all nodes\n  ndn::GlobalRoutingHelper ndnGlobalRoutingHelper;\n  ndnGlobalRoutingHelper.InstallAll();\n\n  // Getting containers for the consumer/producer\n  Ptr<Node> consumers[4] = {Names::Find<Node>(\"leaf-1\"), Names::Find<Node>(\"leaf-2\"),\n                            Names::Find<Node>(\"leaf-3\"), Names::Find<Node>(\"leaf-4\")};\n  Ptr<Node> producer = Names::Find<Node>(\"root\");\n\n  ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerBatches\");\n  consumerHelper.SetPrefix(\"/root\");\n  consumerHelper.SetAttribute(\"Batches\", StringValue(\"1s 1 10s 1\"));\n  consumerHelper.Install(consumers[0]);\n\n  consumerHelper.SetAttribute(\"Batches\", StringValue(\"11s 1\"));\n  consumerHelper.Install(consumers[1]);\n\n  consumerHelper.SetAttribute(\"Batches\", StringValue(\"11s 1\"));\n  consumerHelper.Install(consumers[2]);\n\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n\n  // Register /root prefix with global routing controller and\n  // install producer that will satisfy Interests in /root namespace\n  ndnGlobalRoutingHelper.AddOrigins(\"/root\", producer);\n  producerHelper.SetPrefix(\"/root\");\n  producerHelper.Install(producer).Start(Seconds(9));\n\n  // Calculate and install FIBs\n  ndn::GlobalRoutingHelper::CalculateRoutes();\n\n  Simulator::Stop(Seconds(20.0));\n\n  ndn::AppDelayTracer::InstallAll(\"app-delays-trace.txt\");\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-tree-cs-tracers.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-tree-cs-tracers.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nnamespace ns3 {\n\n/**\n * This scenario simulates a tree topology (using topology reader module)\n *\n *    /------\\      /------\\      /------\\      /------\\\n *    |leaf-1|      |leaf-2|      |leaf-3|      |leaf-4|\n *    \\------/      \\------/      \\------/      \\------/\n *         ^          ^                ^           ^\n *         |          |                |           |\n *          \\        /                  \\         /\n *           \\      /                    \\       /    10Mbps / 1ms\n *            \\    /                      \\     /\n *             |  |                        |   |\n *             v  v                        v   v\n *          /-------\\                    /-------\\\n *          | rtr-1 |                    | rtr-2 |\n *          \\-------/                    \\-------/\n *                ^                        ^\n *                |                        |\n *                 \\                      /  10 Mpbs / 1ms\n *                  +--------+  +--------+\n *                           |  |\n *                           v  v\n *                        /--------\\\n *                        |  root  |\n *                        \\--------/\n *\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     ./waf --run=ndn-tree-cs-tracers\n */\n\nint\nmain(int argc, char* argv[])\n{\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  AnnotatedTopologyReader topologyReader(\"\", 1);\n  topologyReader.SetFileName(\"src/ndnSIM/examples/topologies/topo-tree.txt\");\n  topologyReader.Read();\n\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.setPolicy(\"nfd::cs::lru\");\n  ndnHelper.setCsSize(100);\n  ndnHelper.InstallAll();\n\n  // Choosing forwarding strategy\n  ndn::StrategyChoiceHelper::InstallAll(\"/prefix\", \"/localhost/nfd/strategy/best-route\");\n\n  // Installing global routing interface on all nodes\n  ndn::GlobalRoutingHelper ndnGlobalRoutingHelper;\n  ndnGlobalRoutingHelper.InstallAll();\n\n  // Getting containers for the consumer/producer\n  Ptr<Node> consumers[4] = {Names::Find<Node>(\"leaf-1\"), Names::Find<Node>(\"leaf-2\"),\n                            Names::Find<Node>(\"leaf-3\"), Names::Find<Node>(\"leaf-4\")};\n  Ptr<Node> producer = Names::Find<Node>(\"root\");\n\n  for (int i = 0; i < 4; i++) {\n    ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n    consumerHelper.SetAttribute(\"Frequency\", StringValue(\"10\")); // 100 interests a second\n\n    // Each consumer will express the same data /root/<seq-no>\n    consumerHelper.SetPrefix(\"/root\");\n    ApplicationContainer app = consumerHelper.Install(consumers[i]);\n    app.Start(Seconds(0.01 * i));\n  }\n\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n\n  // Register /root prefix with global routing controller and\n  // install producer that will satisfy Interests in /root namespace\n  ndnGlobalRoutingHelper.AddOrigins(\"/root\", producer);\n  producerHelper.SetPrefix(\"/root\");\n  producerHelper.Install(producer);\n\n  // Calculate and install FIBs\n  ndn::GlobalRoutingHelper::CalculateRoutes();\n\n  Simulator::Stop(Seconds(20.0));\n\n  ndn::CsTracer::InstallAll(\"cs-trace.txt\", Seconds(1));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-tree-tracers.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-tree-tracers.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nnamespace ns3 {\n\n/**\n * This scenario simulates a tree topology (using topology reader module)\n *\n *    /------\\      /------\\      /------\\      /------\\\n *    |leaf-1|      |leaf-2|      |leaf-3|      |leaf-4|\n *    \\------/      \\------/      \\------/      \\------/\n *         ^          ^                ^           ^\n *         |          |                |           |\n *          \\        /                  \\         /\n *           \\      /                    \\       /    10Mbps / 1ms\n *            \\    /                      \\     /\n *             |  |                        |   |\n *             v  v                        v   v\n *          /-------\\                    /-------\\\n *          | rtr-1 |                    | rtr-2 |\n *          \\-------/                    \\-------/\n *                ^                        ^\n *                |                        |\n *                 \\                      /  10 Mpbs / 1ms\n *                  +--------+  +--------+\n *                           |  |\n *                           v  v\n *                        /--------\\\n *                        |  root  |\n *                        \\--------/\n *\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     ./waf --run=ndn-tree-tracers\n */\n\nint\nmain(int argc, char* argv[])\n{\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  AnnotatedTopologyReader topologyReader(\"\", 1);\n  topologyReader.SetFileName(\"src/ndnSIM/examples/topologies/topo-tree.txt\");\n  topologyReader.Read();\n\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.InstallAll();\n\n  // Choosing forwarding strategy\n  ndn::StrategyChoiceHelper::InstallAll(\"/prefix\", \"/localhost/nfd/strategy/best-route\");\n\n  // Installing global routing interface on all nodes\n  ndn::GlobalRoutingHelper ndnGlobalRoutingHelper;\n  ndnGlobalRoutingHelper.InstallAll();\n\n  // Getting containers for the consumer/producer\n  Ptr<Node> consumers[4] = {Names::Find<Node>(\"leaf-1\"), Names::Find<Node>(\"leaf-2\"),\n                            Names::Find<Node>(\"leaf-3\"), Names::Find<Node>(\"leaf-4\")};\n  Ptr<Node> producer = Names::Find<Node>(\"root\");\n\n  for (int i = 0; i < 4; i++) {\n    ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n    consumerHelper.SetAttribute(\"Frequency\", StringValue(\"100\")); // 100 interests a second\n\n    // Each consumer will express unique interests /root/<leaf-name>/<seq-no>\n    consumerHelper.SetPrefix(\"/root/\" + Names::FindName(consumers[i]));\n    consumerHelper.Install(consumers[i]);\n  }\n\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n\n  // Register /root prefix with global routing controller and\n  // install producer that will satisfy Interests in /root namespace\n  ndnGlobalRoutingHelper.AddOrigins(\"/root\", producer);\n  producerHelper.SetPrefix(\"/root\");\n  producerHelper.Install(producer);\n\n  // Calculate and install FIBs\n  ndn::GlobalRoutingHelper::CalculateRoutes();\n\n  Simulator::Stop(Seconds(20.0));\n\n  ndn::L3RateTracer::InstallAll(\"rate-trace.txt\", Seconds(0.5));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-tree-with-l2tracer.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-simple-withl2tracer.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nnamespace ns3 {\n\nint\nmain(int argc, char* argv[])\n{\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  AnnotatedTopologyReader topologyReader(\"\", 10);\n  topologyReader.SetFileName(\"src/ndnSIM/examples/topologies/topo-tree-25-node.txt\");\n  topologyReader.Read();\n\n  /****************************************************************************/\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.setPolicy(\"nfd::cs::lru\");\n  ndnHelper.setCsSize(1000);\n  ndnHelper.InstallAll();\n  /****************************************************************************/\n  // Installing global routing interface on all nodes\n  ndn::GlobalRoutingHelper ndnGlobalRoutingHelper;\n  ndnGlobalRoutingHelper.InstallAll();\n  /****************************************************************************/\n  // Getting containers for the consumer/producer\n  Ptr<Node> consumer1 = Names::Find<Node>(\"Src1\");\n  Ptr<Node> consumer2 = Names::Find<Node>(\"Src2\");\n  Ptr<Node> consumer3 = Names::Find<Node>(\"Src3\");\n  Ptr<Node> consumer4 = Names::Find<Node>(\"Src4\");\n  Ptr<Node> consumer5 = Names::Find<Node>(\"Src5\");\n  Ptr<Node> consumer6 = Names::Find<Node>(\"Src6\");\n  Ptr<Node> consumer7 = Names::Find<Node>(\"Src7\");\n  Ptr<Node> consumer8 = Names::Find<Node>(\"Src8\");\n  Ptr<Node> consumer9 = Names::Find<Node>(\"Src9\");\n\n  Ptr<Node> producer1 = Names::Find<Node>(\"Dst1\");\n  Ptr<Node> producer2 = Names::Find<Node>(\"Dst2\");\n  Ptr<Node> producer3 = Names::Find<Node>(\"Dst3\");\n  Ptr<Node> producer4 = Names::Find<Node>(\"Dst4\");\n  Ptr<Node> producer5 = Names::Find<Node>(\"Dst5\");\n  Ptr<Node> producer6 = Names::Find<Node>(\"Dst6\");\n  Ptr<Node> producer7 = Names::Find<Node>(\"Dst7\");\n  Ptr<Node> producer8 = Names::Find<Node>(\"Dst8\");\n  Ptr<Node> producer9 = Names::Find<Node>(\"Dst9\");\n  /****************************************************************************/\n  ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerCbr\");\n  consumerHelper.SetAttribute(\"Frequency\", StringValue(\"1000\")); // interests per Second\n  consumerHelper.SetAttribute(\"Randomize\", StringValue(\"uniform\"));\n  /****************************************************************************/\n  // on the first to ninth consumer node install a Consumer application\n  // that will express interests in /dst1 to /dst9 namespace\n  consumerHelper.SetPrefix(\"/dst9\");\n  consumerHelper.Install(consumer1);\n\n  consumerHelper.SetPrefix(\"/dst8\");\n  consumerHelper.Install(consumer2);\n\n  consumerHelper.SetPrefix(\"/dst7\");\n  consumerHelper.Install(consumer3);\n\n  consumerHelper.SetPrefix(\"/dst6\");\n  consumerHelper.Install(consumer4);\n\n  consumerHelper.SetPrefix(\"/dst5\");\n  consumerHelper.Install(consumer5);\n\n  consumerHelper.SetPrefix(\"/dst4\");\n  consumerHelper.Install(consumer6);\n\n  consumerHelper.SetPrefix(\"/dst3\");\n  consumerHelper.Install(consumer7);\n\n  consumerHelper.SetPrefix(\"/dst2\");\n  consumerHelper.Install(consumer8);\n\n  consumerHelper.SetPrefix(\"/dst1\");\n  consumerHelper.Install(consumer9);\n\n  /****************************************************************************/\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"1024\"));\n  /****************************************************************************/\n  // Register /dst1 to /dst9 prefix with global routing controller and\n  // install producer that will satisfy Interests in /dst1 to /dst9 namespace\n  ndnGlobalRoutingHelper.AddOrigins(\"/dst1\", producer1);\n  producerHelper.SetPrefix(\"/dst1\");\n  producerHelper.Install(producer1);\n\n  ndnGlobalRoutingHelper.AddOrigins(\"/dst2\", producer2);\n  producerHelper.SetPrefix(\"/dst2\");\n  producerHelper.Install(producer2);\n\n  ndnGlobalRoutingHelper.AddOrigins(\"/dst3\", producer3);\n  producerHelper.SetPrefix(\"/dst3\");\n  producerHelper.Install(producer3);\n\n  ndnGlobalRoutingHelper.AddOrigins(\"/dst4\", producer4);\n  producerHelper.SetPrefix(\"/dst4\");\n  producerHelper.Install(producer4);\n\n  ndnGlobalRoutingHelper.AddOrigins(\"/dst5\", producer5);\n  producerHelper.SetPrefix(\"/dst5\");\n  producerHelper.Install(producer5);\n\n  ndnGlobalRoutingHelper.AddOrigins(\"/dst6\", producer6);\n  producerHelper.SetPrefix(\"/dst6\");\n  producerHelper.Install(producer6);\n\n  ndnGlobalRoutingHelper.AddOrigins(\"/dst7\", producer7);\n  producerHelper.SetPrefix(\"/dst7\");\n  producerHelper.Install(producer7);\n\n  ndnGlobalRoutingHelper.AddOrigins(\"/dst8\", producer8);\n  producerHelper.SetPrefix(\"/dst8\");\n  producerHelper.Install(producer8);\n\n  ndnGlobalRoutingHelper.AddOrigins(\"/dst9\", producer9);\n  producerHelper.SetPrefix(\"/dst9\");\n  producerHelper.Install(producer9);\n\n  /*****************************************************************************/\n  // Calculate and install FIBs\n  ndn::GlobalRoutingHelper::CalculateRoutes();\n\n  Simulator::Stop(Seconds(10.0));\n\n  /****************************************************************************/\n  // Tracer:\n\n  L2RateTracer::InstallAll(\"drop-trace.txt\", Seconds(0.5));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-triangle-calculate-routes.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-triangle-calculate-routes.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\n#include \"ns3/ndnSIM/model/ndn-net-device-transport.hpp\"\n\nnamespace ns3 {\n\nint\nmain(int argc, char* argv[])\n{\n  // setting default parameters for PointToPoint links and channels\n  Config::SetDefault(\"ns3::PointToPointNetDevice::DataRate\", StringValue(\"1Mbps\"));\n  Config::SetDefault(\"ns3::PointToPointChannel::Delay\", StringValue(\"10ms\"));\n  Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\", StringValue(\"20p\"));\n\n  // Read optional command-line parameters (e.g., enable visualizer with ./waf --run=<> --visualize\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  ofstream file1(\"/tmp/topo1.txt\");\n  file1 << \"router\\n\\n\"\n        << \"#node\tcity\ty\tx\tmpi-partition\\n\"\n        << \"A1\tNA\t1\t1\t1\\n\"\n        << \"B1\tNA\t80\t-40\t1\\n\"\n        << \"C1\tNA\t80\t40\t1\\n\"\n        << \"A2\tNA\t1\t1\t1\\n\"\n        << \"B2\tNA\t80\t-40\t1\\n\"\n        << \"C2\tNA\t80\t40\t1\\n\\n\"\n        << \"link\\n\\n\"\n        << \"# from  to  capacity\tmetric\tdelay\tqueue\\n\"\n        << \"A1\t    B1\t10Mbps\t\t100\t1ms\t100\\n\"\n        << \"A1\t    C1\t10Mbps\t\t50\t1ms\t100\\n\"\n        << \"B1\t    C1\t10Mbps\t\t1\t1ms\t100\\n\"\n        << \"A2\t    B2\t10Mbps\t\t50\t1ms\t100\\n\"\n        << \"A2\t    C2\t10Mbps\t\t100\t1ms\t100\\n\"\n        << \"B2\t    C2\t10Mbps\t\t1\t1ms\t100\\n\";\n  file1.close();\n\n  AnnotatedTopologyReader topologyReader(\"\");\n  topologyReader.SetFileName(\"/tmp/topo1.txt\");\n  topologyReader.Read();\n\n  // Install NDN stack on all nodes\n  ndn::StackHelper ndnHelper;\n  ndnHelper.InstallAll();\n\n  topologyReader.ApplyOspfMetric();\n\n  ndn::GlobalRoutingHelper ndnGlobalRoutingHelper;\n  ndnGlobalRoutingHelper.InstallAll();\n\n  ndnGlobalRoutingHelper.AddOrigins(\"/test/prefix\", Names::Find<Node>(\"C1\"));\n  ndnGlobalRoutingHelper.AddOrigins(\"/test/prefix\", Names::Find<Node>(\"C2\"));\n  ndn::GlobalRoutingHelper::CalculateRoutes();\n\n  auto printFib = [](Ptr<Node> node) {\n    auto ndn = node->GetObject<ndn::L3Protocol>();\n    for (const auto& entry : ndn->getForwarder()->getFib()) {\n      cout << entry.getPrefix() << \" (\";\n\n      bool isFirst = true;\n      for (auto& nextHop : entry.getNextHops()) {\n        cout << nextHop.getFace();\n        auto& face = nextHop.getFace();\n        auto transport = dynamic_cast<ndn::NetDeviceTransport*>(face.getTransport());\n        if (transport == nullptr) {\n          continue;\n        }\n\n        cout << \" towards \";\n\n        if (!isFirst)\n          cout << \", \";\n        cout << Names::FindName(transport->GetNetDevice()->GetChannel()->GetDevice(1)->GetNode());\n        isFirst = false;\n      }\n      cout << \")\" << endl;\n    }\n  };\n\n  cout << \"FIB content on node A1\" << endl;\n  printFib(Names::Find<Node>(\"A1\"));\n\n  cout << \"FIB content on node A2\" << endl;\n  printFib(Names::Find<Node>(\"A2\"));\n\n  Simulator::Stop(Seconds(20.0));\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    },
    {
      "file_path": "examples/ndn-zipf-mandelbrot.cpp",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/**\n * Copyright (c) 2011-2015  Regents of the University of California.\n *\n * This file is part of ndnSIM. See AUTHORS for complete list of ndnSIM authors and\n * contributors.\n *\n * ndnSIM is free software: you can redistribute it and/or modify it under the terms\n * of the GNU General Public License as published by the Free Software Foundation,\n * either version 3 of the License, or (at your option) any later version.\n *\n * ndnSIM is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n * PURPOSE.  See the GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along with\n * ndnSIM, e.g., in COPYING.md file.  If not, see <http://www.gnu.org/licenses/>.\n **/\n\n// ndn-grid.cpp\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/point-to-point-layout-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n\nnamespace ns3 {\n\n/**\n * This scenario simulates a grid topology (using PointToPointGrid module)\n *\n * (consumer) -- ( ) ----- ( )\n *     |          |         |\n *    ( ) ------ ( ) ----- ( )\n *     |          |         |\n *    ( ) ------ ( ) -- (producer)(2,2)\n *\n * All links are 1Mbps with propagation 10ms delay.\n *\n * FIB is populated using NdnGlobalRoutingHelper.\n *\n * Consumer requests data from producer with frequency 100 interests per second\n * (interests contain constantly increasing sequence number).\n *\n * For every received interest, producer replies with a data packet, containing\n * 1024 bytes of virtual payload.\n *\n * To run scenario and see what is happening, use the following command:\n *\n *     NS_LOG=ndn.Consumer:ndn.ConsumerZipfMandelbrot:ndn.Producer ./waf --run=ndn-zipf-mandelbrot\n */\n\nint\nmain(int argc, char* argv[])\n{\n  // LogComponentEnable(\"ndn.CbisGlobalRoutingHelper\", LOG_LEVEL_INFO);\n  // Setting default parameters for PointToPoint links and channels\n  Config::SetDefault(\"ns3::PointToPointNetDevice::DataRate\", StringValue(\"1Mbps\"));\n  Config::SetDefault(\"ns3::PointToPointChannel::Delay\", StringValue(\"1ms\"));\n  Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\", StringValue(\"10p\"));\n\n  // Read optional command-line parameters (e.g., enable visualizer with ./waf --run=<> --visualize\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  // Creating 3x3 topology\n  PointToPointHelper p2p;\n  PointToPointGridHelper grid(3, 3, p2p);\n  grid.BoundingBox(100, 100, 200, 200);\n\n  // Install CCNx stack on all nodes\n  ndn::StackHelper ndnHelper;\n  // ndnHelper.SetForwardingStrategy (\"ns3::ndn::fw::SmartFlooding\");\n  // ndnHelper.SetContentStore (\"ns3::ndn::cs::Lru\", \"MaxSize\", \"10\");\n  ndnHelper.InstallAll();\n\n  // Choosing forwarding strategy\n  ndn::StrategyChoiceHelper::InstallAll(\"/prefix\", \"/localhost/nfd/strategy/ncc\");\n\n  // Installing global routing interface on all nodes\n  // ndn::CbisGlobalRoutingHelper ndnGlobalRoutingHelper;\n  ndn::GlobalRoutingHelper ndnGlobalRoutingHelper;\n  ndnGlobalRoutingHelper.InstallAll();\n\n  // Getting containers for the consumer/producer\n  Ptr<Node> producer = grid.GetNode(2, 2);\n  NodeContainer consumerNodes;\n  consumerNodes.Add(grid.GetNode(0, 0));\n\n  // Install CCNx applications\n  std::string prefix = \"/prefix\";\n\n  ndn::AppHelper consumerHelper(\"ns3::ndn::ConsumerZipfMandelbrot\");\n  // ndn::AppHelper consumerHelper (\"ns3::ndn::ConsumerCbr\");\n  consumerHelper.SetPrefix(prefix);\n  consumerHelper.SetAttribute(\"Frequency\", StringValue(\"100\"));        // 100 interests a second\n  consumerHelper.SetAttribute(\"NumberOfContents\", StringValue(\"100\")); // 10 different contents\n  // consumerHelper.SetAttribute (\"Randomize\", StringValue (\"uniform\")); // 100 interests a second\n  consumerHelper.Install(consumerNodes);\n\n  ndn::AppHelper producerHelper(\"ns3::ndn::Producer\");\n  producerHelper.SetPrefix(prefix);\n  producerHelper.SetAttribute(\"PayloadSize\", StringValue(\"100\"));\n  producerHelper.Install(producer);\n  ndnGlobalRoutingHelper.AddOrigins(prefix, producer);\n\n  // Calculate and install FIBs\n  ndn::GlobalRoutingHelper::CalculateRoutes();\n\n  Simulator::Stop(Seconds(1.0));\n\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n  return ns3::main(argc, argv);\n}\n"
    }
  ]
}