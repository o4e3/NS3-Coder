{
  "repo_name": "networkedsystems/lora-ns3",
  "github_url": "https://github.com/networkedsystems/lora-ns3",
  "readme": "LoraWAN partial network implementation \n-------------------------------------\n\nIntroduction\n============\nLoRaWAN is a long range wireless protocol with interesting features such as:\n\t* long range\n\t* spread spectrum (enabling to receive multiple packets at the same time)\n\t* Scalable data rate\n\t\t\t\t- not only to increase the range, but also to schedule dynamically \n\nSupport\n=======\n\nParts that are supported: \n\t* Device class A \n\t\nCommands that are supported\n\t* LinkAdrReq\n\t* LinkAdrAns\n\n\n\nTopology\n========\n\nDevice\t\t\t\t\t\t\t\t\tGateway\t\t\t\t\t\t\t\t\t\t\t\t\t\tNetwork\n------\t\t\t\t\t\t\t\t\t-------\t\t\t\t\t\t\t\t\t\t\t\t\t\t-------\n\t\nLoRaApplication\t\t\t\t\tLoRaSinkApplication\t\t\t\t\t\t\t\tLoRaNetwork|LoRaPowerControl\nLoRaNetDevice\t\t\t\t\t\tLoRaNetDeviceGw\t| IP layer--------IP layer (Does not matter what protocol.)\t\t\t\t\nLoRaPhy\t\t\t\t\t\t\t\t\tLoRaPhy\t\t\t\t\t|\n\n----------SpectrumChannel------------\n\nHelper\n======\n\n",
  "examples": [
    {
      "file_path": "examples/lora.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2018 KU Leuven\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Brecht Reynders\n */\n#include \"ns3/non-communicating-net-device.h\"\n#include <ns3/okumura-hata-propagation-loss-model.h>\n#include <ns3/core-module.h>\n#include <ns3/packet.h>\n#include <ns3/lora-module.h>\n#include <ns3/spectrum-module.h>\n#include <ns3/mobility-module.h>\n#include <ns3/energy-module.h>\n#include <ns3/spectrum-value.h>\n#include <ns3/spectrum-analyzer.h>\n#include <ns3/rectangle.h>\n//#include <ns3/log.h>\n//#include <string>\n#include <iostream>\n#include <ns3/isotropic-antenna-model.h>\n#include <ns3/trace-helper.h>\n#include <ns3/drop-tail-queue.h>\n#include <unordered_map>\n#include \"ns3/network-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include <ns3/gw-trailer.h>\nNS_LOG_COMPONENT_DEFINE (\"lora\");\n\nusing namespace ns3;\nusing namespace std;\n\n\nclass Hasher_brecht {\npublic:\n    size_t operator() (const Address& key) const {     // the parameter type should be the same as the type of key of unordered_map\n        uint64_t hash = 0;\n\t\t\t\tuint8_t buffer[8];\n\t\t\t\tmemset(buffer,0,8);\n\t\t\t\tkey.CopyAllTo(buffer,key.GetLength()+2);\n        for(uint32_t i = 0; i < 8; i++) {\n            hash += ((uint64_t) buffer[i]) << i;\n        }\n        return hash;\n    }\n};\n\n\n/////////////////////////////////\n// Configuration\n/////////////////////////////////\n//std::vector <int, double> marked_list;\nbool ack = false;\nbool rslora = false;\nbool learning = false;\nbool optimized = false;\nbool monitorEnergy = false;\nbool interference = false;\nbool randomSend = false;\ndouble length = 1000;\t\t\t//!< Square city with length as distance\ndouble iterationCount = 5;\t\t\t//!< Square city with length as distance\nint pktsize = 51;              //!< size of packets, in bytes\nint duration = 24*60*60;\t//!< Duration of the simulation\nint measurementStart = 0;\t//!< Start of the measured simulation (gives time to settle) \ndouble interval = 120;        // interval between packets, minutes\nbool verbose = false;          // enable logging (different from trace)\nbool nakagami = true;         // enable nakagami path loss\nbool dynamic = false;          // enable random moving of pan node\nuint32_t nSensors = 500; // numbenir of sent packets\nuint32_t nGateways = 1; // numbenir of sent packets\nuint32_t reportingInterval = 0; // numbenir of sent packets\nPtr<OutputStreamWrapper> m_stream = 0;\nstd::stringstream filename;\nPtr<UniformRandomVariable> randT = CreateObject<UniformRandomVariable> ();\nstd::unordered_map<Address, Ptr<NetDevice>, Hasher_brecht> deviceMap;\n//errormap: transmitted, received, received unique, received original, xlocation, ylocation\nstd::unordered_map<Address, std::tuple<uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t>, Hasher_brecht> errorMap;\nMac32Address server;\nNetDeviceContainer gateways;\nuint8_t offsets [7] = {2,3,3,1,2,2,3};\n/////////////////////////////////\n// End configuration\n/////////////////////////////////\n\n\tuint32_t \nGetClosestGateway (Ptr<MobilityModel> location)\n{\n\tuint32_t closestNode; \n\tdouble smallestDistance = 99999999;\n\tfor (uint32_t i = 0; i<gateways.GetN (); i++)\n\t{\n\t\tdouble distanceToI = location->GetDistanceFrom (gateways.Get(i)->GetNode ()->GetObject<MobilityModel> ());\n\t\tif (distanceToI < smallestDistance)\n\t\t{\n\t\t\tsmallestDistance = distanceToI;\n\t\t\tclosestNode = gateways.Get(i)->GetNode ()->GetId();\n\t\t}\n\t}\n\treturn closestNode;\n}\n\n\n/// Save that teh message has been transmitted\n\tvoid\nTransmitted (const Ptr<const Packet> packet)\n{\n\tif (Simulator::Now().GetSeconds() > measurementStart)\n\t{\n\t\tPtr<Packet> copy = packet->Copy();\n\t\tLoRaMacHeader header;\n\t\tcopy->RemoveHeader(header);\n\t\tAddress addr = (header.GetAddr());\n\t\t//std::tuple<uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t> tuple = errorMap[addr];\n\t\tstd::get<0>(errorMap[addr])++;// = std::make_tuple(++std::get<0>(tuple),std::get<1>(tuple),std::get<2>(tuple),std::get<3>(tuple),std::get<4>(tuple));\n\t}\n}\n\n// save that a message has been received\n\tvoid\nReceived (const Ptr<const Packet> packet)\n{\n\tif (Simulator::Now().GetSeconds() > measurementStart)\n\t{\n\tPtr<Packet> copy = packet->Copy();\n\tLoRaMacHeader header;\n\tcopy->RemoveHeader(header);\n\tGwTrailer trailer;\n\tcopy->RemoveTrailer (trailer);\n\tAddress addr = (header.GetAddr());\n\tstd::get<1>(errorMap[addr])++;\n\tif ( trailer.GetGateway () == GetClosestGateway (deviceMap[addr]->GetNode ()->GetObject<MobilityModel>())) \n\t\tstd::get<3>(errorMap[addr])++;\n\t}\n}\n\n// save that a message has been uniquely received\n\tvoid\nReceivedUnique (const Ptr<const Packet> packet)\n{\n\tif (Simulator::Now().GetSeconds() > measurementStart)\n\t{\n\t\tPtr<Packet> copy = packet->Copy();\n\t\tLoRaMacHeader header;\n\t\tcopy->RemoveHeader(header);\n\t\tAddress addr = (header.GetAddr());\n\t\tstd::get<2>(errorMap[addr])++;\n\t}\n}\n\nvoid StoreData(uint32_t timeInSimulation)\n{\n\t\tfor ( auto it = errorMap.begin(); it !=errorMap.end();++it)\n\t\t{\n\t\t\tAddress addr = it->first;\n\t\t\tPtr<LoRaNetDevice> netdevice = DynamicCast<LoRaNetDevice>(deviceMap[addr]);\n\t\t\tstd::tuple<uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t> tuple = it->second;\n\t\t\tif ( netdevice!=0)\n\t\t\t{\n\t\t\t\t// print ID, transmitted, received, received unique, received at closest gateway, x coords, y coords, get average amount of retransmissions, get average time of transmissions, number of missed messages, amount of received messages.\n\t\t\t\t*m_stream->GetStream() << addr << \",\" << std::get<0>(tuple)<< \",\" << std::get<1>(tuple) << \",\" <<   std::get<2>(tuple) << \",\" << std::get<3>(tuple) << \",\" << std::get<4>(tuple) << \",\" << std::get<5>(tuple) <<\",\"<< netdevice->GetAvgRetransmissionCount() << \",\" << netdevice->GetAvgTime() << \",\" << netdevice->GetMissed() << \",\" << netdevice->GetArrived() << \",\" << timeInSimulation;\n\t\t\t\tif (netdevice->GetNode()->GetObject<EnergySourceContainer>())\n\t\t\t\t{\n\t\t\t\t\t*m_stream->GetStream() << \",\" << netdevice->GetNode()->GetObject<EnergySourceContainer>()->Get(0)->GetRemainingEnergy() << \",1\"<< std::endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t*m_stream->GetStream() << \",0,1\"<< std::endl;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t*m_stream->GetStream() << addr << \",\" << std::get<0>(tuple)<< \",\" << std::get<1>(tuple) << \",\" <<   std::get<2>(tuple) << \",\" << std::get<3>(tuple) << \",\" << std::get<4>(tuple) << \",\" << std::get<5>(tuple) <<\",0,0,0,0,0,0\" << std::endl;\n\t\t\t}\n\t\t}\n}\n\nvoid\nScheduleStoring()\n{\n\tStoreData(Simulator::Now().GetSeconds());\n\tSimulator::Schedule(Seconds(reportingInterval),&ScheduleStoring);\n}\n\n\n\n/////////////////////////////\n// THIS IS THE ACTUAL CODE //\n/////////////////////////////\n\tint\nmainBody ()\n{\n\trandT->SetAttribute(\"Max\",DoubleValue(interval));\n\t//Enable checksum (FCS)\n\tGlobalValue::Bind (\"ChecksumEnabled\", BooleanValue (true));\n\n\t// Logging\n\tif (verbose)\n\t{\n\t\tLogComponentEnableAll (LOG_PREFIX_TIME);\n\t\tLogComponentEnableAll (LOG_PREFIX_FUNC);\n\t}\n\n\t//Set the information Callback\n\tif (reportingInterval > 0)\n\t\tSimulator::Schedule(Seconds(reportingInterval),&ScheduleStoring);\n\n\t//Create nodes\n\tNodeContainer loraNetworkNode;\n\tloraNetworkNode.Create (1);\n\tNodeContainer loraCoordinatorNodes;\n\tloraCoordinatorNodes.Create (nGateways);\n\tNodeContainer loraDeviceNodes;\n\tloraDeviceNodes.Create(nSensors);\n\tNodeContainer loraBackendNodes(loraNetworkNode, loraCoordinatorNodes);\n\n\t//Create mobility of basestations\n\tMobilityHelper mobility;\n\tPtr<ListPositionAllocator> basePositionList = CreateObject<ListPositionAllocator> ();\n\t// place gateways in a hexagonal structure\n\tbasePositionList->Add (Vector (0.0,0.0,0.0)); //network\t\n\t// center gateway\n\tbasePositionList->Add (Vector (length,length,50));\n\t// 3 gateway equally spaced around the central gateway\n\tbasePositionList->Add (Vector (length/2,1866*length/1000,50.0)); //main base station\t\n\tbasePositionList->Add (Vector (length/2,134*length/1000,50.0)); //main base station\t\n\tbasePositionList->Add (Vector (2*length,length,50.0)); //main base station\t\n\t// 3 gateways equally spaced between all other gw's\n\tbasePositionList->Add (Vector (0,length,50.0)); //main base station\t\n\tbasePositionList->Add (Vector (1.500*length,1866*length/1000,50.0)); //main base station\t\n\tbasePositionList->Add (Vector (1.500*length,134*length/1000,50.0)); //main base station\t\n\t//basePositionList->Add (Vector (length,length,50.0)); //main base station\t\n\t//basePositionList->Add (Vector (length/3,length,50.0)); //main base station\t\n\t//basePositionList->Add (Vector (4*length/3,1.5774*length,50.0)); //main base station\t\n\t//basePositionList->Add (Vector (length*4/3,.42265*length,50.0)); //main base station\n\t//basePositionList->Add (Vector (length*2/3,1.5774*length,50.0)); //main base station\t\n\t//basePositionList->Add (Vector (length*2/3,.42265*length,50.0)); //main base station\t\n\t//basePositionList->Add (Vector (5*length/3,length,50.0)); //main base station\t\n\tmobility.SetPositionAllocator (basePositionList);\n\tmobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n\tmobility.Install(loraBackendNodes);\n\n\n\t//Mobility nodes\n\t// this is random\n\tstd::cout << \"Create mobility of nodes\" << std::endl;\n\tMobilityHelper mobility2;\n\tPtr<ListPositionAllocator> nodePositionList = CreateObject<ListPositionAllocator>();\n\tdouble lengthMax = length;\n\tif (nGateways>3)\n\t\tlengthMax = 1500;\n\tfor(uint32_t nodePositionsAssigned = 0; nodePositionsAssigned < nSensors; nodePositionsAssigned++){\n\t\tdouble x,y;\n\t\tdo{\n\t\t\tx = randT->GetInteger(0,2*lengthMax);\n\t\t\ty = randT->GetInteger(0,2*lengthMax);\n\t\t}\n\t\twhile ((x-length)*(x-length)+(y-length)*(y-length) > lengthMax*lengthMax);\n\t\tnodePositionList->Add (Vector (x,y,1.0));\n\t}\n\tmobility2.SetPositionAllocator (nodePositionList);\n\tmobility2.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n\tmobility2.Install (loraDeviceNodes);\n\n\t//Channel\n\tstd::cout << \"Create channel\" << std::endl;\n\tSpectrumChannelHelper channelHelper;\n\tchannelHelper.SetChannel (\"ns3::MultiModelSpectrumChannel\");\n\tif (nakagami)\n\t{\n\t\tchannelHelper.AddPropagationLoss (\"ns3::OkumuraHataPropagationLossModel\",\"Frequency\",DoubleValue(868e6));\n\t\tchannelHelper.AddPropagationLoss (\"ns3::NakagamiPropagationLossModel\",\"m0\",DoubleValue(1),\"m1\",DoubleValue(1),\"m2\",DoubleValue(1));\n\t}\n\telse\n\t{\n\t\tchannelHelper.AddPropagationLoss (\"ns3::OkumuraHataPropagationLossModel\",\"Frequency\",DoubleValue(868e6));\n\t}\n\tchannelHelper.SetPropagationDelay (\"ns3::ConstantSpeedPropagationDelayModel\");\n\tPtr<SpectrumChannel> channel = channelHelper.Create ();\n\tLoRaHelper lorahelper;\n\tlorahelper.SetChannel (channel);\n\n\n\t// Configure gateways\n\tstd::cout << \"Create gateways\" << std::endl;\n\tif (rslora)\n\t{\n\t\tgateways = lorahelper.InstallRsGateways (loraCoordinatorNodes);\n\t\tfor (uint32_t i = 0; i< gateways.GetN(); i++)\n\t\t\tgateways.Get(i)->SetAttribute (\"Offset\",UintegerValue(offsets[i]-1));\n\t}\n\telse\n\t\tgateways = lorahelper.InstallGateways (loraCoordinatorNodes);\n\n\t// Create the nodes\n\tstd::cout << \"Create nodes\" << std::endl;\n\tNetDeviceContainer loraNetDevices;\n\tif (rslora)\n\t{\n\t\tloraNetDevices = lorahelper.InstallRs (loraDeviceNodes);\n\t\tfor (uint32_t i = 0; i< loraNetDevices.GetN (); i++)\n\t\t{\n\t\t\t// this is a dirty workaround. Make sure to create first the network and then the gateways\n\t\t\tloraNetDevices.Get(i)->SetAttribute (\"Offset2\",UintegerValue(offsets[GetClosestGateway(loraNetDevices.Get(i)->GetNode()->GetObject<MobilityModel>())-1]-1));\n\t\t}\n\t}\n\telse\n\t\tloraNetDevices = lorahelper.Install (loraDeviceNodes);\n\n\n\t// Check if reliable\n\tif (ack)\n\t\tfor (uint32_t i = 0; i<loraNetDevices.GetN(); i++)\n\t\t{\n\t\t\tloraNetDevices.Get(i)->SetAttribute(\"Reliable\",BooleanValue(true));\n\t\t\t\n\t\t\tPtr<LoRaPhy> temp = StaticCast<LoRaPhy>(StaticCast<LoRaNetDevice>(loraNetDevices.Get(i))->GetPhy());\n\t\t}\n\n\t// create energy source\n\tif(monitorEnergy)\n\t{\n\t\tstd::cout << \"Monitoring energy enabled\" << std::endl;\n\t\tLoRaEnergySourceHelper sourceHelper;\n\t\tsourceHelper.Set(\"BasicEnergySourceInitialEnergyJ\",DoubleValue(100));\n\t\tEnergySourceContainer energySources = sourceHelper.Install(loraDeviceNodes);\n\t\tLoRaRadioEnergyModelHelper radioHelper;\n\t\tDeviceEnergyModelContainer deviceModels = radioHelper.Install (loraNetDevices, energySources);\n\t}\n\n\t// Connect gateways with network\n\tstd::cout << \"Create wired network\" << std::endl;\n\tCsmaHelper csma;\n\tcsma.SetChannelAttribute (\"DataRate\", StringValue (\"1000Mbps\"));\n\tcsma.SetChannelAttribute (\"Delay\", TimeValue (NanoSeconds (60)));\n\n\tstd::cout << \"Connect devices with wired network\" << std::endl;\n\tNetDeviceContainer csmaDevices;\n\tcsmaDevices = csma.Install (loraBackendNodes);\n\n\tstd::cout << \"Install IP/TCP\" << std::endl;\n\tInternetStackHelper stack;\n\tstack.Install (loraBackendNodes);\n\tIpv4AddressHelper address;\n\taddress.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n\tIpv4InterfaceContainer interfaces = address.Assign (csmaDevices);\n\n\t// set addresses \n\tstd::cout << \"Set the addresses\" << std::endl;\n\tlorahelper.FinishGateways (loraCoordinatorNodes, gateways, interfaces.GetAddress(0));\n\t// Reset the power after each succesfull message\n\tif (learning)\n\t{\n\t\tlorahelper.InstallNetworkApplication(\"ns3::LoRaSfControllerApplication\");\n\t\t//Simulator::Schedule(Seconds(duration-1),&LoRaSfControllerApplication::PrintValues(),DynamicCast<LoRaSfControllerApplication>(apps.get(0)));\n\t}\n\telse\n\t{\n\t\tif (optimized)\n\t\t{\n\t\t\tlorahelper.InstallNetworkApplication(\"ns3::LoRaPowerApplication\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlorahelper.InstallNetworkApplication(\"ns3::LoRaNoPowerApplication\");\n\t\t}\n\t}\n\tPtr<LoRaNetwork> loraNetwork = lorahelper.InstallBackend (loraNetworkNode.Get (0),loraNetDevices);\n\n\t// Let the nodes generate data\n\tstd::cout << \" Generate data from the nodes in the LoRa network\" << std::endl;\n\tApplicationContainer apps = lorahelper.GenerateTraffic (randT, loraDeviceNodes, pktsize, 0, duration, interval,randomSend);\n\n\t// hookup functions to the netdevices of each node to measure the performance\n\tfor (uint32_t i = 0; i< loraNetDevices.GetN(); i++)\n\t{\n\t\tdeviceMap[ (loraNetDevices.Get(i)->GetAddress())]=loraNetDevices.Get(i);\n\t\tuint32_t x  = loraNetDevices.Get(i)->GetNode()->GetObject<MobilityModel>()->GetPosition ().x;\n\t\tuint32_t y  = loraNetDevices.Get(i)->GetNode()->GetObject<MobilityModel>()->GetPosition ().y;\n\t\terrorMap[ (loraNetDevices.Get(i)->GetAddress())] = make_tuple (0,0,0,0,x,y);\n\t\tDynamicCast<LoRaNetDevice>(loraNetDevices.Get(i))->TraceConnectWithoutContext (\"MacTx\",MakeCallback(&Transmitted));\n\t}\n\n\t// hookup functions to the network for measuring performance\n\tloraNetwork->TraceConnectWithoutContext(\"NetRx\",MakeCallback(&ReceivedUnique));\n\tloraNetwork->TraceConnectWithoutContext(\"NetPromiscRx\",MakeCallback(&Received));\t\n\n\t// Configure interference\n\tif (interference)\n\t{\n\t\tstd::cout << \"Interference Enabled\" << std::endl;\n\t\tMobilityHelper mobilityInterference;\n\t\tPtr<RandomDiscPositionAllocator> allocator = CreateObject<RandomDiscPositionAllocator>();\n\t\tPtr<RandomVariableStream> radius = CreateObject<UniformRandomVariable>();\n\t\tradius->SetAttribute(\"Max\",DoubleValue(2000));\n\t\tallocator->SetAttribute(\"Rho\",PointerValue(radius));\n\t\tallocator->SetAttribute(\"X\",DoubleValue(1500));\n\t\tallocator->SetAttribute(\"Y\",DoubleValue(1500));\n\t\tPtr<RandomVariableStream> speed = CreateObject<ConstantRandomVariable>();\n\t\tspeed->SetAttribute(\"Constant\",DoubleValue(3e9));\n\t\tPtr<RandomVariableStream> pause = CreateObject<ConstantRandomVariable>();\n\t\tpause->SetAttribute(\"Constant\",DoubleValue(0.5));\n\n\t\tmobilityInterference.SetMobilityModel (\"ns3::RandomDirection2dMobilityModel\",\"Bounds\",RectangleValue(Rectangle(-length*3,length*3,-length*3,length*3)),\"Speed\",PointerValue(speed),\"Pause\",PointerValue(pause));\n\t\tmobilityInterference.SetPositionAllocator((allocator));\n\t\tlorahelper.AddInterference(mobilityInterference);\n\t}\n\n\n\t// Start the simulation\n\tstd::cout << \"start the fun\" << std::endl;\n\tSimulator::Stop (Seconds (duration));\n\tSimulator::Run ();\n\n\treturn 0;\n}\n\n\tint \nmain (int argc, char** argv)\n{\n\tCommandLine cmd;\n\tcmd.AddValue (\"ack\", \"Only send confirmed messages\", ack);\n\tcmd.AddValue (\"pktsize\", \"The size of a packet\", pktsize);\n\tcmd.AddValue (\"rate\", \"Time between 2 consecutive messages\", interval);\n\tcmd.AddValue (\"rslora\", \"Improved LoRa MAC layer\", rslora);\n\tcmd.AddValue (\"learning\", \"CCMAB for learning ideal spreading factor set\", learning);\n\tcmd.AddValue (\"gateways\", \"The amount of gateways (up to 7) (1,4,7 for optimal performance)\", nGateways);\n\tcmd.AddValue (\"sensors\", \"The amount of sensors\", nSensors);\n\tcmd.AddValue (\"interference\", \"Use measured interference\", interference);\n\tcmd.AddValue (\"optimized\", \"Use the best static spreading factor set [haven't used this in a very long time. Use at your own risk, I hard coded a few things]\", optimized);\n\tcmd.AddValue (\"length\", \"Radius of a cell\", length);\n\tcmd.AddValue (\"duration\", \"Duration of a simulation\", duration);\n\tcmd.AddValue (\"start\", \"Starting time of measuring packets\", measurementStart);\n\tcmd.AddValue (\"monitorEnergy\", \"Monitors the energy of the nodes\", monitorEnergy);\n\tcmd.AddValue (\"iterationCount\", \"The amount of repeated simulations\", iterationCount);\n\tcmd.AddValue (\"randomSend\", \"Add randomness to interval\", randomSend);\n\tcmd.AddValue (\"reportingInterval\",\"The interval for reporting statistics\",reportingInterval);\n\n\tcmd.Parse (argc,argv);\n\tAsciiTraceHelper ascii;\n\tfilename <<  \"data94\";\n\tif (randomSend)\n\t\tfilename << \"random\";\n\tfilename<<\"_\"<<(int)nSensors<<\"_\"<<(int)nGateways<<\"_\"<<length<<\"_\"<<duration-measurementStart<<\"_\"<<iterationCount<<\"_\"<<pktsize<<\"_\"<<interval;\n\tif(ack)\n\t\tfilename << \"_ack\";\n\tif(rslora)\n\t\tfilename << \"_rslora\";\n\tif(learning)\n\t\tfilename << \"_learning\";\n\tif(optimized)\n\t\tfilename << \"_optimized\";\n\tif(interference)\n\t\tfilename << \"_interference\";\n\tm_stream = ascii.CreateFileStream(filename.str());\n\t*m_stream->GetStream() << \"#Scenario \" << (int)nSensors <<  \" nodes with \" << (int)nGateways << \" gateways and \" << (int)nSensors << \" nodes on a square field with side \" << length << \" meter\" <<std::endl;\n\t*m_stream->GetStream() << \"#ack \" << ack << \", pktsize \"  << pktsize;\n\t*m_stream->GetStream() << \", rate \" << interval << \", rslora \"  << rslora;\n\t*m_stream->GetStream() << \", learning \" << learning << \", optimized \"  << optimized;\n\t*m_stream->GetStream() << \", energy \" << monitorEnergy << \", iterations \"  << iterationCount<<std::endl;\n\n\t*m_stream->GetStream() << \"ID, transmitted, received, uniquelyReceived, closestReceived, xCoords, yCoords, avgRetransmission, avgDelay, noAck, acksReceived,timeInSimulation,energyleft << std::endl;\n\tfor (uint8_t iterationI=0;iterationI<iterationCount;iterationI++){\n\t\tstd::cout << \"Iteration: \" << (int)iterationI << std::endl;\n\t\tmainBody();\n\t\tStoreData(duration);\n\t\terrorMap.clear();\n\t\tSimulator::Destroy ();\n\t}\n\treturn 0;\n}\n"
    },
    {
      "file_path": "examples/lora_battery.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2018 KU Leuven\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Brecht Reynders\n */\n#include \"ns3/non-communicating-net-device.h\"\n#include <ns3/okumura-hata-propagation-loss-model.h>\n#include <ns3/core-module.h>\n#include <ns3/packet.h>\n#include <ns3/lora-module.h>\n#include <ns3/spectrum-module.h>\n#include <ns3/mobility-module.h>\n#include <ns3/energy-module.h>\n#include <ns3/spectrum-value.h>\n#include <ns3/spectrum-analyzer.h>\n//#include <ns3/log.h>\n//#include <string>\n#include <iostream>\n#include <ns3/isotropic-antenna-model.h>\n#include <ns3/trace-helper.h>\n#include <ns3/drop-tail-queue.h>\n#include <unordered_map>\n#include \"ns3/network-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include <ns3/gw-trailer.h>\n\nNS_LOG_COMPONENT_DEFINE (\"lora\");\n\nusing namespace ns3;\nusing namespace std;\n\n/////////////////////////////////\n// Configuration\n/////////////////////////////////\n//std::vector <int, double> marked_list;\ndouble length = 3000;\t\t\t//!< Square city with length as distance\nint pktsize = 51;              //!< size of packets, in bytes\nint duration = 24*60*60;\t//!< Duration of the simulation\ndouble interval = 10;        // interval between packets, minutes\nbool verbose = false;          // enable logging (different from trace)\nbool nakagami = true;         // enable nakagami path loss\nbool dynamic = false;          // enable random moving of pan node\nuint32_t nSensors = 10; // numbenir of sent packets\nuint32_t nGateways = 1; // numbenir of sent packets\nPtr<OutputStreamWrapper> m_stream = 0; // stream for waterfallcurve\nPtr<UniformRandomVariable> randT = CreateObject<UniformRandomVariable> ();\nuint32_t interT = 600; // time between a retransmissions.\nstd::unordered_map<uint32_t,std::tuple<uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t> > errorMap;\n//errormap: transmitted, received, received unique, received original, xlocation, ylocation\nstd::unordered_map<uint32_t,Ptr<LoRaNetDevice> > deviceMap;\nMac32Address server;\nNetDeviceContainer gateways;\n/////////////////////////////////\n// End configuration\n/////////////////////////////////\n\n\tuint32_t \nGetClosestGateway (Ptr<MobilityModel> location)\n{\n\tuint32_t closestNode; \n\tdouble smallestDistance = 99999999;\n\tfor (uint32_t i = 0; i<gateways.GetN (); i++)\n\t{\n\t\tdouble distanceToI = location->GetDistanceFrom (gateways.Get(i)->GetNode ()->GetObject<MobilityModel> ());\n\t\tif (distanceToI < smallestDistance)\n\t\t{\n\t\t\tsmallestDistance = distanceToI;\n\t\t\tclosestNode = gateways.Get(i)->GetNode ()->GetId();\n\t\t}\n\t}\n\treturn closestNode;\n}\n\n\n/// Save that teh message has been transmitted\n\tvoid\nTransmitted (const Ptr<const Packet> packet)\n{\n\tPtr<Packet> copy = packet->Copy();\n\tLoRaMacHeader header;\n\tcopy->RemoveHeader(header);\n\tuint32_t addr = Mac32Address::ConvertFrom(header.GetAddr()).GetUInt();\n\t//std::tuple<uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t> tuple = errorMap[addr];\n\tstd::get<0>(errorMap[addr])++;// = std::make_tuple(++std::get<0>(tuple),std::get<1>(tuple),std::get<2>(tuple),std::get<3>(tuple),std::get<4>(tuple));\n}\n\n// save that a message has been received\n\tvoid\nReceived (const Ptr<const Packet> packet)\n{\n\tPtr<Packet> copy = packet->Copy();\n\tLoRaMacHeader header;\n\tcopy->RemoveHeader(header);\n\tGwTrailer trailer;\n\tcopy->RemoveTrailer (trailer);\n\tuint32_t addr = Mac32Address::ConvertFrom(header.GetAddr()).GetUInt();\n\tstd::get<1>(errorMap[addr])++;\n\tif ( trailer.GetGateway () == GetClosestGateway (deviceMap[addr]->GetNode ()->GetObject<MobilityModel>())) \n\t\tstd::get<3>(errorMap[addr])++;\n}\n\n// save that a message has been uniquely received\n\tvoid\nReceivedUnique (const Ptr<const Packet> packet)\n{\n\tPtr<Packet> copy = packet->Copy();\n\tLoRaMacHeader header;\n\tcopy->RemoveHeader(header);\n\tuint32_t addr = Mac32Address::ConvertFrom(header.GetAddr()).GetUInt();\n\tstd::get<2>(errorMap[addr])++;\n}\n\n\n\n/////////////////////////////\n// THIS IS THE ACTUAL CODE //\n/////////////////////////////\n\tint\nmainBody ()\n{\n\trandT->SetAttribute(\"Max\",DoubleValue(600));\n\t//Enable checksum (FCS)\n\tGlobalValue::Bind (\"ChecksumEnabled\", BooleanValue (true));\n\n\t// Logging\n\tif (verbose)\n\t{\n\t\tLogComponentEnableAll (LOG_PREFIX_TIME);\n\t\tLogComponentEnableAll (LOG_PREFIX_FUNC);\n\t}\n\n\t//Create nodes\n\tNodeContainer loraNetworkNode;\n\tloraNetworkNode.Create (1);\n\tNodeContainer loraCoordinatorNodes;\n\tloraCoordinatorNodes.Create (nGateways);\n\tNodeContainer loraDeviceNodes;\n\tloraDeviceNodes.Create(nSensors);\n\tNodeContainer loraBackendNodes(loraNetworkNode, loraCoordinatorNodes);\n\n\t//Create mobility of basestations\n\tMobilityHelper mobility;\n\tPtr<ListPositionAllocator> basePositionList = CreateObject<ListPositionAllocator> ();\n\tbasePositionList->Add (Vector (0.0,0.0,0.0)); //network\t\n\tbasePositionList->Add (Vector (1000,1000,50.0)); //main base station\t\n\tmobility.SetPositionAllocator (basePositionList);\n\tmobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n\tmobility.Install(loraBackendNodes);\n\n\n\t//Mobility nodes\n\tstd::cout << \"Create mobility of nodes\" << std::endl;\n\tMobilityHelper mobility2;\n\tPtr<ListPositionAllocator> nodePositionList = CreateObject<ListPositionAllocator>();\n\tfor(uint32_t nodePositionsAssigned = 0; nodePositionsAssigned < nSensors; nodePositionsAssigned++){\n\t\tdouble x,y;\n\t\tdo{\n\t\tx = randT->GetInteger(0,length);\n\t\ty = randT->GetInteger(0,length);\n\t\t}\n\t\twhile ((x-1000)*(x-1000)+(y-1000)*(y-1000) > 1000*1000);\n\t\tstd::cout << x << \",\" << y << std::endl;\n\t\tnodePositionList->Add (Vector (x,y,1.0));\n\t}\n\tmobility2.SetPositionAllocator (nodePositionList);\n\tmobility2.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n\tmobility2.Install (loraDeviceNodes);\n\t\n\n\n\t//Channel\n\tstd::cout << \"Create channel\" << std::endl;\n\tSpectrumChannelHelper channelHelper;\n\tchannelHelper.SetChannel (\"ns3::MultiModelSpectrumChannel\");\n\tif (nakagami)\n\t{\n\t\tchannelHelper.AddPropagationLoss (\"ns3::OkumuraHataPropagationLossModel\",\"Frequency\",DoubleValue(868e6));\n\t\tchannelHelper.AddPropagationLoss (\"ns3::NakagamiPropagationLossModel\",\"m0\",DoubleValue(1),\"m1\",DoubleValue(1),\"m2\",DoubleValue(1));\n\t}\n\telse\n\t{\n\t\tchannelHelper.AddPropagationLoss (\"ns3::OkumuraHataPropagationLossModel\",\"Frequency\",DoubleValue(868e6));\n\t}\n\tchannelHelper.SetPropagationDelay (\"ns3::ConstantSpeedPropagationDelayModel\");\n\tPtr<SpectrumChannel> channel = channelHelper.Create ();\n\tLoRaHelper lorahelper;\n\tlorahelper.SetChannel (channel);\n\n\n\t// Configure gateways\n\tstd::cout << \"Create gateways\" << std::endl;\n\tgateways = lorahelper.InstallGateways (loraCoordinatorNodes);\n\n\t// Create the nodes\n\tstd::cout << \"Create nodes\" << std::endl;\n\tNetDeviceContainer loraNetDevices;\n\tloraNetDevices = lorahelper.Install (loraDeviceNodes);\n\t\n\t// create energy source\n\tLoRaEnergySourceHelper sourceHelper;\n\tEnergySourceContainer energySources = sourceHelper.Install(loraDeviceNodes);\n\tLoRaRadioEnergyModelHelper radioHelper;\n\tDeviceEnergyModelContainer deviceModels = radioHelper.Install (loraNetDevices, energySources);\n\n\t// Connect gateways with network\n\tstd::cout << \"Create wired network\" << std::endl;\n\tCsmaHelper csma;\n\tcsma.SetChannelAttribute (\"DataRate\", StringValue (\"1000Mbps\"));\n\tcsma.SetChannelAttribute (\"Delay\", TimeValue (NanoSeconds (60)));\n\n\tstd::cout << \"Connect devices with wired network\" << std::endl;\n\tNetDeviceContainer csmaDevices;\n\tcsmaDevices = csma.Install (loraBackendNodes);\n\n\tstd::cout << \"Install IP/TCP\" << std::endl;\n\tInternetStackHelper stack;\n\tstack.Install (loraBackendNodes);\n\tIpv4AddressHelper address;\n\taddress.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n\tIpv4InterfaceContainer interfaces = address.Assign (csmaDevices);\n\n\t// set addresses \n\tstd::cout << \"Set the addresses\" << std::endl;\n\tlorahelper.FinishGateways (loraCoordinatorNodes, gateways, interfaces.GetAddress(0));\n\t// Reset the power after each succesfull message\n\tlorahelper.InstallNetworkApplication(\"ns3::LoRaNoPowerApplication\");\n\tPtr<LoRaNetwork> loraNetwork = lorahelper.InstallBackend (loraNetworkNode.Get (0),loraNetDevices);\n\n\t// Let the nodes generate data\n\tstd::cout << \" Generate data from the nodes in the LoRa network\" << std::endl;\n\tApplicationContainer apps = lorahelper.GenerateTraffic (randT, loraDeviceNodes, pktsize, 0, duration, 120, false);\n\n\t// hookup functions to the netdevices of each node to measure the performance\n\tfor (uint32_t i = 0; i< loraNetDevices.GetN(); i++)\n\t{\n\t\tdeviceMap[ Mac32Address::ConvertFrom(loraNetDevices.Get(i)->GetAddress()).GetUInt()]=DynamicCast<LoRaNetDevice>(loraNetDevices.Get(i));\n\t\tuint32_t x  = loraNetDevices.Get(i)->GetNode()->GetObject<MobilityModel>()->GetPosition ().x;\n\t\tuint32_t y  = loraNetDevices.Get(i)->GetNode()->GetObject<MobilityModel>()->GetPosition ().y;\n\t\terrorMap[ Mac32Address::ConvertFrom(loraNetDevices.Get(i)->GetAddress()).GetUInt()] = make_tuple (0,0,0,0,x,y);\n\t\tDynamicCast<LoRaNetDevice>(loraNetDevices.Get(i))->TraceConnectWithoutContext (\"MacTx\",MakeCallback(&Transmitted));\n\t}\n\n\t// hookup functions to the network for measuring performance\n\tloraNetwork->TraceConnectWithoutContext(\"NetRx\",MakeCallback(&ReceivedUnique));\n\tloraNetwork->TraceConnectWithoutContext(\"NetPromiscRx\",MakeCallback(&Received));\t\n\n\t// Start the simulation\n\tstd::cout << \"start the fun\" << std::endl;\n\tSimulator::Stop (Seconds (duration));\n\tSimulator::Run ();\n\n\tfor (uint8_t i = 1; i<= nSensors; i++)\n\t{\n\t//\tstd::cout << energySources.GetSize() << std::endl;\n\t\tstd::cout << energySources.Get(i-1)->GetRemainingEnergy();\n\t}\n\n\treturn 0;\n}\n\n\tint \nmain (int argc, char** argv)\n{\n\tAsciiTraceHelper ascii;\n\tm_stream = ascii.CreateFileStream(\"data.csv\");\n\t*m_stream->GetStream() << \"#Scenario \" << (int)nSensors <<  \" nodes with \" << (int)nGateways << \" gateways and \" << (int)nSensors << \" nodes on a square field with side \" << length << \" meter\" <<std::endl;\n\tfor (uint8_t iterationI=0;iterationI<10;iterationI++){\n\t\tstd::cout << \"Iteration: \" << (int)iterationI << std::endl;\n\t\tmainBody();\n\t\tfor ( auto it = errorMap.begin(); it !=errorMap.end();++it)\n\t\t{\n\t\t\tuint32_t addr = it->first;\n\t\t\tPtr<LoRaNetDevice> netdevice = deviceMap[addr];\n\t\t\tstd::tuple<uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t> tuple = it->second;\n\t\t\t// print ID, transmitted, received, received unique, received at closest gateway, x coords, y coords, get average amount of retransmissions, get average time of transmissions, number of missed messages, amount of received messages.\n\t\t\t*m_stream->GetStream() << addr << \",\" << std::get<0>(tuple)<< \",\" << std::get<1>(tuple) << \",\" <<   std::get<2>(tuple) << \",\" << std::get<3>(tuple) << \",\" << std::get<4>(tuple) << \",\" << std::get<5>(tuple) <<\",\"<< netdevice->GetAvgRetransmissionCount() << \",\" << netdevice->GetAvgTime() << \",\" << netdevice->GetMissed() << \",\" << netdevice->GetArrived() << std::endl;\n\t\t}\n\t\terrorMap.clear();\n\t\tSimulator::Destroy ();\n\t}\n\treturn 0;\n}\n\n"
    },
    {
      "file_path": "examples/rs-example.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2014 NXP\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Luis Pacheco <luisbelem@gmail.com>\n *         Peishuo Li <pressthunder@gmail.com>\n *\n * This example ilustrates the following 6 timeslot types:\n * - RxDataTxAck: a device receives a data pkt and sends an ack\n * - TxDataRxAck: a device transmits a data pkt and receives an ack\n * - TxData: a device transmits data and does not receive an ack\n * - RxData: a device receives data but does not send an ack\n * - Idle: a device waits for adata pkt does not receive one\n * - Sleep: the timeslot is not assigned for the device\n */\n#include \"ns3/non-communicating-net-device.h\"\n#include <ns3/okumura-hata-propagation-loss-model.h>\n#include <ns3/core-module.h>\n#include <ns3/packet.h>\n#include <ns3/lora-module.h>\n#include <ns3/spectrum-module.h>\n#include <ns3/mobility-module.h>\n#include <ns3/spectrum-value.h>\n#include <ns3/spectrum-analyzer.h>\n//#include <ns3/log.h>\n//#include <string>\n#include <iostream>\n#include <ns3/isotropic-antenna-model.h>\n#include <ns3/trace-helper.h>\n#include <ns3/drop-tail-queue.h>\n#include <unordered_map>\n#include \"ns3/network-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include <ns3/gw-trailer.h>\nNS_LOG_COMPONENT_DEFINE (\"lora\");\n\nusing namespace ns3;\nusing namespace std;\n\n/////////////////////////////////\n// Configuration\n/////////////////////////////////\n//std::vector <int, double> marked_list;\ndouble length = 2000;\t\t\t//!< Square city with length as distance\nint pktsize = 51;              //!< size of packets, in bytes\nint duration = 60*60;//10000;\t//!< Duration of the simulation\ndouble interval = 10;        // interval between packets, minutes\nbool verbose = false;          // enable logging (different from trace)\nbool nakagami = true;         // enable nakagami path loss\nbool dynamic = false;          // enable random moving of pan node\nuint32_t nSensors = 10; // numbenir of sent packets\nuint32_t nGateways = 1; // numbenir of sent packets\nPtr<OutputStreamWrapper> m_stream = 0; // stream for waterfallcurve\nPtr<UniformRandomVariable> randT = CreateObject<UniformRandomVariable> ();\nuint32_t interT = 600; // time between a retransmissions.\nstd::unordered_map<uint32_t,std::tuple<uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t> > errorMap;\n//errormap: transmitted, received, received unique, received original, xlocation, ylocation\nstd::unordered_map<uint32_t,Ptr<LoRaNetDevice> > deviceMap;\nMac32Address server;\nNetDeviceContainer gateways;\nuint8_t offsets [7] = {2,3,3,1,2,2,3};\n/////////////////////////////////\n// End configuration\n/////////////////////////////////\n\n\tuint32_t \nGetClosestGateway (Ptr<MobilityModel> location)\n{\n\tuint32_t closestNode; \n\tdouble smallestDistance = 99999999;\n\tfor (uint32_t i = 0; i<gateways.GetN (); i++)\n\t{\n\t\tdouble distanceToI = location->GetDistanceFrom (gateways.Get(i)->GetNode ()->GetObject<MobilityModel> ());\n\t\tif (distanceToI < smallestDistance)\n\t\t{\n\t\t\tsmallestDistance = distanceToI;\n\t\t\tclosestNode = gateways.Get(i)->GetNode ()->GetId();\n\t\t}\n\t}\n\treturn closestNode;\n}\n\n\n/// Save that teh message has been transmitted\n\tvoid\nTransmitted (const Ptr<const Packet> packet)\n{\n\tPtr<Packet> copy = packet->Copy();\n\tLoRaMacHeader header;\n\tcopy->RemoveHeader(header);\n\tuint32_t addr = Mac32Address::ConvertFrom(header.GetAddr()).GetUInt();\n\t//std::tuple<uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t> tuple = errorMap[addr];\n\tstd::get<0>(errorMap[addr])++;// = std::make_tuple(++std::get<0>(tuple),std::get<1>(tuple),std::get<2>(tuple),std::get<3>(tuple),std::get<4>(tuple));\n}\n\n// save that a message has been received\n\tvoid\nReceived (const Ptr<const Packet> packet)\n{\n\tPtr<Packet> copy = packet->Copy();\n\tLoRaMacHeader header;\n\tcopy->RemoveHeader(header);\n\tGwTrailer trailer;\n\tcopy->RemoveTrailer (trailer);\n\tuint32_t addr = Mac32Address::ConvertFrom(header.GetAddr()).GetUInt();\n\tstd::get<1>(errorMap[addr])++;\n\tif ( trailer.GetGateway () == GetClosestGateway (deviceMap[addr]->GetNode ()->GetObject<MobilityModel>())) \n\t\tstd::get<3>(errorMap[addr])++;\n}\n\n// save that a message has been uniquely received\n\tvoid\nReceivedUnique (const Ptr<const Packet> packet)\n{\n\tPtr<Packet> copy = packet->Copy();\n\tLoRaMacHeader header;\n\tcopy->RemoveHeader(header);\n\tuint32_t addr = Mac32Address::ConvertFrom(header.GetAddr()).GetUInt();\n\tstd::get<2>(errorMap[addr])++;\n}\n\n\tint\nmainBody ()\n{\n\trandT->SetAttribute(\"Max\",DoubleValue(600));\n\t//Enable checksum (FCS)\n\tGlobalValue::Bind (\"ChecksumEnabled\", BooleanValue (true));\n\n\t// Logging\n\tif (verbose)\n\t{\n\t\tLogComponentEnableAll (LOG_PREFIX_TIME);\n\t\tLogComponentEnableAll (LOG_PREFIX_FUNC);\n\t}\n\n\t//Create nodes\n\tNodeContainer loraNetworkNode;\n\tloraNetworkNode.Create (1);\n\tNodeContainer loraCoordinatorNodes;\n\tloraCoordinatorNodes.Create (nGateways);\n\tNodeContainer loraDeviceNodes;\n\tloraDeviceNodes.Create(nSensors);\n\tNodeContainer loraBackendNodes(loraNetworkNode, loraCoordinatorNodes);\n\n\t//std::cout << \"Create mobility of basestations\" << std::endl;\n\tMobilityHelper mobility;\n\tPtr<ListPositionAllocator> basePositionList = CreateObject<ListPositionAllocator> ();\n\tbasePositionList->Add (Vector (0.0,0.0,0.0)); //network\t\n\t//basePositionList->Add (Vector (1000,500,50.0)); //main base station\t\n\t//basePositionList->Add (Vector (2000,500,50.0)); //main base station\t\n\t//basePositionList->Add (Vector (500,std::sqrt(3)*500+500,50.0)); //main base station\t\n\t//basePositionList->Add (Vector (1500,std::sqrt(3)*500+500,50.0)); //main base station\t\n\tbasePositionList->Add (Vector (1000,1000,50));//std::sqrt(3)*500+500,50.0)); //main base station\t\n\t//basePositionList->Add (Vector (2500,std::sqrt(3)*500+500,50.0)); //main base station\t\n\t//basePositionList->Add (Vector (1000,std::sqrt(3)*500*2+500,50.0)); //main base station\t\n\t//basePositionList->Add (Vector (2000,std::sqrt(3)*500*2+500,50.0)); //main base station\t\n\tmobility.SetPositionAllocator (basePositionList);\n\tmobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n\tmobility.Install(loraBackendNodes);\n\n\t//Mobility nodes\n\tstd::cout << \"Create mobility of nodes\" << std::endl;\n\tMobilityHelper mobility2;\n\tPtr<ListPositionAllocator> nodePositionList = CreateObject<ListPositionAllocator>();\n\tfor(uint32_t nodePositionsAssigned = 0; nodePositionsAssigned < nSensors; nodePositionsAssigned++){\n\t\tdouble x,y;\n\t\tdo{\n\t\tx = randT->GetInteger(0,length);\n\t\ty = randT->GetInteger(0,length);\n\t\t}\n\t\twhile ((x-1000)*(x-1000)+(y-1000)*(y-1000) > 1000*1000);\n\t\tstd::cout << x << \",\" << y << std::endl;\n\t\tnodePositionList->Add (Vector (x,y,1.0));\n\t}\n\tmobility2.SetPositionAllocator (nodePositionList);\n\tmobility2.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n\tmobility2.Install (loraDeviceNodes);\n\n\n\t//Channel\n\tstd::cout << \"Create channel\" << std::endl;\n\tSpectrumChannelHelper channelHelper;\n\tchannelHelper.SetChannel (\"ns3::MultiModelSpectrumChannel\");\n\tif (nakagami)\n\t{\n\t\tchannelHelper.AddPropagationLoss (\"ns3::OkumuraHataPropagationLossModel\",\"Frequency\",DoubleValue(868e6));\n\t\tchannelHelper.AddPropagationLoss (\"ns3::NakagamiPropagationLossModel\",\"m0\",DoubleValue(1),\"m1\",DoubleValue(1),\"m2\",DoubleValue(1));\n\t}\n\telse\n\t{\n\t\tchannelHelper.AddPropagationLoss (\"ns3::OkumuraHataPropagationLossModel\",\"Frequency\",DoubleValue(868e6));\n\t}\n\tchannelHelper.SetPropagationDelay (\"ns3::ConstantSpeedPropagationDelayModel\");\n\tPtr<SpectrumChannel> channel = channelHelper.Create ();\n\tLoRaHelper lorahelper;\n\tlorahelper.SetChannel (channel);\n\n\n\t// Configure gateways\n\tstd::cout << \"Create gateways\" << std::endl;\n\tgateways = lorahelper.InstallRsGateways (loraCoordinatorNodes);\n\tfor (uint32_t i = 0; i< gateways.GetN(); i++)\n\t\tgateways.Get(i)->SetAttribute (\"Offset\",UintegerValue(offsets[i]-1));\n\n\t// Create the nodes\n\tstd::cout << \"Create nodes\" << std::endl;\n\tNetDeviceContainer loraNetDevices;\n\tloraNetDevices = lorahelper.InstallRs (loraDeviceNodes);\n\tfor (uint32_t i = 0; i< loraNetDevices.GetN (); i++)\n\t{\n\t\t// this is a dirty workaround. Make sure to create first the network and then the gateways\n\t\tloraNetDevices.Get(i)->SetAttribute (\"Offset2\",UintegerValue(offsets[GetClosestGateway(loraNetDevices.Get(i)->GetNode()->GetObject<MobilityModel>())-1]-1));\n\t\tuint32_t x  = loraNetDevices.Get(i)->GetNode()->GetObject<MobilityModel>()->GetPosition ().x;\n\t\tuint32_t y  = loraNetDevices.Get(i)->GetNode()->GetObject<MobilityModel>()->GetPosition ().y;\n\t\tstd::cout << x << \",\" << y << \",\" << (uint32_t)offsets[GetClosestGateway(loraNetDevices.Get(i)->GetNode()->GetObject<MobilityModel>())-1] << std::endl;;\n\t}\n\n\t// Connect gateways with network\n\tstd::cout << \"Create wired network\" << std::endl;\n\tCsmaHelper csma;\n\tcsma.SetChannelAttribute (\"DataRate\", StringValue (\"1000Mbps\"));\n\tcsma.SetChannelAttribute (\"Delay\", TimeValue (NanoSeconds (60)));\n\n\tstd::cout << \"Connect devices with wired network\" << std::endl;\n\tNetDeviceContainer csmaDevices;\n\tcsmaDevices = csma.Install (loraBackendNodes);\n\n\tstd::cout << \"Install IP/TCP\" << std::endl;\n\tInternetStackHelper stack;\n\tstack.Install (loraBackendNodes);\n\tIpv4AddressHelper address;\n\taddress.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n\tIpv4InterfaceContainer interfaces = address.Assign (csmaDevices);\n\n\t// set addresses \n\tstd::cout << \"Set the addresses\" << std::endl;\n\tlorahelper.FinishGateways (loraCoordinatorNodes, gateways, interfaces.GetAddress(0));\n\tPtr<LoRaNetwork> loraNetwork = lorahelper.InstallBackend (loraNetworkNode.Get (0),loraNetDevices);\n\n\t// Let the nodes generate data\n\tstd::cout << \" Generate data from the nodes in the LoRa network\" << std::endl;\n\tApplicationContainer apps = lorahelper.GenerateTraffic (randT, loraDeviceNodes, pktsize, 0, duration, 120);\n\n\t// hookup functions to the netdevices of each node to measure the performance\n\tfor (uint32_t i = 0; i< loraNetDevices.GetN(); i++)\n\t{\n\t\tdeviceMap[ Mac32Address::ConvertFrom(loraNetDevices.Get(i)->GetAddress()).GetUInt()]=DynamicCast<LoRaNetDevice>(loraNetDevices.Get(i));\n\t\tuint32_t x  = loraNetDevices.Get(i)->GetNode()->GetObject<MobilityModel>()->GetPosition ().x;\n\t\tuint32_t y  = loraNetDevices.Get(i)->GetNode()->GetObject<MobilityModel>()->GetPosition ().y;\n\t\terrorMap[ Mac32Address::ConvertFrom(loraNetDevices.Get(i)->GetAddress()).GetUInt()] = make_tuple (0,0,0,0,x,y);\n\t\tDynamicCast<LoRaNetDevice>(loraNetDevices.Get(i))->TraceConnectWithoutContext (\"MacTx\",MakeCallback(&Transmitted));\n\t}\n\n\t// hookup functions to the network for measuring performance\n\tloraNetwork->TraceConnectWithoutContext(\"NetRx\",MakeCallback(&ReceivedUnique));\n\tloraNetwork->TraceConnectWithoutContext(\"NetPromiscRx\",MakeCallback(&Received));\t\n\n\t// Start the simulation\n\tstd::cout << \"start the fun\" << std::endl;\n\tSimulator::Stop (Seconds (duration));\n\tSimulator::Run ();\n\n\treturn 0;\n}\n\n\tint \nmain (int argc, char** argv)\n{\n\tAsciiTraceHelper ascii;\n\tm_stream = ascii.CreateFileStream(\"data7loraTSCH1_100.csv\");\n\t*m_stream->GetStream() << \"#Scenario 100 nodes with \" << (int)nGateways << \" gateways and \" << (int)nSensors << \" nodes on a square field with side \" << length << \" meter\" <<std::endl;\n\tfor (uint8_t iterationI=0;iterationI<10;iterationI++){\n\t\tstd::cout << \"Iteration: \" << (int)iterationI << std::endl;\n\t\tmainBody();\n\t\tfor ( auto it = errorMap.begin(); it !=errorMap.end();++it)\n\t\t{\n\t\t\tuint32_t addr = it->first;\n\t\t\tPtr<LoRaNetDevice> netdevice = deviceMap[addr];\n\t\t\tstd::tuple<uint32_t,uint32_t,uint32_t,uint32_t,uint32_t,uint32_t> tuple = it->second;\n\t\t\t*m_stream->GetStream() << addr << \",\" << std::get<0>(tuple)<< \",\" << std::get<1>(tuple) << \",\" <<   std::get<2>(tuple) << \",\" << std::get<3>(tuple) << \",\" << std::get<4>(tuple) << \",\" << std::get<5>(tuple) <<\",\"<< netdevice->GetAvgRetransmissionCount() << \",\" << netdevice->GetAvgTime() << \",\" << netdevice->GetMissed() << \",\" << netdevice->GetArrived() << std::endl;\n\t\t}\n\t\terrorMap.clear();\n\t\tSimulator::Destroy ();\n\t}\n\treturn 0;\n}\n\n"
    }
  ]
}