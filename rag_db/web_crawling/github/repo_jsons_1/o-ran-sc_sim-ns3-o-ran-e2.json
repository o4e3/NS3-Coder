{
  "repo_name": "o-ran-sc/sim-ns3-o-ran-e2",
  "github_url": "https://github.com/o-ran-sc/sim-ns3-o-ran-e2",
  "readme": "# ns3-o-ran-e2 aka ns-O-RAN\n\n================================\n\nThis ns-3 module enables the support for running multiple terminations of an O-RAN-compliant E2 interface inside the simulation process.\nThis module has been developed by a team at the [Institute for the Wireless Internet of Things (WIoT)](https://wiot.northeastern.edu) at Northeastern University, in collaboration with Sapienza University of Rome, the University of Padova and with support from Mavenir.\n\n## How to use\n\nThis module can be used with an extension of the [ns3-mmWave module](https://github.com/wineslab/ns-o-ran-ns3-mmwave).\nThis repository must be cloned in the `contrib` folder.\nMoreover, our custom version of the [e2sim library](https://github.com/wineslab/o-ran-e2sim) must be installed.\nPlease refer to this [quick start guide](https://openrangym.com/tutorials/ns-o-ran) that presents a tutorial to bridge ns-O-RAN and Colosseum RIC (i.e., OSC RIC bronze reduced) ns-O-RAN.\n\nAdditional material:\n\n- Framework presentation https://openrangym.com/ran-frameworks/ns-o-ran \n- Tutorial OSC RIC version E ns-O-RAN connection  https://www.nsnam.org/tutorials/consortium23/oran-tutorial-slides-wns3-2023.pdf \n- Recording of the tutorial OSC RIC version E done at the WNS3 2023 https://vimeo.com/867704832 \n- xApp repositories working with ns-O-RAN:\n  - https://github.com/wineslab/ns-o-ran-scp-ric-app-kpimon \n  - https://github.com/wineslab/ns-o-ran-xapp-rc \n- Gymnasium Environment wrapper for ns-O-RAN https://github.com/wineslab/ns-o-ran-gym-environment\n\n## References\n\nMore information can be found in the technical paper:\n\n> A. Lacava, M. Bordin, M. Polese, R. Sivaraj, T. Zugno, F. Cuomo, and T. Melodia. \"ns-O-RAN: Simulating O-RAN 5G Systems in ns-3\", Proceedings of the 2023 Workshop on ns-3 (2023), [DOI:10.1145/3592149.3592161](https://dl.acm.org/doi/abs/10.1145/3592149.3592161)\n\nIf you use the scenario-one.cc or the traffic steering implementation please cite:\n\n>A. Lacava, M. Polese, R. Sivaraj, R. Soundrarajan, B. Bhati, T. Singh, T. Zugno, F. Cuomo, and T. Melodia. \"Programmable and Customized Intelligence for Traffic Steering in 5G Networks Using Open RAN Architectures\", IEEE Transactions on Mobile Computing (2024), [DOI:10.1109/TMC.2023.3266642](https://doi.org/10.1109/TMC.2023.3266642) [pdf](https://ieeexplore.ieee.org/document/10102369) [bibtex](https://ece.northeastern.edu/wineslab/wines_bibtex/andrea/LacavaAMC22.txt)\n\n## Authors\n\nThe ns3-o-ran-e2 module is the result of the development effort carried out by different people. The main contributors are:\n\n- Andrea Lacava, Northeastern University and Sapienza University of Rome\n- Michele Polese, Northeastern University\n- Tommaso Zugno, University of Padova\n- Rajarajan Sivaraj and team, Mavenir\n\nWe welcome contributions through pull requests.\n",
  "examples": [
    {
      "file_path": "examples/e2sim-integration-example.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2022 Northeastern University\n * Copyright (c) 2022 Sapienza, University of Rome\n * Copyright (c) 2022 University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Andrea Lacava <thecave003@gmail.com>\n *\t\t   Tommaso Zugno <tommasozugno@gmail.com>\n *\t\t   Michele Polese <michele.polese@gmail.com>\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/oran-interface.h\"\n\nextern \"C\" {\n  // #include \"OCUCP-PF-Container.h\"\n  #include \"OCTET_STRING.h\"\n  #include \"asn_application.h\"\n  // #include \"E2SM-KPM-IndicationMessage.h\"\n  // #include \"FQIPERSlicesPerPlmnListItem.h\"\n  // #include \"E2SM-KPM-RANfunction-Description.h\"\n  // #include \"E2SM-KPM-IndicationHeader-Format1.h\"\n  // #include \"E2SM-KPM-IndicationHeader.h\"\n  // #include \"Timestamp.h\"\n  #include \"E2AP-PDU.h\"\n  #include \"RICsubscriptionRequest.h\"\n  #include \"RICsubscriptionResponse.h\"\n  #include \"RICactionType.h\"\n  #include \"ProtocolIE-Field.h\"\n  #include \"ProtocolIE-SingleContainer.h\"\n  #include \"InitiatingMessage.h\"\n}\n\n#include \"e2sim.hpp\"\n\nusing namespace ns3;\n\nint \nmain (int argc, char *argv[])\n{\n  E2Sim e2sim;\n  e2sim.run_loop (argc, argv);\n  \n  Simulator::Run ();\n  Simulator::Destroy ();\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/encode-decode-indication.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2022 Northeastern University\n * Copyright (c) 2022 Sapienza, University of Rome\n * Copyright (c) 2022 University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Andrea Lacava <thecave003@gmail.com>\n *\t\t   Tommaso Zugno <tommasozugno@gmail.com>\n *\t\t   Michele Polese <michele.polese@gmail.com>\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/oran-interface.h\"\n#include <errno.h>\n#include <E2SM-KPM-IndicationMessage-Format1.h>\n#include <PM-Containers-Item.h>\n#include \"ProtocolIE-Field.h\"\n#include \"CellResourceReportListItem.h\"\n#include \"ServedPlmnPerCellListItem.h\"\n#include \"EPC-DU-PM-Container.h\"\n#include \"FGC-DU-PM-Container.h\"\n#include \"PerQCIReportListItem.h\"\n\nusing namespace ns3;\nNS_LOG_COMPONENT_DEFINE (\"EncodeDecodeIndication\");\n\nstd::string DecodeOctectString(OCTET_STRING_t* octetString){\n  int size = octetString->size;\n  char out[size + 1];\n  std::memcpy (out, octetString->buf, size);\n  out[size] = '\\0';\n\n  return std::string (out);\n}\n\nvoid\nreadPfDuContainer (ODU_PF_Container_t *oDU)\n{\n  int count = oDU->cellResourceReportList.list.count;\n  if (count <= 0) {\n    NS_LOG_ERROR(\"[E2SM] received empty ODU list\");\n    return;\n  }\n\n  for (int i = 0; i < count; i++)\n  {\n    CellResourceReportListItem_t *report = oDU->cellResourceReportList.list.array[i];\n    // NS_LOG_UNCOND (\"CellResourceReportListItem \" << i);\n    // NS_LOG_UNCOND (xer_fprint (stderr, &asn_DEF_CellResourceReportListItem, report));\n    NS_LOG_UNCOND (\"NRCGI\");\n    NS_LOG_UNCOND (\"Buf PlmNID: \" << report->nRCGI.pLMN_Identity.buf);\n    NS_LOG_UNCOND (\"String PlmNID: \" << std::string (DecodeOctectString(&report->nRCGI.pLMN_Identity)));\n    \n    // TODO Decode the report->nRCGI.nRCellIdentity to a std::string\n    // It's a bitstring I don't know how to do it\n\n    long ulTotalOfAvailablePRBs = *(report->ul_TotalofAvailablePRBs);\n    long dlTotalOfAvailablePRBs = *(report->dl_TotalofAvailablePRBs);\n    NS_LOG_UNCOND (\"UL Total of Available PRBs: \" << ulTotalOfAvailablePRBs);\n    NS_LOG_UNCOND(\"DL Total of Available PRBs: \" << dlTotalOfAvailablePRBs);\n\n    for (int j = 0; j < report->servedPlmnPerCellList.list.count; j++)\n    {\n      ServedPlmnPerCellListItem_t *servedPlmnPerCell = report->servedPlmnPerCellList.list.array[j];\n      NS_LOG_UNCOND (\"ServedPLMNPerCell \" << j << \" with PlmNID: \" << DecodeOctectString(&servedPlmnPerCell->pLMN_Identity));\n      // NS_LOG_UNCOND (xer_fprint (stderr, &asn_DEF_ServedPlmnPerCellListItem, servedPlmnPerCell));\n      \n      FGC_DU_PM_Container_t* fgcDuPmContainer = servedPlmnPerCell->du_PM_5GC;\n      if (fgcDuPmContainer != NULL)\n      {\n        NS_LOG_UNCOND (\"5GC DU PM Container\");\n        NS_LOG_UNCOND (xer_fprint (stderr, &asn_DEF_FGC_DU_PM_Container, fgcDuPmContainer));\n      }\n\n      EPC_DU_PM_Container_t *epcDuPmContainer = servedPlmnPerCell->du_PM_EPC;\n      if(epcDuPmContainer != NULL)\n      {\n        NS_LOG_UNCOND (\"EPC DU PM Container\");\n        // NS_LOG_UNCOND (xer_fprint (stderr, &asn_DEF_EPC_DU_PM_Container, epcDuPmContainer));\n\n        for (int z = 0; z < epcDuPmContainer->perQCIReportList_du.list.count; z++)\n          {\n            PerQCIReportListItem_t * perQCIReportItem = epcDuPmContainer->perQCIReportList_du.list.array[z];\n            long dlPrbUsage = *perQCIReportItem->dl_PRBUsage;\n            long ulPrbUsage = *perQCIReportItem->ul_PRBUsage;\n            long qci =  perQCIReportItem->qci;\n\n            NS_LOG_UNCOND (\"QCI \" << qci << \", dlPrbUsage: \" << dlPrbUsage\n                                  << \", ulPrbUsage: \" << ulPrbUsage);\n          }\n      }\n \n    }\n\n  }\n}\n\nvoid\nreadPfCuContainer (OCUCP_PF_Container_t *oCU_CP)\n{\n  // Decode the values in container and create a variable for each decoded values and then print on screen with UNCOND\n  NS_LOG_UNCOND (xer_fprint (stderr, &asn_DEF_OCUCP_PF_Container, oCU_CP));\n  NS_LOG_UNCOND (\"OCUCP_PF_Container_t\");\n  long numActiveUes = *oCU_CP->cu_CP_Resource_Status.numberOfActive_UEs;\n  NS_LOG_UNCOND (numActiveUes);\n}\n\nvoid\nreadPfCuContainer (OCUUP_PF_Container_t *oCU_UP)\n{\n}\n\nvoid\nProcessIndicationMessage (E2SM_KPM_IndicationMessage_t *indMsg)\n{\n  if (indMsg->present == E2SM_KPM_IndicationMessage_PR_indicationMessage_Format1)\n  {\n    NS_LOG_UNCOND (\"Format 1 present\\n\");\n\n    E2SM_KPM_IndicationMessage_Format1_t *e2SmIndicationMessageFormat1 = indMsg->choice.indicationMessage_Format1;\n\n    // extract RAN container, which is where we put our payload\n    std::vector<uint8_t *> serving_cell_payload_vec;\n    std::vector<uint8_t *> neighbor_cell_payload_vec;\n    for (int i = 0; i < e2SmIndicationMessageFormat1->pm_Containers.list.count; i++){\n      PM_Containers_Item_t *pmContainer = e2SmIndicationMessageFormat1->pm_Containers.list.array[i];\n      // NS_LOG_UNCOND (\"PM Container\");\n      // NS_LOG_UNCOND (xer_fprint (stderr, &asn_DEF_PM_Containers_Item, pmContainer));\n      PF_Container_t *pfContainer = pmContainer->performanceContainer;\n      switch (pfContainer->present)\n        {\n        case PF_Container_PR_NOTHING:\n          NS_LOG_ERROR (\"PF Container is empty\");\n          break;\n        case PF_Container_PR_oDU:\n          // NS_LOG_UNCOND (\"oDU PF Container\");\n          // NS_LOG_UNCOND (xer_fprint (stderr, &asn_DEF_PF_Container, pfContainer));\n          readPfDuContainer (pfContainer->choice.oDU);\n          break;\n        case PF_Container_PR_oCU_CP:\n          // NS_LOG_UNCOND (\"oCU CP PF Container\");\n          // NS_LOG_UNCOND (xer_fprint (stderr, &asn_DEF_PF_Container, pfContainer));\n          readPfCuContainer (pfContainer->choice.oCU_CP);\n          break;\n\n        case PF_Container_PR_oCU_UP:\n          // NS_LOG_UNCOND (\"oCU UP PF Container\");\n          // NS_LOG_UNCOND (xer_fprint (stderr, &asn_DEF_PF_Container, pfContainer));\n          readPfCuContainer (pfContainer->choice.oCU_UP);\n          break;\n\n        default:\n          NS_LOG_ERROR (\"PF Container not supported\");\n          break;\n        }\n    }\n\n    //                        // combine content of vectors, there should be a single entry in the vector anyway\n    //                        std::ostringstream serving_cell_payload_oss;\n    //                        std::copy(serving_cell_payload_vec.begin(), serving_cell_payload_vec.end() - 1, std::ostream_iterator<uint8_t*>(serving_cell_payload_oss, \", \"));\n    //                        serving_cell_payload_oss << serving_cell_payload_vec.back();\n    //                        std::string serving_cell_payload = serving_cell_payload_oss.str();\n    //\n    //                        std::ostringstream neighbor_cell_payload_oss;\n    //                        std::copy(neighbor_cell_payload_vec.begin(), neighbor_cell_payload_vec.end() - 1, std::ostream_iterator<uint8_t*>(neighbor_cell_payload_oss, \", \"));\n    //                        neighbor_cell_payload_oss << neighbor_cell_payload_vec.back();\n    //                        std::string neighbor_cell_payload = neighbor_cell_payload_oss.str();\n    //\n    //                        NS_LOG_UNCOND( \"String conversion: serving_Cell_RF_Type %s, neighbor_Cell_RF: %s\\n\", serving_cell_payload.c_str(), neighbor_cell_payload.c_str());\n    //\n    //                        // assemble final payload\n    //                        if (serving_cell_payload.length() > 0 && neighbor_cell_payload.length() > 0) {\n    //                            payload = serving_cell_payload + \", \" + neighbor_cell_payload;\n    //                        }\n    //                        else if (serving_cell_payload.length() > 0 && neighbor_cell_payload.length() == 0) {\n    //                            payload = serving_cell_payload;\n    //                        }\n    //                        else if (serving_cell_payload.length() == 0 && neighbor_cell_payload.length() > 0) {\n    //                            payload = neighbor_cell_payload;\n    //                        }\n    //                        else {\n    //                            payload = \"\";\n    //                        }\n    //\n    //                        NS_LOG_UNCOND( \"Payload from RIC Indication message: %s\\n\", payload.c_str());\n  }\n  else\n  {\n    NS_LOG_UNCOND (\"No payload received in RIC Indication message (or was unable to decode \"\n                   \"received payload\\n\");\n  }\n  //                    add_gnb_to_vector_unique(gnb_id);\n  //\n  //                    if (payload.length() > 0) {\n  //                        // add gnb id to payload\n  //                        payload += \"\\n{\\\"gnb_id\\\": \\\"\" + std::string(reinterpret_cast<char const*>(gnb_id)) + \"\\\"}\";\n  //\n  //                        NS_LOG_UNCOND( \"Sending RIC Indication message to agent\\n\");\n  //                        send_socket(payload.c_str());\n  //                    }\n  //                    else if (payload.length() <= 0) {\n  //                        NS_LOG_UNCOND( \"Received empty payload\\n\");\n  //                    }\n  //                    else {\n  //                        NS_LOG_UNCOND( \"Returned empty agent IP\\n\");\n  //                    }\n}\n\nvoid\nDecodeIndicationMessage (Ptr<KpmIndicationMessage> msg)\n{\n  asn_dec_rval_t decode_result;\n  E2SM_KPM_IndicationMessage_t *indMsg = 0;\n\n  decode_result = aper_decode_complete (NULL, &asn_DEF_E2SM_KPM_IndicationMessage,\n                                        (void **) &indMsg, msg->m_buffer, msg->m_size);\n\n  if (decode_result.code == RC_OK)\n    {\n      NS_LOG_UNCOND (\"Decode OKAY\");\n      // NS_LOG_UNCOND (xer_fprint (stderr, &asn_DEF_E2SM_KPM_IndicationMessage, indMsg));\n      ProcessIndicationMessage (indMsg);\n    }\n  else\n    {\n      ASN_STRUCT_FREE (asn_DEF_E2SM_KPM_IndicationMessage, indMsg);\n      NS_LOG_UNCOND (\"DECODE NOT OKAY\");\n    }\n}\n\n/**\n* Create and encode RIC Indication messages.\n* Prints the encoded messages in XML format. \n*/\n\nint \nmain (int argc, char *argv[])\n{\n  // LogComponentEnable (\"Asn1Types\", LOG_LEVEL_ALL);\n  LogComponentEnable (\"KpmIndication\", LOG_LEVEL_INFO);\n  \n  std::string plmId = \"111\";\n  std::string gnbId = \"1\";\n  uint16_t nrCellId = 5;\n\n  uint64_t timestamp = 1630068655325;\n\n  NS_LOG_UNCOND (\"----------- Begin of Kpm Indication header -----------\");\n\n  KpmIndicationHeader::KpmRicIndicationHeaderValues headerValues; \n  headerValues.m_plmId = plmId;\n  headerValues.m_gnbId = gnbId;\n  headerValues.m_nrCellId = nrCellId;\n  headerValues.m_timestamp = timestamp;\n\n  Ptr<KpmIndicationHeader> header = Create<KpmIndicationHeader> (KpmIndicationHeader::GlobalE2nodeType::eNB, headerValues);\n  \n  NS_LOG_UNCOND (\"----------- End of the Kpm Indication header -----------\");\n\n  NS_LOG_UNCOND (\"----------- Start decode of Header -----------\");\n  asn_dec_rval_t decode_header_result;\n  E2SM_KPM_IndicationHeader_t *indHdr = 0;\n  decode_header_result = aper_decode_complete(NULL, &asn_DEF_E2SM_KPM_IndicationHeader, (void **)&indHdr, header->m_buffer,\n  header->m_size);\n   if(decode_header_result.code == RC_OK) {\n       NS_LOG_UNCOND (\"Decode OKAY\");\n       NS_LOG_UNCOND (xer_fprint (stderr, &asn_DEF_E2SM_KPM_IndicationHeader, indHdr));\n    }\n    else {\n        ASN_STRUCT_FREE(asn_DEF_E2SM_KPM_IndicationHeader, indHdr);\n        NS_LOG_UNCOND (\"DECODE NOT OKAY\");\n    }\n  NS_LOG_UNCOND (\"----------- End test of decode header -----------\");\n\n\n  NS_LOG_UNCOND (\"----------- Begin test of the DU message -----------\");\n  KpmIndicationMessage::KpmIndicationMessageValues msgValues3;\n  msgValues3.m_cellObjectId = \"NRCellCU\";\n\n  Ptr<ODuContainerValues> oDuContainerVal = Create<ODuContainerValues> ();\n  Ptr<CellResourceReport> cellResRep = Create<CellResourceReport> ();\n  cellResRep->m_plmId = \"111\";\n  // std::stringstream ss;\n  // ss << std::hex << 1340012;\n  cellResRep->m_nrCellId = 2;\n  cellResRep->dlAvailablePrbs = 6;\n  cellResRep->ulAvailablePrbs = 6;\n\n    Ptr<CellResourceReport> cellResRep2 = Create<CellResourceReport> ();\n  cellResRep2->m_plmId = \"444\";\n  cellResRep2->m_nrCellId = 3;\n  cellResRep2->dlAvailablePrbs = 5;\n  cellResRep2->ulAvailablePrbs = 5;\n\n  Ptr<ServedPlmnPerCell> servedPlmnPerCell = Create<ServedPlmnPerCell> ();\n  servedPlmnPerCell->m_plmId = \"121\";\n  servedPlmnPerCell->m_nrCellId = 3;\n\n  Ptr<ServedPlmnPerCell> servedPlmnPerCell2 = Create<ServedPlmnPerCell> ();\n  servedPlmnPerCell2->m_plmId = \"121\";\n  servedPlmnPerCell2->m_nrCellId = 2;\n\n  Ptr<EpcDuPmContainer> epcDuVal = Create<EpcDuPmContainer> ();\n  epcDuVal->m_qci = 1;\n  epcDuVal->m_dlPrbUsage = 1;\n  epcDuVal->m_ulPrbUsage = 2;\n\n  Ptr<EpcDuPmContainer> epcDuVal2 = Create<EpcDuPmContainer> ();\n  epcDuVal2->m_qci = 1;\n  epcDuVal2->m_dlPrbUsage = 3;\n  epcDuVal2->m_ulPrbUsage = 4;\n\n  servedPlmnPerCell->m_perQciReportItems.insert (epcDuVal);\n  servedPlmnPerCell->m_perQciReportItems.insert (epcDuVal2);\n  servedPlmnPerCell2->m_perQciReportItems.insert (epcDuVal);\n  servedPlmnPerCell2->m_perQciReportItems.insert (epcDuVal2);\n  cellResRep->m_servedPlmnPerCellItems.insert (servedPlmnPerCell2);\n  cellResRep->m_servedPlmnPerCellItems.insert (servedPlmnPerCell);\n  cellResRep2->m_servedPlmnPerCellItems.insert (servedPlmnPerCell2);\n  cellResRep2->m_servedPlmnPerCellItems.insert (servedPlmnPerCell);\n  \n  oDuContainerVal->m_cellResourceReportItems.insert (cellResRep);\n  oDuContainerVal->m_cellResourceReportItems.insert (cellResRep2);\n\n  Ptr<MeasurementItemList> ue5DummyValues = Create<MeasurementItemList> (\"UE-5\");\n  ue5DummyValues->AddItem<long> (\"DRB.EstabSucc.5QI.UEID\", 6);\n  ue5DummyValues->AddItem<long> (\"DRB.RelActNbr.5QI.UEID\", 7);\n  msgValues3.m_ueIndications.insert (ue5DummyValues);\n\n  msgValues3.m_pmContainerValues = oDuContainerVal;\n  Ptr<KpmIndicationMessage> msg = Create<KpmIndicationMessage> (msgValues3);\n  \n  NS_LOG_UNCOND (\"----------- End test of the DU message -----------\");\n\n  NS_LOG_UNCOND (\"----------- Start decode of DU message -----------\");\n  DecodeIndicationMessage (msg);\n  NS_LOG_UNCOND (\"----------- End test of decode DU message -----------\");\n\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/l3-rrc-example.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2022 Northeastern University\n * Copyright (c) 2022 Sapienza, University of Rome\n * Copyright (c) 2022 University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Andrea Lacava <thecave003@gmail.com>\n *\t\t   Tommaso Zugno <tommasozugno@gmail.com>\n *\t\t   Michele Polese <michele.polese@gmail.com>\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/oran-interface.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"L3RrcExample\");\n\nPtr<L3RrcMeasurements>\nCreateL3RrcUeSpecificSinrServing (long servingCellId, long physCellId, long sinr)\n{\n  Ptr<L3RrcMeasurements> l3RrcMeasurement = Create<L3RrcMeasurements> (RRCEvent_b1);\n  Ptr<ServingCellMeasurementsWrap> servingCellMeasurements =\n      Create<ServingCellMeasurementsWrap> (ServingCellMeasurements_PR_nr_measResultServingMOList);\n\n  Ptr<MeasResultNr> measResultNr = Create<MeasResultNr> (physCellId);\n  Ptr<MeasQuantityResultsWrap> measQuantityResultWrap = Create<MeasQuantityResultsWrap> ();\n  measQuantityResultWrap->AddSinr (sinr);\n  measResultNr->AddCellResults (MeasResultNr::SSB, measQuantityResultWrap->GetPointer ());\n  Ptr<MeasResultServMo> measResultServMo =\n      Create<MeasResultServMo> (servingCellId, measResultNr->GetValue ());\n  servingCellMeasurements->AddMeasResultServMo (measResultServMo->GetPointer ());\n  l3RrcMeasurement->AddServingCellMeasurement (servingCellMeasurements->GetPointer ());\n  return l3RrcMeasurement;\n}\n\nPtr<L3RrcMeasurements>\nCreateL3RrcUeSpecificSinrNeigh (long neighCellId, long sinr)\n{\n  Ptr<L3RrcMeasurements> l3RrcMeasurement = Create<L3RrcMeasurements> (RRCEvent_b1);\n  Ptr<MeasResultNr> measResultNr = Create<MeasResultNr> (neighCellId);\n  Ptr<MeasQuantityResultsWrap> measQuantityResultWrap = Create<MeasQuantityResultsWrap> ();\n  measQuantityResultWrap->AddSinr (sinr);\n  measResultNr->AddCellResults (MeasResultNr::SSB, measQuantityResultWrap->GetPointer ());\n\n  l3RrcMeasurement->AddMeasResultNRNeighCells (\n      measResultNr->GetPointer ()); // MAX 8 UE per message (standard)\n\n  return l3RrcMeasurement;\n}\n\n\n// The memory leaks occurring in this file are wanted because L3-RRC is usually freed after use in the Ric Indication Message\n\nint\nmain (int argc, char *argv[])\n{\n  LogComponentEnableAll (LOG_PREFIX_ALL);\n  LogComponentEnable (\"L3RrcExample\", LOG_LEVEL_ALL);\n  LogComponentEnable (\"Asn1Types\", LOG_LEVEL_ALL);\n\n  //  1 UE-specific (L3) SINR from NR serving cells\n  NS_LOG_INFO (\"1 UE-specific (L3) SINR from NR serving cells\");\n  Ptr<L3RrcMeasurements> l3RrcMeasurement1 = CreateL3RrcUeSpecificSinrServing (1, 1, 10);\n  xer_fprint (stderr, &asn_DEF_L3_RRC_Measurements, l3RrcMeasurement1->GetPointer ());\n\n  //  2 UE-specific (L3) SINR from NR neighboring cells\n  NS_LOG_INFO (\"2 UE-specific (L3) SINR from NR neighboring cells\");\n  Ptr<L3RrcMeasurements> l3RrcMeasurement2 = CreateL3RrcUeSpecificSinrNeigh (2, 20);\n\n  //  3 UE-specific (L3) SINR report from NR neighboring cells\n  NS_LOG_INFO (\"3 UE-specific (L3) SINR report from NR neighboring cells\");\n  long neighCellId3 = 3;\n  long sinr3 = 30;\n\n  Ptr<MeasResultNr> measResultNr3 = Create<MeasResultNr> (neighCellId3);\n  Ptr<MeasQuantityResultsWrap> measQuantityResultWrap3 = Create<MeasQuantityResultsWrap> ();\n  measQuantityResultWrap3->AddSinr (sinr3);\n  measResultNr3->AddCellResults (MeasResultNr::SSB, measQuantityResultWrap3->GetPointer ());\n\n  l3RrcMeasurement2->AddMeasResultNRNeighCells (measResultNr3->GetPointer ());\n\n  xer_fprint (stderr, &asn_DEF_L3_RRC_Measurements, l3RrcMeasurement2->GetPointer ());\n\n  //  4 UE-specific (L3) SINR from LTE serving cells\n  NS_LOG_INFO (\"4 UE-specific (L3) SINR from LTE serving cells\");\n  long eutraPhysCellId4 = 4;\n  long servCellId4 = 4;\n  long sinr4 = 40;\n  Ptr<L3RrcMeasurements> l3RrcMeasurement4 =\n      CreateL3RrcUeSpecificSinrServing (servCellId4, eutraPhysCellId4, sinr4);\n  xer_fprint (stderr, &asn_DEF_L3_RRC_Measurements, l3RrcMeasurement4->GetPointer ());\n\n\n  //  5 UE-specific (L3) SINR from LTE neighboring cells\n  NS_LOG_INFO (\"5 UE-specific (L3) SINR from LTE neighboring cells\");\n  long neighCellId5 = 5;\n  long sinr5 = 50;\n  Ptr<L3RrcMeasurements> l3RrcMeasurement3 = Create<L3RrcMeasurements> (RRCEvent_a5);\n  Ptr<MeasResultEutra> measResultEutra5 = Create<MeasResultEutra> (neighCellId5);\n  measResultEutra5->AddSinr (sinr5);\n  l3RrcMeasurement3->AddMeasResultEUTRANeighCells (measResultEutra5->GetPointer ());\n  xer_fprint (stderr, &asn_DEF_L3_RRC_Measurements, l3RrcMeasurement3->GetPointer ());\n\n\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/oran-interface-example.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2022 Northeastern University\n * Copyright (c) 2022 Sapienza, University of Rome\n * Copyright (c) 2022 University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Andrea Lacava <thecave003@gmail.com>\n *\t\t   Tommaso Zugno <tommasozugno@gmail.com>\n *\t\t   Michele Polese <michele.polese@gmail.com>\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/oran-interface.h\"\n#include \"encode_e2apv1.hpp\"\n#include <errno.h>\n\n\nusing namespace ns3;\n\nPtr<E2Termination> e2Term;\n// TODO create getters for these parameters in e2Term\nstd::string plmId = \"111\";\nuint16_t cellId = 1;\nconst std::string gnb = std::to_string (cellId);\n\n/**\n* Creates an empty RIC Report message and send it to the RIC\n*\n* \\param params the RIC Subscription Request parameters\n*/\nstatic void BuildAndSendReportMessage (E2Termination::RicSubscriptionRequest_rval_s params)\n{\n  KpmIndicationHeader::KpmRicIndicationHeaderValues headerValues; \n  headerValues.m_plmId = plmId;\n  headerValues.m_gnbId = cellId;\n  headerValues.m_nrCellId = cellId;\n\n  Ptr<KpmIndicationHeader> header = Create<KpmIndicationHeader> (KpmIndicationHeader::GlobalE2nodeType::gNB, headerValues);\n  \n  KpmIndicationMessage::KpmIndicationMessageValues msgValues;\n  \n  Ptr<OCuUpContainerValues> cuUpValues = Create<OCuUpContainerValues> ();\n  cuUpValues->m_plmId = plmId;\n  cuUpValues->m_pDCPBytesUL = 100;\n  cuUpValues->m_pDCPBytesDL = 100;\n  msgValues.m_pmContainerValues = cuUpValues;\n  \n  Ptr<MeasurementItemList> ue0DummyValues = Create<MeasurementItemList> (\"UE-0\");\n  ue0DummyValues->AddItem<long> (\"DRB.PdcpSduVolumeDl_Filter.UEID\", 6);\n  ue0DummyValues->AddItem<long> (\"QosFlow.PdcpPduVolumeDL_Filter.UEID\", 7);\n  ue0DummyValues->AddItem<long> (\"Tot.PdcpSduNbrDl.UEID\", 8);\n  ue0DummyValues->AddItem<long> (\"DRB.PdcpPduNbrDl.Qos.UEID\", 9);\n  ue0DummyValues->AddItem<double> (\"DRB.IPThpDl.UEID\", 10.0);\n  ue0DummyValues->AddItem<double> (\"DRB.IPLateDl.UEID\", 11.0);\n  msgValues.m_ueIndications.insert (ue0DummyValues);\n \n  Ptr<MeasurementItemList> ue1DummyValues = Create<MeasurementItemList> (\"UE-1\");;\n  ue1DummyValues->AddItem<long> (\"DRB.PdcpSduVolumeDl_Filter.UEID\", 6);\n  ue1DummyValues->AddItem<long> (\"QosFlow.PdcpPduVolumeDL_Filter.UEID\", 7);\n  ue1DummyValues->AddItem<long> (\"Tot.PdcpSduNbrDl.UEID\", 8);\n  ue1DummyValues->AddItem<long> (\"DRB.PdcpPduNbrDl.Qos.UEID\", 9);\n  ue1DummyValues->AddItem<double> (\"DRB.IPThpDl.UEID\", 10.0);\n  ue1DummyValues->AddItem<double> (\"DRB.IPLateDl.UEID\", 11.0);\n  msgValues.m_ueIndications.insert (ue1DummyValues);\n  \n  Ptr<KpmIndicationMessage> msg = Create<KpmIndicationMessage> (msgValues);\n  \n  E2AP_PDU *pdu_cuup_ue = new E2AP_PDU;\t\n  encoding::generate_e2apv1_indication_request_parameterized(pdu_cuup_ue, \n                                                             params.requestorId,\n                                                             params.instanceId,\n                                                             params.ranFuncionId,\n                                                             params.actionId,\n                                                             1, // TODO sequence number  \n                                                             (uint8_t*) header->m_buffer, // buffer containing the encoded header\n                                                             header->m_size, // size of the encoded header\n                                                             (uint8_t*) msg->m_buffer, // buffer containing the encoded message\n                                                             msg->m_size); // size of the encoded message  \n  e2Term->SendE2Message (pdu_cuup_ue);\n  delete pdu_cuup_ue;\n  \n}\n\n/**\n* KPM Subscription Request callback.\n* This function is triggered whenever a RIC Subscription Request for \n* the KPM RAN Function is received.\n*\n* \\param pdu request message\n*/\nstatic void KpmSubscriptionCallback (E2AP_PDU_t* sub_req_pdu)\n{\n  NS_LOG_UNCOND (\"\\n\\nReceived RIC Subscription Request\");\n  \n  E2Termination::RicSubscriptionRequest_rval_s params = e2Term->ProcessRicSubscriptionRequest (sub_req_pdu);\n  NS_LOG_UNCOND (\"requestorId \" << +params.requestorId << \n                 \", instanceId \" << +params.instanceId << \n                 \", ranFuncionId \" << +params.ranFuncionId << \n                 \", actionId \" << +params.actionId);  \n  \n  BuildAndSendReportMessage (params);\n}\n\n/**\n* RIC Control Message callback.\n* This function is triggered whenever a RIC Control Message is received.\n*\n* \\param pdu request message\n*/\nstatic void\nRicControlMessageCallback (E2AP_PDU_t *ric_ctrl_pdu)\n{\n  NS_LOG_UNCOND (\"\\n\\nReceived RIC Control Message\");\n\n  RicControlMessage msg = RicControlMessage (ric_ctrl_pdu);\n  // TODO log something\n}\n\n\nint \nmain (int argc, char *argv[])\n{\n  LogComponentEnable (\"E2Termination\", LOG_LEVEL_ALL);\n  // LogComponentEnable (\"Asn1Types\", LOG_LEVEL_ALL);\n  // LogComponentEnable (\"RicControlMessage\", LOG_LEVEL_ALL);\n  e2Term = CreateObject<E2Termination> (\"10.0.2.10\", 36422, 38472, gnb, plmId);\n  e2Term->Start ();\n  bool use = true;\n  if (use){\n\n    Ptr<KpmFunctionDescription> kpmFd = Create<KpmFunctionDescription> ();\n    e2Term->RegisterKpmCallbackToE2Sm (200, kpmFd, &KpmSubscriptionCallback);    \n    Ptr<RicControlFunctionDescription> rcFd = Create<RicControlFunctionDescription> ();\n    e2Term->RegisterSmCallbackToE2Sm (300, rcFd, &RicControlMessageCallback);\n\n    E2Termination::RicSubscriptionRequest_rval_s params;\n    params.actionId = 0;\n    params.instanceId = 1;\n    params.ranFuncionId = 2;\n    params.requestorId = 1;\n    BuildAndSendReportMessage (params);\n  }\n\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/ric-control-function-desc.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2022 Northeastern University\n * Copyright (c) 2022 Sapienza, University of Rome\n * Copyright (c) 2022 University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Andrea Lacava <thecave003@gmail.com>\n *\t\t   Tommaso Zugno <tommasozugno@gmail.com>\n *\t\t   Michele Polese <michele.polese@gmail.com>\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/oran-interface.h\"\n\nusing namespace ns3;\n\n\n\nint \nmain (int argc, char *argv[])\n{\n  LogComponentEnable (\"Asn1Types\", LOG_LEVEL_ALL);\n  LogComponentEnable (\"RicControlMessage\", LOG_LEVEL_ALL);\n  Ptr<RicControlFunctionDescription> rcFd = Create<RicControlFunctionDescription> ();\n\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/ric-indication-messages.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2022 Northeastern University\n * Copyright (c) 2022 Sapienza, University of Rome\n * Copyright (c) 2022 University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Andrea Lacava <thecave003@gmail.com>\n *\t\t   Tommaso Zugno <tommasozugno@gmail.com>\n *\t\t   Michele Polese <michele.polese@gmail.com>\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/oran-interface.h\"\n#include <errno.h>\n\nusing namespace ns3;\n\n/**\n* Create and encode RIC Indication messages.\n* Prints the encoded messages in XML format. \n*/\nint \nmain (int argc, char *argv[])\n{\n  // LogComponentEnable (\"Asn1Types\", LOG_LEVEL_ALL);\n  LogComponentEnable (\"KpmIndication\", LOG_LEVEL_INFO);\n  LogComponentEnable (\"KpmFunctionDescription\", LOG_LEVEL_INFO);\n  \n  std::string plmId = \"111\";\n  std::string gnbId = \"1\";\n  uint16_t nrCellId = 5;\n\n  uint64_t timestamp = 1630068655325;\n  // \"12:58:04.123456\";\n  uint64_t timestamp2 = 1630068679511;\n  // \"12:58:05.123457\";\n  uint64_t timestamp3 = 1630068680196;\n  // \"12:58:06.123458\";\n  uint64_t timestamp4 = 1630068681372;\n  // \"12:58:07.123459\";\n\n  NS_LOG_UNCOND (\"----------- Begin of Kpm Indication header -----------\");\n\n  KpmIndicationHeader::KpmRicIndicationHeaderValues headerValues; \n  headerValues.m_plmId = plmId;\n  headerValues.m_gnbId = gnbId;\n  headerValues.m_nrCellId = nrCellId;\n  headerValues.m_timestamp = timestamp;\n\nKpmIndicationHeader::KpmRicIndicationHeaderValues headerValues2; \n  headerValues2.m_plmId = plmId;\n  headerValues2.m_gnbId = gnbId;\n  headerValues2.m_nrCellId = nrCellId;\n  headerValues2.m_timestamp = timestamp2;\n\n  KpmIndicationHeader::KpmRicIndicationHeaderValues headerValues3; \n  headerValues3.m_plmId = plmId;\n  headerValues3.m_gnbId = gnbId;\n  headerValues3.m_nrCellId = nrCellId;\n  headerValues3.m_timestamp = timestamp3;\n\n  KpmIndicationHeader::KpmRicIndicationHeaderValues headerValues4; \n  headerValues4.m_plmId = plmId;\n  headerValues4.m_gnbId = gnbId;\n  headerValues4.m_nrCellId = nrCellId;\n  headerValues4.m_timestamp = timestamp4;\n\n  Ptr<KpmIndicationHeader> header = Create<KpmIndicationHeader> (KpmIndicationHeader::GlobalE2nodeType::eNB, headerValues);\n  Ptr<KpmIndicationHeader> header2 = Create<KpmIndicationHeader> (KpmIndicationHeader::GlobalE2nodeType::gNB, headerValues2);\n  Ptr<KpmIndicationHeader> header3 = Create<KpmIndicationHeader> (KpmIndicationHeader::GlobalE2nodeType::ng_eNB, headerValues3);\n  Ptr<KpmIndicationHeader> header4 = Create<KpmIndicationHeader> (KpmIndicationHeader::GlobalE2nodeType::en_gNB, headerValues4);\n\n  NS_LOG_UNCOND (\"----------- End of the Kpm Indication header -----------\");\n\n  KpmIndicationMessage::KpmIndicationMessageValues msgValues1;\n\n  NS_LOG_UNCOND (\"----------- Begin of the CU-UP message -----------\");\n\n  // Begin example CU-UP\n  // uncomment this to test CU-UP\n\n  Ptr<OCuUpContainerValues> cuUpValues = Create<OCuUpContainerValues> ();\n  cuUpValues->m_plmId = plmId;\n  cuUpValues->m_pDCPBytesUL = 100;\n  cuUpValues->m_pDCPBytesDL = 100;\n\n  Ptr<MeasurementItemList> ue0DummyValues = Create<MeasurementItemList> (\"UE-0\");\n  ue0DummyValues->AddItem<long> (\"DRB.PdcpSduVolumeDl_Filter.UEID\", 6);\n  ue0DummyValues->AddItem<long> (\"QosFlow.PdcpPduVolumeDL_Filter.UEID\", 7);\n  ue0DummyValues->AddItem<long> (\"Tot.PdcpSduNbrDl.UEID\", 8);\n  ue0DummyValues->AddItem<long> (\"DRB.PdcpPduNbrDl.Qos.UEID\", 9);\n  ue0DummyValues->AddItem<double> (\"DRB.IPThpDl.UEID\", 10.0);\n  ue0DummyValues->AddItem<double> (\"DRB.IPLateDl.UEID\", 11.0);\n  msgValues1.m_ueIndications.insert (ue0DummyValues);\n \n  Ptr<MeasurementItemList> ue1DummyValues = Create<MeasurementItemList> (\"UE-1\");\n  ue1DummyValues->AddItem<long> (\"DRB.PdcpSduVolumeDl_Filter.UEID\", 6);\n  ue1DummyValues->AddItem<long> (\"QosFlow.PdcpPduVolumeDL_Filter.UEID\", 7);\n  ue1DummyValues->AddItem<long> (\"Tot.PdcpSduNbrDl.UEID\", 8);\n  ue1DummyValues->AddItem<long> (\"DRB.PdcpPduNbrDl.Qos.UEID\", 9);\n  ue1DummyValues->AddItem<double> (\"DRB.IPThpDl.UEID\", 10.0);\n  ue1DummyValues->AddItem<double> (\"DRB.IPLateDl.UEID\", 11.0);\n  msgValues1.m_ueIndications.insert(ue1DummyValues);\n  msgValues1.m_pmContainerValues = cuUpValues; \n\n  Ptr<KpmIndicationMessage> msg = Create<KpmIndicationMessage> (msgValues1);\n\n  NS_LOG_UNCOND (\"----------- End of the CU-UP message -----------\");\n\n  NS_LOG_UNCOND (\"----------- Begin of the CU-CP message -----------\");\n  KpmIndicationMessage::KpmIndicationMessageValues msgValues2;\n  msgValues2.m_cellObjectId = \"NRCellCU\";\n  Ptr<OCuCpContainerValues> cuCpValues = Create<OCuCpContainerValues> ();\n  cuCpValues->m_numActiveUes = 100;\n\n  Ptr<MeasurementItemList> ue2DummyValues =\n      Create<MeasurementItemList> (\"UE-2\");\n  ue2DummyValues->AddItem<long> (\"DRB.EstabSucc.5QI.UEID\", 6);\n  ue2DummyValues->AddItem<long> (\"DRB.RelActNbr.5QI.UEID\", 7);\n  msgValues2.m_ueIndications.insert (ue2DummyValues);\n\n   Ptr<MeasurementItemList> ue3DummyValues =\n      Create<MeasurementItemList> (\"UE-3\");\n  ue3DummyValues->AddItem<long> (\"DRB.EstabSucc.5QI.UEID\", 6);\n  ue3DummyValues->AddItem<long> (\"DRB.RelActNbr.5QI.UEID\", 7);\n  msgValues2.m_ueIndications.insert (ue3DummyValues);\n\n  Ptr<MeasurementItemList> ue4DummyValues =\n      Create<MeasurementItemList> (\"UE-4\");\n\n  Ptr<L3RrcMeasurements> l3RrcMeasurement = Create<L3RrcMeasurements> (RRCEvent_b1);\n  Ptr<ServingCellMeasurementsWrap> servingCellMeasurements =\n      Create<ServingCellMeasurementsWrap> (ServingCellMeasurements_PR_nr_measResultServingMOList);\n\n  Ptr<MeasResultNr> measResultNr = Create<MeasResultNr> (39);\n  Ptr<MeasQuantityResultsWrap> measQuantityResultWrap = Create<MeasQuantityResultsWrap> ();\n  measQuantityResultWrap->AddSinr (20);\n  measResultNr->AddCellResults (MeasResultNr::SSB, measQuantityResultWrap->GetPointer ());\n  Ptr<MeasResultServMo> measResultServMo =\n      Create<MeasResultServMo> (10, measResultNr->GetValue ());\n  servingCellMeasurements->AddMeasResultServMo (measResultServMo->GetPointer ());\n  l3RrcMeasurement->AddServingCellMeasurement (servingCellMeasurements->GetPointer ());\n\n  ue4DummyValues->AddItem<Ptr<L3RrcMeasurements>> (\"calla\",l3RrcMeasurement);\n  ue4DummyValues->AddItem<long> (\"DRB.RelActNbr.5QI.UEID\", 7);\n  msgValues2.m_ueIndications.insert (ue4DummyValues);\n  msgValues2.m_pmContainerValues = cuCpValues;\n\n  Ptr<KpmIndicationMessage> msg2 = Create<KpmIndicationMessage> (msgValues2);\n  NS_LOG_UNCOND (\"----------- End of the CU-CP message -----------\");\n  \n  NS_LOG_UNCOND (\"----------- Begin test of the DU message -----------\");\n  KpmIndicationMessage::KpmIndicationMessageValues msgValues3;\n  msgValues3.m_cellObjectId = \"NRCellCU\";\n\n  Ptr<ODuContainerValues> oDuContainerVal = Create<ODuContainerValues> ();\n  Ptr<CellResourceReport> cellResRep = Create<CellResourceReport> ();\n  cellResRep->m_plmId = \"111\";\n  // std::stringstream ss;\n  // ss << std::hex << 1340012;\n  cellResRep->m_nrCellId = 2;\n  cellResRep->dlAvailablePrbs = 6;\n  cellResRep->ulAvailablePrbs = 6;\n\n    Ptr<CellResourceReport> cellResRep2 = Create<CellResourceReport> ();\n  cellResRep2->m_plmId = \"444\";\n  cellResRep2->m_nrCellId = 3;\n  cellResRep2->dlAvailablePrbs = 5;\n  cellResRep2->ulAvailablePrbs = 5;\n\n  Ptr<ServedPlmnPerCell> servedPlmnPerCell = Create<ServedPlmnPerCell> ();\n  servedPlmnPerCell->m_plmId = \"121\";\n  servedPlmnPerCell->m_nrCellId = 3;\n\n  Ptr<ServedPlmnPerCell> servedPlmnPerCell2 = Create<ServedPlmnPerCell> ();\n  servedPlmnPerCell2->m_plmId = \"121\";\n  servedPlmnPerCell2->m_nrCellId = 2;\n\n  Ptr<EpcDuPmContainer> epcDuVal = Create<EpcDuPmContainer> ();\n  epcDuVal->m_qci = 1;\n  epcDuVal->m_dlPrbUsage = 1;\n  epcDuVal->m_ulPrbUsage = 2;\n\n  Ptr<EpcDuPmContainer> epcDuVal2 = Create<EpcDuPmContainer> ();\n  epcDuVal2->m_qci = 1;\n  epcDuVal2->m_dlPrbUsage = 3;\n  epcDuVal2->m_ulPrbUsage = 4;\n\n  servedPlmnPerCell->m_perQciReportItems.insert (epcDuVal);\n  servedPlmnPerCell->m_perQciReportItems.insert (epcDuVal2);\n  servedPlmnPerCell2->m_perQciReportItems.insert (epcDuVal);\n  servedPlmnPerCell2->m_perQciReportItems.insert (epcDuVal2);\n  cellResRep->m_servedPlmnPerCellItems.insert (servedPlmnPerCell2);\n  cellResRep->m_servedPlmnPerCellItems.insert (servedPlmnPerCell);\n  cellResRep2->m_servedPlmnPerCellItems.insert (servedPlmnPerCell2);\n  cellResRep2->m_servedPlmnPerCellItems.insert (servedPlmnPerCell);\n  \n  oDuContainerVal->m_cellResourceReportItems.insert (cellResRep);\n  oDuContainerVal->m_cellResourceReportItems.insert (cellResRep2);\n\n  Ptr<MeasurementItemList> ue5DummyValues = Create<MeasurementItemList> (\"UE-5\");\n  ue5DummyValues->AddItem<long> (\"DRB.EstabSucc.5QI.UEID\", 6);\n  ue5DummyValues->AddItem<long> (\"DRB.RelActNbr.5QI.UEID\", 7);\n  msgValues3.m_ueIndications.insert (ue5DummyValues);\n\n  msgValues3.m_pmContainerValues = oDuContainerVal;\n  Ptr<KpmIndicationMessage> msg3 = Create<KpmIndicationMessage> (msgValues3);\n  \n  NS_LOG_UNCOND (\"----------- End test of the DU message -----------\");\n\n  NS_LOG_UNCOND (\"----------- Begin test of the KpmFunctionDescription -----------\");\n  Ptr<KpmFunctionDescription> fd = Create<KpmFunctionDescription> ();\n  NS_LOG_UNCOND (\"----------- End test of the KpmFunctionDescription -----------\");\n\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/test-wrappers.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2022 Northeastern University\n * Copyright (c) 2022 Sapienza, University of Rome\n * Copyright (c) 2022 University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Andrea Lacava <thecave003@gmail.com>\n *\t\t   Tommaso Zugno <tommasozugno@gmail.com>\n *\t\t   Michele Polese <michele.polese@gmail.com>\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/oran-interface.h\"\n#include <errno.h>\n\nusing namespace ns3;\n\n/**\n* Test field for the wrappers and their functions\n*/\nint \nmain (int argc, char *argv[])\n{\n  // LogComponentEnable (\"Asn1Types\", LOG_LEVEL_ALL);\n  std::string test = \"test\";\n//   Ptr<OctetString> one = Create<OctetString> (test, test.size ());\n  // Ptr<OctetString> due = Create<OctetString> (test, test.size ());\n  // Ptr<Snssai> snssai = Create<Snssai> (\"test\");\n\n  // std::cout << due->DecodeContent() << std::endl;\n\n  std::vector<Ptr<NrCellId>> nrCellIds;\n  for (uint16_t i = 0; i < 20; i++)\n    {\n      nrCellIds.push_back(Create<NrCellId> (i));\n      NS_LOG_UNCOND (\"Count: \" << i << \" , value: \");\n      xer_fprint (stdout, &asn_DEF_BIT_STRING, nrCellIds[i]->GetPointer ());\n    }\n\n  return 0;\n}\n"
    }
  ]
}