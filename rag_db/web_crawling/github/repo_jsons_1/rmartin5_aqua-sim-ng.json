{
  "repo_name": "rmartin5/aqua-sim-ng",
  "github_url": "https://github.com/rmartin5/aqua-sim-ng",
  "readme": "# Aqua-Sim Next Generation\n\n-------------------------------------\n\n## About\n\nAqua-Sim is a underwater network simulator which supports a vast amount of protocols and features. Originally developed on the basis of [NS-2](http://www.isi.edu/nsnam/ns/), Aqua-Sim can effectively simulate acoustic signal attenuation and packet collisions in underwater sensor networks (UWSN). Moreover, Aqua-Sim supports three-dimensional deployment. This work consists of rewriting and porting [Aqua-Sim](http://obinet.engr.uconn.edu/wiki/index.php/Aqua-Sim) to [NS-3](http://www.nsnam.org) to improve upon current simulation issues such as memory leakage and usage simplicity.\n\nWork supported by the UWSN Lab at University of Connecticut.\n\n--------------------------------------\n## Advantages of Aqua-Sim\n- Discrete-event driven network simulator\n- Support 3D networks and mobile networks\n- Simulate underwater acoustic channels with high fidelity\n- Implement a complete protocol stack from physical layer to application layer\n\n--------------------------------------\n\n## Requirements\nThis code is meant to be an add-on to current NS-3 software and therefore requires NS-3 and all pre-requirements of said software.\n\nCurrent recommended NS-3 version is `3.40`. The following system requirements must be met:\n\n- `gcc-11`, `g++-11` or higher for Linux\n- `clang` version `15.0.0` for Mac OS\n- `cmake` version `3.16` or higher\n\n\n--------------------------------------\n\n## Documentation and Installation\n\nTo build current version of `aqua-sim-ng`, please follow these steps:\n\n- download and install `ns-3.40`:\n\n```\nmkdir workspace\ncd workspace\nwget https://www.nsnam.org/releases/ns-allinone-3.40.tar.bz2\ntar xvf ns-allinone-3.40.tar.bz2\ncd ns-allinone-3.40/ns-3.40/\n./ns3 clean\n./ns3 configure --build-profile=debug --enable-examples --enable-tests --disable-python --disable-werror\n./ns3 build\n```\n\n- after the initial NS-3 build, copy `aqua-sim-ng` code into `src/` folder:\n\n```\ncd src/\ngit clone https://github.com/rmartin5/aqua-sim-ng.git \n```\n\n- reconfigure ns-3 project and build the new module:\n\n```\ncd ..\n./ns3 configure --build-profile=debug --enable-examples --enable-tests --disable-python --disable-werror\n./ns3 build\n```\n\nAfter that, you should be able to run example scripts located under `src/aqua-sim-ng/examples/` folder.\n\n--------------------------------------\n## Running Examples\n\n### LIBRA MAC protocol\n\nLIBRA MAC protocol is a MAC protocol for UWSNs with multi-hop transmission range control capabilities, powered by Reinforcement Learning for adaptive route selection. More description can be found in the paper [1] (See `References` section down below).\n\nTo run LIBRA simulations, execute `libra_grid_test.cc` script from `examples/` folder by running:\n\n```\n./ns3 run \"LibraGridTest --lambda=0.01 --packet_size=800 --grid_size=10000 --range=3000 --n_nodes=128 --tx_power=60 --simStop=10000 --RngRun=0\"\n```\nwhere:\n\n`LibraGridTest`: name of the simulation script that refers to `libra_grid_test.cc`\n\n`--lambda`: application traffic rate, following Poisson distribution, pkts/sec\n\n`--packet_size`: user packet size, bytes\n\n`--grid_size`: size of the node allocation area, X by X meters\n\n`--range`: maximum transmission range, meters\n\n`--n_nodes`: number of nodes to allocate\n\n`--tx_power`: maximum Tx power, Watts\n\n`--simStop`: total simulation time, seconds\n\n`--RngRun`: seed for random generator\n\nAfter successful run, the script should generate a simulation trace-file with the following name: `libra-density-trace-0.01-128-0.asc`\n\nThe trace-file contains raw simulation logs with every Tx/Rx event traced in a specific format. To extract useful data from the trace-file, such as network throughput, PDR, and more, please refer to `print_results_libra.py` script, located under `scripts/` folder.\n\nAfter executing the script, the parsed `.txt` file should be generated that will contain network metrics. An example of the parsed `libra-density-0.01.txt` content is the following:\n\n```\nDensity\tNodesNumber\tLambda\tTxPackets\tRxPackets\tTxCount\tRxCount\tCollisionCount\tTotalEnergyConsumption\tEnergyPerBit\tTotalThroughput\tPDR\tAvgHopCount\n1.28\t128\t0.01\t12871\t8936\t22730\t152065\t174667\t69036.9\t0.0012\t5709733134989.97\t0.69\t1.89\n```\n\n### ALOHA and SFAMA simulations\n\nSimilar to `LIBRA` simulations described above, the following scripts are available for `ALOHA` and `SFAMA` protocols: `aloha_grid_test.cc` and `sfama_grid_test.cc`.\n\nThe simulation commands are similar to `LIBRA` as well:\n\n```\n./ns3 run \"AlohaGridTest --lambda=0.01 --packet_size=800 --grid_size=10000 --range=3000 --n_nodes=128 --tx_power=60 --simStop=10000 --RngRun=0\"\n```\n\nand\n\n```\n./ns3 run \"SfamaGridTest --lambda=0.01 --packet_size=800 --grid_size=10000 --range=3000 --n_nodes=128 --tx_power=60 --simStop=10000 --RngRun=0\"\n```\n\nTo process raw trace-files after simulations, similar Python-scripts are available: `print_results_aloha.py` and `print_results_sfama.py`.\n\n### TRUMAC protocol\n\nTRUMAC is a token-ring based MAC protocol for UWNs that leverages spatial-temporary diversity of underwater channel to improve channel utilization under high traffic loads. Please refer to [TBD] for more details.\n\nTo repeat simulations from [TBD], `trumac_test.cc` simulation script is available. The script compares `TRUMAC`, `TDMA`, and `ALOHA` against various network sizes and traffic rates. Here is an example:\n\n```\n./ns3 run \"TrumacTest --seed=0 --psize=100 --nodes=40 --simStop=1000 --mac=trumac --rate=120 --dist=120 --algo=0\"\n```\n\nwhere:\n\n`--seed`: seed for pseudo-random generator function\n\n`--psize:`: packet size, bytes\n\n`--nodes:`: number of nodes in network\n\n`--simStop`: total simulation time, seconds\n\n`--mac`: select between `trumac`, `tdma`, or `aloha` protocols\n\n`--rate`: rate of CBR traffic, bps\n\n`--dist:`: average distance between any pair of nodes\n\n`--algo`: next-sender-selection algorithm for TRUMAC: `0` - random selection; `1` - nearest-neighbor TSP algorithm\n\nAfter running the script, a simulation-summary `results_trumac.txt` file should appear. The summary contains 7 columns, with the following metrics:\n\n`1 - total number of packets originated`\n\n`2 - total number of packets received by the app`\n\n`3 - total number of packets transmitted to PHY`\n\n`4 - total number of packets received from PHY`\n\n`5 - total number of collisions at PHY`\n\n`6 - average MAC send-queue size`\n\n`7 - average E2E packet delay, ms`\n\nTo run multiple simulation instances, and aggregate the results, please refer to `scripts/runTRUMAC.py` script.\n\n### JMAC protocol\n\nJamming MAC (JMAC) protocol is a security-focused MAC protocol for UWSNs that aims to provide communication security in a shared unencrypted underwater channel. JMAC computes a pair-sequence of transmission schedules that are recoverable in desirable area, and not recoverable in the adversary area. Please refer to [TBD] for more details.\n\nTo repeat simulations from [TBD], `jmac_test.cc` simulation script is available. The script compares `JMAC` and `ALOHA` protocols in a specific simulation setting with `N` sensor nodes and `M` gateways, staticly allocated at the bottom and the surface, correspondingly. The script compares performance of `JMAC` and `ALOHA` in terms of PDR, throughput, and communication security (vulnerable area) provided. Here is an example:\n\n```\n./ns3 run \"JmacTest --seed=1 --psize=400 --rate=120 --nodes=4 --mac=jmac --sinks=1 --simStop=1000 --center_x=1000 --center_z=1000 --radius=300 --depth=400 --epochTime=10\"\n```\n\nwhere:\n\n`--seed`: seed for pseudo-random generator function\n\n`--psize:`: packet size, bytes\n\n`--rate`: rate of CBR traffic, bps\n\n`--nodes:`: number of nodes in network\n\n`--mac`: select between `jmac`, or `aloha` protocols\n\n`--sinks:`: number of gateways / sinks\n\n`--simStop`: total simulation time, seconds\n\n`--center_x:`: center of a circular bottom: x-coordinate, meters\n\n`--center_z:`: center of a circular bottom: z-coordinate, meters\n\n`--radius:`: radius of random nodes at bottom, meters\n\n`--depth:`: depth of the bottom, meters\n\n`--epochTime:`: Time in-between 2 CC-requests at a node, seconds\n\nAfter running the script, a simulation-summary `jmac_results.txt` file should appear. The summary contains 9 columns, with the following metrics:\n\n`1 - total size of vulnerable area`\n\n`2 - total energy consumed, joules`\n\n`3 - total number of packets originated`\n\n`4 - total number of packets received by the app`\n\n`5 - total number of packets scheduled for transmission at MAC (JMAC only)`\n\n`6 - total number of packets sent to PHY`\n\n`7 - total number of packets received from PHY`\n\n`8 - average MAC send-queue size`\n\n`9 - average E2E packet delay, ms`\n\nTo run multiple simulation instances, and aggregate the results, please refer to `scripts/runJMAC.py` script.\n\n**Note:** Current JMAC implementation (see line `553` in `aqua-sim-mac-jmac.cc`) does not have the `auction` algorithm presented in the paper [TBD]. For the instructions on how to implement the `auction` algorithm, please refer to [TBD], and to the MATLAB code [TBD].\n\n--------------------------------------\n## Legacy Documentation\n\nOlder tested and supported versions of NS-3 included 3.24, 3.26, 3.27, 3.33 and 3.37. Older documentation, installation steps, example script walk through, and protocol creation guides can be found under [Aqua-Sim NG Documentation](documentation/).\n\n![Aqua-Sim NG Diagram](/documentation/asDiagram.png \"Aqua-Sim NG Diagram\")\n\n--------------------------------------\n## New Modules and Features\n\nFull publication of Aqua-Sim NG is currenlty underway and earlier versions of this paper will be available soon.\n\nAqua-Sim NG core continues to support basic underwater functions seen in Aqua-Sim 1.0, such as half-duplex, long propagation delays, and acoustic signal attenuation. Current protocol support includes: (MAC layer:) BroadcastMAC, Underwater ALOHA, CopeMAC, Underwater FAMA, Underwater Slotted FAMA, GOAL, UWAN, RMac, Tmac, (Routing Layer:) DBR, Residual-DBR, Static, Dynamic, Dummy, Flooding, DDoS-Restriction, VBF, and VBVA.\n\n1. NS3 Architecture Support\n   * Core Aqua-Sim revamp and API integration\n   * Example and helper scripts addition\n\n2. Protocol Port\n   * Extensive protocol port\n\n3. Real-World Features\n   * Synchronization support\n   * Localization support\n   * Busy terminal model integration\n   * Fluctuating SNR\n   * Enhanced channel model support\n   * Transmission range uncertainty module\n   * Security features and module support\n   * Trace driven support for channel layer\n\n4. Information-Centric Integration\n   * Adapted Named Data Network components\n   * Helper and test scripts integrated\n   * Specialized protocols addition\n\n### Enhanced Channel Models\nExpanded channel models to support multi-channel simulation, differentiated noise generator classes, and additional propagation model support. Our goal here is to depict better accuracy to real world scenarios in our simulation results.\n\n### Trace Driven Simulation\nBy implementing a trace driven simulation we are able to control certain conditions throughout iterations of testing. An example of this could be applying channel readings from an ocean test directly into the simulator and depicting the given parameters throughout each test. This can be beneficial in cases such as ensuring channel conditions remain the same during protocol testing. While this channel consistency is not guaranteed in real world scenarios, it does add additional control when running simulations.\n\n### Synchronization and Localization\nSynchronization and localization are two critical components for ensuring accurate underwater simulation. Past Aqua-Sim work does not support a dedicated module for these two features which places the burden instead on the developer. For this work, we incorporate location features such as range-based or range-free localization support. For time synchronization, we incorporate features to better integrate clock-skew and offset. The goal for these features is to allow for easier protocol integration for users and developers alike.\n\n### Real System Features\nReal system features is an encompassing category which will better mimic the scenarios seen in UWSNs. Due to the uncertainty of channel conditions, we implement link asymmetry and heterogeneity. This allows the channel to simulate conditions such as fluctuating signal-to-noise ratios. Furthermore, these environmental factors in UWSNs may lead to acoustic transmission range uncertainty, which must be taken into account for more accurate results. Another unique feature which we see in UWSNs is the [busy terminal problem](http://dl.acm.org/citation.cfm?id=2674593). The two main factors contributing to this busy terminal problem are acoustic communication speed and the half-duplex nature of UWSNs. By demonstrating these components in Aqua-Sim Next Generation we can further strengthen our simulation of a real system.\n\n### Security Features\nLike any other network type, UWSN are susceptible to attacks. By implementing jamming, denial of service, packet spoofing, sinkhole and wormhole components, we can assist simulating potential underwater security threats. Our goal is to allow easier integration of these types of attacks by maliciously created nodes and easier analysis support.\n\n### Information-Centric Integration\nWe implement adapted Named Data Networking (NDN) techniques alongside specialized NDN protocols for UWSNs. By implementing these features, we can better depict and evaluate the improvements NDN can have in this environment. This integration consists of introducing interest and data structured packets, Pending Interest Tables, Forwarding Information Bases, and Context Storages for overall NDN inclusion that is specialized for underwater. Additionally, we implement this module through a packet demux on the physical layer, allowing for protocols to implement certain NDN features without completely revamping how our simulator functions.\n\n## References\n\n[1] Dugaev, D.; Peng, Z.; Luo, Y.; Pu, L. Reinforcement-Learning Based Dynamic Transmission Range Adjustment in Medium Access Control for Underwater Wireless Sensor Networks. Electronics 2020, 9, 1727. https://doi.org/10.3390/electronics9101727\n\n\n--------------------------------------\n#### License and Contact\n\nCopyright (c) 2017 UWSN Lab at the University of Connecticut.\nAll rights reserved.\n\nRobert Martin : <robert.martin@uconn.edu>\n\nZheng Peng, Ph.D : <zheng@cs.ccny.cuny.edu>\n\nDmitrii Dugaev : <ddugaev@gradcenter.cuny.edu>\n",
  "examples": [
    {
      "file_path": "examples/GOAL_string.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2016 University of Connecticut\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Robert Martin <robert.martin@engr.uconn.edu>\n */\n\n #include \"ns3/core-module.h\"\n #include \"ns3/network-module.h\"\n #include \"ns3/mobility-module.h\"\n //#include \"ns3/energy-module.h\"  //may not be needed here...\n #include \"ns3/aqua-sim-ng-module.h\"\n #include \"ns3/applications-module.h\"\n #include \"ns3/log.h\"\n #include \"ns3/callback.h\"\n\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ASGoalString\");\n\nclass ASGoalString\n{\npublic:\n  void UpdatePosition(ConstantVelocityHelper helper);\n  Box m_topo;\n};  // class ASGoalString\n\nvoid\nASGoalString::UpdatePosition(ConstantVelocityHelper helper)\n{\n  helper.UpdateWithBounds(m_topo);\n}\n\nint\nmain (int argc, char *argv[])\n{\n  //mobility pattern for bound checking???\n\n  //Mac GOAL:\n  int m_maxBurst = 10;\n  int m_maxRetxTimes = 6;\n  Time m_vbfMaxDelay = Seconds(2.0);\n  //set bit_rate_  1.0e4 ;#10kbps\n  //set encoding_efficiency_ 1\n\n  double m_minSpeed = 0; // min speed of node\n  double m_maxSpeed = 3; // max speed of node\n  //double m_speed = 0.5; // speed of node\n  //int m_routingControlPacketSize = 20; //bytes\n        //unused variables\n  Time m_positionUpdateInterval = Seconds(0.3); // the length of period to update node's position\n  int m_packetSize = 300;\n\n  int m_nodes = 6;\n  double x = 1000;  // topography\n  double y = 10;\n  double z = 10;\n  double m_simStop = 500; //sim time (seconds)\n  double m_preStop = 90;  //time to prepare to stop\n  //trace file \"GOAL.tr\"; // trace file\n  //ifqlen\t\t50\t;# max queue length in if\n  int m_dataInterval = 100; //10.0\n  double m_range = 100; //range of each node in meters\n  double m_width = 100; //vbf width\n  //LL set mindelay_\t\t50us\n  //LL set delay_\t\t\t25us\n\n\n  CommandLine cmd;\n  cmd.AddValue (\"simStop\", \"Length of simulation\", m_simStop);\n  cmd.AddValue (\"nodes\", \"Amount of regular underwater nodes\", m_nodes);\n  cmd.Parse(argc,argv);\n\n  std::cout << \"-----------Initializing simulation-----------\\n\";\n\n  NodeContainer nodesCon;\n  nodesCon.Create(m_nodes);\n\n  PacketSocketHelper socketHelper;\n  socketHelper.Install(nodesCon);\n\n  //establish layers using helper's pre-build settings\n  AquaSimChannelHelper channel = AquaSimChannelHelper::Default();\n  AquaSimHelper asHelper = AquaSimHelper::Default();\n  asHelper.SetChannel(channel.Create());\n  asHelper.SetMac(\"ns3::AquaSimGoal\",\n                    \"MaxBurst\", IntegerValue(m_maxBurst),\n                    \"MaxRetransTimes\", IntegerValue(m_maxRetxTimes),\n                    \"VBFMaxDelay\", TimeValue(m_vbfMaxDelay));\n  asHelper.SetRouting(\"ns3::AquaSimVBF\",\n                    \"HopByHop\", IntegerValue(0),\n                    \"EnableRouting\", IntegerValue(0),\n                    \"Width\", DoubleValue(m_width));\n  asHelper.SetEnergyModel(\"ns3::AquaSimEnergyModel\",\n                    \"RxPower\", DoubleValue(0.75),\n                    \"TxPower\", DoubleValue(2.0),\n                    \"InitialEnergy\", DoubleValue(10000),\n                    \"IdlePower\", DoubleValue(0.008));\n\n  MobilityHelper mobility;\n  NetDeviceContainer devices;\n  Ptr<ListPositionAllocator> position = CreateObject<ListPositionAllocator> ();\n\n  ASGoalString goal;\n  goal.m_topo = Box(0,x,0,y,0,z);\n\n  //Trace TODO\n\n  Vector boundry = Vector(0,0,0);\n  std::cout << \"Creating Nodes\\n\";\n\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n    {\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n      position->Add(boundry);\n      newDevice = asHelper.Create(*i, newDevice);\n      newDevice->GetPhy()->SetTransRange(m_range);\n      devices.Add(newDevice);\n\n      NS_LOG_DEBUG(\"Node: \" << *i << \" newDevice: \" << newDevice << \" Position: \" <<\n\t\t     boundry.x << \",\" << boundry.y << \",\" << boundry.z);\n\n      boundry.x += 100;\n    }\n\n  mobility.SetPositionAllocator(position);\n  mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n  mobility.Install(nodesCon);\n  //Set random velocities for all nodes\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n    {\n      Ptr<UniformRandomVariable> rand = CreateObject<UniformRandomVariable> ();\n      Ptr<ConstantVelocityMobilityModel> model = (*i)->GetObject<ConstantVelocityMobilityModel>();\n      model->SetVelocity(Vector(rand->GetValue(m_minSpeed,m_maxSpeed),0,0));\n\n      ConstantVelocityHelper m_helper = ConstantVelocityHelper(model->GetPosition(), model->GetVelocity());\n      for (Time update = m_positionUpdateInterval; update.GetDouble() < m_simStop-Seconds(1).GetDouble(); update += m_positionUpdateInterval)\n      {\n        Simulator::Schedule(update, &ASGoalString::UpdatePosition, &goal, m_helper);\n      }\n    }\n  PacketSocketAddress socket;\n  socket.SetAllDevices();\n  // socket.SetSingleDevice (devices.Get(0)->GetIfIndex());\n  socket.SetPhysicalAddress (devices.Get(m_nodes-1)->GetAddress());\n  socket.SetProtocol (0);\n\n  OnOffHelper app (\"ns3::PacketSocketFactory\", Address (socket));\n  app.SetAttribute (\"OnTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=1]\"));\n  app.SetAttribute (\"OffTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0]\"));\n  app.SetAttribute (\"DataRate\", DataRateValue (m_dataInterval));\n  app.SetAttribute (\"PacketSize\", UintegerValue (m_packetSize));\n\n  ApplicationContainer apps = app.Install (nodesCon.Get(0));\n  apps.Start (Seconds (0.5));\n  apps.Stop (Seconds (m_simStop - m_preStop));\n\n  Ptr<Node> sinkNode = nodesCon.Get(m_nodes-1);\n  TypeId psfid = TypeId::LookupByName (\"ns3::PacketSocketFactory\");\n\n  Ptr<Socket> sinkSocket = Socket::CreateSocket (sinkNode, psfid);\n  sinkSocket->Bind (socket);\n\n  Packet::EnablePrinting ();  //for debugging purposes\n  std::cout << \"-----------Running Simulation-----------\\n\";\n  Simulator::Stop(Seconds(m_simStop));\n  Simulator::Run();\n  Simulator::Destroy();\n  std::cout << \"End.\\n\";\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/VBF.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2016 University of Connecticut\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Robert Martin <robert.martin@engr.uconn.edu>\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/energy-module.h\"  //may not be needed here...\n#include \"ns3/aqua-sim-ng-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/callback.h\"\n\n\n/*\n * VBF Test\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"VBF\");\n\nint\nmain (int argc, char *argv[])\n{\n  double simStop = 200; //seconds\n  int nodes = 200;\n  int sinks = 1;\n  uint32_t m_dataRate = 10000;\n  uint32_t m_packetSize = 40;\n  double range = 100;\n  //int m_maxBurst =10;\n\n  LogComponentEnable (\"VBF\", LOG_LEVEL_INFO);\n\n  //to change on the fly\n  CommandLine cmd;\n  cmd.AddValue (\"simStop\", \"Length of simulation\", simStop);\n  cmd.AddValue (\"nodes\", \"Amount of regular underwater nodes\", nodes);\n  cmd.AddValue (\"sinks\", \"Amount of underwater sinks\", sinks);\n  cmd.Parse(argc,argv);\n\n  std::cout << \"-----------Initializing simulation-----------\\n\";\n\n  NodeContainer nodesCon;\n  NodeContainer sinksCon;\n  NodeContainer senderCon;\n  nodesCon.Create(nodes);\n  sinksCon.Create(sinks);\n  senderCon.Create(1);\n\n  PacketSocketHelper socketHelper;\n  socketHelper.Install(nodesCon);\n  socketHelper.Install(sinksCon);\n  socketHelper.Install(senderCon);\n\n  //establish layers using helper's pre-build settings\n  AquaSimChannelHelper channel = AquaSimChannelHelper::Default();\n  channel.SetPropagation(\"ns3::AquaSimRangePropagation\");\n  AquaSimHelper asHelper = AquaSimHelper::Default();\n  //AquaSimEnergyHelper energy;\t//******this could instead be handled by node helper. ****/\n  asHelper.SetChannel(channel.Create());\n  asHelper.SetMac(\"ns3::AquaSimBroadcastMac\");\n  asHelper.SetRouting(\"ns3::AquaSimVBF\", \"Width\", DoubleValue(100), \"TargetPos\", Vector3DValue(Vector(190,190,0)));\n\n  /*\n   * Preset up mobility model for nodes and sinks here\n   */\n  MobilityHelper mobility;\n  MobilityHelper nodeMobility;\n  NetDeviceContainer devices;\n  Ptr<ListPositionAllocator> position = CreateObject<ListPositionAllocator> ();\n\n  std::cout << \"Creating Nodes\\n\";\n\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n    {\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n      devices.Add(asHelper.Create(*i, newDevice));\n      newDevice->GetPhy()->SetTransRange(range);\n    }\n\n  for (NodeContainer::Iterator i = sinksCon.Begin(); i != sinksCon.End(); i++)\n    {\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n      position->Add(Vector(190,190,0));\n      devices.Add(asHelper.Create(*i, newDevice));\n      newDevice->GetPhy()->SetTransRange(range);\n    }\n\n  Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n  position->Add(Vector(10,10,0));\n  devices.Add(asHelper.Create(senderCon.Get(0),newDevice));\n  newDevice->GetPhy()->SetTransRange(range);\n\n  //Set sink at origin and surround with uniform distribution of regular nodes.\n  mobility.SetPositionAllocator(position);\n  mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  nodeMobility.SetPositionAllocator(\"ns3::UniformDiscPositionAllocator\", \"X\", DoubleValue(100.0),\n                                      \"Y\", DoubleValue(100.0), \"rho\", DoubleValue(100));\n  nodeMobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  nodeMobility.Install(nodesCon);\n  mobility.Install(sinksCon);\n  mobility.Install(senderCon);\n\n  PacketSocketAddress socket;\n  socket.SetAllDevices();\n  // socket.SetSingleDevice (devices.Get(0)->GetIfIndex());\n  socket.SetPhysicalAddress (devices.Get(nodes)->GetAddress());\n  socket.SetProtocol (0);\n\n  //std::cout << devices.Get(nodes)->GetAddress() << \" &&& \" << devices.Get(0)->GetIfIndex() << \"\\n\";\n  //std::cout << devices.Get(0)->GetAddress() << \" &&& \" << devices.Get(1)->GetIfIndex() << \"\\n\";\n\n  OnOffHelper app (\"ns3::PacketSocketFactory\", Address (socket));\n  app.SetAttribute (\"OnTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0.0066]\"));\n  app.SetAttribute (\"OffTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0.9934]\"));\n//  app.SetAttribute (\"OnTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0.026]\"));\n//  app.SetAttribute (\"OffTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0.974]\"));\n  app.SetAttribute (\"DataRate\", DataRateValue (m_dataRate));\n  app.SetAttribute (\"PacketSize\", UintegerValue (m_packetSize));\n\n  ApplicationContainer apps = app.Install (senderCon);\n  apps.Start (Seconds (0.5));\n  apps.Stop (Seconds (simStop));\n\n  Ptr<Node> sinkNode = sinksCon.Get(0);\n  TypeId psfid = TypeId::LookupByName (\"ns3::PacketSocketFactory\");\n\n  Ptr<Socket> sinkSocket = Socket::CreateSocket (sinkNode, psfid);\n  sinkSocket->Bind (socket);\n\n\n  Packet::EnablePrinting ();  //for debugging purposes\n  std::cout << \"-----------Running Simulation-----------\\n\";\n  Simulator::Stop(Seconds(simStop));\n  Simulator::Run();\n  asHelper.GetChannel()->PrintCounters();\n  Simulator::Destroy();\n\n  std::cout << \"fin.\\n\";\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/aloha_grid_test.cc",
      "code": "/*\n * aloha_tests.cc\n *\n *  Created on: March 8, 2019\n *      Author: dmitry\n */\n\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/aqua-sim-ng-module.h\"\n#include \"ns3/aqua-sim-propagation.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/callback.h\"\n\n#include <random>\n#include <math.h>\n\n/*\n * ALOHA NxN grid random destination topology tests\n *\n *\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ALOHA_grid_test\");\n\nint\nmain (int argc, char *argv[])\n{\n  double simStop = 100; //seconds\n//  double simStop = 2; //seconds\n\n  int n_nodes = 10;\n//  int sinks = 1;\n//  uint32_t m_dataRate = 80000; // bps\n  double m_dataRate = 80000; // bps\n\n  double m_packetSize = 50; // bytes\n  double range = 1500;\t// meters\n\n  // Poisson traffic parameters\n  double lambda = 0.1;\n\n  // Grid parameters\n  int max_x = 100; // meters\n//  int max_y = 10000; // meters\n//  double distance = 10; // meters\n\n  // Max Tx power\n  double max_tx_power = 20; // Watts\n\n//  LogComponentEnable (\"ASBroadcastMac\", LOG_LEVEL_INFO);\n\n  //to change on the fly\n  CommandLine cmd;\n  cmd.AddValue (\"simStop\", \"Length of simulation\", simStop);\n  cmd.AddValue (\"lambda\", \"Packet arrival rate\", lambda);\n  cmd.AddValue (\"packet_size\", \"Packet size\", m_packetSize);\n  cmd.AddValue (\"grid_size\", \"Grid size, in km\", max_x);\n  cmd.AddValue (\"n_nodes\", \"Number of nodes\", n_nodes);\n  cmd.AddValue (\"range\", \"Transmission range\", range);\n  cmd.AddValue (\"tx_power\", \"Max transmission power\", max_tx_power);\n\n\n  cmd.Parse(argc,argv);\n\n  // Random integer selection-related parameters\n  std::random_device rd;     // only used once to initialise (seed) engine\n  std::mt19937 rng(rd());    // random-number engine used (Mersenne-Twister in this case)\n  std::uniform_int_distribution<int> uni_distance(0, max_x); // guaranteed unbiased\n  std::uniform_int_distribution<int> uni_nodes(0, n_nodes - 1); // guaranteed unbiased\n\n\n  std::cout << \"-----------Initializing simulation-----------\\n\";\n\n  NodeContainer nodesCon;\n//  NodeContainer sinksCon;\n  nodesCon.Create(n_nodes);\n//  sinksCon.Create(sinks);\n\n  PacketSocketHelper socketHelper;\n  socketHelper.Install(nodesCon);\n//  socketHelper.Install(sinksCon);\n\n  //establish layers using helper's pre-build settings\n  AquaSimChannelHelper channel = AquaSimChannelHelper::Default();\n  channel.SetPropagation(\"ns3::AquaSimRangePropagation\");\n  AquaSimHelper asHelper = AquaSimHelper::Default();\n  asHelper.SetChannel(channel.Create());\n\n  asHelper.SetMac(\"ns3::AquaSimAloha\", \"AckOn\", IntegerValue(0), \"MinBackoff\", DoubleValue(0.0),\n\t\t  \"MaxBackoff\", DoubleValue(1.5));\n\n  asHelper.SetRouting(\"ns3::AquaSimRoutingDummy\");\n\n  // Define the Tx power\n  asHelper.SetPhy(\"ns3::AquaSimPhyCmn\", \"PT\", DoubleValue(max_tx_power));\n\n  /*\n   * Set up mobility model for nodes and sinks\n   */\n  MobilityHelper mobility;\n  NetDeviceContainer devices;\n  Ptr<ListPositionAllocator> position = CreateObject<ListPositionAllocator> ();\n  Vector boundry = Vector(0,0,0);\n\n  std::cout << \"Creating Nodes\\n\";\n\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n    {\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n\n      // Select random (x, y) position\n      boundry.x = uni_distance(rng);\n      boundry.y = uni_distance(rng);\n\n      position->Add(boundry);\n      devices.Add(asHelper.Create(*i, newDevice));\n\n//      NS_LOG_DEBUG(\"Node:\" << newDevice->GetAddress() << \" position(x):\" << boundry.x);\n//      std::cout << \"Node:\" << newDevice->GetAddress() << \" position(x):\" << boundry.x <<\n//    \t\t  \" position(y):\" << boundry.y << \"\\n\";\n      newDevice->GetPhy()->SetTransRange(range);\n//      newDevice->GetPhy()->SetTxPower(0.001);\n    }\n\n  mobility.SetPositionAllocator(position);\n  mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install(nodesCon);\n//  mobility.Install(sinksCon);\n\n  int j = 0;\n  char duration_on[300];\n  char duration_off[300];\n\n  // Set application to each node\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n  {\n\t  AquaSimApplicationHelper app (\"ns3::PacketSocketFactory\", n_nodes);\n\n\t  sprintf(duration_on, \"ns3::ExponentialRandomVariable[Mean=%f]\", (m_packetSize * 8) / m_dataRate);\n\t  sprintf(duration_off, \"ns3::ExponentialRandomVariable[Mean=%f]\", 1 / lambda);\n//\t  std::cout << \"Duration On: \" << duration_on << \"\\n\";\n//\t  std::cout << \"Duration Off: \" << duration_off << \"\\n\";\n\t  app.SetAttribute (\"OnTime\", StringValue (duration_on));\n\t  app.SetAttribute (\"OffTime\", StringValue (duration_off));\n\n\t  app.SetAttribute (\"DataRate\", DataRateValue (m_dataRate));\n\t  app.SetAttribute (\"PacketSize\", UintegerValue (m_packetSize));\n\n\t  ApplicationContainer apps = app.Install (nodesCon.Get(j));\n\n\t  apps.Start (Seconds (0.5));\n\t  apps.Stop (Seconds (simStop + 1));\n\n\t  j++;\n  }\n\n  Packet::EnablePrinting (); //for debugging purposes\n  std::cout << \"-----------Running Simulation-----------\\n\";\n  Simulator::Stop(Seconds(simStop));\n\n  // Enable ASCII trace files\n  Packet::EnablePrinting ();  //for debugging purposes\n  char buff[1000];\n  // Naming convention: lambda-number_of_nodes-n_intermediate_nodes-seed\n  std::stringstream stream;\n  stream << std::fixed << std::setprecision(2) << lambda;\n  std::string lambda_string = stream.str();\n  snprintf(buff, sizeof(buff), \"aloha-density-trace-%s-%d-%d.asc\", lambda_string.c_str(), n_nodes, 0);\n  std::string asciiTraceFile = buff;\n\n  // std::string asciiTraceFile = \"aloha-trace.asc\";\n  // asciiTraceFile.\n  std::ofstream ascii (asciiTraceFile.c_str());\n  if (!ascii.is_open()) {\n    NS_FATAL_ERROR(\"Could not open trace file.\");\n  }\n  asHelper.EnableAsciiAll(ascii);\n\n  Simulator::Run();\n\n  asHelper.GetChannel()->PrintCounters();\n\n  Simulator::Destroy();\n\n  std::cout << \"fin.\\n\";\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/bMAC.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2017 University of Connecticut\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Robert Martin <robert.martin@engr.uconn.edu>\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/energy-module.h\"  //may not be needed here...\n#include \"ns3/aqua-sim-ng-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/callback.h\"\n#include \"ns3/netanim-module.h\"\n\n#include <fstream>\n\n/*\n * BroadCastMAC\n *\n * N ---->  N  -----> N -----> N* -----> S\n *\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BMac\");\n\nclass Test\n{\npublic:\n  void RunTest();\n  void ReceivedPkt(Ptr<Socket> socket);\n};\n\nvoid Test::ReceivedPkt(Ptr<Socket> socket)\n{\n  std::cout << \"Received a packet\\n\";\n}\n\nvoid Test::RunTest()\n{\n  double simStop = 500; //seconds\n  int nodes = 4;\n  int sinks = 1;\n  uint32_t m_dataRate = 180;//120;\n  uint32_t m_packetSize = 320;//32;\n  double range = 40;\n\n  std::string asciiTraceFile = \"bMAC-trace.asc\";\n\n  /*\n   * **********\n   * Node -> NetDevice -> AquaSimNetDeive -> etc.\n   * Note: Nodelist keeps track of all nodes created.\n   * ---Also need to look into id of nodes and assignment of this\n   * ---need to look at assignment of address and making it unique per node.\n   *\n   *\n   *  Ensure to use NS_LOG when testing in terminal. ie. ./waf --run broadcastMAC_example NS_LOG=Node=level_all or export 'NS_LOG=*=level_all|prefix_func'\n   *  *********\n   */\n\n  LogComponentEnable (\"BMac\", LOG_LEVEL_INFO);\n\n  std::cout << \"-----------Initializing simulation-----------\\n\";\n\n  NodeContainer nodesCon;\n  NodeContainer sinksCon;\n  nodesCon.Create(nodes);\n  sinksCon.Create(sinks);\n\n  PacketSocketHelper socketHelper;\n  socketHelper.Install(nodesCon);\n  socketHelper.Install(sinksCon);\n\n  //establish layers using helper's pre-build settings\n  AquaSimChannelHelper channel = AquaSimChannelHelper::Default();\n  channel.SetPropagation(\"ns3::AquaSimRangePropagation\");\n  AquaSimHelper asHelper = AquaSimHelper::Default();\n  //AquaSimEnergyHelper energy;\t//******this could instead be handled by node helper. ****/\n  asHelper.SetChannel(channel.Create());\n  asHelper.SetMac(\"ns3::AquaSimBroadcastMac\");\n  asHelper.SetRouting(\"ns3::AquaSimRoutingDummy\"); //XXX\n\n  /*\n   * Preset up mobility model for nodes and sinks here\n   */\n  MobilityHelper mobility;\n  NetDeviceContainer devices;\n  Ptr<ListPositionAllocator> position = CreateObject<ListPositionAllocator> ();\n\n  //Static Y and Z dimension for now\n  Vector boundry = Vector(0,0,0);\n\n  std::cout << \"Creating Nodes\\n\";\n\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n    {\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n      position->Add(boundry);\n\n      devices.Add(asHelper.Create(*i, newDevice));\n\n    /*  NS_LOG_DEBUG(\"Node: \" << *i << \" newDevice: \" << newDevice << \" Position: \" <<\n\t\t     boundry.x << \",\" << boundry.y << \",\" << boundry.z <<\n\t\t     \" freq:\" << newDevice->GetPhy()->GetFrequency() << \" addr:\" <<\n         AquaSimAddress::ConvertFrom(newDevice->GetAddress()).GetAsInt() );\n\t\t  */   //<<\n\t\t     //\" NDtypeid:\" << newDevice->GetTypeId() <<\n\t\t     //\" Ptypeid:\" << newDevice->GetPhy()->GetTypeId());\n\n      boundry.x += 20;\n      newDevice->GetPhy()->SetTransRange(range);\n    }\n\n  for (NodeContainer::Iterator i = sinksCon.Begin(); i != sinksCon.End(); i++)\n    {\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n      position->Add(boundry);\n\n      devices.Add(asHelper.Create(*i, newDevice));\n\n    /*  NS_LOG_DEBUG(\"Sink: \" << *i << \" newDevice: \" << newDevice << \" Position: \" <<\n\t\t     boundry.x << \",\" << boundry.y << \",\" << boundry.z<< \" addr:\" <<\n         AquaSimAddress::ConvertFrom(newDevice->GetAddress()).GetAsInt() );\n         */\n      boundry.x += 20;\n      newDevice->GetPhy()->SetTransRange(range);\n    }\n\n\n  mobility.SetPositionAllocator(position);\n  mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install(nodesCon);\n  mobility.Install(sinksCon);\n\n  PacketSocketAddress socket;\n  socket.SetAllDevices();\n  // socket.SetSingleDevice (devices.Get(0)->GetIfIndex());\n  socket.SetPhysicalAddress (devices.Get(nodes)->GetAddress()); //for &dest on Recv()\n  socket.SetProtocol (0);\n\n  OnOffHelper app (\"ns3::PacketSocketFactory\", Address (socket));\n  app.SetAttribute (\"OnTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=1]\"));\n  app.SetAttribute (\"OffTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0]\"));\n  app.SetAttribute (\"DataRate\", DataRateValue (m_dataRate));\n  app.SetAttribute (\"PacketSize\", UintegerValue (m_packetSize));\n\n  ApplicationContainer apps = app.Install (nodesCon.Get(0));\n  apps.Start (Seconds (0.5));\n  apps.Stop (Seconds (simStop + 1));\n  ApplicationContainer apps2 = app.Install (nodesCon.Get(1));\n  apps2.Start (Seconds (0.6));\n  apps2.Stop (Seconds (simStop + 1.1));\n\n  Ptr<Node> sinkNode = sinksCon.Get(0);\n  TypeId psfid = TypeId::LookupByName (\"ns3::PacketSocketFactory\");\n\n  Ptr<Socket> sinkSocket = Socket::CreateSocket (sinkNode, psfid);\n  sinkSocket->Bind (socket);\n  sinkSocket->SetRecvCallback (MakeCallback (&Test::ReceivedPkt, this));\n\n  Packet::EnablePrinting ();  //for debugging purposes\n  Simulator::Stop(Seconds(simStop));\n  //AnimationInterface anim (\"bmac-anim.xml\"); /* Animiation is very buggy with Aqua-Sim NG */\n  std::ofstream ascii (asciiTraceFile.c_str());\n  if (!ascii.is_open()) {\n    NS_FATAL_ERROR(\"Could not open trace file.\");\n  }\n  asHelper.EnableAsciiAll(ascii);\n\n  std::cout << \"-----------Running Simulation-----------\\n\";\n  Simulator::Run();\n  Simulator::Destroy();\n\n  std::cout << \"fin.\\n\";\n}\n\nint\nmain (int argc, char *argv[])\n{\n  Test test;\n  test.RunTest();\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/broadcastMAC_example.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2016 University of Connecticut\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Robert Martin <robert.martin@engr.uconn.edu>\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/aqua-sim-ng-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/callback.h\"\n\n\n/*\n * BroadCastMAC\n *\n * String topology:\n * N ---->  N  -----> N -----> N* -----> S\n *\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ASBroadcastMac\");\n\nint\nmain (int argc, char *argv[])\n{\n  double simStop = 100; //seconds\n  int nodes = 3;\n  int sinks = 1;\n  uint32_t m_dataRate = 128;\n  uint32_t m_packetSize = 40;\n  //double range = 20;\n\n  LogComponentEnable (\"ASBroadcastMac\", LOG_LEVEL_INFO);\n\n  //to change on the fly\n  CommandLine cmd;\n  cmd.AddValue (\"simStop\", \"Length of simulation\", simStop);\n  cmd.AddValue (\"nodes\", \"Amount of regular underwater nodes\", nodes);\n  cmd.AddValue (\"sinks\", \"Amount of underwater sinks\", sinks);\n  cmd.Parse(argc,argv);\n\n  std::cout << \"-----------Initializing simulation-----------\\n\";\n\n  NodeContainer nodesCon;\n  NodeContainer sinksCon;\n  nodesCon.Create(nodes);\n  sinksCon.Create(sinks);\n\n  PacketSocketHelper socketHelper;\n  socketHelper.Install(nodesCon);\n  socketHelper.Install(sinksCon);\n\n  //establish layers using helper's pre-build settings\n  AquaSimChannelHelper channel = AquaSimChannelHelper::Default();\n  //channel.SetPropagation(\"ns3::AquaSimRangePropagation\");\n  AquaSimHelper asHelper = AquaSimHelper::Default();\n  asHelper.SetChannel(channel.Create());\n  asHelper.SetMac(\"ns3::AquaSimBroadcastMac\");\n  asHelper.SetRouting(\"ns3::AquaSimRoutingDummy\");\n\n  /*\n   * Set up mobility model for nodes and sinks\n   */\n  MobilityHelper mobility;\n  NetDeviceContainer devices;\n  Ptr<ListPositionAllocator> position = CreateObject<ListPositionAllocator> ();\n  Vector boundry = Vector(0,0,0);\n\n  std::cout << \"Creating Nodes\\n\";\n\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n    {\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n      position->Add(boundry);\n      devices.Add(asHelper.Create(*i, newDevice));\n\n      NS_LOG_DEBUG(\"Node:\" << newDevice->GetAddress() << \" position(x):\" << boundry.x);\n      boundry.x += 100;\n      //newDevice->GetPhy()->SetTransRange(range);\n    }\n\n  for (NodeContainer::Iterator i = sinksCon.Begin(); i != sinksCon.End(); i++)\n    {\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n      position->Add(boundry);\n      devices.Add(asHelper.Create(*i, newDevice));\n\n      NS_LOG_DEBUG(\"Sink:\" << newDevice->GetAddress() << \" position(x):\" << boundry.x);\n      boundry.x += 100;\n      //newDevice->GetPhy()->SetTransRange(range);\n    }\n\n\n  mobility.SetPositionAllocator(position);\n  mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install(nodesCon);\n  mobility.Install(sinksCon);\n\n  PacketSocketAddress socket;\n  socket.SetAllDevices();\n  socket.SetPhysicalAddress (devices.Get(nodes)->GetAddress()); //Set dest to first sink (nodes+1 device)\n  socket.SetProtocol (0);\n\n  OnOffHelper app (\"ns3::PacketSocketFactory\", Address (socket));\n  app.SetAttribute (\"OnTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=1]\"));\n  app.SetAttribute (\"OffTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0]\"));\n  app.SetAttribute (\"DataRate\", DataRateValue (m_dataRate));\n  app.SetAttribute (\"PacketSize\", UintegerValue (m_packetSize));\n\n  ApplicationContainer apps = app.Install (nodesCon);\n  apps.Start (Seconds (0.5));\n  apps.Stop (Seconds (simStop + 1));\n\n\n  Ptr<Node> sinkNode = sinksCon.Get(0);\n  TypeId psfid = TypeId::LookupByName (\"ns3::PacketSocketFactory\");\n\n  Ptr<Socket> sinkSocket = Socket::CreateSocket (sinkNode, psfid);\n  sinkSocket->Bind (socket);\n\n/*\n *  For channel trace driven simulation\n */\n/*\n  AquaSimTraceReader tReader;\n  tReader.SetChannel(asHelper.GetChannel());\n  if (tReader.ReadFile(\"channelTrace.txt\")) NS_LOG_DEBUG(\"Trace Reader Success\");\n  else NS_LOG_DEBUG(\"Trace Reader Failure\");\n*/\n\n  Packet::EnablePrinting (); //for debugging purposes\n  std::cout << \"-----------Running Simulation-----------\\n\";\n  Simulator::Stop(Seconds(simStop));\n  Simulator::Run();\n  Simulator::Destroy();\n\n  std::cout << \"fin.\\n\";\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/ddos.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2016 University of Connecticut\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Robert Martin <robert.martin@engr.uconn.edu>\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/energy-module.h\"  //may not be needed here...\n#include \"ns3/aqua-sim-ng-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/callback.h\"\n#include <math.h>\n#include <sstream>\n\n#include <iostream>\n#include <fstream>\n/*\n *  Tree like topography\n *\n *  Protocol description can be found at:\n *  Robert Martin, Sanguthevar Rajasekaran, \"Data Centric Approach to\n *    Analyzing Security Threats in Underwater Sensor Networks,\"\n *    in Proceedings of IEEE/MTS OCEANS, Monterey, California, USA, 2016 (to appear).\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"DdosSim\");\n\nstatic void\nTrafficTracer (Ptr<OutputStreamWrapper> stream, uint32_t oldval, uint32_t newval)\n{\n  *stream->GetStream () << oldval << \" \" << newval << std::endl;\n}\n\nstatic void\nTraceTraffic (std::string trafficTrFileName)\n{\n  AsciiTraceHelper ascii;\n  if (trafficTrFileName.compare (\"\") == 0)\n    {\n      NS_LOG_DEBUG (\"No trace file for traffic provided\");\n      return;\n    }\n  else\n    {\n      Ptr<OutputStreamWrapper> stream = ascii.CreateFileStream (trafficTrFileName.c_str ());\n      Config::ConnectWithoutContext (\"/NodeList/1/ns3::AquaSimNetDevice/AquaSimRouting/TrafficPkts\",MakeBoundCallback (&TrafficTracer, stream));\n    }\n}\n\nint\nmain (int argc, char *argv[])\n{\n  std::cout << \"-----------Initializing simulation-----------\\n\";\n\n  double simStop=1000; //seconds\n  double preStop=20; //seconds\n  int nodes=15;\n  int attackers=3;\n  //int sinks;\n  uint32_t m_dataRate=45;\n  uint32_t m_packetSize=32;\n  //NOTE dataRate = 360bps(45Bps)\n  //NOTE pktSize = (interest) 320 b (40 Bytes) / (data) 1 kb (128 Bytes)\n  int totalDataSegments=1500;\n  int traceFreq=30;\n\n  std::string trafficTrFileName = \"ddos.tr\";\n\n  LogComponentEnable (\"DdosSim\", LOG_LEVEL_INFO);\n  //to change on the fly\n  CommandLine cmd;\n  cmd.AddValue (\"simStop\", \"Length of simulation\", simStop);\n  cmd.AddValue (\"nodes\", \"Amount of regular underwater nodes\", nodes);\n  //cmd.AddValue (\"sinks\", \"Amount of underwater sinks\", sinks);\n  cmd.Parse(argc,argv);\n\n  NodeContainer nodesCon;\n  NodeContainer attackerCon;\n  nodesCon.Create(nodes);\n  attackerCon.Create(attackers);\n\n  PacketSocketHelper socketHelper;\n  socketHelper.Install(nodesCon);\n  socketHelper.Install(attackerCon);\n\n  //establish layers using helper's pre-build settings\n  AquaSimChannelHelper channel = AquaSimChannelHelper::Default();\n  AquaSimHelper asHelper = AquaSimHelper::Default();\n  Ptr<AquaSimChannel> c = channel.Create();\n  asHelper.SetChannel(c);\n  asHelper.SetRouting(\"ns3::AquaSimDDOS\");\n\n  /*\n   * Preset up mobility model for nodes and sinks here\n   */\n  MobilityHelper mobility;\n  NetDeviceContainer devices;\n  Ptr<ListPositionAllocator> position = CreateObject<ListPositionAllocator> ();\n\n  std::cout << \"-----------Data/Path Setup-----------\\n\";\n\n  //assumably paths are handled seperately in NDN and therefore simulated as already known\n  std::vector<std::string> allKnownPaths, crabKnownPath, sharkKnownPath, whaleKnownPath,\n                              crabSharkPath, sharkWhalePath;\n  allKnownPaths.push_back(\"/videos/crab/\");\n  allKnownPaths.push_back(\"/videos/shark/\");\n  allKnownPaths.push_back(\"/videos/whale/\");\n\n  crabKnownPath.push_back(\"/videos/crab/\");\n  sharkKnownPath.push_back(\"/videos/shark/\");\n  whaleKnownPath.push_back(\"/videos/whale/\");\n  crabSharkPath.push_back(\"/videos/crab/\");\n  crabSharkPath.push_back(\"/videos/shark/\");\n  sharkWhalePath.push_back(\"/videos/shark/\");\n  sharkWhalePath.push_back(\"/videos/whale/\");\n\n  std::vector<std::string> data0, data1;\n  int segmentOffset = totalDataSegments / 2;\n  for (int i =0; i<segmentOffset; i++)\n  {\n    std::stringstream seg0, seg1;\n    seg0 << \"v\" << i;\n    seg1 << \"v\" << i+segmentOffset;\n    data0.push_back(seg0.str());\n    data1.push_back(seg1.str());\n  }\n\n  std::cout << \"-----------Creating Nodes-----------\\n\";\n\n  /*\n  *     This should be automated...\n  */\n\n  //sink\n  Ptr<AquaSimNetDevice> newDevice0 = CreateObject<AquaSimNetDevice>();\n  position->Add(Vector(6000,10000,0));\n  Ptr<AquaSimNetDevice> sink = asHelper.Create(nodesCon.Get(0), newDevice0);\n  sink->SetSinkStatus();\n  sink->GetRouting()->AssignInternalDataPath(allKnownPaths);  //slightly awkward but works for this.\n  sink->SetIfIndex(0);\n  devices.Add(sink);\n\n  //row 1\n  Ptr<AquaSimNetDevice> newDevice1 = CreateObject<AquaSimNetDevice>();\n  position->Add(Vector(4000,8000,0));\n  Ptr<AquaSimNetDevice> dev1 = asHelper.Create(nodesCon.Get(1), newDevice1);\n  dev1->GetRouting()->AssignInternalDataPath(crabSharkPath);\n  dev1->SetIfIndex(1);\n  devices.Add(dev1);\n\n  Ptr<AquaSimNetDevice> newDevice2 = CreateObject<AquaSimNetDevice>();\n  position->Add(Vector(8000,8000,0));\n  Ptr<AquaSimNetDevice> dev2 = asHelper.Create(nodesCon.Get(2), newDevice2);\n  dev2->GetRouting()->AssignInternalDataPath(sharkWhalePath);\n  dev2->SetIfIndex(1);\n  devices.Add(dev2);\n\n  //row 2\n  Ptr<AquaSimNetDevice> newDevice3 = CreateObject<AquaSimNetDevice>();\n  position->Add(Vector(2000,6000,0));\n  Ptr<AquaSimNetDevice> dev3 = asHelper.Create(nodesCon.Get(3), newDevice3);\n  dev3->GetRouting()->AssignInternalDataPath(crabKnownPath);\n  dev3->SetIfIndex(2);\n  devices.Add(dev3);\n\n  Ptr<AquaSimNetDevice> newDevice4 = CreateObject<AquaSimNetDevice>();\n  position->Add(Vector(6000,6000,0));\n  Ptr<AquaSimNetDevice> dev4 = asHelper.Create(nodesCon.Get(4), newDevice4);\n  dev4->GetRouting()->AssignInternalDataPath(sharkKnownPath);\n  dev4->SetIfIndex(2);\n  devices.Add(dev4);\n\n  Ptr<AquaSimNetDevice> newDevice5 = CreateObject<AquaSimNetDevice>();\n  position->Add(Vector(10000,6000,0));\n  Ptr<AquaSimNetDevice> dev5 = asHelper.Create(nodesCon.Get(5), newDevice5);\n  dev5->GetRouting()->AssignInternalDataPath(whaleKnownPath);\n  dev5->SetIfIndex(2);\n  devices.Add(dev5);\n\n  //row 3\n  Ptr<AquaSimNetDevice> newDevice6 = CreateObject<AquaSimNetDevice>();\n  position->Add(Vector(1000,3000,0));\n  Ptr<AquaSimNetDevice> dev6 = asHelper.Create(nodesCon.Get(6), newDevice6);\n  dev6->GetRouting()->AssignInternalDataPath(crabKnownPath);\n  dev6->SetIfIndex(3);\n  devices.Add(dev6);\n\n  Ptr<AquaSimNetDevice> newDevice7 = CreateObject<AquaSimNetDevice>();\n  position->Add(Vector(6000,3000,0));\n  Ptr<AquaSimNetDevice> dev7 = asHelper.Create(nodesCon.Get(7), newDevice7);\n  dev7->GetRouting()->AssignInternalDataPath(sharkKnownPath);\n  dev7->SetIfIndex(3);\n  devices.Add(dev7);\n\n  Ptr<AquaSimNetDevice> newDevice8 = CreateObject<AquaSimNetDevice>();\n  position->Add(Vector(11000,3000,0));\n  Ptr<AquaSimNetDevice> dev8 = asHelper.Create(nodesCon.Get(8), newDevice8);\n  dev8->GetRouting()->AssignInternalDataPath(whaleKnownPath);\n  dev8->SetIfIndex(3);\n  devices.Add(dev8);\n\n  //data sources:\n  Ptr<AquaSimNetDevice> newDevice9 = CreateObject<AquaSimNetDevice>();\n  position->Add(Vector(0,0,0));\n  Ptr<AquaSimNetDevice> dev9 = asHelper.Create(nodesCon.Get(9), newDevice9);\n  dev9->GetRouting()->AssignInternalDataPath(crabKnownPath);\n  dev9->GetRouting()->AssignInternalData(data0);\n  dev9->SetIfIndex(4);\n  devices.Add(dev9);\n\n  Ptr<AquaSimNetDevice> newDevice10 = CreateObject<AquaSimNetDevice>();\n  position->Add(Vector(2000,0,0));\n  Ptr<AquaSimNetDevice> dev10 = asHelper.Create(nodesCon.Get(10), newDevice10);\n  dev10->GetRouting()->AssignInternalDataPath(crabKnownPath);\n  dev10->GetRouting()->AssignInternalData(data1);\n  dev10->SetIfIndex(4);\n  devices.Add(dev10);\n\n  Ptr<AquaSimNetDevice> newDevice11 = CreateObject<AquaSimNetDevice>();\n  position->Add(Vector(5000,0,0));\n  Ptr<AquaSimNetDevice> dev11 = asHelper.Create(nodesCon.Get(11), newDevice11);\n  dev11->GetRouting()->AssignInternalDataPath(sharkKnownPath);\n  dev11->GetRouting()->AssignInternalData(data0);\n  dev11->SetIfIndex(4);\n  devices.Add(dev11);\n\n  Ptr<AquaSimNetDevice> newDevice12 = CreateObject<AquaSimNetDevice>();\n  position->Add(Vector(7000,0,0));\n  Ptr<AquaSimNetDevice> dev12 = asHelper.Create(nodesCon.Get(12), newDevice12);\n  dev12->GetRouting()->AssignInternalDataPath(sharkKnownPath);\n  dev12->GetRouting()->AssignInternalData(data1);\n  dev12->SetIfIndex(4);\n  devices.Add(dev12);\n\n  Ptr<AquaSimNetDevice> newDevice13 = CreateObject<AquaSimNetDevice>();\n  position->Add(Vector(10000,0,0));\n  Ptr<AquaSimNetDevice> dev13 = asHelper.Create(nodesCon.Get(13), newDevice13);\n  dev13->GetRouting()->AssignInternalDataPath(whaleKnownPath);\n  dev13->GetRouting()->AssignInternalData(data0);\n  dev13->SetIfIndex(4);\n  devices.Add(dev13);\n\n  Ptr<AquaSimNetDevice> newDevice14 = CreateObject<AquaSimNetDevice>();\n  position->Add(Vector(12000,0,0));\n  Ptr<AquaSimNetDevice> dev14 = asHelper.Create(nodesCon.Get(14), newDevice14);\n  dev14->GetRouting()->AssignInternalDataPath(whaleKnownPath);\n  dev14->GetRouting()->AssignInternalData(data1);\n  dev14->SetIfIndex(4);\n  devices.Add(dev14);\n\n\n  //attacker\n  asHelper.SetRouting(\"ns3::AquaSimDDOS\", \"Attacker\", BooleanValue(true));\n  MobilityHelper attMobility;\n  Ptr<ListPositionAllocator> attPosition = CreateObject<ListPositionAllocator> ();\n\n  Ptr<AquaSimNetDevice> attackDevice0 = CreateObject<AquaSimNetDevice>();\n  attPosition->Add(Vector(1000,5000,0));\n  Ptr<AquaSimNetDevice> attacker0 = asHelper.Create(attackerCon.Get(0), attackDevice0);\n  //attacker->SetSinkStatus();\n  attacker0->GetRouting()->AssignInternalDataPath(allKnownPaths);\n  attacker0->SetIfIndex(2);\n  devices.Add(attacker0);\n\n  Ptr<AquaSimNetDevice> attackDevice1 = CreateObject<AquaSimNetDevice>();\n  attPosition->Add(Vector(6000,5000,0));\n  Ptr<AquaSimNetDevice> attacker1 = asHelper.Create(attackerCon.Get(1), attackDevice1);\n  //attacker->SetSinkStatus();\n  attacker1->GetRouting()->AssignInternalDataPath(allKnownPaths);\n  attacker1->SetIfIndex(2);\n  devices.Add(attacker1);\n\n  Ptr<AquaSimNetDevice> attackDevice2 = CreateObject<AquaSimNetDevice>();\n  attPosition->Add(Vector(11000,5000,0));\n  Ptr<AquaSimNetDevice> attacker2 = asHelper.Create(attackerCon.Get(2), attackDevice2);\n  //attacker->SetSinkStatus();\n  attacker2->GetRouting()->AssignInternalDataPath(allKnownPaths);\n  attacker2->SetIfIndex(2);\n  devices.Add(attacker2);\n\n  int id = 0;\n  for (NetDeviceContainer::Iterator i = devices.Begin(); i != devices.End(); i++)\n  {\n    if (id >= nodes) continue;\n\n    Vector v = position->GetNext();\n    NS_LOG_DEBUG(\"Node(\" << id << \") Position:(\" << v.x << \",\" << v.y << \",\" << v.z << \")\");\n    id++;\n  }\n\n  mobility.SetPositionAllocator(position);\n  mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install(nodesCon);\n  attMobility.SetPositionAllocator(attPosition);\n  //attMobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  attMobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                               \"Mode\", StringValue (\"Time\"),\n                               \"Time\", StringValue (\"500s\"),\n                               \"Speed\", StringValue (\"ns3::UniformRandomVariable[Min=0.5|Max=2.0]\"),\n                               \"Bounds\", StringValue (\"0|12000|0|10000\")); //,\n                               //\"Direction\", StringValue (\"ns3::UniformRandomVariable[Min=4.7|Max=1.5]\"));\n\n  attMobility.Install(attackerCon);\n  // NOTE Mobile Attacker Speed = 1 to 4 knots (0.5 to 2.0 m/s).\n\n  PacketSocketAddress socket;\n  socket.SetAllDevices();\n  // socket.SetSingleDevice (devices.Get(0)->GetIfIndex());\n  socket.SetPhysicalAddress (devices.Get(nodes-1)->GetAddress());\n  socket.SetProtocol (0);\n\n\n  OnOffHelper app (\"ns3::PacketSocketFactory\", Address (socket));\n  app.SetAttribute (\"OnTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0.25]\"));\n  app.SetAttribute (\"OffTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0.75]\"));\n  app.SetAttribute (\"DataRate\", DataRateValue (m_dataRate));\n  app.SetAttribute (\"PacketSize\", UintegerValue (m_packetSize));\n  app.SetAttribute(\"MaxBytes\", UintegerValue (0));\n  //change above to create interesting interest types (pkt spikes / heavy attacks)\n\n  /*XXX should be changed and handled by tracers... and FileHandler API.\n  FILE * pFile;\n  pFile = fopen (\"outputFile.txt\", \"a\");\n  if (pFile!=NULL)\n  {\n    fputs (\"Simulation Started.\",pFile);\n    fclose (pFile);\n  }*/\n\n  ApplicationContainer apps = app.Install (nodesCon.Get(0));\n  apps.Start (Seconds (0.5));\n  apps.Stop (Seconds (simStop - preStop));\n\n  //look into this note with a quick check...\n  /* NOTE besides the main traffic generator, others are having no effect besides creating additional traffic\n      Since i am not seeing any change in how many pkt the sink is receiving, meaning either\n      there is no recv socket set up correctly (most likely not the case),\n      SinkStatus not set for node (may be true but outside of 1 sink, attackers should behave similar to sinks),\n      OR protocol is behaving normally and suppressing duplicates (MOST LIKELY but needs testing.)\n  */\n\n  ApplicationContainer apps2 = app.Install (attackerCon.Get(0));\n  apps2.Start (Seconds (0.5));\n  apps2.Stop (Seconds (simStop - preStop));\n  ApplicationContainer apps3 = app.Install (attackerCon.Get(1));\n  apps3.Start (Seconds (0.5));\n  apps3.Stop (Seconds (simStop - preStop));\n  ApplicationContainer apps4 = app.Install (attackerCon.Get(2));\n  apps4.Start (Seconds (0.5));\n  apps4.Stop (Seconds (simStop - preStop));\n\n\n  Ptr<Node> sinkNode = nodesCon.Get(0);\n  TypeId psfid = TypeId::LookupByName (\"ns3::PacketSocketFactory\");\n\n  Ptr<Socket> sinkSocket = Socket::CreateSocket (sinkNode, psfid);\n  sinkSocket->Bind (socket);\n  //sinkSocket->SetRecvCallback (MakeCallback (&LocalExperiment::RecvPacket, this));\n\n/*\n  ApplicationContainer serverApp;\n  UdpServerHelper myServer (250);\n  serverApp = myServer.Install (nodesCon.Get (0));\n  serverApp.Start (Seconds (0.0));\n  serverApp.Stop (Seconds (simStop + 1));\n*/ //TODO implement application within this example...\n\n  Packet::EnablePrinting ();  //for debugging purposes\n  std::cout << \"-----------Running Simulation-----------\\n\";\n\n  Simulator::Schedule (Seconds (0.00001), &TraceTraffic, trafficTrFileName);\n  //XXX should be changed and handled by tracers... and FileHandler API.\n\n  Simulator::Stop(Seconds(simStop +1));\n  for (int i = traceFreq; i < simStop; i += traceFreq )\n  {\n    Simulator::Schedule(Seconds(i),&AquaSimChannel::FilePrintCounters,c,i,15);\n  }\n  //Simulator::Schedule(Seconds(100),&AquaSimChannel::FilePrintCounters,c,100,15);\n  Simulator::Run();\n  Simulator::Destroy(); //null all nodes too??\n  std::cout << \"-----------Printing Simulation Results-----------\\n\";\n\n  asHelper.GetChannel()->PrintCounters();\n  asHelper.GetChannel()->FilePrintCounters(simStop,15);\n\n  std::cout << \"End.\\n\";\n\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/floodMac.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Moshin Raza Jafri <mohsin.jafri@unive.it>\n */\n\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/energy-module.h\"\n#include \"ns3/aqua-sim-ng-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/callback.h\"\n#include <math.h>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"FloodingMac\");\n\nclass LocalExperiment\n{\npublic:\n  LocalExperiment();\n  void Run();\n  void RecvPacket(Ptr<Socket> socket);\n  void UpdatePosition(ConstantVelocityHelper helper);\n  Box m_topo;\n  double simStop; //seconds\n  int nodes;\n  int sinks;\n  uint32_t m_dataRate;\n  uint32_t m_packetSize;\n  double m_minSpeed; // min speed of node\n  double m_maxSpeed; // max speed of node\n};\n\nvoid\nLocalExperiment::UpdatePosition(ConstantVelocityHelper helper)\n{\n  helper.UpdateWithBounds(m_topo);\n}\n\nLocalExperiment::LocalExperiment() :\n  simStop(100), nodes(800), sinks(1),\n  m_dataRate(100), m_packetSize(32)\n{\n}\n\nvoid\nLocalExperiment::RecvPacket(Ptr<Socket> socket)\n{\n  std::cout << \"HIT;\\n\";\n  Ptr<Packet> packet;\n  while ((packet = socket->Recv ()))\n  {\n    std::cout << \"Recv a packet of size \" << packet->GetSize() << \"\\n\";\n    //m_bytesTotal += packet->GetSize ();\n  }\n}\n\nvoid\nLocalExperiment::Run()\n{\n  std::cout << \"-----------Initializing simulation-----------\\n\";\n\n  NodeContainer nodesCon;\n  NodeContainer sinksCon;\n  nodesCon.Create(nodes);\n  sinksCon.Create(sinks);\n\n  PacketSocketHelper socketHelper;\n  socketHelper.Install(nodesCon);\n  socketHelper.Install(sinksCon);\n\n  //establish layers using helper's pre-build settings\n  AquaSimChannelHelper channel = AquaSimChannelHelper::Default();\n  AquaSimHelper asHelper = AquaSimHelper::Default();\n  asHelper.SetChannel(channel.Create());\n  asHelper.SetEnergyModel(\"ns3::AquaSimEnergyModel\",\n                        \"RxPower\", DoubleValue(0.1),\n                        \"TxPower\", DoubleValue(2.0),\n                        \"InitialEnergy\", DoubleValue(50),\n                        \"IdlePower\", DoubleValue(0.01));\n  asHelper.SetMac(\"ns3::AquaSimBroadcastMac\");\n  asHelper.SetRouting(\"ns3::AquaSimDDBR\");\n\n  MobilityHelper mobility;\n  MobilityHelper mobilitysink;\n  NetDeviceContainer devices;\n  Ptr<ListPositionAllocator> position = CreateObject<ListPositionAllocator> ();\n  RngSeedManager::SetSeed(1);\n  RngSeedManager::SetRun (4);\n\n  Ptr<UniformRandomVariable> rand = CreateObject<UniformRandomVariable>();\n\n  LocalExperiment flood;\n  flood.m_topo = Box(0,500,0,500,0,500);\n  // Vector boundry = Vector(125,125,10);\n  Vector boundry = Vector((rand->GetValue(10,490)),(rand->GetValue(10,490)),10);\n  int nodedis = 75;\n  std::cout << \"Creating Nodes\\n\";\n\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n    {\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n      // newDevice->SetTransmitDistance(100);\n      position->Add(boundry);\n      devices.Add(asHelper.Create(*i, newDevice));\n      NS_LOG_DEBUG(\"Node: \" << *i << \" newDevice: \" << newDevice << \" Position:(\" <<\n\t\t     boundry.x << \",\" << boundry.y << \",\" << boundry.z <<\n          \") freq:\" << newDevice->GetPhy()->GetFrequency()<<\" id:\"<<newDevice->GetAddress()<<\" new id:\"<<\n           AquaSimAddress::ConvertFrom(newDevice->GetAddress()).GetAsInt() );\n\n      boundry.x = rand->GetValue(20,490);\n      boundry.y = rand->GetValue(20,490);\n      boundry.z = rand->GetValue(20,490);\n    }\n\n  for (NodeContainer::Iterator i = sinksCon.Begin(); i != sinksCon.End(); i++)\n    {\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n      // newDevice->SetTransmitDistance(100);\n      boundry.x += nodedis;\n      boundry.y += nodedis;\n      boundry.z = 500;\n      position->Add(boundry);\n      devices.Add(asHelper.Create(*i, newDevice));\n      NS_LOG_DEBUG(\"Sink: \" << *i << \" newDevice: \" << newDevice << \" Position:(\" <<\n\t\t     boundry.x << \",\" << boundry.y << \",\" << boundry.z << \")\");\n\n    }\n\n  mobility.SetPositionAllocator(position);\n  mobilitysink.SetPositionAllocator(position);\n  mobility.SetMobilityModel (\"ns3::RandomDirection2dMobilityModel\",\n                             \"Bounds\", RectangleValue (Rectangle (0, 500, 0, 500)),\n                             \"Speed\", StringValue (\"ns3::ConstantRandomVariable[Constant=1]\"),\n                             \"Pause\", StringValue (\"ns3::ConstantRandomVariable[Constant=0.01]\"));\n\n// mobility.SetMobilityModel (\"ns3::GaussMarkovMobilityModel\",\n//                             \"Bounds\", BoxValue (Box (0, 245, 0, 245, 0, 245)),\n//                             \"TimeStep\", TimeValue (Seconds (0.00001)),\n//                             \"Alpha\", DoubleValue (0.85),\n//                             \"MeanVelocity\", StringValue (\"ns3::UniformRandomVariable[Min=0.0|Max=3.0]\"),\n//                             \"MeanDirection\", StringValue (\"ns3::UniformRandomVariable[Min=0|Max=6.283185307]\"),\n//                             \"MeanPitch\", StringValue (\"ns3::UniformRandomVariable[Min=0.05|Max=0.05]\"),\n//                             \"NormalVelocity\", StringValue (\"ns3::NormalRandomVariable[Mean=0.0|Variance=0.0|Bound=0.0]\"),\n//                             \"NormalDirection\", StringValue (\"ns3::NormalRandomVariable[Mean=0.0|Variance=0.2|Bound=0.4]\"),\n//                             \"NormalPitch\", StringValue (\"ns3::NormalRandomVariable[Mean=0.0|Variance=0.02|Bound=0.04]\"));\n\n  mobilitysink.SetMobilityModel (\"ns3::RandomDirection2dMobilityModel\",\n                             \"Bounds\", RectangleValue (Rectangle (0, 500, 0, 500)),\n                             \"Speed\", StringValue (\"ns3::ConstantRandomVariable[Constant=0.01]\"),\n                             \"Pause\", StringValue (\"ns3::ConstantRandomVariable[Constant=0.01]\"));\n\n  mobility.Install(nodesCon);\n  mobilitysink.Install(sinksCon);\n\n  PacketSocketAddress socket;\n  socket.SetAllDevices();\n  // socket.SetSingleDevice (devices.Get(0)->GetIfIndex());\n  socket.SetPhysicalAddress (devices.Get(nodes+sinks-1)->GetAddress());\n  // socket.SetProtocol (0);\n\n  OnOffHelper app (\"ns3::PacketSocketFactory\", Address (socket));\n  app.SetAttribute (\"OnTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=1]\"));\n  app.SetAttribute (\"OffTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0]\"));\n  app.SetAttribute (\"DataRate\", DataRateValue (m_dataRate));\n  app.SetAttribute (\"PacketSize\", UintegerValue (m_packetSize));\n  // app.SetAttribute (\"MaxBytes\", UintegerValue (0));\n\n  ApplicationContainer apps = app.Install (nodesCon.Get(0));\n  apps.Start (Seconds (0.5));\n  apps.Stop (Seconds (simStop + 1));\n\n  Ptr<Node> sinkNode = sinksCon.Get(0);\n  TypeId psfid = TypeId::LookupByName (\"ns3::PacketSocketFactory\");\n\n  Ptr<Socket> sinkSocket = Socket::CreateSocket (sinkNode, psfid);\n  sinkSocket->Bind (socket);\n  // sinkSocket->SetRecvCallback (MakeCallback (&LocalExperiment::RecvPacket, this));\n\n/*\n  ApplicationContainer serverApp;\n  UdpServerHelper myServer (250);\n  serverApp = myServer.Install (nodesCon.Get (0));\n  serverApp.Start (Seconds (0.0));\n  serverApp.Stop (Seconds (simStop + 1));\n*/ //TODO implement application within this example...\n\n  Packet::EnablePrinting ();  //for debugging purposes\n  std::cout << \"-----------Running Simulation-----------\\n\";\n  Simulator::Stop(Seconds(simStop + 1));\n  Simulator::Run();\n  Simulator::Destroy(); //null all nodes too??\n  std::cout << \"-----------Printing Simulation Results-----------\\n\";\n  asHelper.GetChannel()->PrintCounters();\n  std::cout << \"End.\\n\";\n}\n\nint\nmain (int argc, char *argv[])\n{\n  LocalExperiment exp;\n  LogComponentEnable (\"FloodingMac\", LOG_LEVEL_INFO);\n  CommandLine cmd;\n  cmd.AddValue (\"simStop\", \"Length of simulation\", exp.simStop);\n  cmd.AddValue (\"nodes\", \"Amount of regular underwater nodes\", exp.nodes);\n  cmd.AddValue (\"sinks\", \"Amount of underwater sinks\", exp.sinks);\n  cmd.Parse(argc,argv);\n  exp.Run();\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/floodtest.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2016 University of Connecticut\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Robert Martin <robert.martin@engr.uconn.edu>\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/energy-module.h\"  //may not be needed here...\n#include \"ns3/aqua-sim-ng-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/callback.h\"\n#include <math.h>\n\n/*\n * Flood : 2xN architecture\n *\n * N ---->  N  -----> N -----> N*\n * |        |         |        |    ->(S)\n * N ---->  N  -----> N -----> N*\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"FloodingMac\");\n\nclass LocalExperiment\n{\npublic:\n  LocalExperiment();\n  void Run();\n  void RecvPacket(Ptr<Socket> socket);\n\n  double simStop; //seconds\n  int nodes;\n  int sinks;\n  uint32_t m_dataRate;\n  uint32_t m_packetSize;\n};\n\nLocalExperiment::LocalExperiment() :\n  simStop(100), nodes(4), sinks(1),\n  m_dataRate(20), m_packetSize(32)  //TODO datarate = 180\n{\n}\n\nvoid\nLocalExperiment::RecvPacket(Ptr<Socket> socket)\n{\n  std::cout << \"HIT;\\n\";\n  Ptr<Packet> packet;\n  while ((packet = socket->Recv ()))\n  {\n    std::cout << \"Recv a packet of size \" << packet->GetSize() << \"\\n\";\n    //m_bytesTotal += packet->GetSize ();\n  }\n}\n\nvoid\nLocalExperiment::Run()\n{\n  std::cout << \"-----------Initializing simulation-----------\\n\";\n\n  NodeContainer nodesCon;\n  NodeContainer sinksCon;\n  nodesCon.Create(nodes);\n  sinksCon.Create(sinks);\n\n  PacketSocketHelper socketHelper;\n  socketHelper.Install(nodesCon);\n  socketHelper.Install(sinksCon);\n\n  //establish layers using helper's pre-build settings\n  AquaSimChannelHelper channel = AquaSimChannelHelper::Default();\n  AquaSimHelper asHelper = AquaSimHelper::Default();\n  asHelper.SetChannel(channel.Create());\n  asHelper.SetRouting(\"ns3::AquaSimFloodingRouting\");\n\n  /*\n   * Preset up mobility model for nodes and sinks here\n   */\n  MobilityHelper mobility;\n  NetDeviceContainer devices;\n  Ptr<ListPositionAllocator> position = CreateObject<ListPositionAllocator> ();\n\n  //Static Y and Z dimension for now\n  Vector boundry = Vector(0,0,0);\n\n  std::cout << \"Creating Nodes\\n\";\n\n  int c = 0;\n  int nodeDistance = 2000;\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n    {\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n      position->Add(boundry);\n      devices.Add(asHelper.Create(*i, newDevice));\n\n      NS_LOG_DEBUG(\"Node: \" << *i << \" newDevice: \" << newDevice << \" Position:(\" <<\n\t\t     boundry.x << \",\" << boundry.y << \",\" << boundry.z <<\n\t\t     \") freq:\" << newDevice->GetPhy()->GetFrequency());\n\t\t     //<<\n\t\t     //\" NDtypeid:\" << newDevice->GetTypeId() <<\n\t\t     //\" Ptypeid:\" << newDevice->GetPhy()->GetTypeId());\n\n      if(c%2) //row 1\n      {\n        boundry.y = 0;\n        boundry.x += nodeDistance;\n      }\n      else  //row 2\n      {\n        boundry.y = nodeDistance;\n      }\n      c++;\n    }\n\n  for (NodeContainer::Iterator i = sinksCon.Begin(); i != sinksCon.End(); i++)\n    {\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n\n      if(c%2==1)\n        {boundry.x += nodeDistance;}\n      boundry.y = nodeDistance/2;\n      position->Add(boundry);\n\n      devices.Add(asHelper.Create(*i, newDevice));\n\n      NS_LOG_DEBUG(\"Sink: \" << *i << \" newDevice: \" << newDevice << \" Position:(\" <<\n\t\t     boundry.x << \",\" << boundry.y << \",\" << boundry.z << \")\");\n    }\n\n  mobility.SetPositionAllocator(position);\n  mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install(nodesCon);\n  mobility.Install(sinksCon);\n\n  PacketSocketAddress socket;\n  socket.SetAllDevices();\n  // socket.SetSingleDevice (devices.Get(0)->GetIfIndex());\n  socket.SetPhysicalAddress (devices.Get(nodes+sinks-1)->GetAddress());\n  socket.SetProtocol (0);\n\n\n  OnOffHelper app (\"ns3::PacketSocketFactory\", Address (socket));\n  app.SetAttribute (\"OnTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=1]\"));\n  app.SetAttribute (\"OffTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0]\"));\n  app.SetAttribute (\"DataRate\", DataRateValue (m_dataRate));\n  app.SetAttribute (\"PacketSize\", UintegerValue (m_packetSize));\n\n  ApplicationContainer apps = app.Install (nodesCon.Get(0));\n  apps.Start (Seconds (0.5));\n  apps.Stop (Seconds (simStop + 1));\n\n\n  Ptr<Node> sinkNode = sinksCon.Get(0);\n  TypeId psfid = TypeId::LookupByName (\"ns3::PacketSocketFactory\");\n\n  Ptr<Socket> sinkSocket = Socket::CreateSocket (sinkNode, psfid);\n  sinkSocket->Bind (socket);\n  sinkSocket->SetRecvCallback (MakeCallback (&LocalExperiment::RecvPacket, this));\n\n/*\n  ApplicationContainer serverApp;\n  UdpServerHelper myServer (250);\n  serverApp = myServer.Install (nodesCon.Get (0));\n  serverApp.Start (Seconds (0.0));\n  serverApp.Stop (Seconds (simStop + 1));\n*/ //TODO implement application within this example...\n\n  Packet::EnablePrinting ();  //for debugging purposes\n  std::cout << \"-----------Running Simulation-----------\\n\";\n  Simulator::Stop(Seconds(simStop + 1));\n  Simulator::Run();\n  Simulator::Destroy(); //null all nodes too??\n  std::cout << \"-----------Printing Simulation Results-----------\\n\";\n  asHelper.GetChannel()->PrintCounters();\n  std::cout << \"End.\\n\";\n}\n\nint\nmain (int argc, char *argv[])\n{\n  LocalExperiment exp;\n\n  LogComponentEnable (\"FloodingMac\", LOG_LEVEL_INFO);\n  //to change on the fly\n  CommandLine cmd;\n  cmd.AddValue (\"simStop\", \"Length of simulation\", exp.simStop);\n  cmd.AddValue (\"nodes\", \"Amount of regular underwater nodes\", exp.nodes);\n  cmd.AddValue (\"sinks\", \"Amount of underwater sinks\", exp.sinks);\n  cmd.Parse(argc,argv);\n\n  exp.Run();\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/jmac_test.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Jamming MAC (JMAC) tests\n *\n * Author: Dmitrii Dugaev <ddugaev@gradcenter.cuny.edu>\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/aqua-sim-ng-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/callback.h\"\n\n#include <iomanip>\n\n/*\n * JMAC\n *\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"JammingMacTest\");\n\n// Return random coordinates in a circle with given radius and center, at given depth (y-coord)\nVector\ngetBottomCoords(double center_x, double center_z, double radius, double depth, Ptr<UniformRandomVariable> random_stream)\n{\n  Vector boundry = Vector(0,0,0);\n  double x,z;\n  do\n  {\n    // x = random_stream->GetValue (-radius, radius);\n    // z = random_stream->GetValue (-radius, radius);\n    x = random_stream->GetValue (0, 2*radius);\n    z = random_stream->GetValue (0, 2*radius);\n  }\n  while (std::sqrt (x*x + z*z) > radius);\n\n  boundry.x = x+center_x;\n  boundry.z = z+center_z;\n  boundry.y = depth; // the nodes are located at the bottom\n  return boundry;\n}\n\n// tracebacks for the stats\ndouble vulnerableArea = 0;\ndouble totalEnergy = 0;\nuint32_t totalScheduledPkts = 0;\nuint32_t totalRecvDataPkts = 0;\nuint32_t totalQueueSize = 0;\nuint32_t queueCount = 0;\nuint32_t totalDelay = 0;\nuint32_t delayCount = 0;\nuint32_t totalOrigPkts = 0;\nuint32_t totalPhyTxPkts = 0;\nuint32_t totalPhyRxPkts = 0;\n\nvoid\ntraceVulnerableArea(double area)\n{\n  vulnerableArea += area;\n}\n\nvoid\ntraceEnergy(double energy)\n{\n  totalEnergy += energy;\n}\n\nvoid\ntraceScheduledPkts(uint32_t scheduledPkts)\n{\n  totalScheduledPkts += scheduledPkts;\n}\n\nvoid\ntraceQueueSize(uint32_t qSize)\n{\n  totalQueueSize += qSize;\n  queueCount += 1;\n}\n\nvoid\ntraceE2EDelay(uint32_t delay_ms)\n{\n  totalDelay += delay_ms;\n  delayCount += 1;\n}\n\nvoid\ntraceRecvDataPkts()\n{\n  totalRecvDataPkts += 1;\n}\n\nvoid\ntraceRoutingRx(Ptr<const Packet> packet)\n{\n  totalRecvDataPkts += 1;\n}\n\nvoid\ntraceOrigPkts(Ptr<const Packet> packet)\n{\n  totalOrigPkts += 1;\n}\n\nvoid\ntracePhyTx(Ptr<Packet> packet, double noise)\n{\n  totalPhyTxPkts += 1;\n}\n\nvoid\ntracePhyRx(Ptr<Packet> packet, double noise)\n{\n  totalPhyRxPkts += 1;\n}\n\nint\nmain (int argc, char *argv[])\n{\n  double simStop = 100; //seconds\n  uint32_t seed_no;\n  int nodes = 2;\n  int sinks = 1;\n  double m_dataRate = 24;\n  uint32_t m_packetSize = 100;\n  // location params, meters\n  double radius = 100;\n  double center_x = 100;\n  double center_z = 100;\n  double depth = 100;\n  Time epochTime = Seconds(10);\n  //double range = 20;\n  std::string m_mac_protocol = \"jmac\";\n\n  LogComponentEnable (\"JammingMacTest\", LOG_LEVEL_INFO);\n\n  //to change on the fly\n  CommandLine cmd;\n  cmd.AddValue (\"seed\", \"Seed for random generation\", seed_no);\n  cmd.AddValue (\"simStop\", \"Length of simulation\", simStop);\n  cmd.AddValue (\"nodes\", \"Amount of regular underwater nodes\", nodes);\n  cmd.AddValue (\"sinks\", \"Amount of underwater sinks\", sinks);\n  cmd.AddValue (\"psize\", \"Data packet size, bytes\", m_packetSize);\n  cmd.AddValue (\"rate\", \"Data rate for CBR, bps\", m_dataRate);\n  cmd.AddValue (\"radius\", \"Radius of random nodes at bottom, meters\", radius);\n  cmd.AddValue (\"center_x\", \"Center of a circular bottom: x-coordinate, meters\", center_x);\n  cmd.AddValue (\"center_z\", \"Center of a circular bottom: z-coordinate, meters\", center_z);\n  cmd.AddValue (\"depth\", \"Depth of the bottom, meters\", depth);\n  cmd.AddValue (\"epochTime\", \"Time in-between 2 CC-requests at a node\", epochTime);\n  cmd.AddValue (\"mac\", \"Select between TR-MAC and TDMA\", m_mac_protocol);\n  cmd.Parse(argc,argv);\n\n  std::cout << \"-----------Initializing simulation-----------\\n\";\n\n  // Initialize pseudo-random generator\n  SeedManager::SetSeed (12345);\n  SeedManager::SetRun (seed_no);\n  Ptr<UniformRandomVariable> random_stream = CreateObject<UniformRandomVariable> ();\n\n  NodeContainer nodesCon;\n  NodeContainer sinksCon;\n  nodesCon.Create(nodes);\n  sinksCon.Create(sinks);\n\n  PacketSocketHelper socketHelper;\n  socketHelper.Install(nodesCon);\n  socketHelper.Install(sinksCon);\n\n  //establish layers using helper's pre-build settings\n  AquaSimChannelHelper channel = AquaSimChannelHelper::Default();\n  //channel.SetPropagation(\"ns3::AquaSimRangePropagation\");\n  AquaSimHelper asHelper = AquaSimHelper::Default();\n  asHelper.SetChannel(channel.Create());\n\n  if (m_mac_protocol == \"jmac\")\n  {\n    asHelper.SetMac(\"ns3::AquaSimJammingMac\", \"PacketSize\", IntegerValue(m_packetSize), \"EpochTime\", TimeValue(epochTime));  }\n  else if (m_mac_protocol == \"aloha\")\n  {\n    asHelper.SetMac(\"ns3::AquaSimAloha\", \"AckOn\", IntegerValue(0));\n  }\n  else\n  {\n    NS_FATAL_ERROR (\"Unkown MAC protocol name provided!\");\n  }\n\n\n  asHelper.SetRouting(\"ns3::AquaSimRoutingDummy\");\n\n  /*\n   * Set up mobility model for nodes and sinks\n   */\n  MobilityHelper mobility;\n  NetDeviceContainer devices;\n  Ptr<ListPositionAllocator> position = CreateObject<ListPositionAllocator> ();\n  Vector boundry = Vector(0,0,0);\n\n  std::cout << \"Creating Nodes\\n\";\n\n  // Place nodes at the \"bottom\" - a random circle in (x,z)-plane; y - depth of the \"bottom\"\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n    {\n      position->Add(getBottomCoords(center_x, center_z, radius, depth, random_stream));\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n      devices.Add(asHelper.Create(*i, newDevice));\n      //newDevice->GetPhy()->SetTransRange(range);\n    }\n\n  // Place all sinks at the center of the circle, at 0-meter depth (y=0)\n  // TODO: place multiple sinks at different positions\n  for (NodeContainer::Iterator i = sinksCon.Begin(); i != sinksCon.End(); i++)\n    {\n      boundry.x = center_x;\n      boundry.z = center_z;\n      boundry.y = 0; // sink is located at the surface\n      position->Add(boundry);\n\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n      devices.Add(asHelper.Create(*i, newDevice));\n      //newDevice->GetPhy()->SetTransRange(range);\n    }\n\n  mobility.SetPositionAllocator(position);\n  mobility.Install(nodesCon);\n  mobility.Install(sinksCon);\n\n  // Debug node positions\n  for (uint32_t i = 0; i < nodesCon.GetN(); i++)\n  {    \n    Ptr<MobilityModel> mob = nodesCon.Get(i)->GetObject<MobilityModel>();\n    NS_LOG_DEBUG(\"Node \" << i << \" (x,y,z)-position: (\" << mob->GetPosition().x << \n                  \",\\t\" << mob->GetPosition().y << \",\\t\" << mob->GetPosition().z << \")\");\n  }\n  for (uint32_t i = 0; i < sinksCon.GetN(); i++)\n  {    \n    Ptr<MobilityModel> mob = sinksCon.Get(i)->GetObject<MobilityModel>();\n    NS_LOG_DEBUG(\"Sink \" << i << \" (x,y,z)-position: (\" << mob->GetPosition().x << \n                  \",\\t\" << mob->GetPosition().y << \",\\t\" << mob->GetPosition().z << \")\");\n  }\n\n  // Application and sockets\n  PacketSocketAddress socket;\n  socket.SetAllDevices();\n  socket.SetPhysicalAddress (devices.Get(nodes)->GetAddress()); //Set dest to first sink (nodes+1 device)\n  socket.SetProtocol (0);\n\n  OnOffHelper app (\"ns3::PacketSocketFactory\", Address (socket));\n\n  char duration_on[300];\n  char duration_off[300];\n\n  sprintf(duration_on, \"ns3::ExponentialRandomVariable[Mean=%f]\", (m_packetSize * 8) / m_dataRate);\n  sprintf(duration_off, \"ns3::ExponentialRandomVariable[Mean=%f]\", 1 / 100.0);  // lambda\n\n  app.SetAttribute (\"OnTime\", StringValue (duration_on));\n  app.SetAttribute (\"OffTime\", StringValue (duration_off));\n\n  app.SetAttribute (\"DataRate\", DataRateValue (m_dataRate));\n  app.SetAttribute (\"PacketSize\", UintegerValue (m_packetSize));\n\n  ApplicationContainer apps = app.Install (nodesCon);\n  apps.Start (Seconds (0.5));\n  apps.Stop (Seconds (simStop + 1));\n\n  Ptr<Node> sinkNode = sinksCon.Get(0);\n  TypeId psfid = TypeId::LookupByName (\"ns3::PacketSocketFactory\");\n\n  Ptr<Socket> sinkSocket = Socket::CreateSocket (sinkNode, psfid);\n  sinkSocket->Bind (socket);\n\n  if (m_mac_protocol == \"jmac\") {\n    Config::ConnectWithoutContext (\"/NodeList/*/DeviceList/*/$ns3::NetDevice/Mac/AreaTrace\", MakeCallback (&traceVulnerableArea));\n    Config::ConnectWithoutContext (\"/NodeList/*/DeviceList/*/$ns3::NetDevice/Mac/EnergyTrace\", MakeCallback (&traceEnergy));\n    Config::ConnectWithoutContext (\"/NodeList/*/DeviceList/*/$ns3::NetDevice/Mac/ScheduledPktsTrace\", MakeCallback (&traceScheduledPkts));\n    Config::ConnectWithoutContext (\"/NodeList/*/DeviceList/*/$ns3::NetDevice/Mac/RecvDataPktsTrace\", MakeCallback (&traceRecvDataPkts));\n  }\n  if (m_mac_protocol == \"aloha\") {\n    Config::ConnectWithoutContext (\"/NodeList/*/DeviceList/*/$ns3::NetDevice/Mac/RoutingRx\", MakeCallback (&traceRoutingRx));\n  }\n  Config::ConnectWithoutContext (\"/NodeList/*/DeviceList/*/$ns3::NetDevice/Mac/QueueSizeTrace\", MakeCallback (&traceQueueSize));\n  Config::ConnectWithoutContext (\"/NodeList/*/DeviceList/*/$ns3::NetDevice/Mac/E2EDelayTrace\", MakeCallback (&traceE2EDelay));\n  Config::ConnectWithoutContext (\"/NodeList/*/ApplicationList/*/$ns3::Application/Tx\", MakeCallback (&traceOrigPkts));\n  Config::ConnectWithoutContext (\"/NodeList/*/DeviceList/*/$ns3::NetDevice/Phy/Tx\", MakeCallback (&tracePhyTx));\n  Config::ConnectWithoutContext (\"/NodeList/*/DeviceList/*/$ns3::NetDevice/Phy/Rx\", MakeCallback (&tracePhyRx));\n\n/*\n *  For channel trace driven simulation\n */\n/*\n  AquaSimTraceReader tReader;\n  tReader.SetChannel(asHelper.GetChannel());\n  if (tReader.ReadFile(\"channelTrace.txt\")) NS_LOG_DEBUG(\"Trace Reader Success\");\n  else NS_LOG_DEBUG(\"Trace Reader Failure\");\n*/\n\n  Packet::EnablePrinting (); //for debugging purposes\n  std::cout << \"-----------Running Simulation-----------\\n\";\n  Simulator::Stop(Seconds(simStop));\n  Simulator::Run();\n  asHelper.GetChannel()->PrintCounters();\n  Simulator::Destroy();\n\n  // print the stats\n  // std::cout << \"VULNERABLE AREA: \" << vulnerableArea << \"\\n\";\n  // std::cout << \"TOTAL ENERGY: \" << totalEnergy << \"\\n\";\n\n  std::ofstream results (\"jmac_results.txt\", std::ofstream::app);\n  results << vulnerableArea << \"\\t\" << totalEnergy << \"\\t\"\n  << totalOrigPkts << \"\\t\"\n  << totalRecvDataPkts << \"\\t\"\n  << totalScheduledPkts << \"\\t\"\n  << totalPhyTxPkts << \"\\t\"\n  << totalPhyRxPkts << \"\\t\"\n  << std::setprecision (4) << (double) totalQueueSize/queueCount << \"\\t\"\n  << std::setprecision (8) << (double) totalDelay/delayCount << \"\\t\"\n  << \"\\n\";\n  //\n\n  std::cout << \"fin.\\n\";\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/libra_grid_test.cc",
      "code": "/*\n * libra_tests\n *\n *  Created on: Aug 16, 2019\n *      Author: dmitry\n * \n * Added kinematic mobility model\n */\n\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/aqua-sim-ng-module.h\"\n#include \"ns3/aqua-sim-propagation.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/callback.h\"\n\n#include <random>\n#include <math.h>\n#include <iomanip> // setprecision\n#include <sstream> // stringstream\n\n/*\n * MAC-Libra NxN grid random destination topology tests\n *\n *\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MAC_libra_grid_test\");\n\nint\nmain (int argc, char *argv[])\n{\n  double simStop = 100; //seconds\n//  double simStop = 2; //seconds\n\n  int n_nodes = 10;\n//  int sinks = 1;\n//  uint32_t m_dataRate = 80000; // bps\n  double m_dataRate = 80000; // bps\n\n  double m_packetSize = 50; // bytes\n  double range = 1500;\t// meters\n\n  // Poisson traffic parameters\n  double lambda = 0.1;\n\n  // Grid parameters\n  int max_x = 100; // meters\n//  int max_y = 10000; // meters\n//  double distance = 10; // meters\n\n  // Max Tx power\n  double max_tx_power = 60; // Watts\n\n  // Number of intermediate nodes (only for some experiments!!!)\n  int n_intermediate_nodes = 0;\n\n  //to change on the fly\n  CommandLine cmd;\n  cmd.AddValue (\"simStop\", \"Length of simulation\", simStop);\n  cmd.AddValue (\"lambda\", \"Packet arrival rate\", lambda);\n  cmd.AddValue (\"packet_size\", \"Packet size\", m_packetSize);\n  cmd.AddValue (\"grid_size\", \"Grid size, in km\", max_x);\n  cmd.AddValue (\"n_nodes\", \"Number of nodes\", n_nodes);\n  cmd.AddValue (\"range\", \"Transmission range\", range);\n  cmd.AddValue (\"tx_power\", \"Max transmission power\", max_tx_power);\n  cmd.AddValue (\"intermediate_nodes\", \"Number of intermediate nodes\", n_intermediate_nodes);\n\n\n  cmd.Parse(argc,argv);\n\n  // Random integer selection-related parameters\n  std::random_device rd;     // only used once to initialise (seed) engine\n  std::mt19937 rng(rd());    // random-number engine used (Mersenne-Twister in this case)\n  std::uniform_int_distribution<int> uni_distance(0, max_x); // guaranteed unbiased\n  std::uniform_int_distribution<int> uni_nodes(0, n_nodes - 1); // guaranteed unbiased\n\n\n  std::cout << \"-----------Initializing simulation-----------\\n\";\n\n  NodeContainer nodesCon;\n//  NodeContainer sinksCon;\n  nodesCon.Create(n_nodes);\n//  sinksCon.Create(sinks);\n\n  PacketSocketHelper socketHelper;\n  socketHelper.Install(nodesCon);\n//  socketHelper.Install(sinksCon);\n\n  //establish layers using helper's pre-build settings\n  AquaSimChannelHelper channel = AquaSimChannelHelper::Default();\n  channel.SetPropagation(\"ns3::AquaSimRangePropagation\");\n  AquaSimHelper asHelper = AquaSimHelper::Default();\n  asHelper.SetChannel(channel.Create());\n\n  asHelper.SetMac(\"ns3::AquaSimMacLibra\", \"max_range\", DoubleValue(range), \"max_tx_power\", DoubleValue(max_tx_power),\n  \t\t  \"packet_size\", IntegerValue(m_packetSize), \"intermediate_nodes\", IntegerValue(n_intermediate_nodes));\n\n//    asHelper.SetMac(\"ns3::AquaSimSFama\", \"packet_size\", DoubleValue(m_packetSize));\n//    asHelper.SetMac(\"ns3::AquaSimBroadcastMac\");\n//  asHelper.SetMac(\"ns3::AquaSimAloha\");\n\n  asHelper.SetRouting(\"ns3::AquaSimRoutingDummy\");\n\n  // Define the Tx power\n  asHelper.SetPhy(\"ns3::AquaSimPhyCmn\", \"PT\", DoubleValue(max_tx_power));\n\n\n  /*\n   * Set up mobility model for nodes and sinks\n   */\n  MobilityHelper mobility;\n  NetDeviceContainer devices;\n  Ptr<ListPositionAllocator> position = CreateObject<ListPositionAllocator> ();\n  Vector boundry = Vector(0,0,0);\n\n  std::cout << \"Creating Nodes\\n\";\n\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n    {\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n\n      // Select random (x, y) position\n      boundry.x = uni_distance(rng);\n      boundry.y = uni_distance(rng);\n\n      position->Add(boundry);\n      devices.Add(asHelper.Create(*i, newDevice));\n\n//      NS_LOG_DEBUG(\"Node:\" << newDevice->GetAddress() << \" position(x):\" << boundry.x);\n//      std::cout << \"Node:\" << newDevice->GetAddress() << \" position(x):\" << boundry.x <<\n//    \t\t  \" position(y):\" << boundry.y << \"\\n\";\n      newDevice->GetPhy()->SetTransRange(range);\n//      newDevice->GetPhy()->SetTxPower(0.001);\n    }\n\n  mobility.SetPositionAllocator(position);\n  mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install(nodesCon);\n//  mobility.Install(sinksCon);\n\n  int j = 0;\n  char duration_on[300];\n  char duration_off[300];\n\n  // Set application to each node\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n  {\n\t  AquaSimApplicationHelper app (\"ns3::PacketSocketFactory\", n_nodes);\n\n\t  sprintf(duration_on, \"ns3::ExponentialRandomVariable[Mean=%f]\", (m_packetSize * 8) / m_dataRate);\n\t  sprintf(duration_off, \"ns3::ExponentialRandomVariable[Mean=%f]\", 1 / lambda);\n//\t  std::cout << \"Duration On: \" << duration_on << \"\\n\";\n//\t  std::cout << \"Duration Off: \" << duration_off << \"\\n\";\n\t  app.SetAttribute (\"OnTime\", StringValue (duration_on));\n\t  app.SetAttribute (\"OffTime\", StringValue (duration_off));\n\n\t  app.SetAttribute (\"DataRate\", DataRateValue (m_dataRate));\n\t  app.SetAttribute (\"PacketSize\", UintegerValue (m_packetSize));\n\n\t  ApplicationContainer apps = app.Install (nodesCon.Get(j));\n\n\t  // apps.Start (Seconds (0.5));\n\t  // apps.Stop (Seconds (simStop + 1));\n\n      // Stop the application 30 seconds earlier - for more accurate throughput calculations\n      apps.Start (Seconds (1));\n\t  apps.Stop (Seconds (simStop + 1));\n\n\t  j++;\n  }\n\n  Packet::EnablePrinting (); //for debugging purposes\n  std::cout << \"-----------Running Simulation-----------\\n\";\n  Simulator::Stop(Seconds(simStop + 30));\n\n  // Enable ASCII trace files\n  Packet::EnablePrinting ();  //for debugging purposes\n  char buff[1000];\n  // Naming convention: lambda-number_of_nodes-n_intermediate_nodes-seed\n  std::stringstream stream;\n  stream << std::fixed << std::setprecision(2) << lambda;\n  std::string lambda_string = stream.str();\n  snprintf(buff, sizeof(buff), \"libra-density-trace-%s-%d-%d.asc\", lambda_string.c_str(), n_nodes, n_intermediate_nodes);\n  std::string asciiTraceFile = buff;\n\n  // std::string asciiTraceFile = \"libra-trace.asc\";\n  // asciiTraceFile.\n  std::ofstream ascii (asciiTraceFile.c_str());\n  if (!ascii.is_open()) {\n    NS_FATAL_ERROR(\"Could not open trace file.\");\n  }\n  asHelper.EnableAsciiAll(ascii);\n\n  Simulator::Run();\n\n  asHelper.GetChannel()->PrintCounters();\n\n  Simulator::Destroy();\n\n  std::cout << \"fin.\\n\";\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/named_data_example.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2016 University of Connecticut\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Robert Martin <robert.martin@engr.uconn.edu>\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/energy-module.h\"  //may not be needed here...\n#include \"ns3/aqua-sim-ng-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/callback.h\"\n\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"NamedDataExample\");\n\nint\nmain (int argc, char *argv[])\n{\n  double simStop = 60; //seconds\n  int nodes = 3;\n  uint32_t m_dataRate = 180;\n  uint32_t m_packetSize = 32;\n\n  LogComponentEnable (\"NamedDataExample\", LOG_LEVEL_INFO);\n\n  //to change on the fly\n  CommandLine cmd;\n  cmd.AddValue (\"simStop\", \"Length of simulation\", simStop);\n  cmd.AddValue (\"nodes\", \"Amount of regular underwater nodes\", nodes);\n  cmd.Parse(argc,argv);\n\n  std::cout << \"-----------Initializing simulation-----------\\n\";\n\n  NodeContainer nodesCon;\n  nodesCon.Create(nodes);\n\n  PacketSocketHelper socketHelper;\n  socketHelper.Install(nodesCon);\n\n  //establish layers using helper's pre-build settings\n  AquaSimChannelHelper channel = AquaSimChannelHelper::Default();\n  NamedDataHelper ndHelper;\n  //AquaSimEnergyHelper energy;\t//******this could instead be handled by node helper. ****/\n  ndHelper.SetChannel(channel.Create());\n\n  /*\n   * Preset up mobility model for nodes here\n   */\n  MobilityHelper mobility;\n  NetDeviceContainer devices;\n  Ptr<ListPositionAllocator> position = CreateObject<ListPositionAllocator> ();\n  Vector boundry = Vector(0,0,0);\n\n  std::cout << \"Creating Nodes\\n\";\n\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n    {\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n      position->Add(boundry);\n      devices.Add(ndHelper.Create(*i, newDevice));\n\n      NS_LOG_DEBUG(\"Node: \" << *i << \" newDevice: \" << newDevice << \" Position: \" <<\n\t\t     boundry.x << \",\" << boundry.y << \",\" << boundry.z <<\n\t\t     \" freq:\" << newDevice->GetPhy()->GetFrequency() << \" addr:\" <<\n         AquaSimAddress::ConvertFrom(newDevice->GetAddress()).GetAsInt() );\n\n      boundry.x += 2000;\n    }\n\n  mobility.SetPositionAllocator(position);\n  mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install(nodesCon);\n\n  PacketSocketAddress socket;\n  socket.SetAllDevices();\n  // socket.SetSingleDevice (devices.Get(0)->GetIfIndex());\n  socket.SetPhysicalAddress (devices.Get(0)->GetAddress());\n  socket.SetProtocol (0);\n\n  OnOffNdHelper app (\"ns3::PacketSocketFactory\", Address (socket));\n  app.SetAttribute (\"OnTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=1]\"));\n  app.SetAttribute (\"OffTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0]\"));\n  app.SetAttribute (\"DataRate\", DataRateValue (m_dataRate));\n  app.SetAttribute (\"PacketSize\", UintegerValue (m_packetSize));\n\n  ApplicationContainer apps = app.Install (nodesCon);\n  apps.Start (Seconds (0.5));\n  apps.Stop (Seconds (simStop + 1));\n\n  //XXX remove sink assignment here for a correct producer/consumer app model\n  Ptr<Node> sNode = nodesCon.Get(0);\n  TypeId psfid = TypeId::LookupByName (\"ns3::PacketSocketFactory\");\n\n  Ptr<Socket> sinkSocket = Socket::CreateSocket (sNode, psfid);\n  sinkSocket->Bind (socket);\n\n/*\n  ApplicationContainer serverApp;\n  UdpServerHelper myServer (250);\n  serverApp = myServer.Install (nodesCon.Get (0));\n  serverApp.Start (Seconds (0.0));\n  serverApp.Stop (Seconds (simStop + 1));\n*/ //TODO implement application within this example...\n\n  Packet::EnablePrinting ();  //for debugging purposes\n  std::cout << \"-----------Running Simulation-----------\\n\";\n  Simulator::Stop(Seconds(simStop + 1));\n  Simulator::Run();\n  Simulator::Destroy();\n\n  std::cout << \"Simulation Completed.\\n\";\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/sfama_grid_test.cc",
      "code": "/*\n * sfama_tests.cc\n *\n *  Created on: March 8, 2019\n *      Author: dmitry\n */\n\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/aqua-sim-ng-module.h\"\n#include \"ns3/aqua-sim-propagation.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/callback.h\"\n\n#include <random>\n#include <math.h>\n\n/*\n * SFAMA NxN grid random destination topology tests\n *\n *\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SFAMA_grid_test\");\n\nint\nmain (int argc, char *argv[])\n{\n  double simStop = 100; //seconds\n//  double simStop = 2; //seconds\n\n  int n_nodes = 10;\n//  int sinks = 1;\n//  uint32_t m_dataRate = 80000; // bps\n  double m_dataRate = 80000; // bps\n\n  double m_packetSize = 50; // bytes\n  double range = 1500;\t// meters\n\n  // Poisson traffic parameters\n  double lambda = 0.1;\n\n  // Grid parameters\n  int max_x = 100; // meters\n//  int max_y = 10000; // meters\n//  double distance = 10; // meters\n\n  // Max Tx power\n  double max_tx_power = 20; // Watts\n\n//  LogComponentEnable (\"ASBroadcastMac\", LOG_LEVEL_INFO);\n\n  //to change on the fly\n  CommandLine cmd;\n  cmd.AddValue (\"simStop\", \"Length of simulation\", simStop);\n  cmd.AddValue (\"lambda\", \"Packet arrival rate\", lambda);\n  cmd.AddValue (\"packet_size\", \"Packet size\", m_packetSize);\n  cmd.AddValue (\"grid_size\", \"Grid size, in km\", max_x);\n  cmd.AddValue (\"n_nodes\", \"Number of nodes\", n_nodes);\n  cmd.AddValue (\"range\", \"Transmission range\", range);\n  cmd.AddValue (\"tx_power\", \"Max transmission power\", max_tx_power);\n\n\n  cmd.Parse(argc,argv);\n\n  // Random integer selection-related parameters\n  std::random_device rd;     // only used once to initialise (seed) engine\n  std::mt19937 rng(rd());    // random-number engine used (Mersenne-Twister in this case)\n  std::uniform_int_distribution<int> uni_distance(0, max_x); // guaranteed unbiased\n  std::uniform_int_distribution<int> uni_nodes(0, n_nodes - 1); // guaranteed unbiased\n\n\n  std::cout << \"-----------Initializing simulation-----------\\n\";\n\n  NodeContainer nodesCon;\n//  NodeContainer sinksCon;\n  nodesCon.Create(n_nodes);\n//  sinksCon.Create(sinks);\n\n  PacketSocketHelper socketHelper;\n  socketHelper.Install(nodesCon);\n//  socketHelper.Install(sinksCon);\n\n  //establish layers using helper's pre-build settings\n  AquaSimChannelHelper channel = AquaSimChannelHelper::Default();\n  channel.SetPropagation(\"ns3::AquaSimRangePropagation\");\n  AquaSimHelper asHelper = AquaSimHelper::Default();\n  asHelper.SetChannel(channel.Create());\n\n  asHelper.SetMac(\"ns3::AquaSimSFama\", \"packet_size\", DoubleValue(m_packetSize));\n\n  asHelper.SetRouting(\"ns3::AquaSimRoutingDummy\");\n\n  // Define the Tx power\n  asHelper.SetPhy(\"ns3::AquaSimPhyCmn\", \"PT\", DoubleValue(max_tx_power));\n\n  /*\n   * Set up mobility model for nodes and sinks\n   */\n  MobilityHelper mobility;\n  NetDeviceContainer devices;\n  Ptr<ListPositionAllocator> position = CreateObject<ListPositionAllocator> ();\n  Vector boundry = Vector(0,0,0);\n\n  std::cout << \"Creating Nodes\\n\";\n\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n    {\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n\n      // Select random (x, y) position\n      boundry.x = uni_distance(rng);\n      boundry.y = uni_distance(rng);\n\n      position->Add(boundry);\n      devices.Add(asHelper.Create(*i, newDevice));\n\n//      NS_LOG_DEBUG(\"Node:\" << newDevice->GetAddress() << \" position(x):\" << boundry.x);\n//      std::cout << \"Node:\" << newDevice->GetAddress() << \" position(x):\" << boundry.x <<\n//    \t\t  \" position(y):\" << boundry.y << \"\\n\";\n      newDevice->GetPhy()->SetTransRange(range);\n//      newDevice->GetPhy()->SetTxPower(0.001);\n    }\n\n  mobility.SetPositionAllocator(position);\n  mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install(nodesCon);\n//  mobility.Install(sinksCon);\n\n  int j = 0;\n  char duration_on[300];\n  char duration_off[300];\n\n  // Set application to each node\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n  {\n\t  AquaSimApplicationHelper app (\"ns3::PacketSocketFactory\", n_nodes);\n\n\t  sprintf(duration_on, \"ns3::ExponentialRandomVariable[Mean=%f]\", (m_packetSize * 8) / m_dataRate);\n\t  sprintf(duration_off, \"ns3::ExponentialRandomVariable[Mean=%f]\", 1 / lambda);\n//\t  std::cout << \"Duration On: \" << duration_on << \"\\n\";\n//\t  std::cout << \"Duration Off: \" << duration_off << \"\\n\";\n\t  app.SetAttribute (\"OnTime\", StringValue (duration_on));\n\t  app.SetAttribute (\"OffTime\", StringValue (duration_off));\n\n\t  app.SetAttribute (\"DataRate\", DataRateValue (m_dataRate));\n\t  app.SetAttribute (\"PacketSize\", UintegerValue (m_packetSize));\n\n\t  ApplicationContainer apps = app.Install (nodesCon.Get(j));\n\n\t  apps.Start (Seconds (0.5));\n\t  apps.Stop (Seconds (simStop + 1));\n\n\t  j++;\n  }\n\n  Packet::EnablePrinting (); //for debugging purposes\n  std::cout << \"-----------Running Simulation-----------\\n\";\n  Simulator::Stop(Seconds(simStop));\n\n  // Enable ASCII trace files\n  Packet::EnablePrinting ();  //for debugging purposes\n  char buff[1000];\n  // Naming convention: lambda-number_of_nodes-n_intermediate_nodes-seed\n  std::stringstream stream;\n  stream << std::fixed << std::setprecision(2) << lambda;\n  std::string lambda_string = stream.str();\n  snprintf(buff, sizeof(buff), \"sfama-density-trace-%s-%d-%d.asc\", lambda_string.c_str(), n_nodes, 0);\n  std::string asciiTraceFile = buff;\n\n  // std::string asciiTraceFile = \"sfama-trace.asc\";\n  // asciiTraceFile.\n  std::ofstream ascii (asciiTraceFile.c_str());\n  if (!ascii.is_open()) {\n    NS_FATAL_ERROR(\"Could not open trace file.\");\n  }\n  asHelper.EnableAsciiAll(ascii);\n\n  Simulator::Run();\n\n  asHelper.GetChannel()->PrintCounters();\n\n  Simulator::Destroy();\n\n  std::cout << \"fin.\\n\";\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/trumac_test.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * MAC tests across TRUMAC, ALOHA and TDMA protocols\n *\n * Author: Dmitrii Dugaev <ddugaev@gradcenter.cuny.edu>\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/aqua-sim-ng-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/callback.h\"\n\n#include <iomanip>\n\n/*\n * TRUMAC\n *\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TrumacTest\");\n\n\n// tracebacks for the stats\nuint32_t totalRecvDataPkts = 0;\nuint32_t totalQueueSize = 0;\nuint32_t queueCount = 0;\nuint32_t totalDelay = 0;\nuint32_t delayCount = 0;\nuint32_t totalOrigPkts = 0;\nuint32_t totalPhyTxPkts = 0;\nuint32_t totalPhyRxPkts = 0;\nuint32_t totalPhyRxColls = 0;\n\n\nvoid\ntraceQueueSize(uint32_t qSize)\n{\n  totalQueueSize += qSize;\n  queueCount += 1;\n}\n\nvoid\ntraceE2EDelay(uint32_t delay_ms)\n{\n  totalDelay += delay_ms;\n  delayCount += 1;\n}\n\nvoid\ntraceRecvDataPkts(Ptr<const Packet>)\n{\n  totalRecvDataPkts += 1;\n}\n\nvoid\ntraceOrigPkts(Ptr<const Packet> packet)\n{\n  totalOrigPkts += 1;\n}\n\nvoid\ntracePhyTx(Ptr<Packet> packet, double noise)\n{\n  totalPhyTxPkts += 1;\n}\n\nvoid\ntracePhyRx(Ptr<Packet> packet, double noise)\n{\n  totalPhyRxPkts += 1;\n}\n\nvoid\ntracePhyRxColl()\n{\n  totalPhyRxColls += 1;\n}\n\nint\nmain (int argc, char *argv[])\n{\n  double simStop = 100; //seconds\n  uint32_t seed_no;\n  int nodes = 2;\n  double dist = 100;\n  double m_dataRate = 24;\n  uint32_t m_packetSize = 40;\n  uint32_t m_algo_id = 0;\n\n  std::string m_mac_protocol = \"trumac\";\n\n  LogComponentEnable (\"TrumacTest\", LOG_LEVEL_INFO);\n\n  //to change on the fly\n  CommandLine cmd;\n  cmd.AddValue (\"seed\", \"Seed for random generation\", seed_no);\n  cmd.AddValue (\"simStop\", \"Length of simulation\", simStop);\n  cmd.AddValue (\"nodes\", \"Amount of regular underwater nodes\", nodes);\n  cmd.AddValue (\"psize\", \"Data packet size, bytes\", m_packetSize);\n  cmd.AddValue (\"rate\", \"Data rate for CBR, bps\", m_dataRate);\n  cmd.AddValue (\"mac\", \"Select between TR-MAC and TDMA\", m_mac_protocol);\n  cmd.AddValue (\"dist\", \"Distance between two nodes, in meters\", dist);\n  cmd.AddValue (\"algo\", \"Switch between random selection and sub-optimal TSP-cucle\", m_algo_id);\n  cmd.Parse(argc,argv);\n\n  std::cout << \"-----------Initializing simulation-----------\\n\";\n\n  // Initialize pseudo-random generator\n  SeedManager::SetSeed (12345);\n  SeedManager::SetRun (seed_no);\n  Ptr<UniformRandomVariable> random_stream = CreateObject<UniformRandomVariable> ();\n\n  NodeContainer nodesCon;\n  nodesCon.Create(nodes);\n\n  PacketSocketHelper socketHelper;\n  socketHelper.Install(nodesCon);\n\n  //establish layers using helper's pre-build settings\n  AquaSimChannelHelper channel = AquaSimChannelHelper::Default();\n  channel.SetPropagation(\"ns3::AquaSimRangePropagation\");\n  AquaSimHelper asHelper = AquaSimHelper::Default();\n  asHelper.SetChannel(channel.Create());\n\n  if (m_mac_protocol == \"trumac\")\n  {\n    asHelper.SetMac(\"ns3::AquaSimTrumac\", \"PacketSize\", IntegerValue(m_packetSize), \"StartNodeId\", UintegerValue(0), \n                                        \"TotalNodes\", UintegerValue(nodes), \"AlgoId\", UintegerValue(m_algo_id),\n                                        \"GuardTime\", TimeValue(MilliSeconds(1)));\n  }\n  else if (m_mac_protocol == \"tdma\")\n  {\n    asHelper.SetMac(\"ns3::AquaSimTdmaMac\", \"TdmaSlotPeriod\", UintegerValue(nodes), \"TdmaSlotDuration\", TimeValue(Seconds(0.6)));\n  }\n  else if (m_mac_protocol == \"aloha\")\n  {\n    asHelper.SetMac(\"ns3::AquaSimAloha\", \"AckOn\", IntegerValue(0));\n  }\n  else\n  {\n    NS_FATAL_ERROR (\"Unkown MAC protocol name provided!\");\n  }\n\n  asHelper.SetRouting(\"ns3::AquaSimRoutingDummy\");\n\n  /*\n   * Set up mobility model for nodes and sinks\n   */\n  MobilityHelper mobility;\n  NetDeviceContainer devices;\n\n  std::cout << \"Creating Nodes\\n\";\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n    {\n      Ptr<AquaSimNetDevice> newDevice = CreateObject<AquaSimNetDevice>();\n      devices.Add(asHelper.Create(*i, newDevice));\n      newDevice->GetPhy()->SetTransRange(1500);\n      if (m_mac_protocol == \"tdma\")\n      {\n        newDevice->GetMac()->SetAttribute(\"TdmaSlotNumber\", UintegerValue(newDevice->GetNode()->GetId()));\n      }\n    }\n\n  // Allocate nodes randomly within a circle\n  // mobility.SetPositionAllocator(\"ns3::UniformDiscPositionAllocator\", \"X\", DoubleValue(0),\n  //                                     \"Y\", DoubleValue(0), \"rho\", DoubleValue(dist/2)); // TODO: change to Max.Tx.Range/2\n  // mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  ObjectFactory pos;\n  pos.SetTypeId(\"ns3::UniformDiscPositionAllocator\");\n  pos.Set(\"X\", DoubleValue(0));\n  pos.Set(\"Y\", DoubleValue(0));\n  pos.Set(\"rho\", DoubleValue(dist/2));\n  Ptr<PositionAllocator> positionAlloc = pos.Create ()->GetObject<PositionAllocator> ();\n  mobility.SetPositionAllocator(positionAlloc);\n  mobility.SetMobilityModel (\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", StringValue (\"ns3::ConstantRandomVariable[Constant=0.5]\"),\n                              \"Pause\", StringValue (\"ns3::UniformRandomVariable[Min=0.1|Max=3.0]\"),\n                              \"PositionAllocator\", PointerValue (positionAlloc));\n\n  mobility.Install(nodesCon);\n\n  // // Allocate nodes in a fixed grid\n  // mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n  //                                   \"MinX\", DoubleValue (0.0),\n  //                                   \"MinY\", DoubleValue (0.0),\n  //                                   \"DeltaX\", DoubleValue (dist),\n  //                                   \"DeltaY\", DoubleValue (dist),\n  //                                   \"GridWidth\", UintegerValue (sqrt(nodes)),\n  //                                   // \"GridWidth\", UintegerValue (2), // for 3-node triangle test\n  //                                   \"LayoutType\", StringValue (\"RowFirst\"));\n  // mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  // mobility.Install(nodesCon);\n\n  // Debug node positions\n  for (uint32_t i = 0; i < nodesCon.GetN(); i++)\n  {    \n    Ptr<MobilityModel> mob = nodesCon.Get(i)->GetObject<MobilityModel>();\n    NS_LOG_DEBUG(\"Node \" << i << \" (x,y,z)-position: (\" << mob->GetPosition().x << \n                  \",\\t\" << mob->GetPosition().y << \",\\t\" << mob->GetPosition().z << \")\");\n  }\n\n  int j = 0;\n  char duration_on[300];\n  char duration_off[300];\n  for (NodeContainer::Iterator i = nodesCon.Begin(); i != nodesCon.End(); i++)\n  {\n\t  AquaSimApplicationHelper app (\"ns3::PacketSocketFactory\", nodes);\n\n    // app.SetAttribute (\"OnTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=1]\"));\n    // app.SetAttribute (\"OffTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0]\"));\n    // app.SetAttribute (\"DataRate\", DataRateValue (m_dataRate));\n    // app.SetAttribute (\"PacketSize\", UintegerValue (m_packetSize));\n  \n\t  sprintf(duration_on, \"ns3::ExponentialRandomVariable[Mean=%f]\", (m_packetSize * 8) / m_dataRate);\n\t  sprintf(duration_off, \"ns3::ExponentialRandomVariable[Mean=%f]\", 1 / 100.0);  // lambda\n \n \t  app.SetAttribute (\"OnTime\", StringValue (duration_on));\n\t  app.SetAttribute (\"OffTime\", StringValue (duration_off));\n\n    app.SetAttribute (\"DataRate\", DataRateValue (m_dataRate));\n    app.SetAttribute (\"PacketSize\", UintegerValue (m_packetSize));\n\n    ApplicationContainer apps = app.Install (nodesCon.Get(j));\n\n    // // start traffic only on a single node\n    // if (j == 0)\n    // {\n      apps.Start (Seconds (0.5));\n      apps.Stop (Seconds (simStop + 1));\n    // }\n    // else\n    // {\n    //   apps.Start (Seconds (100000));\n    //   apps.Stop (Seconds (100000));\n    // }\n\n    // // generate 1000 packets side-by-side\n    // apps.Start (Seconds (0.001));\n    // apps.Stop (Seconds (0.08 * 1001 + 0.001));\n\n    j++;\n  }\n\n  Config::ConnectWithoutContext (\"/NodeList/*/DeviceList/*/$ns3::NetDevice/Mac/RoutingRx\", MakeCallback (&traceRecvDataPkts));\n  Config::ConnectWithoutContext (\"/NodeList/*/DeviceList/*/$ns3::NetDevice/Mac/QueueSizeTrace\", MakeCallback (&traceQueueSize));\n  Config::ConnectWithoutContext (\"/NodeList/*/DeviceList/*/$ns3::NetDevice/Mac/E2EDelayTrace\", MakeCallback (&traceE2EDelay));\n  Config::ConnectWithoutContext (\"/NodeList/*/ApplicationList/*/$ns3::Application/Tx\", MakeCallback (&traceOrigPkts));\n  Config::ConnectWithoutContext (\"/NodeList/*/DeviceList/*/$ns3::NetDevice/Phy/Tx\", MakeCallback (&tracePhyTx));\n  Config::ConnectWithoutContext (\"/NodeList/*/DeviceList/*/$ns3::NetDevice/Phy/Rx\", MakeCallback (&tracePhyRx));\n  Config::ConnectWithoutContext (\"/NodeList/*/DeviceList/*/$ns3::NetDevice/Phy/RxColl\", MakeCallback (&tracePhyRxColl));\n\n/*\n *  For channel trace driven simulation\n */\n/*\n  AquaSimTraceReader tReader;\n  tReader.SetChannel(asHelper.GetChannel());\n  if (tReader.ReadFile(\"channelTrace.txt\")) NS_LOG_DEBUG(\"Trace Reader Success\");\n  else NS_LOG_DEBUG(\"Trace Reader Failure\");\n*/\n\n  Packet::EnablePrinting (); //for debugging purposes\n  std::cout << \"-----------Running Simulation-----------\\n\";\n  // Simulator::Stop(Seconds(simStop + 0.5));\n  Simulator::Stop(Seconds(simStop));\n  Simulator::Run();\n  asHelper.GetChannel()->PrintCounters();\n  Simulator::Destroy();\n\n  // print the stats\n  std::ofstream results (\"results_trumac.txt\", std::ofstream::app);\n  results << totalOrigPkts << \"\\t\"\n  << totalRecvDataPkts << \"\\t\"\n  << totalPhyTxPkts << \"\\t\"\n  << totalPhyRxPkts << \"\\t\"\n  << totalPhyRxColls << \"\\t\"\n  << std::setprecision (4) << (double) totalQueueSize/queueCount << \"\\t\"\n  << std::setprecision (8) << (double) totalDelay/delayCount << \"\\t\"\n  << \"\\n\";\n  //\n\n  std::cout << \"fin.\\n\";\n  return 0;\n}\n"
    }
  ]
}