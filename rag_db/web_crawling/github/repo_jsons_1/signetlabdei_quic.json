{
  "repo_name": "signetlabdei/quic",
  "github_url": "https://github.com/signetlabdei/quic",
  "readme": "QUIC implementation for ns-3\n================================\n\n## QUIC code base\nThis repository contains in the code for a native IETF QUIC implementation in ns-3.\n\nThe implementation is described in [this paper](https://arxiv.org/abs/1902.06121).\n\nPlease use this [issue tracker](https://github.com/signetlabdei/quic-ns-3/issues) for bugs/questions.\n\n## Install\n\n### Prerequisites ###\n\nTo run simulations using this module, you will need to install ns-3, clone\nthis repository inside the `src` directory, copy the QUIC applications from the quic-applications folder, and patch the `wscript` file of the applications module.\nRequired dependencies include git and a build environment.\n\n#### Installing dependencies ####\n\nPlease refer to [the ns-3 wiki](https://www.nsnam.org/wiki/Installation) for instructions on how to set up your system to install ns-3.\n\n#### Downloading #####\n\nFirst, clone the main ns-3 repository:\n\n```bash\ngit clone https://gitlab.com/nsnam/ns-3-dev ns-3-dev\ncd ns-3-dev/src\n```\n\nThen, clone the quic module:\n\n```bash\ngit clone https://github.com/signetlabdei/quic quic\n```\n\nThirdly, copy the QUIC applications and helpers to the applications module\n\n```bash\ncp quic/quic-applications/model/* applications/model/\ncp quic/quic-applications/helper/* applications/helper/\n```\n\nFinally, edit the `CMakeLists.txt` file of the applications module and add\n\n```python\n        model/quic-echo-client.h\n        model/quic-echo-server.h\n        model/quic-client.h\n        model/quic-server.h\n        helper/quic-echo-helper.h\n        helper/quic-client-server-helper.h\n```\nto the `HEADER_FILES` list and\n\n```python\n        model/quic-echo-client.cc\n        model/quic-echo-server.cc\n        model/quic-client.cc\n        model/quic-server.cc\n        helper/quic-echo-helper.cc\n        helper/quic-client-server-helper.cc\n```\nto the `SOURCE_FILES` list.\n### Compilation ###\n\nConfigure and build ns-3 from the `ns-3-dev` folder:\n\n```bash\n./ns3 configure --enable-tests --enable-examples\n./ns3 build\n```\n\nIf you are not interested in using the Python bindings, use\n\n```bash\n./ns3 configure --enable-tests --enable-examples --disable-python\n./ns3 build\n```\n",
  "examples": [
    {
      "file_path": "examples/quic-pacing.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n// Network topology\n//\n//       n0 ----------- n1\n//            40 Gbps\n//            0.01 ms\n\n// This programs illustrates how QUIC pacing can be used and how user can set\n// pacing rate. The program gives information about each flow like transmitted\n// and received bytes (packets) and throughput of that flow. Currently, it is\n// using QUIC NewReno-like but in future after having congestion control algorithms\n// which can change pacing rate can be used.\n#include <fstream>\n#include <string>\n\n#include \"ns3/core-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/quic-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"QuicPacingExample\");\n\nint\nmain (int argc, char *argv[])\n{\n\n  bool tracing = false;\n  uint32_t maxBytes = 0;\n  uint32_t QUICFlows = 1;\n  bool isPacingEnabled = true;\n  std::string pacingRate = \"10Mbps\";\n  uint32_t maxPackets = 0;\n\n\n  // User may find it convenient to enable logging\n  Time::SetResolution (Time::NS);\n  LogComponentEnableAll (LOG_PREFIX_TIME);\n  LogComponentEnableAll (LOG_PREFIX_FUNC);\n  LogComponentEnableAll (LOG_PREFIX_NODE);\n  LogComponentEnable(\"QuicSocketBase\", LOG_LEVEL_DEBUG);\n  LogComponentEnable(\"QuicPacingExample\", LOG_LEVEL_INFO);\n\n\n  CommandLine cmd;\n  cmd.AddValue (\"tracing\", \"Flag to enable/disable tracing\", tracing);\n  cmd.AddValue (\"maxBytes\",\n                \"Total number of bytes for application to send\", maxBytes);\n  cmd.AddValue (\"maxPackets\",\n                \"Total number of bytes for application to send\", maxPackets);\n  cmd.AddValue (\"QUICFlows\", \"Number of application flows between sender and receiver\", QUICFlows);\n  cmd.AddValue (\"Pacing\", \"Flag to enable/disable pacing in QUIC\", isPacingEnabled);\n  cmd.AddValue (\"PacingRate\", \"Max Pacing Rate in bps\", pacingRate);\n  cmd.Parse (argc, argv);\n\n  if (maxPackets != 0 )\n    {\n      maxBytes = 500 * maxPackets;\n    }\n\n  Config::SetDefault (\"ns3::TcpSocketState::MaxPacingRate\", StringValue (pacingRate));\n  Config::SetDefault (\"ns3::TcpSocketState::EnablePacing\", BooleanValue (isPacingEnabled));\n\n  NS_LOG_INFO (\"Create nodes.\");\n  NodeContainer nodes;\n  nodes.Create (2);\n\n\n  NS_LOG_INFO (\"Create channels.\");\n  PointToPointHelper pointToPoint;\n  pointToPoint.SetDeviceAttribute (\"DataRate\", StringValue (\"20Mbps\"));\n  pointToPoint.SetChannelAttribute (\"Delay\", StringValue (\"10ms\"));\n\n  NetDeviceContainer devices;\n  devices = pointToPoint.Install (nodes);\n\n  QuicHelper stack;\n  stack.InstallQuic (nodes);\n\n  NS_LOG_INFO (\"Assign IP Addresses.\");\n  Ipv4AddressHelper ipv4;\n  ipv4.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer i = ipv4.Assign (devices);\n\n  NS_LOG_INFO (\"Create Applications.\");\n\n  ApplicationContainer sourceApps;\n  ApplicationContainer sinkApps;\n  for (uint32_t iterator = 0; iterator < QUICFlows; iterator++)\n    {\n      uint16_t port = 10000 + iterator;\n\n      BulkSendHelper source  (\"ns3::QuicSocketFactory\",\n                              InetSocketAddress (i.GetAddress (1), port));\n      // Set the amount of data to send in bytes.  Zero is unlimited.\n      source.SetAttribute (\"MaxBytes\", UintegerValue (maxBytes));\n      sourceApps.Add (source.Install (nodes.Get (0)));\n\n    PacketSinkHelper sink (\"ns3::QuicSocketFactory\",\n                             InetSocketAddress (Ipv4Address::GetAny (), port));\n      sinkApps.Add (sink.Install (nodes.Get (1)));\n    }\n\n  sinkApps.Start (Seconds (0.0));\n  sinkApps.Stop (Seconds (9));\n  sourceApps.Start (Seconds (1));\n  sourceApps.Stop (Seconds (9));\n\n  if (tracing)\n    {\n      AsciiTraceHelper ascii;\n      pointToPoint.EnableAsciiAll (ascii.CreateFileStream (\"quic-pacing.tr\"));\n      pointToPoint.EnablePcapAll (\"quic-pacing\", false);\n    }\n\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();\n\n  NS_LOG_INFO (\"Run Simulation.\");\n  Simulator::Stop (Seconds (10));\n  Simulator::Run ();\n\n  monitor->CheckForLostPackets ();\n  Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowmon.GetClassifier ());\n  FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats ();\n  for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)\n    {\n      Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (i->first);\n      if (t.sourceAddress == \"10.1.1.2\")\n        {\n          continue;\n        }\n      std::cout << \"Flow \" << i->first  << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\\n\";\n      std::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n      std::cout << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n      std::cout << \"  TxOffered:  \" << i->second.txBytes * 8.0 / 9.0 / 1000 / 1000  << \" Mbps\\n\";\n      std::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n      std::cout << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n      std::cout << \"  Throughput: \" << i->second.rxBytes * 8.0 / 9.0 / 1000 / 1000  << \" Mbps\\n\";\n    }\n\n  Simulator::Destroy ();\n  NS_LOG_INFO (\"Done.\");\n}\n"
    },
    {
      "file_path": "examples/quic-tester-streams.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2019 SIGNET Lab, Department of Information Engineering, University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Authors: Alvise De Biasio <alvise.debiasio@gmail.com>\n *          Federico Chiariotti <whatever@blbl.it>\n *          Michele Polese <michele.polese@gmail.com>\n *          Davide Marcato <davidemarcato@outlook.com>\n *          \n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/quic-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store-module.h\"\n#include <iostream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"QuicTesterStreams\");\n\n// connect to a number of traces\nstatic void\nCwndChange (Ptr<OutputStreamWrapper> stream, uint32_t oldCwnd, uint32_t newCwnd)\n{\n  *stream->GetStream () << Simulator::Now ().GetSeconds () << \"\\t\" << oldCwnd << \"\\t\" << newCwnd << std::endl;\n}\n\nstatic void\nRttChange (Ptr<OutputStreamWrapper> stream, Time oldRtt, Time newRtt)\n{\n  *stream->GetStream () << Simulator::Now ().GetSeconds () << \"\\t\" << oldRtt.GetSeconds () << \"\\t\" << newRtt.GetSeconds () << std::endl;\n}\n\nstatic void\nRx (Ptr<OutputStreamWrapper> stream, Ptr<const Packet> p, const QuicHeader& q, Ptr<const QuicSocketBase> qsb)\n{\n  *stream->GetStream () << Simulator::Now ().GetSeconds () << \"\\t\" << p->GetSize() << std::endl;\n}\n\nstatic void\nTraces(uint32_t serverId, std::string pathVersion, std::string finalPart)\n{\n  AsciiTraceHelper asciiTraceHelper;\n\n  std::ostringstream pathCW;\n  pathCW << \"/NodeList/\" << serverId << \"/$ns3::QuicL4Protocol/SocketList/0/QuicSocketBase/CongestionWindow\";\n  NS_LOG_INFO(\"Matches cw \" << Config::LookupMatches(pathCW.str().c_str()).GetN());\n\n  std::ostringstream fileCW;\n  fileCW << pathVersion << \"QUIC-cwnd-change\"  << serverId << \"\" << finalPart;\n\n  std::ostringstream pathRTT;\n  pathRTT << \"/NodeList/\" << serverId << \"/$ns3::QuicL4Protocol/SocketList/0/QuicSocketBase/RTT\";\n\n  std::ostringstream fileRTT;\n  fileRTT << pathVersion << \"QUIC-rtt\"  << serverId << \"\" << finalPart;\n\n  std::ostringstream pathRCWnd;\n  pathRCWnd<< \"/NodeList/\" << serverId << \"/$ns3::QuicL4Protocol/SocketList/0/QuicSocketBase/RWND\";\n\n  std::ostringstream fileRCWnd;\n  fileRCWnd<<pathVersion << \"QUIC-rwnd-change\"  << serverId << \"\" << finalPart;\n\n  std::ostringstream fileName;\n  fileName << pathVersion << \"QUIC-rx-data\" << serverId << \"\" << finalPart;\n  std::ostringstream pathRx;\n  pathRx << \"/NodeList/\" << serverId << \"/$ns3::QuicL4Protocol/SocketList/*/QuicSocketBase/Rx\";\n  NS_LOG_INFO(\"Matches rx \" << Config::LookupMatches(pathRx.str().c_str()).GetN());\n\n  Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream (fileName.str ().c_str ());\n  Config::ConnectWithoutContext (pathRx.str ().c_str (), MakeBoundCallback (&Rx, stream));\n\n  Ptr<OutputStreamWrapper> stream1 = asciiTraceHelper.CreateFileStream (fileCW.str ().c_str ());\n  Config::ConnectWithoutContext (pathCW.str ().c_str (), MakeBoundCallback(&CwndChange, stream1));\n\n  Ptr<OutputStreamWrapper> stream2 = asciiTraceHelper.CreateFileStream (fileRTT.str ().c_str ());\n  Config::ConnectWithoutContext (pathRTT.str ().c_str (), MakeBoundCallback(&RttChange, stream2));\n\n  Ptr<OutputStreamWrapper> stream4 = asciiTraceHelper.CreateFileStream (fileRCWnd.str ().c_str ());\n  Config::ConnectWithoutContextFailSafe (pathRCWnd.str ().c_str (), MakeBoundCallback(&CwndChange, stream4));\n}\n\nint\nmain (int argc, char *argv[])\n{\n  CommandLine cmd;\n  cmd.Parse (argc, argv);\n\n  Config::SetDefault (\"ns3::QuicSocketBase::SocketSndBufSize\", UintegerValue(40000000));\n  Config::SetDefault (\"ns3::QuicSocketBase::SocketRcvBufSize\", UintegerValue(40000000));\n  Config::SetDefault (\"ns3::QuicStreamBase::StreamSndBufSize\", UintegerValue(40000000));\n  Config::SetDefault (\"ns3::QuicStreamBase::StreamRcvBufSize\", UintegerValue(40000000));\n  Config::SetDefault (\"ns3::QuicSocketBase::SchedulingPolicy\", TypeIdValue(QuicSocketTxEdfScheduler::GetTypeId ()));\n  \n  std::cout\n      << \"\\n\\n#################### SIMULATION SET-UP ####################\\n\\n\\n\";\n\n  LogLevel log_precision = LOG_LEVEL_INFO;\n  Time::SetResolution (Time::NS);\n  LogComponentEnableAll (LOG_PREFIX_TIME);\n  LogComponentEnableAll (LOG_PREFIX_FUNC);\n  LogComponentEnableAll (LOG_PREFIX_NODE);\n  LogComponentEnable (\"QuicEchoClientApplication\", log_precision);\n  LogComponentEnable (\"QuicEchoServerApplication\", log_precision);\n  //LogComponentEnable (\"QuicSocketBase\", log_precision);\n  LogComponentEnable (\"QuicStreamBase\", log_precision);\n  LogComponentEnable(\"QuicStreamRxBuffer\", log_precision);\n  LogComponentEnable(\"QuicStreamTxBuffer\", log_precision);\n  LogComponentEnable(\"QuicSocketTxScheduler\", log_precision);\n  LogComponentEnable(\"QuicSocketTxEdfScheduler\", log_precision);\n  //LogComponentEnable (\"Socket\", log_precision);\n  // LogComponentEnable (\"Application\", log_precision);\n  // LogComponentEnable (\"Node\", log_precision);\n  //LogComponentEnable (\"InternetStackHelper\", log_precision);\n  //LogComponentEnable (\"QuicSocketFactory\", log_precision);\n  //LogComponentEnable (\"ObjectFactory\", log_precision);\n  //LogComponentEnable (\"TypeId\", log_precision);\n  //LogComponentEnable (\"QuicL4Protocol\", log_precision);\n  LogComponentEnable (\"QuicL5Protocol\", log_precision);\n  //LogComponentEnable (\"ObjectBase\", log_precision);\n\n  //LogComponentEnable (\"QuicEchoHelper\", log_precision);\n  //LogComponentEnable (\"UdpSocketImpl\", log_precision);\n  //LogComponentEnable (\"QuicHeader\", log_precision);\n  //LogComponentEnable (\"QuicSubheader\", log_precision);\n  //LogComponentEnable (\"Header\", log_precision);\n  //LogComponentEnable (\"PacketMetadata\", log_precision);\n  LogComponentEnable (\"QuicSocketTxBuffer\", log_precision);\n\n\n  NodeContainer nodes;\n  nodes.Create (2);\n  auto n1 = nodes.Get (0);\n  auto n2 = nodes.Get (1);\n\n  PointToPointHelper pointToPoint;\n  pointToPoint.SetDeviceAttribute (\"DataRate\", StringValue (\"8Mbps\"));\n  pointToPoint.SetChannelAttribute (\"Delay\", StringValue (\"20ms\"));\n\n  NetDeviceContainer devices;\n  devices = pointToPoint.Install (nodes);\n\n  QuicHelper stack;\n  stack.InstallQuic (nodes);\n  \n  Ipv4AddressHelper address;\n  address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n\n  Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  ApplicationContainer clientApps;\n  ApplicationContainer serverApps;\n\n  // QUIC client and server\n  uint32_t dlPort = 1025;\n  QuicServerHelper dlPacketSinkHelper (dlPort);\n  serverApps.Add (dlPacketSinkHelper.Install (n2));\n\n  double interPacketInterval = 1000;\n  QuicClientHelper dlClient (interfaces.GetAddress (1), dlPort);\n  dlClient.SetAttribute (\"Interval\", TimeValue (MicroSeconds(interPacketInterval)));\n  dlClient.SetAttribute (\"PacketSize\", UintegerValue(1000));\n  dlClient.SetAttribute (\"MaxPackets\", UintegerValue(10000000));\n  clientApps.Add (dlClient.Install (n1));\n\n  serverApps.Start (Seconds (0.99));\n  clientApps.Stop (Seconds (5.0));\n  clientApps.Start (Seconds (1.0));\n\n  Simulator::Schedule (Seconds (2.0000001), &Traces, n2->GetId(),\n        \"./server\", \".txt\");\n  Simulator::Schedule (Seconds (2.0000001), &Traces, n1->GetId(),\n        \"./client\", \".txt\");\n\n  Packet::EnablePrinting ();\n  Packet::EnableChecking ();\n\n  std::cout << \"\\n\\n#################### STARTING RUN ####################\\n\\n\";\n  Simulator::Stop (Seconds (3000));\n  Simulator::Run ();\n  std::cout\n      << \"\\n\\n#################### RUN FINISHED ####################\\n\\n\\n\";\n  Simulator::Destroy ();\n\n  std::cout\n      << \"\\n\\n#################### SIMULATION END ####################\\n\\n\\n\";\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/quic-tester.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2019 SIGNET Lab, Department of Information Engineering, University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Authors: Alvise De Biasio <alvise.debiasio@gmail.com>\n *          Federico Chiariotti <whatever@blbl.it>\n *          Michele Polese <michele.polese@gmail.com>\n *          Davide Marcato <davidemarcato@outlook.com>\n *          \n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/quic-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store-module.h\"\n#include <iostream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"quic-tester\");\n\nint\nmain (int argc, char *argv[])\n{\n  CommandLine cmd;\n  cmd.Parse (argc, argv);\n\n  std::cout\n      << \"\\n\\n#################### SIMULATION SET-UP ####################\\n\\n\\n\";\n\n  LogLevel log_precision = LOG_LEVEL_LOGIC;\n  Time::SetResolution (Time::NS);\n  LogComponentEnableAll (LOG_PREFIX_TIME);\n  LogComponentEnableAll (LOG_PREFIX_FUNC);\n  LogComponentEnableAll (LOG_PREFIX_NODE);\n  LogComponentEnable (\"QuicEchoClientApplication\", log_precision);\n  LogComponentEnable (\"QuicEchoServerApplication\", log_precision);\n//  LogComponentEnable (\"QuicHeader\", log_precision);\n  //LogComponentEnable (\"QuicSocketBase\", log_precision);\n//  LogComponentEnable (\"QuicStreamBase\", LOG_LEVEL_LOGIC);\n//  LogComponentEnable (\"Socket\", log_precision);\n//  LogComponentEnable (\"Application\", log_precision);\n//  LogComponentEnable (\"Node\", log_precision);\n//  LogComponentEnable (\"InternetStackHelper\", log_precision);\n//  LogComponentEnable (\"QuicSocketFactory\", log_precision);\n//  LogComponentEnable (\"ObjectFactory\", log_precision);\n//  //LogComponentEnable (\"TypeId\", log_precision);\n//  LogComponentEnable (\"QuicL4Protocol\", log_precision);\n//  LogComponentEnable (\"QuicL5Protocol\", log_precision);\n//  //LogComponentEnable (\"ObjectBase\", log_precision);\n//\n//  LogComponentEnable (\"QuicEchoHelper\", log_precision);\n    LogComponentEnable (\"QuicSocketTxScheduler\", log_precision);\n//  LogComponentEnable (\"QuicSocketRxBuffer\", log_precision);\n//  LogComponentEnable (\"QuicHeader\", log_precision);\n//  LogComponentEnable (\"QuicSubheader\", log_precision);\n//  LogComponentEnable (\"Header\", log_precision);\n//  LogComponentEnable (\"PacketMetadata\", log_precision);\n\n\n  NodeContainer nodes;\n  nodes.Create (2);\n  auto n1 = nodes.Get (0);\n  auto n2 = nodes.Get (1);\n\n  PointToPointHelper pointToPoint;\n  pointToPoint.SetDeviceAttribute (\"DataRate\", StringValue (\"5Mbps\"));\n  pointToPoint.SetChannelAttribute (\"Delay\", StringValue (\"2ms\"));\n\n  NetDeviceContainer devices;\n  devices = pointToPoint.Install (nodes);\n\n  QuicHelper stack;\n  stack.InstallQuic (nodes);\n\n  Ipv4AddressHelper address;\n  address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n\n  Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  QuicEchoServerHelper echoServer (9);\n\n  ApplicationContainer serverApps = echoServer.Install (nodes.Get (1));\n  serverApps.Start (Seconds (1.0));\n  serverApps.Stop (Seconds (1200.0));\n\n  QuicEchoClientHelper echoClient (interfaces.GetAddress (1), 9);\n  echoClient.SetAttribute (\"MaxPackets\", UintegerValue (1));\n  echoClient.SetAttribute (\"Interval\", TimeValue (Seconds (1.0)));\n  //echoClient.SetAttribute (\"MaxStreamData\", UintegerValue (1024));\n\n  ApplicationContainer clientApps = echoClient.Install (nodes.Get (0));\n  echoClient.SetFill (clientApps.Get (0), \"Hello World\");\n  clientApps.Start (Seconds (2.0));\n  clientApps.Stop (Seconds (5.0));\n\n  Packet::EnablePrinting ();\n  Packet::EnableChecking ();\n\n  std::cout << \"\\n\\n#################### STARTING RUN ####################\\n\\n\";\n  Simulator::Run ();\n  std::cout\n      << \"\\n\\n#################### RUN FINISHED ####################\\n\\n\\n\";\n  Simulator::Destroy ();\n\n  std::cout\n      << \"\\n\\n#################### SIMULATION END ####################\\n\\n\\n\";\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/quic-variants-comparison-bulksend.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2013 ResiliNets, ITTC, University of Kansas\n * Copyright (c) 2019 SIGNET Lab, Department of Information Engineering, University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Authors of the original TCP example:\n * Justin P. Rohrer, Truc Anh N. Nguyen <annguyen@ittc.ku.edu>, Siddharth Gangadhar <siddharth@ittc.ku.edu>\n * James P.G. Sterbenz <jpgs@ittc.ku.edu>, director\n * ResiliNets Research Group  http://wiki.ittc.ku.edu/resilinets\n * Information and Telecommunication Technology Center (ITTC)\n * and Department of Electrical Engineering and Computer Science\n * The University of Kansas Lawrence, KS USA.\n *\n * Work supported in part by NSF FIND (Future Internet Design) Program\n * under grant CNS-0626918 (Postmodern Internet Architecture),\n * NSF grant CNS-1050226 (Multilayer Network Resilience Analysis and Experimentation on GENI),\n * US Department of Defense (DoD), and ITTC at The University of Kansas.\n *\n * Adapted to QUIC by:\n *          Alvise De Biasio <alvise.debiasio@gmail.com>\n *          Federico Chiariotti <chiariotti.federico@gmail.com>\n *          Michele Polese <michele.polese@gmail.com>\n *          Davide Marcato <davidemarcato@outlook.com>\n *\n */\n\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/quic-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/error-model.h\"\n#include \"ns3/tcp-header.h\"\n#include \"ns3/udp-header.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/event-id.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/traffic-control-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"QuicVariantsComparisonBulkSend\");\n\n// connect to a number of traces\nstatic void\nCwndChange (Ptr<OutputStreamWrapper> stream, uint32_t oldCwnd, uint32_t newCwnd)\n{\n  *stream->GetStream () << Simulator::Now ().GetSeconds () << \"\\t\" << oldCwnd << \"\\t\" << newCwnd << std::endl;\n}\n\nstatic void\nRttChange (Ptr<OutputStreamWrapper> stream, Time oldRtt, Time newRtt)\n{\n  *stream->GetStream () << Simulator::Now ().GetSeconds () << \"\\t\" << oldRtt.GetSeconds () << \"\\t\" << newRtt.GetSeconds () << std::endl;\n}\n\nstatic void\nRx (Ptr<OutputStreamWrapper> stream, Ptr<const Packet> p, const QuicHeader& q, Ptr<const QuicSocketBase> qsb)\n{\n  *stream->GetStream () << Simulator::Now ().GetSeconds () << \"\\t\" << p->GetSize() << std::endl;\n}\n\nstatic void\nTraces(uint32_t serverId, std::string pathVersion, std::string finalPart)\n{\n  AsciiTraceHelper asciiTraceHelper;\n\n  std::ostringstream pathCW;\n  pathCW << \"/NodeList/\" << serverId << \"/$ns3::QuicL4Protocol/SocketList/0/QuicSocketBase/CongestionWindow\";\n  NS_LOG_INFO(\"Matches cw \" << Config::LookupMatches(pathCW.str().c_str()).GetN());\n\n  std::ostringstream fileCW;\n  fileCW << pathVersion << \"QUIC-cwnd-change\"  << serverId << \"\" << finalPart;\n\n  std::ostringstream pathRTT;\n  pathRTT << \"/NodeList/\" << serverId << \"/$ns3::QuicL4Protocol/SocketList/0/QuicSocketBase/RTT\";\n\n  std::ostringstream fileRTT;\n  fileRTT << pathVersion << \"QUIC-rtt\"  << serverId << \"\" << finalPart;\n\n  std::ostringstream pathRCWnd;\n  pathRCWnd<< \"/NodeList/\" << serverId << \"/$ns3::QuicL4Protocol/SocketList/0/QuicSocketBase/RWND\";\n\n  std::ostringstream fileRCWnd;\n  fileRCWnd<<pathVersion << \"QUIC-rwnd-change\"  << serverId << \"\" << finalPart;\n\n  std::ostringstream fileName;\n  fileName << pathVersion << \"QUIC-rx-data\" << serverId << \"\" << finalPart;\n  std::ostringstream pathRx;\n  pathRx << \"/NodeList/\" << serverId << \"/$ns3::QuicL4Protocol/SocketList/*/QuicSocketBase/Rx\";\n  NS_LOG_INFO(\"Matches rx \" << Config::LookupMatches(pathRx.str().c_str()).GetN());\n\n  Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream (fileName.str ().c_str ());\n  Config::ConnectWithoutContext (pathRx.str ().c_str (), MakeBoundCallback (&Rx, stream));\n\n  Ptr<OutputStreamWrapper> stream1 = asciiTraceHelper.CreateFileStream (fileCW.str ().c_str ());\n  Config::ConnectWithoutContext (pathCW.str ().c_str (), MakeBoundCallback(&CwndChange, stream1));\n\n  Ptr<OutputStreamWrapper> stream2 = asciiTraceHelper.CreateFileStream (fileRTT.str ().c_str ());\n  Config::ConnectWithoutContext (pathRTT.str ().c_str (), MakeBoundCallback(&RttChange, stream2));\n\n  Ptr<OutputStreamWrapper> stream4 = asciiTraceHelper.CreateFileStream (fileRCWnd.str ().c_str ());\n  Config::ConnectWithoutContextFailSafe (pathRCWnd.str ().c_str (), MakeBoundCallback(&CwndChange, stream4));\n}\n\nint main (int argc, char *argv[])\n{\n  std::string transport_prot = \"QuicBbr\";\n  double error_p = 0.0;\n  std::string bandwidth = \"2Mbps\";\n  std::string delay = \"0.01ms\";\n  std::string access_bandwidth = \"12Mbps\";\n  std::string access_delay = \"25ms\";\n  bool tracing = false;\n  std::string prefix_file_name = \"QuicVariantsComparison\";\n  double data_mbytes = 0;\n  uint32_t mtu_bytes = 1400;\n  uint16_t num_flows = 1;\n  float duration = 100;\n  uint32_t run = 0;\n  bool flow_monitor = false;\n  bool pcap = false;\n  std::string queue_disc_type = \"ns3::PfifoFastQueueDisc\";\n\n  // LogComponentEnable (\"Config\", LOG_LEVEL_ALL);\n  CommandLine cmd;\n  cmd.AddValue (\"transport_prot\", \"Transport protocol to use: TcpNewReno, \"\n                \"TcpHybla, TcpHighSpeed, TcpHtcp, TcpVegas, TcpScalable, TcpVeno, \"\n                \"TcpBic, TcpYeah, TcpIllinois, TcpLedbat\", transport_prot);\n  cmd.AddValue (\"error_p\", \"Packet error rate\", error_p);\n  cmd.AddValue (\"bandwidth\", \"Bottleneck bandwidth\", bandwidth);\n  cmd.AddValue (\"delay\", \"Bottleneck delay\", delay);\n  cmd.AddValue (\"access_bandwidth\", \"Access link bandwidth\", access_bandwidth);\n  cmd.AddValue (\"access_delay\", \"Access link delay\", access_delay);\n  cmd.AddValue (\"tracing\", \"Flag to enable/disable tracing\", tracing);\n  cmd.AddValue (\"prefix_name\", \"Prefix of output trace file\", prefix_file_name);\n  cmd.AddValue (\"data\", \"Number of Megabytes of data to transmit\", data_mbytes);\n  cmd.AddValue (\"mtu\", \"Size of IP packets to send in bytes\", mtu_bytes);\n  cmd.AddValue (\"num_flows\", \"Number of flows\", num_flows);\n  cmd.AddValue (\"duration\", \"Time to allow flows to run in seconds\", duration);\n  cmd.AddValue (\"run\", \"Run index (for setting repeatable seeds)\", run);\n  cmd.AddValue (\"flow_monitor\", \"Enable flow monitor\", flow_monitor);\n  cmd.AddValue (\"pcap_tracing\", \"Enable or disable PCAP tracing\", pcap);\n  cmd.AddValue (\"queue_disc_type\", \"Queue disc type for gateway (e.g. ns3::CoDelQueueDisc)\", queue_disc_type);\n  cmd.Parse (argc, argv);\n\n  transport_prot = std::string (\"ns3::\") + transport_prot;\n\n  SeedManager::SetSeed (1);\n  SeedManager::SetRun (run);\n\n  // User may find it convenient to enable logging\n  Time::SetResolution (Time::NS);\n  LogComponentEnableAll (LOG_PREFIX_TIME);\n  LogComponentEnableAll (LOG_PREFIX_FUNC);\n  LogComponentEnableAll (LOG_PREFIX_NODE);\n  // LogComponentEnable(\"QuicVariantsComparison\", LOG_LEVEL_ALL);\n  // LogComponentEnable(\"BulkSendApplication\", LOG_LEVEL_INFO);\n  // LogComponentEnable(\"PfifoFastQueueDisc\", LOG_LEVEL_ALL);\n  // LogComponentEnable (\"QuicSocketBase\", LOG_LEVEL_ALL);\n  LogComponentEnable(\"TcpVegas\", LOG_LEVEL_ALL);\n  LogComponentEnable(\"QuicBbr\", LOG_LEVEL_ALL);\n  // LogComponentEnable(\"QuicL5Protocol\", LOG_LEVEL_ALL);\n\n  // Set the simulation start and stop time\n  float start_time = 0.1;\n  float stop_time = start_time + duration;\n\n  // 4 MB of TCP buffer\n  Config::SetDefault (\"ns3::QuicSocketBase::SocketRcvBufSize\", UintegerValue (1 << 21));\n  Config::SetDefault (\"ns3::QuicSocketBase::SocketSndBufSize\", UintegerValue (1 << 21));\n  Config::SetDefault (\"ns3::QuicStreamBase::StreamSndBufSize\", UintegerValue (1 << 21));\n  Config::SetDefault (\"ns3::QuicStreamBase::StreamRcvBufSize\", UintegerValue (1 << 21));\n\n  TypeId tcpTid;\n  NS_ABORT_MSG_UNLESS (TypeId::LookupByNameFailSafe (transport_prot, &tcpTid), \"TypeId \" << transport_prot << \" not found\");\n  Config::SetDefault (\"ns3::QuicL4Protocol::SocketType\", TypeIdValue (TypeId::LookupByName (transport_prot)));\n\n\n  // Create gateways, sources, and sinks\n  NodeContainer gateways;\n  gateways.Create (2);\n  NodeContainer sources;\n  sources.Create (num_flows);\n  NodeContainer sinks;\n  sinks.Create (num_flows);\n\n  // Configure the error model\n  // Here we use RateErrorModel with packet error rate\n  Ptr<UniformRandomVariable> uv = CreateObject<UniformRandomVariable> ();\n  uv->SetStream (50);\n  RateErrorModel error_model;\n  error_model.SetRandomVariable (uv);\n  error_model.SetUnit (RateErrorModel::ERROR_UNIT_PACKET);\n  error_model.SetRate (error_p);\n\n  PointToPointHelper BottleneckLink;\n  BottleneckLink.SetDeviceAttribute (\"DataRate\", StringValue (bandwidth));\n  BottleneckLink.SetChannelAttribute (\"Delay\", StringValue (delay));\n  BottleneckLink.SetDeviceAttribute (\"ReceiveErrorModel\", PointerValue (&error_model));\n\n  PointToPointHelper AccessLink;\n  AccessLink.SetDeviceAttribute (\"DataRate\", StringValue (access_bandwidth));\n  AccessLink.SetChannelAttribute (\"Delay\", StringValue (access_delay));\n\n  QuicHelper stack;\n  stack.InstallQuic (sources);\n  stack.InstallQuic (sinks);\n  stack.InstallQuic (gateways);\n\n  TrafficControlHelper tchPfifo;\n  tchPfifo.SetRootQueueDisc (\"ns3::PfifoFastQueueDisc\");\n\n  TrafficControlHelper tchCoDel;\n  tchCoDel.SetRootQueueDisc (\"ns3::CoDelQueueDisc\");\n\n  Ipv4AddressHelper address;\n  address.SetBase (\"10.0.0.0\", \"255.255.255.0\");\n\n  // Configure the sources and sinks net devices\n  // and the channels between the sources/sinks and the gateways\n  PointToPointHelper LocalLink;\n  LocalLink.SetDeviceAttribute (\"DataRate\", StringValue (access_bandwidth));\n  LocalLink.SetChannelAttribute (\"Delay\", StringValue (access_delay));\n\n  Ipv4InterfaceContainer sink_interfaces;\n\n  DataRate access_b (access_bandwidth);\n  DataRate bottle_b (bandwidth);\n  Time access_d (access_delay);\n  Time bottle_d (delay);\n\n  uint32_t size = (std::min (access_b, bottle_b).GetBitRate () / 8) *\n    ((access_d + bottle_d) * 2).GetSeconds ();\n\n  Config::SetDefault (\"ns3::PfifoFastQueueDisc::MaxSize\",\n                      QueueSizeValue (QueueSize (QueueSizeUnit::PACKETS, size / mtu_bytes)));\n  Config::SetDefault (\"ns3::CoDelQueueDisc::MaxSize\",\n                      QueueSizeValue (QueueSize (QueueSizeUnit::BYTES, size)));\n\n  for (int i = 0; i < num_flows; i++)\n    {\n      NetDeviceContainer devices;\n      devices = AccessLink.Install (sources.Get (i), gateways.Get (0));\n      tchPfifo.Install (devices);\n      address.NewNetwork ();\n      Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n      devices = LocalLink.Install (gateways.Get (1), sinks.Get (i));\n      if (queue_disc_type.compare (\"ns3::PfifoFastQueueDisc\") == 0)\n        {\n          tchPfifo.Install (devices);\n        }\n      else if (queue_disc_type.compare (\"ns3::CoDelQueueDisc\") == 0)\n        {\n          tchCoDel.Install (devices);\n        }\n      else\n        {\n          NS_FATAL_ERROR (\"Queue not recognized. Allowed values are ns3::CoDelQueueDisc or ns3::PfifoFastQueueDisc\");\n        }\n      address.NewNetwork ();\n      interfaces = address.Assign (devices);\n      sink_interfaces.Add (interfaces.Get (1));\n\n      devices = BottleneckLink.Install (gateways.Get (0), gateways.Get (1));\n      if (queue_disc_type.compare (\"ns3::PfifoFastQueueDisc\") == 0)\n        {\n          tchPfifo.Install (devices);\n        }\n      else if (queue_disc_type.compare (\"ns3::CoDelQueueDisc\") == 0)\n        {\n          tchCoDel.Install (devices);\n        }\n      else\n        {\n          NS_FATAL_ERROR (\"Queue not recognized. Allowed values are ns3::CoDelQueueDisc or ns3::PfifoFastQueueDisc\");\n        }\n      address.NewNetwork ();\n      interfaces = address.Assign (devices);\n    }\n\n  NS_LOG_INFO (\"Initialize Global Routing.\");\n  Ipv4GlobalRoutingHelper::PopulateRoutingTables ();\n\n  uint16_t port = 50000;\n  Address sinkLocalAddress (InetSocketAddress (Ipv4Address::GetAny (), port));\n\n  ApplicationContainer clientApps;\n  ApplicationContainer serverApps;\n  // applications client and server\n  for (uint16_t i = 0; i < sources.GetN (); i++)\n    {\n      AddressValue remoteAddress (InetSocketAddress (sink_interfaces.GetAddress (i, 0), port));\n      BulkSendHelper ftp (\"ns3::QuicSocketFactory\", Address ());\n      ftp.SetAttribute (\"Remote\", remoteAddress);\n      ftp.SetAttribute (\"SendSize\", UintegerValue (1400));\n      clientApps.Add(ftp.Install (sources.Get (i)));\n      PacketSinkHelper sinkHelper (\"ns3::QuicSocketFactory\", sinkLocalAddress);\n      sinkHelper.SetAttribute (\"Protocol\", TypeIdValue (QuicSocketFactory::GetTypeId ()));\n      serverApps.Add(sinkHelper.Install (sinks.Get (i)));\n    }\n\n  serverApps.Start (Seconds (0.99));\n  clientApps.Stop (Seconds (20.0));\n  clientApps.Start (Seconds (2));\n\n  for (uint16_t i = 0; i < num_flows; i++)\n    {\n      auto n2 = sinks.Get (i);\n      auto n1 = sources.Get (i);\n      Time t = Seconds(2.100001);\n      Simulator::Schedule (t, &Traces, n2->GetId(),\n            \"./server\", \".txt\");\n      Simulator::Schedule (t, &Traces, n1->GetId(),\n            \"./client\", \".txt\");\n    }\n\n  if (pcap)\n    {\n      BottleneckLink.EnablePcapAll (prefix_file_name, true);\n      LocalLink.EnablePcapAll (prefix_file_name, true);\n      AccessLink.EnablePcapAll (prefix_file_name, true);\n    }\n\n  // Flow monitor\n  FlowMonitorHelper flowHelper;\n  if (flow_monitor)\n    {\n      flowHelper.InstallAll ();\n    }\n\n  Simulator::Stop (Seconds (stop_time));\n  Simulator::Run ();\n\n  if (flow_monitor)\n    {\n      flowHelper.SerializeToXmlFile (prefix_file_name + \".flowmonitor\", true, true);\n    }\n\n  Simulator::Destroy ();\n  return 0;\n}\n"
    },
    {
      "file_path": "examples/quic-variants-comparison.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2013 ResiliNets, ITTC, University of Kansas\n * Copyright (c) 2019 SIGNET Lab, Department of Information Engineering, University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Authors of the original TCP example:\n * Justin P. Rohrer, Truc Anh N. Nguyen <annguyen@ittc.ku.edu>, Siddharth Gangadhar <siddharth@ittc.ku.edu>\n * James P.G. Sterbenz <jpgs@ittc.ku.edu>, director\n * ResiliNets Research Group  http://wiki.ittc.ku.edu/resilinets\n * Information and Telecommunication Technology Center (ITTC)\n * and Department of Electrical Engineering and Computer Science\n * The University of Kansas Lawrence, KS USA.\n *\n * Work supported in part by NSF FIND (Future Internet Design) Program\n * under grant CNS-0626918 (Postmodern Internet Architecture),\n * NSF grant CNS-1050226 (Multilayer Network Resilience Analysis and Experimentation on GENI),\n * US Department of Defense (DoD), and ITTC at The University of Kansas.\n *\n * Adapted to QUIC by:\n *          Alvise De Biasio <alvise.debiasio@gmail.com>\n *          Federico Chiariotti <chiariotti.federico@gmail.com>\n *          Michele Polese <michele.polese@gmail.com>\n *          Davide Marcato <davidemarcato@outlook.com>\n *\n */\n\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#include <ns3/config-store.h>\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/quic-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/error-model.h\"\n#include \"ns3/tcp-header.h\"\n#include \"ns3/udp-header.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/event-id.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/traffic-control-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"QuicVariantsComparison\");\n\n// connect to a number of traces\nstatic void\nCwndChange (Ptr<OutputStreamWrapper> stream, uint32_t oldCwnd, uint32_t newCwnd)\n{\n  *stream->GetStream () << Simulator::Now ().GetSeconds () << \"\\t\" << oldCwnd << \"\\t\" << newCwnd << std::endl;\n}\n\nstatic void\nRttChange (Ptr<OutputStreamWrapper> stream, Time oldRtt, Time newRtt)\n{\n  *stream->GetStream () << Simulator::Now ().GetSeconds () << \"\\t\" << oldRtt.GetSeconds () << \"\\t\" << newRtt.GetSeconds () << std::endl;\n}\n\nstatic void\nRx (Ptr<OutputStreamWrapper> stream, Ptr<const Packet> p, const QuicHeader& q, Ptr<const QuicSocketBase> qsb)\n{\n  *stream->GetStream () << Simulator::Now ().GetSeconds () << \"\\t\" << p->GetSize() << std::endl;\n}\n\nstatic void\nTraces(uint32_t serverId, std::string pathVersion, std::string finalPart)\n{\n  AsciiTraceHelper asciiTraceHelper;\n\n  std::ostringstream pathCW;\n  pathCW << \"/NodeList/\" << serverId << \"/$ns3::QuicL4Protocol/SocketList/0/QuicSocketBase/CongestionWindow\";\n  NS_LOG_INFO(\"Matches cw \" << Config::LookupMatches(pathCW.str().c_str()).GetN());\n\n  std::ostringstream fileCW;\n  fileCW << pathVersion << \"QUIC-cwnd-change\"  << serverId << \"\" << finalPart;\n\n  std::ostringstream pathRTT;\n  pathRTT << \"/NodeList/\" << serverId << \"/$ns3::QuicL4Protocol/SocketList/0/QuicSocketBase/RTT\";\n\n  std::ostringstream fileRTT;\n  fileRTT << pathVersion << \"QUIC-rtt\"  << serverId << \"\" << finalPart;\n\n  std::ostringstream pathRCWnd;\n  pathRCWnd<< \"/NodeList/\" << serverId << \"/$ns3::QuicL4Protocol/SocketList/0/QuicSocketBase/RWND\";\n\n  std::ostringstream fileRCWnd;\n  fileRCWnd<<pathVersion << \"QUIC-rwnd-change\"  << serverId << \"\" << finalPart;\n\n  std::ostringstream fileName;\n  fileName << pathVersion << \"QUIC-rx-data\" << serverId << \"\" << finalPart;\n  std::ostringstream pathRx;\n  pathRx << \"/NodeList/\" << serverId << \"/$ns3::QuicL4Protocol/SocketList/*/QuicSocketBase/Rx\";\n  NS_LOG_INFO(\"Matches rx \" << Config::LookupMatches(pathRx.str().c_str()).GetN());\n\n  Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream (fileName.str ().c_str ());\n  Config::ConnectWithoutContext (pathRx.str ().c_str (), MakeBoundCallback (&Rx, stream));\n\n  Ptr<OutputStreamWrapper> stream1 = asciiTraceHelper.CreateFileStream (fileCW.str ().c_str ());\n  Config::ConnectWithoutContext (pathCW.str ().c_str (), MakeBoundCallback(&CwndChange, stream1));\n\n  Ptr<OutputStreamWrapper> stream2 = asciiTraceHelper.CreateFileStream (fileRTT.str ().c_str ());\n  Config::ConnectWithoutContext (pathRTT.str ().c_str (), MakeBoundCallback(&RttChange, stream2));\n\n  Ptr<OutputStreamWrapper> stream4 = asciiTraceHelper.CreateFileStream (fileRCWnd.str ().c_str ());\n  Config::ConnectWithoutContextFailSafe (pathRCWnd.str ().c_str (), MakeBoundCallback(&CwndChange, stream4));\n}\n\nint main (int argc, char *argv[])\n{\n  std::string transport_prot = \"TcpVegas\";\n  double error_p = 0.0;\n  std::string bandwidth = \"2Mbps\";\n  std::string delay = \"0.01ms\";\n  std::string access_bandwidth = \"12Mbps\";\n  std::string access_delay = \"25ms\";\n  bool tracing = false;\n  std::string prefix_file_name = \"QuicVariantsComparison\";\n  double data_mbytes = 0;\n  uint32_t mtu_bytes = 1400;\n  uint16_t num_flows = 1;\n  float duration = 100;\n  uint32_t run = 0;\n  bool flow_monitor = false;\n  bool pcap = false;\n  std::string queue_disc_type = \"ns3::PfifoFastQueueDisc\";\n\n  // LogComponentEnable (\"Config\", LOG_LEVEL_ALL);\n  CommandLine cmd;\n  cmd.AddValue (\"transport_prot\", \"Transport protocol to use: TcpNewReno, \"\n                \"TcpHybla, TcpHighSpeed, TcpHtcp, TcpVegas, TcpScalable, TcpVeno, \"\n                \"TcpBic, TcpYeah, TcpIllinois, TcpLedbat \", transport_prot);\n  cmd.AddValue (\"error_p\", \"Packet error rate\", error_p);\n  cmd.AddValue (\"bandwidth\", \"Bottleneck bandwidth\", bandwidth);\n  cmd.AddValue (\"delay\", \"Bottleneck delay\", delay);\n  cmd.AddValue (\"access_bandwidth\", \"Access link bandwidth\", access_bandwidth);\n  cmd.AddValue (\"access_delay\", \"Access link delay\", access_delay);\n  cmd.AddValue (\"tracing\", \"Flag to enable/disable tracing\", tracing);\n  cmd.AddValue (\"prefix_name\", \"Prefix of output trace file\", prefix_file_name);\n  cmd.AddValue (\"data\", \"Number of Megabytes of data to transmit\", data_mbytes);\n  cmd.AddValue (\"mtu\", \"Size of IP packets to send in bytes\", mtu_bytes);\n  cmd.AddValue (\"num_flows\", \"Number of flows\", num_flows);\n  cmd.AddValue (\"duration\", \"Time to allow flows to run in seconds\", duration);\n  cmd.AddValue (\"run\", \"Run index (for setting repeatable seeds)\", run);\n  cmd.AddValue (\"flow_monitor\", \"Enable flow monitor\", flow_monitor);\n  cmd.AddValue (\"pcap_tracing\", \"Enable or disable PCAP tracing\", pcap);\n  cmd.AddValue (\"queue_disc_type\", \"Queue disc type for gateway (e.g. ns3::CoDelQueueDisc)\", queue_disc_type);\n  cmd.Parse (argc, argv);\n\n  transport_prot = std::string (\"ns3::\") + transport_prot;\n\n  SeedManager::SetSeed (1);\n  SeedManager::SetRun (run);\n\n  // User may find it convenient to enable logging\n  Time::SetResolution (Time::NS);\n  LogComponentEnableAll (LOG_PREFIX_TIME);\n  LogComponentEnableAll (LOG_PREFIX_FUNC);\n  LogComponentEnableAll (LOG_PREFIX_NODE);\n  // LogComponentEnable(\"QuicVariantsComparison\", LOG_LEVEL_ALL);\n  // LogComponentEnable(\"BulkSendApplication\", LOG_LEVEL_INFO);\n  // LogComponentEnable(\"PfifoFastQueueDisc\", LOG_LEVEL_ALL);\n  // LogComponentEnable (\"QuicSocketBase\", LOG_LEVEL_ALL);\n  LogComponentEnable(\"TcpVegas\", LOG_LEVEL_ALL);\n  // LogComponentEnable(\"QuicL5Protocol\", LOG_LEVEL_ALL);\n\n  // Set the simulation start and stop time\n  float start_time = 0.1;\n  float stop_time = start_time + duration;\n\n  // 4 MB of buffer\n  Config::SetDefault (\"ns3::QuicSocketBase::SocketRcvBufSize\", UintegerValue (1 << 21));\n  Config::SetDefault (\"ns3::QuicSocketBase::SocketSndBufSize\", UintegerValue (1 << 21));\n  Config::SetDefault (\"ns3::QuicStreamBase::StreamSndBufSize\", UintegerValue (1 << 21));\n  Config::SetDefault (\"ns3::QuicStreamBase::StreamRcvBufSize\", UintegerValue (1 << 21));\n\n  TypeId tcpTid;\n  NS_ABORT_MSG_UNLESS (TypeId::LookupByNameFailSafe (transport_prot, &tcpTid), \"TypeId \" << transport_prot << \" not found\");\n  Config::SetDefault (\"ns3::QuicL4Protocol::SocketType\", TypeIdValue (TypeId::LookupByName (transport_prot)));\n\n\n  // Create gateways, sources, and sinks\n  NodeContainer gateways;\n  gateways.Create (2);\n  NodeContainer sources;\n  sources.Create (num_flows);\n  NodeContainer sinks;\n  sinks.Create (num_flows);\n\n  // Configure the error model\n  // Here we use RateErrorModel with packet error rate\n  Ptr<UniformRandomVariable> uv = CreateObject<UniformRandomVariable> ();\n  uv->SetStream (50);\n  RateErrorModel error_model;\n  error_model.SetRandomVariable (uv);\n  error_model.SetUnit (RateErrorModel::ERROR_UNIT_PACKET);\n  error_model.SetRate (error_p);\n\n  PointToPointHelper BottleneckLink;\n  BottleneckLink.SetDeviceAttribute (\"DataRate\", StringValue (bandwidth));\n  BottleneckLink.SetChannelAttribute (\"Delay\", StringValue (delay));\n  BottleneckLink.SetDeviceAttribute (\"ReceiveErrorModel\", PointerValue (&error_model));\n\n  PointToPointHelper AccessLink;\n  AccessLink.SetDeviceAttribute (\"DataRate\", StringValue (access_bandwidth));\n  AccessLink.SetChannelAttribute (\"Delay\", StringValue (access_delay));\n\n  QuicHelper stack;\n  stack.InstallQuic (sources);\n  stack.InstallQuic (sinks);\n  stack.InstallQuic (gateways);\n\n  TrafficControlHelper tchPfifo;\n  tchPfifo.SetRootQueueDisc (\"ns3::PfifoFastQueueDisc\");\n\n  TrafficControlHelper tchCoDel;\n  tchCoDel.SetRootQueueDisc (\"ns3::CoDelQueueDisc\");\n\n  Ipv4AddressHelper address;\n  address.SetBase (\"10.0.0.0\", \"255.255.255.0\");\n\n  // Configure the sources and sinks net devices\n  // and the channels between the sources/sinks and the gateways\n  PointToPointHelper LocalLink;\n  LocalLink.SetDeviceAttribute (\"DataRate\", StringValue (access_bandwidth));\n  LocalLink.SetChannelAttribute (\"Delay\", StringValue (access_delay));\n\n  Ipv4InterfaceContainer sink_interfaces;\n\n  DataRate access_b (access_bandwidth);\n  DataRate bottle_b (bandwidth);\n  Time access_d (access_delay);\n  Time bottle_d (delay);\n\n  uint32_t size = (std::min (access_b, bottle_b).GetBitRate () / 8) *\n    ((access_d + bottle_d) * 2).GetSeconds ();\n\n  Config::SetDefault (\"ns3::PfifoFastQueueDisc::MaxSize\",\n                      QueueSizeValue (QueueSize (QueueSizeUnit::PACKETS, size / mtu_bytes)));\n  Config::SetDefault (\"ns3::CoDelQueueDisc::MaxSize\",\n                      QueueSizeValue (QueueSize (QueueSizeUnit::BYTES, size)));\n\n  for (int i = 0; i < num_flows; i++)\n    {\n      NetDeviceContainer devices;\n      devices = AccessLink.Install (sources.Get (i), gateways.Get (0));\n      tchPfifo.Install (devices);\n      address.NewNetwork ();\n      Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n      devices = LocalLink.Install (gateways.Get (1), sinks.Get (i));\n      if (queue_disc_type.compare (\"ns3::PfifoFastQueueDisc\") == 0)\n        {\n          tchPfifo.Install (devices);\n        }\n      else if (queue_disc_type.compare (\"ns3::CoDelQueueDisc\") == 0)\n        {\n          tchCoDel.Install (devices);\n        }\n      else\n        {\n          NS_FATAL_ERROR (\"Queue not recognized. Allowed values are ns3::CoDelQueueDisc or ns3::PfifoFastQueueDisc\");\n        }\n      address.NewNetwork ();\n      interfaces = address.Assign (devices);\n      sink_interfaces.Add (interfaces.Get (1));\n\n      devices = BottleneckLink.Install (gateways.Get (0), gateways.Get (1));\n      if (queue_disc_type.compare (\"ns3::PfifoFastQueueDisc\") == 0)\n        {\n          tchPfifo.Install (devices);\n        }\n      else if (queue_disc_type.compare (\"ns3::CoDelQueueDisc\") == 0)\n        {\n          tchCoDel.Install (devices);\n        }\n      else\n        {\n          NS_FATAL_ERROR (\"Queue not recognized. Allowed values are ns3::CoDelQueueDisc or ns3::PfifoFastQueueDisc\");\n        }\n      address.NewNetwork ();\n      interfaces = address.Assign (devices);\n    }\n\n  NS_LOG_INFO (\"Initialize Global Routing.\");\n  Ipv4GlobalRoutingHelper::PopulateRoutingTables ();\n\n  uint16_t port = 50000;\n  ApplicationContainer clientApps;\n  ApplicationContainer serverApps;\n  double interPacketInterval = 1000;\n\n  // QUIC client and server\n  for (uint16_t i = 0; i < sources.GetN (); i++)\n    {\n      QuicServerHelper dlPacketSinkHelper (port);\n      AddressValue remoteAddress (InetSocketAddress (sink_interfaces.GetAddress (i, 0), port));\n      serverApps.Add (dlPacketSinkHelper.Install (sinks.Get (i)));\n      QuicClientHelper dlClient (sink_interfaces.GetAddress (i, 0), port);\n      dlClient.SetAttribute (\"Interval\", TimeValue (MicroSeconds(interPacketInterval)));\n      dlClient.SetAttribute (\"PacketSize\", UintegerValue(1400));\n      dlClient.SetAttribute (\"MaxPackets\", UintegerValue(10000000));\n      clientApps.Add (dlClient.Install (sources.Get (i)));\n    }\n\n  serverApps.Start (Seconds (0.99));\n  clientApps.Stop (Seconds (20.0));\n  clientApps.Start (Seconds (2.0));\n\n  for (uint16_t i = 0; i < num_flows; i++)\n    {\n      auto n2 = sinks.Get (i);\n      auto n1 = sources.Get (i);\n      Time t = Seconds(2.100001);\n      Simulator::Schedule (t, &Traces, n2->GetId(),\n            \"./server\", \".txt\");\n      Simulator::Schedule (t, &Traces, n1->GetId(),\n            \"./client\", \".txt\");\n    }\n\n  if (pcap)\n    {\n      BottleneckLink.EnablePcapAll (prefix_file_name, true);\n      LocalLink.EnablePcapAll (prefix_file_name, true);\n      AccessLink.EnablePcapAll (prefix_file_name, true);\n    }\n\n  // Flow monitor\n  FlowMonitorHelper flowHelper;\n  if (flow_monitor)\n    {\n      flowHelper.InstallAll ();\n    }\n\n  Simulator::Stop (Seconds (stop_time));\n  Simulator::Run ();\n\n  if (flow_monitor)\n    {\n      flowHelper.SerializeToXmlFile (prefix_file_name + \".flowmonitor\", true, true);\n    }\n\n  Simulator::Destroy ();\n  return 0;\n}\n"
    }
  ]
}