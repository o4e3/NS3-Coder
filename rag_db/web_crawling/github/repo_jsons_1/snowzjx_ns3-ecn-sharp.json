{
  "repo_name": "snowzjx/ns3-ecn-sharp",
  "github_url": "https://github.com/snowzjx/ns3-ecn-sharp",
  "readme": "# ns3 Simulator for ECN#\n\n## Papers that use this simulator\n\n[Enabling ECN for Datacenter Networks with RTT Variations (CoNEXT 19)](https://dl.acm.org/authorize.cfm?key=N690741)\n\n[Resilient Datacenter Load Balancing in the Wild (SIGCOMM 17)](http://www.cse.ust.hk/~kaichen/papers/hermes-sigcomm17.pdf)\n\n[PURR: a primitive for reconfigurable fast reroute: hope for the best and program for the worst (CoNEXT 19)](https://dl.acm.org/authorize?N690721)\n\nPlease cite both of the following papers if you are using our simulator. Thanks! :P\n\n```\n@inproceedings{zhang2017resilient,\n  title={Resilient datacenter load balancing in the wild},\n  author={Zhang, Hong and Zhang, Junxue and Bai, Wei and Chen, Kai and Chowdhury, Mosharaf},\n  booktitle={Proceedings of the Conference of the ACM Special Interest Group on Data Communication},\n  pages={253--266},\n  year={2017},\n  organization={ACM}\n}\n```\n\n```\n@inproceedings{zhang2019enabling,\n  title={Enabling ECN for datacenter networks with RTT variations},\n  author={Zhang, Junxue and Bai, Wei and Chen, Kai},\n  booktitle={Proceedings of the 15th International Conference on Emerging Networking Experiments And Technologies},\n  pages={233--245},\n  year={2019},\n  organization={ACM}\n}\n```\n\n## Download and Compile\n\n1. Ubuntu + gcc-4.9 has been verified to compatiable with the project.\n\n``` docker run -it gcc:4.9 ```\n\n2. Clone the project.\n\n``` git clone git@github.com:snowzjx/ns3-ecn-sharp.git ```\n\n3. Configuration.\n\n``` cd ns3-ecn-sharp ```\n\n``` ./waf -d optimized --enable-examples configure ```\n\n4. If you want to enable the debug mode for logging, can pass ```-d debug ``` to the configuration.\n\n``` ./waf -d debug --enable-examples configure ```\n\n5. Compile the simulator.\n\n``` ./waf ```\n\n## Docker Image\n\nYou can also directly use our docker image for this simulator.\n\n``` docker run -it snowzjx/ns3-ecn-sharp:optimized ```\n\n``` cd ~/ns3-ecn-sharp ```\n\n## ECN# Implementation\n\nThe ECN# (ECN Sharp)'s implementation is here:\n\n[https://github.com/snowzjx/ns3-ecn-sharp/blob/master/src/traffic-control/model/ecn-sharp-queue-disc.h](https://github.com/snowzjx/ns3-ecn-sharp/blob/master/src/traffic-control/model/ecn-sharp-queue-disc.h)\n\n[https://github.com/snowzjx/ns3-ecn-sharp/blob/master/src/traffic-control/model/ecn-sharp-queue-disc.cc](https://github.com/snowzjx/ns3-ecn-sharp/blob/master/src/traffic-control/model/ecn-sharp-queue-disc.cc)\n\n### Measuring the sojourn time\n\nThe sojourn time is measured using ```ECNSharpTimestampTag```.\n\nWhen a packet enqueues, we add a timestamp tag on the packet.\n\n```\nECNSharpTimestampTag tag;\np->AddPacketTag (tag);\nGetInternalQueue (0)->Enqueue (item);\n```\n\nWhen a packet dequeues, we calculate the sojourn time by deducing enqueue timestamp from current timestamp.\n\n```\nPtr<QueueDiscItem> item = StaticCast<QueueDiscItem> (GetInternalQueue (0)->Dequeue ());\nPtr<Packet> p = item->GetPacket ();\nECNSharpTimestampTag tag;\nbool found = p->RemovePacketTag (tag);\nif (!found)\n{\n  NS_LOG_ERROR (\"Cannot find the ECNSharp Timestamp Tag\");\n  return NULL;\n}\nTime sojournTime = now - tag.GetTxTime ();\n```\n\n### Instantaneous ECN Marking\n\n```\nif (sojournTime > m_instantMarkingThreshold)\n{\n  instantaneousMarking = true;\n}\n```\n\n### Persistent ECN Marking\n```\nbool okToMark = OkToMark (p, sojournTime, now);\nif (m_marking)\n{\n  if (!okToMark)\n  {\n    m_marking = false;\n  }\n  else if (now >= m_markNext)\n  {\n    m_markCount ++;\n    m_markNext = now + ECNSharpQueueDisc::ControlLaw ();\n    persistentMarking = true;\n  }\n}\nelse\n{\n  if (okToMark)\n  {\n    m_marking = true;\n    m_markCount = 1;\n    m_markNext = now + m_persistentMarkingInterval;\n    persistentMarking = true;\n   }\n}\n```\n\n### Mark ECN based on the above 2 conditions\n```\nif (instantaneousMarking || persistentMarking)\n{\n  if (!ECNSharpQueueDisc::MarkingECN (item))\n  {\n    NS_LOG_ERROR (\"Cannot mark ECN\");\n    return item; // Hey buddy, if the packet is not ECN supported, we should never drop it\n   }\n}\n```\n\n## Run Simulations\nRun ```large-scale``` program for this experiment:\n\n```\n./waf --run \"large-scale --help\"\n```\n\nPlease note, the default simulation time is very short, you should tune the simulation time by setting the ```--EndTime``` and ```--FlowLaunchEndTime``` to obtain a similar results in our paper.\n\nIn this program, TCN is identical to RED because here we only use one queue.\n\nYou should run:\n```\n./waf --run \"large-scale --randomSeed=233 --load=0.6 --ID=TCN_High --AQM=TCN --TCNThreshold=70\"\n```\n```\n./waf --run \"large-scale --randomSeed=233 --load=0.6 --ID=TCN_Low --AQM=TCN --TCNThreshold=30\"\n```\n```\n./waf --run \"large-scale --randomSeed=233 --load=0.6 --ID=ECNSharp --AQM=ECNSharp --ECNShaprInterval=70 --ECNSharpTarget=10 --ECNShaprMarkingThreshold=70\"\n```\n\nto compare the ECN#, RED with marking threshold calculated based on tail RTT and average RTT.\n\nAfter simulation finishes, you will get a flow monitor file. The file is xml format and can be parsed by ```fct_parser.py``` script. Please note, our [flow monitor](https://github.com/snowzjx/ns3-ecn-sharp/blob/master/src/flow-monitor/model/flow-monitor.cc) is slight different from the original version (some bugs are fixed).\n\n```\npython examples/rtt-variations/fct_parser.py Large_Scale_TCN_High_4X4_TCN_DcTcp_0.6.xml\n```\n```\npython examples/rtt-variations/fct_parser.py Large_Scale_TCN_Low_4X4_TCN_DcTcp_0.6.xml\n```\n```\npython examples/rtt-variations/fct_parser.py Large_Scale_ECNSharp_4X4_ECNSharp_DcTcp_0.6.xml\n```\n\nYou can obtain the results as follows. Here we give a sample with default parameters (short simulation time) only to demonstrate the trends.\n\nFor ECN#:\n```\n...\nAVG FCT: 0.009724\nAVG Large flow FCT: 0.075342\nAVG Small flow FCT: 0.001556\nAVG Small flow 99 FCT: 0.008763\n...\n```\n\nFor RED (TCN) with marking threshold calculated based on high percentile RTT:\n```\n...\nAVG FCT: 0.010133\nAVG Large flow FCT: 0.073115\nAVG Small flow FCT: 0.002375\nAVG Small flow 99 FCT: 0.009398\n...\n```\n\nFor RED (TCN) with marking threshold calculated based on average RTT:\n```\n...\nAVG FCT: 0.009593\nAVG Large flow FCT: 0.081166\nAVG Small flow FCT: 0.001483\nAVG Small flow 99 FCT: 0.008892\n...\n```\nWe can see RED suffers from either throughput loss (poor FCT for all flows and large flows) or increased latency (poor FCT and tail FCT for short flows).\n\nECN# simultaneously deliver high throughput and low latency communications. \n\n### Queue Track\nRun ```queue-track``` program for this experiment:\n\n```\n./waf --run \"queue-track --help\"\n```\n\nYou can use GNU Plot to plot the queue.\n```\ngnuplot Queue_Track_ ... .plt\n```\n\nThe results are as follows, we can see ECN# can at the same time mitigate the persistent queue buildups and tolerate traffic burstiness.\n\n![Queue Track](https://raw.githubusercontent.com/snowzjx/ns3-ecn-sharp/master/examples/rtt-variations/queue-track.png)\n\n\n### Multi-Queue\n\nRun ```mq``` program for this experiment:\n\n```\n./waf --run \"mq --help\"\n```\n\nBoth TCN and ECN# will output the throughput of all 3 flows. The results should be similar as follows, which shows both strategy can preserve the packet sceduling policy.\n\n```\n...\nFlow: 0, throughput (Gbps): 9.57376\nFlow: 1, throughput (Gbps): 0\nFlow: 2, throughput (Gbps): 0\n...\nFlow: 0, throughput (Gbps): 6.55424\nFlow: 1, throughput (Gbps): 3.01392\nFlow: 2, throughput (Gbps): 0\n...\nFlow: 0, throughput (Gbps): 4.86864\nFlow: 1, throughput (Gbps): 2.42928\nFlow: 2, throughput (Gbps): 2.2372\n...\n```\n\nWhen we anaylzing FCT of all flows, we should obtain the following results. This shows ECN# has much better results for short flows by mitigating the unnecessary persistent queue buildups.\n\nFor ECN#:\n\n```\n...\nAVG Small flow FCT: 0.001329\nAVG Small flow 99 FCT: 0.001694\n...\n```\n\nFor TCN:\n\n```\n...\nAVG Small flow FCT: 0.002105\nAVG Small flow 99 FCT: 0.005068\n...\n```\n\n## Implemented Modules\n\nWe have implemented the following transportation protocols, tc modules and load balance schemes in this simulator.\n\n### Transport Protocol\n\n1. [DCTCP](https://people.csail.mit.edu/alizadeh/papers/dctcp-sigcomm10.pdf)\n\n### Traffic Control Module\n\n1. ECN#\n2. RED\n3. [TCN](http://www.cse.ust.hk/~kaichen/papers/tcn-conext16.pdf)\n4. [CoDel(with ECN)](https://queue.acm.org/detail.cfm?id=2209336)\n5. DWRR\n6. WFQ\n\n### Load Balance Scheme\n\n1. [Hermes](http://www.cse.ust.hk/~kaichen/papers/hermes-sigcomm17.pdf)\n2. Per flow ECMP\n3. [CONGA](https://people.csail.mit.edu/alizadeh/papers/conga-sigcomm14.pdf)\n4. [DRB](http://conferences.sigcomm.org/co-next/2013/program/p49.pdf)\n5. [Presto](http://pages.cs.wisc.edu/~akella/papers/presto-sigcomm15.pdf)\n6. Weighted Presto, which has to be used together with asymmetric topology\n7. [FlowBender](http://conferences2.sigcomm.org/co-next/2014/CoNEXT_papers/p149.pdf) \n8. [CLOVE](https://www.cs.princeton.edu/~jrex/papers/clove16.pdf)\n9. [DRILL](http://conferences.sigcomm.org/hotnets/2015/papers/ghorbani.pdf)\n10. [LetFlow](https://people.csail.mit.edu/alizadeh/papers/letflow-nsdi17.pdf)\n\n### Routing \n\n1. [XPath](http://www.cse.ust.hk/~kaichen/papers/xpath-nsdi15.pdf)\n",
  "examples": []
}