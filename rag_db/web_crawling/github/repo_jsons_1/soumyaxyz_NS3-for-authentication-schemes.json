{
  "repo_name": "soumyaxyz/NS3-for-authentication-schemes",
  "github_url": "https://github.com/soumyaxyz/NS3-for-authentication-schemes",
  "readme": "<!DOCTYPE html>\n<html>\n<body class=\"stackedit\">\n  <div class=\"stackedit__html\"><h1 id=\"NS3-simulation-for-authentication-schemes-a-walkthrough\">NS3 simulation for authentication schemes: a walkthrough</h1>\n<p>In this writeup, we will model an authentication mechanism for IoT devices.  A NS3 model is insutable for security analysis. Thus, we are not attempting to analyse the security aspect of the scheme, we only intend to measure the network  impact  (end-to-end delay, throughput, packet delivery ratio etc) of such an scheme in a deployment setting.</p>\n<p>A high level description of the scheme in question:<br>\n<a href=\"https://i.stack.imgur.com/osMTA.png\"><img src=\"https://i.stack.imgur.com/osMTA.png\" alt=\"enter image description here\"></a></p>\n<p>For our NS3 simulation we need to know the sizes  M<sub>1</sub> - M<sub>3</sub> . In the scheme in question</p>\n<ul>\n<li>M<sub>1</sub> = 104 Bytes</li>\n<li>M<sub>2</sub> = 84 Bytes</li>\n<li>M<sub>3</sub> = 84 Bytes</li>\n</ul>\n<h2 id=\"ns3-installation-and-setup\">NS3 installation and setup</h2>\n<p>The <a href=\"https://www.nsnam.org/wiki/Installation\">installation guide</a> at <a href=\"http://nsnam.org\">nsnam.org</a> is very detailed. It is also highly recommended that new NS3 users go through the <a href=\"https://www.nsnam.org/docs/release/3.29/tutorial/html/index.html\">tutorial</a>. The website is the official repository for NS3 and the most reliable resource. In case of issues, the <a href=\"https://groups.google.com/forum/#!forum/ns-3-users\">ns3-user google group</a> is the most active forum for NS3. The maintainers of the projects are active there and oftentimes are there to  guide newcomers.</p>\n<h2 id=\"ns3-simulation-code\">NS3 simulation code</h2>\n<p>We can model NS3 simulations in C++ or python. In my experience,  as the examples provided are mostly in C++, its more convenient to write the code in C++ purely for the relatively more abundant reference material.<br>\nThe C++ code is written under the ns3 namespace. We also set up some global defaults.</p>\n<pre><code>#include &lt;stdlib.h&gt;    \t\t\t\t\t \t// for rand()\n#include &lt;math.h&gt;\t\t\t\t\t\t\t// for mathemetical operations\n#include \"ns3/core-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/olsr-helper.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/basic-energy-source.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/simple-device-energy-model.h\"\n#include \"ns3/v4ping-helper.h\"\n#include \"ns3/v4ping.h\"\nusing namespace ns3;\nstatic bool verbose = 0;\nuint32_t M1 = 104, M2=84, M3 = 84;\nchar * stringbuilder( char* prefix,  char* sufix){\n  char* buf = (char*)malloc(50); \n  snprintf(buf, 50, \"%s%s\", prefix, sufix);\n  return  buf;\n}\n</code></pre>\n<p>We begin the program as a normal  C++ program  and define variables to be set up by the command line argument</p>\n<pre><code>int main (int argc, char *argv[])\n{  \n  //\n  // First, we declare and initialize a few local variables that control some\n  // simulation parameters.\n  uint32_t mobileUserNodes = 3;\n  uint32_t smartDeviceNodes = 2;\n  uint32_t stopTime = 3600;\n  bool verbose = 0;\n  bool enablePcap = 0;\n  bool enableAnim = 0;\n  bool verifyResults = 0; //used for regression\n  char saveFilePrefix[50] ;\n  //\n  // Simulation defaults are typically set next, before command line\n  // arguments are parsed.\n  //\n  //\n  //\n  // For convenience, we add the local variables to the command line argument\n  // system so that they can be overridden with flags such as\n  // \"--smartDeviceNodes=20\"\n  //\n  CommandLine cmd;  \n  cmd.AddValue (\"MU\", \"number of User nodes\", mobileUserNodes);\n  cmd.AddValue (\"SD\", \"number of smart device nodes\", smartDeviceNodes);\n  cmd.AddValue (\"t\", \"simulation stop time (seconds)\", stopTime);  \n  cmd.AddValue (\"p\", \"Enable/disable pcap file generation\", enablePcap);\n  cmd.AddValue (\"a\", \"Enable/disable xml gneration for netanim-module\", enableAnim);\n  cmd.AddValue (\"o\", \"Show output end of the simulation\", verifyResults);\n  cmd.AddValue (\"v\", \"Verbose mode.\", verbose);\n  cmd.AddValue (\"s\", \"Define the prefix for .pcap anf .xml files. Default: IOT \", saveFilePrefix);\n  cmd.AddValue (\"M1\", \"Size of message 1 \", M1);\n  cmd.AddValue (\"M2\", \"Size of message 2 \", M2);\n  cmd.AddValue (\"M3\", \"Size of message 3 \", M3);\n  //\n  // The system global variables and the local values added to the argument\n  // system can be overridden by command line arguments by using this call.\n  //\n  cmd.Parse (argc, argv);\n  if (stopTime &lt; 2)\n    {\n      std::cout &lt;&lt; \"Use a simulation stop time &gt;= 2 seconds\" &lt;&lt; std::endl;\n      exit (1);\n    }  \nif (verbose)\n  {\n    //LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n    //LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"Simulator\", LOG_LEVEL_INFO);\n  }\n</code></pre>\n<p>The logging module can be very useful  for debugging  simulations. This cleaned up code does not demonstrate the use of logging. Interested readers may refer to <a href=\"https://www.nsnam.org/docs/release/3.29/tutorial/html/tweaking.html#using-the-logging-module\">this section</a> of the previously referenced NS3 tutorial.</p>\n<p>This write up assumes that the reader has already followed the NS3 tutorial and is familiar with the basics. Thus without elaborating we state that we need distinct nodes for  each role in the simulation.  <em>mobileUserNodes</em> and  <em>smartDeviceNodes</em> account for the number of the users and smart devices in the simulation. There will be a single gateway node. <em>M<sub>1</sub></em>,  <em>M<sub>2</sub></em> and   <em>M<sub>3</sub></em> defines the sizes of the three authentication messages. <em>stopTime</em> defines when the simulation will stop. By default the code shall run the simulation for  3600 seconds or half an hour. Note that this is half hour of simulated network runtime, not how long it will take to actually run the simulation. As NS3 is a discrete event simulator it completely depends on the complexity of the protocol modelled.</p>\n\n<pre><code>  //Since default reference loss is defined for 5 GHz, it needs to be changed when operating at 2.4 GHz\n  Config::SetDefault (\"ns3::LogDistancePropagationLossModel::ReferenceLoss\", DoubleValue (40.046));  \n  // creating nodes\n  //NodeContainer allNodes;\n  NodeContainer wifiUserNodes;\n  wifiUserNodes.Create (mobileUserNodes);\n  //allNodes.Add (wifiUserNodes);\n  NodeContainer wifiDeviceNodes;\n  wifiDeviceNodes.Create (smartDeviceNodes);\n  //allNodes.Add (wifiDeviceNodes);\n  NodeContainer wifiGateway ;\n  wifiGateway.Create (1);\n  // allNodes.Add (wifiGateway);\n  // creating wireless channel\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();\n  YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();\n  phy.SetChannel (channel.Create ());\n\n  WifiHelper wifi;\n  wifi.SetRemoteStationManager (\"ns3::AarfWifiManager\");\n\n  WifiMacHelper mac;\n  Ssid ssid = Ssid (\"ns-3-ssid\");\n  mac.SetType (\"ns3::StaWifiMac\",\n               \"Ssid\", SsidValue (ssid),\n               \"ActiveProbing\", BooleanValue (false));\n\n  NetDeviceContainer UserDevices;\n  UserDevices = wifi.Install (phy, mac, wifiUserNodes);\n  mac.SetType (\"ns3::StaWifiMac\",\n               \"Ssid\", SsidValue (ssid));\n\n  NetDeviceContainer SmartDevices;\n  SmartDevices = wifi.Install (phy, mac, wifiDeviceNodes);\n  mac.SetType (\"ns3::ApWifiMac\",\n               \"Ssid\", SsidValue (ssid));\n\n\n  NetDeviceContainer apDevices;\n  apDevices = wifi.Install (phy, mac, wifiGateway);\n\n</code></pre>\n\n<p>We  set up the simulation such that the users, gateway and the smart devices communicate over the 2.4 GHz wi-fi networks. To this goal, we first set up \u2018NodeContainer\u2019 to separately hold the nodes for  the users, gateway and the smart devices. Then, we define a wireless channel and its properties.<br>\n<code>YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();</code><br>\n<code>YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();</code><br>\n<code>phy.SetChannel (channel.Create ());</code><br>\nThen we define <code>WifiHelper</code> and <code>WifiMacHelpers</code> necessary for defining the actual wifi hardware  . Now, we can set up the <code>NetDeviceContainer</code>s  corresponding to the different nodes. Note that the gateway node is set up as a wifi Access point and the remaining are set up as wifi devices.</p>\n<pre><code>\n  // defining Mobility\n  MobilityHelper mobility;\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (-10.0),\n                                 \"MinY\", DoubleValue (-10.0),\n                                 \"DeltaX\", DoubleValue (5.0),\n                                 \"DeltaY\", DoubleValue (5.0),\n                                 \"GridWidth\", UintegerValue (5),\n                                 \"LayoutType\", StringValue (\"RowFirst\"));  \n  mobility.SetMobilityModel (\"ns3::RandomDirection2dMobilityModel\",\n                                 \"Bounds\", RectangleValue (Rectangle (-150, 150, -150, 150)),                                 \"Speed\", StringValue (\"ns3::ConstantRandomVariable[Constant=3]\"),\n                                 \"Pause\", StringValue (\"ns3::ConstantRandomVariable[Constant=0.4]\"));\n  mobility.Install (wifiUserNodes); \n  Ptr&lt;ListPositionAllocator&gt; subnetAlloc =   CreateObject&lt;ListPositionAllocator&gt; ();\n  subnetAlloc-&gt;Add (Vector (0.0, 0.0, 0.0));   //for gateway\n  for (uint32_t j = 0; j &lt; wifiDeviceNodes.GetN (); ++j){\n    double  theta = (j)*360/wifiDeviceNodes.GetN();\n    uint32_t  r =((double)rand() / (RAND_MAX))*80 +20;\n    subnetAlloc-&gt;Add (Vector (sin(theta)*r, cos(theta)*r, 0.0));\n    //std::cout &lt;&lt;\"[ \"&lt;&lt;sin(theta)*r&lt;&lt;\",\"&lt;&lt; cos(theta)*r&lt;&lt;\",\"&lt;&lt; theta&lt;&lt;\"]\"&lt;&lt;\"r = \"&lt;&lt;r&lt;&lt;std::endl;\n  }\n  mobility.SetPositionAllocator (subnetAlloc);\n  mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install (wifiGateway);\n  mobility.Install (wifiDeviceNodes);\n</code></pre>\n<p>We do not need to simulate energy requirements of the devices for authentication schemes, thus don\u2019t need to define a  energy model but we need to simulate the specify the position of the different nodes in order to simulate the presence of the virtual network devices. Thus we define the mobility model for the nodes. We define two mobility models:</p>\n<ul>\n<li>a <code>ConstantPositionMobilityModel</code>for the static gateway and smart devices</li>\n<li>and a <code>RandomDirection2dMobilityModel</code> for the users, who can randomly move  in any direction with speeds upto 3m\u2019s and within a 150 m<sup>2</sup> square centered on the origin.</li>\n</ul>\n<p>We also need to define the starting position for the nodes. We utilize the  <code>GridPositionAllocator</code> to set position of the users . But, for the rest we  use a <code>ListPositionAllocator</code>  to  set the gateway at origin and randomly scatter the smartdevices across a  80 m ring with inner radius 20 m and centered on the origin.</p>\n<pre><code>\n  // Installing internet stack\n  InternetStackHelper stack;\n  OlsrHelper olsr;\n  stack.SetRoutingHelper (olsr); \n  stack.Install (wifiUserNodes);\n  stack.Install (wifiDeviceNodes);\n  stack.Install (wifiGateway);\n  // Install Ipv4 addresses\n  Ipv4AddressHelper address;\n  address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer apInterface;\n  apInterface = address.Assign (apDevices);\n  //Ipv4InterfaceContainer userInterfaces;\n  apInterface = address.Assign (UserDevices);\n  //Ipv4InterfaceContainer deviceInterfaces;\n  apInterface = address.Assign (SmartDevices);\n  // crating applications\n  ApplicationContainer serverAppContainer, clientAppContainer;  \n  uint16_t port = 9;  // well-known echo port number\n  Ptr&lt;Node&gt; gateway = wifiGateway.Get (0);\n  UdpServerHelper server(port);\n  serverAppContainer.Add(server.Install (gateway));\ndouble time = 1;\nfor (uint32_t i = 0; i &lt; wifiUserNodes.GetN (); ++i){\n\tPtr&lt;Node&gt; user = wifiUserNodes.Get (i);\n\tfor (uint32_t j = 0; j &lt; wifiDeviceNodes.GetN (); ++j){\n\t\tPtr&lt;Node&gt; device = wifiDeviceNodes.Get (j);\n    if(i==0){\n      serverAppContainer.Add(server.Install (device));\n      //std::cout &lt;&lt;\"device \"&lt;&lt;j&lt;&lt;std::endl;\n    }\n    clientAppContainer = authenticate(clientAppContainer, time , user, gateway , device ); \n    //time = time +.2;   \n    //std::cout &lt;&lt;time&lt;&lt;std::endl;\n\t}\n  serverAppContainer.Add(server.Install (user));\n  //time = time +.1;\n  //std::cout &lt;&lt;\"user \"&lt;&lt;i&lt;&lt;std::endl;\n}\n  serverAppContainer.Start (Seconds (0.0));\n  serverAppContainer.Stop (Seconds (stopTime+1));  \n  //clientAppContainer.Start (Seconds (1.0));   //started induvugualy\n  clientAppContainer.Stop (Seconds (stopTime+1));\n</code></pre>\n<p>Now, we set-up the internet stack for  the <code>NodeContainer</code>s  previously defined. We specify the use of OLSR routing. We also associate a <code>Ipv4InterfaceContainer</code> with the  previously defined<code>NetDeviceContainer</code> to assign them IPV4 addresses.</p>\n<p>Now at last, we can define the applications.  We use UDP server and clients as our applications. Each users, smart devices and  gateway node is modeled with a <code>UDPClient</code> to send the authentication messages and a <code>UdpServer</code> to receive the response.  First we  setup two <code>ApplicationContainer</code>: <code>serverAppContainer</code> and  <code>clientAppContainer</code> to hold all the udp servers and clients at once. Then we describe a prototype  udp server with the help of <code>UdpServerHelper</code>.  A UDP client in NS3 can repeatedly at fixed interval  send a packet of data of predefined size.  We could extended the <code>UdpServer</code> and <code>UdpClient</code> to define our own server and client but since we are not attempting to provide actual authentication or prove its correctness (which must be done separately) , we can merely use equal sized  data packets for our simulation. We create a UDP client to send a single message, for every message.</p>\n<pre><code>ApplicationContainer authenticate(ApplicationContainer appContainer, double time, Ptr&lt;Node&gt; user, Ptr&lt;Node&gt; gateway , Ptr&lt;Node&gt; device ){\n  if (verbose){\n    std::cout&lt;&lt;\"user : \"&lt;&lt; user-&gt;GetObject&lt;Ipv4&gt; ()-&gt;GetAddress (1, 0).GetLocal ();\n    std::cout&lt;&lt;\"    gateway : \"&lt;&lt; gateway-&gt;GetObject&lt;Ipv4&gt; ()-&gt;GetAddress (1, 0).GetLocal ();\n\t  std::cout&lt;&lt;\"    device : \"&lt;&lt; device-&gt;GetObject&lt;Ipv4&gt; ()-&gt;GetAddress (1, 0).GetLocal ()&lt;&lt;std::endl;\n  }\t\n  \tappContainer = sendMessage(appContainer, time, user, device , M1);\n\tappContainer = sendMessage(appContainer, time, gateway, device,  M2); \n\tappContainer = sendMessage(appContainer, time, device, user, M3); \n  return appContainer;\n}\n</code></pre>\n<pre><code>ApplicationContainer sendMessage(ApplicationContainer apps, double time, Ptr&lt;Node&gt;source,Ptr&lt;Node&gt;sink, uint32_t packetSize){\n    Ipv4Address  remoteAddress = sink-&gt;GetObject&lt;Ipv4&gt; ()-&gt;GetAddress (1, 0).GetLocal (); \t  \n  uint16_t port = 9;  // well-known echo port number\n  Time interPacketInterval = Seconds (20.);\n  UdpClientHelper client (remoteAddress, port);\n  client.SetAttribute (\"MaxPackets\", UintegerValue (maxPacketCount));\n  client.SetAttribute (\"Interval\", TimeValue (interPacketInterval));\n  client.SetAttribute (\"PacketSize\", UintegerValue (packetSize));\n  client.SetAttribute (\"StartTime\", TimeValue (Seconds (time)));\n  //std::cout&lt;&lt;time&lt;&lt;\"&gt;&gt;\";\n  apps.Add(client.Install (source));\n  return apps;\n }\n</code></pre>\n<p>The <code>sendMessage()</code>function creates the creates the  individual <code>UdpClients</code> for each messages. The <code>authenticate()</code> function  simulates a single authentication handshake, thus invokes <code>sendMessage()</code> thrice. Consequently,<code>authenticate()</code>need to be separately invoked for distinct each set of <em>&lt;user, gateway , device &gt;</em>. The variable time passed to <code>sendMessage()</code> schedules when each message is to be sent.  If too much congestion is observed in the result, this value can be used to stagger the messages (see commented code). Then we set the start and stop time for all application at once using the <code>serverAppContainer</code> and the <code>clientAppContainer</code>.</p>\n<pre><code>if (verbose){\n  std::cout &lt;&lt;\"servers stops at  \"&lt;&lt;stopTime+1&lt;&lt;std::endl;\n  std::cout &lt;&lt;\"final transmission  scheduled at  \"&lt;&lt;(time-.33)&lt;&lt;std::endl;\n  std::cout &lt;&lt; \"server apps installed till now :\"&lt;&lt;serverAppContainer.GetN ()&lt;&lt; std::endl;\n  std::cout &lt;&lt; \"client apps installed till now :\"&lt;&lt;clientAppContainer.GetN ()&lt;&lt; std::endl;\n}\n  snprintf(saveFilePrefix, 50, \"IOT_%dx%d_\", mobileUserNodes, smartDeviceNodes);\nif (enablePcap){\n\tphy.EnablePcap (stringbuilder(saveFilePrefix,(char*)\"_users\"), UserDevices, 0);\n    phy.EnablePcap (stringbuilder(saveFilePrefix,(char*)\"_devices\"), SmartDevices, 0);\n    phy.EnablePcap (stringbuilder(saveFilePrefix,(char*)\"_gateway\"), apDevices, 0);\n}\nif(enableAnim) {\n  AnimationInterface anim (stringbuilder(saveFilePrefix,(char*)\"-animation.xml\")); // Mandatory\n  for (uint32_t i = 0; i &lt; wifiUserNodes.GetN (); ++i)\n    {\n      anim.UpdateNodeDescription (wifiUserNodes.Get (i), \"MU\"); // Optional\n      anim.UpdateNodeColor (wifiUserNodes.Get (i), 255, 0, 0); // Optional\n    }\n  for (uint32_t i = 0; i &lt; wifiDeviceNodes.GetN (); ++i)\n    {\n      anim.UpdateNodeDescription (wifiDeviceNodes.Get (i), \"SD\"); // Optional\n      anim.UpdateNodeColor (wifiDeviceNodes.Get (i), 255, 255, 0); // Optional\n    }\n  for (uint32_t i = 0; i &lt; wifiGateway.GetN (); ++i)\n    {\n      anim.UpdateNodeDescription (wifiGateway.Get (i), \"Gateway\"); // Optional\n      anim.UpdateNodeColor (wifiGateway.Get (i), 0, 255, 0); // Optional\n    }\n  //anim.EnablePacketMetadata (); // Optional/\n  anim.EnableWifiMacCounters (Seconds (0), Seconds (10)); //Optional\n  anim.EnableWifiPhyCounters (Seconds (0), Seconds (10)); //Optional\n}\n</code></pre>\n<p>The above snippet of code, defines how (if the option is set) pcap files are to be saved and how (if the option is set) a xml file can be generated to be viewed in <a href=\"https://www.nsnam.org/wiki/NetAnim\">NetAnim</a>.</p>\n<pre><code>\n  //Populate routing table\n  Ipv4GlobalRoutingHelper::PopulateRoutingTables ();  \n  // setting up flowMonitor  \n  Ptr&lt;FlowMonitor&gt; flowMonitor;\n  FlowMonitorHelper flowHelper;\n  flowMonitor = flowHelper.InstallAll();\n  // setting up simulator\n  Simulator::Stop (Seconds (stopTime+1));\n  Simulator::Run ();\n  Simulator::Destroy ();\n  flowMonitor-&gt;SerializeToXmlFile(stringbuilder(saveFilePrefix,(char*)\"_flowMonitor.xml\"), false, false);\n</code></pre>\n\n<p>The  <code>flowMonitor</code> is utilized to get the transmitted data form the simulation. NS3 can produce  trace(<em>.tr</em>) files  and <em>.pcap</em> files (as shown above) but using the *.xml* generated through <code>flowMonitor</code> the useful data can be extracted with much less hassle.</p>\n<pre><code>\n  uint32_t bytes_received = 0;\n  for (uint32_t i = 0; i &lt; serverAppContainer.GetN (); ++i){\n    char nodename[30+sizeof(serverAppContainer.GetN ())*8];\n    uint32_t expected = 1;\n    uint32_t totalPacketsThrough = DynamicCast&lt;UdpServer&gt; (serverAppContainer.Get (i))-&gt;GetReceived ();;\n    if (i==0){\n      snprintf(nodename, sizeof(nodename), \"gateway\\t\");\n      expected = M2;//martDeviceNodes * mobileUserNodes;\n      bytes_received += expected;\n    }else if (i&lt;smartDeviceNodes+1){\n      snprintf(nodename, sizeof(nodename), \"smart device %d \", i);\n      expected = mobileUserNodes *M1;\n      bytes_received += expected;\n    }else{\n      snprintf(nodename, sizeof(nodename), \"mobile user %d \", i-smartDeviceNodes);\n      expected = smartDeviceNodes*M3;\n      bytes_received += expected;\n    }     \n    std::cout &lt;&lt;\"Number of bytes received at \"&lt;&lt;nodename&lt;&lt;\"\\t : \" &lt;&lt; totalPacketsThrough &lt;&lt;\" / \"&lt;&lt; expected &lt;&lt; std::endl;\n    //uint32_t lost =  DynamicCast&lt;UdpServer&gt; (serverAppContainer.Get (i))-&gt;GetLost ();\n    //uint32_t window =  DynamicCast&lt;UdpServer&gt; (serverAppContainer.Get (i))-&gt;GetPacketWindowSize ();\n    //std::cout &lt;&lt;\"\\t. Packets lost: \" &lt;&lt; lost &lt;&lt;\"( \"&lt;&lt;window&lt;&lt;\" ) \"&lt;&lt; std::endl;\n  }\n  std::cout &lt;&lt;\"Total bytes received (\"&lt;&lt;mobileUserNodes&lt;&lt;\" , \"&lt;&lt;smartDeviceNodes&lt;&lt;\") : \"&lt;&lt; bytes_received &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n\n<p>The closing bit of code for our NS3 simulation. This is completely optional and merely shows some statistics after simulation completion.</p>\n<h2 id=\"running-the-ns3-simulation\">Running the NS3 simulation</h2>\n<p>We can run the simulation with the following line in the terminal<br>\n<code>./waf --run \"IOT_PUF --MU=10 --SD=20\"</code></p>\n<p>Where <strong>IOT_PUF.cc</strong> is the NS3 simulation code and is saved in the <code>scratch/</code> directory. On successful execution it will generate  <strong>IOT_10_20.xml</strong> file as output.</p>\n<p>We can use a shell script to schedule the sequential run of several simulations with different parameters</p>\n\n<pre><code>./waf --run \"IOT_PUF --MU=5 --SD=20\n./waf --run \"IOT_PUF --MU=10 --SD=20\n./waf --run \"IOT_PUF --MU=15 --SD=20\n\npython xmlParser.py\n</code></pre>\n<h2 id=\"parsing-the-output-xml\">Parsing the output XML</h2>\n<p>We utilize a small python script to extract  information from one or more  output XML files at once.  This script is written to  parse the output of the different scenarios of the same  simulation, at once.</p>\n<pre><code>import xml.etree.ElementTree as ET\nimport pdb; \nimport os\nallfiles \t= os.listdir('.')\nsummary_file = open(\"summary.csv\", \"w\")\nfor i in xrange(len(allfiles)):\n\tif allfiles[i].endswith('flowMonitor.xml'):\n\t\tmaxTime \t\t= 0;\n\t\tminTime \t\t= float('inf');\n\t\ttotalDelay \t\t= 0\n\t\ttotalReceived \t= 0\n\t\tmessageCount\t= 0\n\t\ttr =[]\n\t\ttree \t\t\t= ET.parse(allfiles[i])\n\t\troot \t\t\t= tree.getroot()\n\t\tfor child in root:\n\t\t\tif child.tag == 'FlowStats':\n\t\t\t\tmessageCount = len(child)\n\t\t\t\tfor flow in child:\t\t\t\t\t\n\t\t\t\t\tflowDetails =  flow.attrib\n\t\t\t\t\tsent \t\t= int(flowDetails['timeFirstTxPacket'][1:-4])\n\t\t\t\t\trecv \t\t= int(flowDetails['timeLastRxPacket'][1:-4])\n\t\t\t\t\tif sent &lt; minTime:\n\t\t\t\t\t\tminTime = sent\n\t\t\t\t\tif recv &gt; maxTime:\n\t\t\t\t\t\tmaxTime = recv\n\t\t\t\t\ttotalDelay \t\t= totalDelay + int(flowDetails['delaySum'][1:-4])\n\t\t\t\t\ttotalReceived\t= totalReceived + int(flowDetails['rxBytes'])\n\t\t\t\t\ttr.append(int(flowDetails['rxPackets']))\t\t\n\t\tpdr = round( sum(tr)*1.0/messageCount, 2)  \t\t\t\t#  package deliverry ratio\n\t\tnodeCounts \t\t= str(allfiles[i].replace('IOT_','').replace('__flowMonitor.xml',', ').replace('x',', ') )\n\t\tthroughput \t\t= str( round( totalReceived / ((maxTime - minTime)/ 1000000000.0) ,3) )\t\t# in bytes per second\n\t\tend2endDelay \t= str( round( (totalDelay/1000000000.0) / messageCount ,3) )  \t\t\t\t\t# in miliseconds\n\t\tprint nodeCounts +'messageCount = '+ str(messageCount) +', recvd = '+ str(totalReceived) +', time = '+ str(round(totalDelay/1000000000.0,3) )+ ', throughput =' +  throughput+ ', end2endDelay (sec) = '+ end2endDelay+'\\n'\n\t\toutput =  nodeCounts + ', ' + str(messageCount) +', '+str(totalReceived)+ ', '+ str(round(totalDelay/1000000000.0,3) )+ ', '+str(round((maxTime - minTime)/1000000000.0,3) )+ ', '+ throughput + ', ' + end2endDelay  + ', ' + str(pdr)+\"\\n\"\t\t\n\t\t#print output\t\t\n\t\tsummary_file.write(output)\n</code></pre>\n<p>The script utilizes the <a href=\"https://docs.python.org/2/library/xml.etree.elementtree.html\">ElementTree</a>  module of python to parse one xml  file at a time  to summarize the data into  <strong>summary.csv</strong> file.  Each row in the file corresponds to a scenario of the simulation.</p>\n</div>\n</body>\n\n</html>\n<!--stackedit_data:\neyJoaXN0b3J5IjpbLTk2NjcyNTAzNCwtMzQ1NDQ3ODU0XX0=\n-->\n",
  "examples": []
}