{
  "repo_name": "steinwurf/kodo-ns3-examples",
  "github_url": "https://github.com/steinwurf/kodo-ns3-examples",
  "readme": "Kodo NS3 Examples\n=================\n\nThe kodo-ns3-examples repository demonstrates how to use the Kodo erasure\ncoding library (http://kodo.steinwurf.com) in various ns-3 examples.\n\nns-3 (http://nsnam.org) is a discrete-event network simulator, targeted\nprimarily for research and educational use. ns-3 is licensed under the GNU\nGPLv2 license.\n\nThe kodo-ns3-examples repository: https://github.com/steinwurf/kodo-ns3-examples\n\nIf you have any questions or suggestions about this library, please contact\nus at our developer mailing list (hosted at Google Groups):\n\n* http://groups.google.com/group/steinwurf-dev\n\n**Important:** Before asking any questions, please try to precisely follow the\ninstructions here and read the **guidelines** of our mailing list!\n\nIf you have a technical issue with ns-3 itself, then please ask around on\nthe `ns-3 mailing list <https://groups.google.com/d/forum/ns-3-users>`_.\n\nLicense\n-------\n\nA valid Kodo license is required if you wish to use this project.\nPlease request a license by **filling out the license request** form_.\n\nIf you try to configure without a valid license, then you will get an error!\n\n.. _form: https://www.steinwurf.com/research-license-request\n\nUsing Kodo in an ns-3 example\n-----------------------------\nThe examples in this repository will be installed to the ``examples/kodo``\nsubfolder of your ns-3 folder. We will also build the Kodo static libraries\nwhich will be installed in the same folder together with the required header\nfiles. The examples will be linked with the required static libraries.\n\nGetting Started\n---------------\nAs a first step, you need ns-3 installed on your development machine.\nYou may find lots of information about this on the ns-3 webpage:\n\nhttp://www.nsnam.org/wiki/index.php/Installation\n\nOn Ubuntu/Debian, you need to install the following packages::\n\n  sudo apt-get install g++ python3 git\n\nIn the following, we will clone ns-3 to the ``~/ns-3-dev`` folder and we\nwill clone the kodo-ns3-examples to the ``~/kodo-ns3-examples`` folder.\nYou may use different folders, but the two folders **must be separate**,\ni.e. one cannot be the subfolder of the other.\n\nInstalling ns-3\n---------------\n\nFirst clone the ns-3 repository (we start from the home folder,\nso it will be cloned to ``~/ns-3-dev``)::\n\n  cd ~\n  git clone https://gitlab.com/nsnam/ns-3-dev.git\n\nThis command will download the ns-3 simulator to your computer into\nthe ``ns-3-dev`` folder (this may take a few minutes).\n\nGo to this freshly cloned folder::\n\n  cd ns-3-dev\n\nOur aim is to make the examples compatible with the latest ns-3 revision.\nIf you experience any issues with the latest revision, then you can switch\nto the latest stable release (this step is **optional**)::\n\n  git checkout ns-3.35\n\nConfigure the ns-3 project (it is important to also enable the examples)::\n\n  python3 waf configure --enable-examples\n\nThis will output a whole bunch of information about the enabled modules\nbased on the availability of tools and libraries installed on your computer.\n\nNow we build the ns-3 libraries and examples::\n\n  python3 waf build\n\nInstalling the Kodo examples to ns-3\n------------------------------------\nAfter building ns-3, you can switch to the kodo-ns3-examples repository.\nWe will clone this repository to the ``~/kodo-ns3-examples`` folder::\n\n  cd ~\n  git clone git@github.com:steinwurf/kodo-ns3-examples.git\n\nConfigure this project::\n\n  cd kodo-ns3-examples\n  python3 waf configure\n\nThe ``waf configure`` command ensures that all dependencies are downloaded\n(by default, waf will create a folder called ``bundle_dependencies`` to\nstore these libraries).\n\nNow we build the kodo-rlnc static library and we install the examples and all\nthe required files to the ``~/ns-3-dev/examples/kodo`` folder::\n\n  python3 waf build install --destdir ~/ns-3-dev/examples/kodo\n\nThe ``--destdir`` option is used to specify the target folder (you can change\nthe ``kodo`` subfolder name to something else if you like).\n\nBuilding the Kodo examples in ns-3\n----------------------------------\n\nAfter the install step, you can switch back to your ns-3 folder::\n\n  cd ~/ns-3-dev\n\nYou can follow the normal ns-3 workflow to build our examples. The ns-3 waf\nwill automatically find the new examples in ``~/ns-3-dev/examples/kodo``::\n\n  python3 waf build\n\nWe have the following examples:\n\n* ``kodo-wired-broadcast``: This example demonstrates broadcasting packets\n  with RLNC from a transmitter to N receivers with the same erasure channel.\n\n* ``kodo-wifi-broadcast``: This example demonstrates broadcasting packets\n  with RLNC to N receivers over an IEEE 802.11b WiFi channel.\n\n* ``kodo-recoders``: This example shows the gain of RLNC with recoding\n  in a 2-hop line network consisting of an encoder, N recoders and a decoder\n  with different erasure rates. Recoding can be turned on or off and the\n  erasure rates can be modified by command-line options.\n\nYou can find more details about each example in their respective source files.\nThere you can also check how to change the simulation parameters like\nthe packet-, field- and generation sizes.\n\nYou can run the examples with the usual ns-3 run commands::\n\n  python3 waf --run kodo-wired-broadcast\n  python3 waf --run kodo-wifi-broadcast\n  python3 waf --run kodo-recoders\n\nMost of the examples will print out how the decoding matrix changes with\neach combination packet. You will see if a received packet is linearly\ndependent or not. You will also see when the decoding process is completed\nand how many transmissions were required.\n\nAdding your own simulation\n--------------------------\n\nAt this point, you might want to add your own simulation that uses kodo.\n\nIt is recommended to create a separate folder (e.g.\n``~/ns-3-dev/examples/my-simulation``) for your custom simulation and copy all\nthe necessary files from ``~/ns-3-dev/examples/kodo`` (most importantly the\n``include`` and ``lib`` folders).\n\nIf you copy the wscript file, then please delete or comment out the parts where\nwe call ``bld.create_ns3_program``. We cannot have multiple programs with\nthe same name (e.g. ``kodo-recoders``).\n\nWhen you create a new program, you can start by copying one of the kodo examples.\nIf you have a source file called ``my-simulation.cc``, then you can\ndefine a new program in ``~/ns-3-dev/examples/my-simulation/wscript``.\nlike this::\n\n  obj = bld.create_ns3_program('my-simulation',\n                               ['core', 'applications', 'point-to-point',\n                                'point-to-point-layout', 'internet', 'wifi'])\n  obj.source = 'my-simulation.cc'\n  set_properties(obj)\n\nAfter this change, the ns-3 waf will detect the new example and you will be\nable to run it from the ``~/ns-3-dev`` folder as usual::\n\n  cd ~/ns-3-dev\n  python3 waf --run my-simulation\n\nNow you can expand your custom simulation as you like. If you use additional\nns-3 modules, then you need to add them in the wscript (most likely, you will\nget a build error if you are missing a module).\n\nIf your simulation has multiple source files (.cc files), then you can add\nthese in the wscript like this::\n\n  obj.source = ['my-simulation.cc', 'source2.cc', 'source3.cc']\n\n**Warning:** If you install the kodo ns-3 examples again with this command::\n\n  cd ~/kodo-ns3-examples\n  python3 waf build install --destdir=\"~/ns-3-dev/examples/kodo\"\n\nthen the example source files and the wscript will be overwritten in\nthe ``~/ns-3-dev/examples/kodo`` folder, so it is recommended to create a\nbackup if you modified any of these files.\n",
  "examples": [
    {
      "file_path": "examples/kodo-recoders.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2014 Steinwurf ApS\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n// This example shows how to use the Kodo library for recoding at many\n// intermediate nodes in a network within a ns-3 Recoders topology.\n// Recoding is one of the characteristic features of network coding because it\n// differentiates from end-to-end codes by allowing any intermediate node\n// to recode a coded packet, even if its data set has not been completely\n// decoded yet.\n//\n// In the source code below an encoder transmits coded packets from a block of\n// data to a set of nodes with the same erasure channel\n// (errorRateEncoderRecoders) The recoders which may or may not recode the data\n// according to a boolean value (recodingFlag). Then, recoders transmit its\n// packets to a decoder through another erasure channel\n// (errorRateRecodersDecoder). Coded packets are sent from the recoders until\n// the decoder has received the complete generation. By default, packets are\n// sent using the binary8 field, GF(2^8) with a generation of 3 packets and\n// 1000 (application) bytes per packet. Default error rates are 40% (0.4) for\n// the encoder-recoders hop and 20% (0.2) for the recoders-decoder hop. By\n// default, we set the number of recoders to 2.\n//\n// In general, topology with IP addresses per net device is as follows:\n//! [0]\n//                +-----------------------------------------------+\n//                |             Encoder (Node 0)                  |\n//                |                                               |\n//                | Net Device 1   Net Device 2  ..  Net Device N |\n//                | IP: 10.1.1.1   IP: 10.1.2.1  ..  IP: 10.1.N.1 |\n//                |                                               |\n//                |     +---+         +---+             +---+     |\n//                |     |   |         |   |             |   |     |\n//                +-----+-+-+---------+-+-+-------------+-+-+-----+\n//                        |             |                 |\n//     eE-R  +------------+        eE-R |           eE-R  +-------+\n//           |                          |                         |\n//+--------+-v-+-------+     +--------+-v-+-------+    +--------+-v-+-------+\n//|        |   |       |     |        |   |       |    |        |   |       |\n//|        +-+-+       |     |        +-+-+       |    |        +-+-+       |\n//|    Net Device 1    |     |    Net Device 1    | .. |    Net Device 1    |\n//|    IP: 10.1.1.2    |     |    IP: 10.1.2.2    | .. |    IP: 10.1.N.N    |\n//|                    |     |                    |    |                    |\n//| Recoder 1 (Node 1) |     | Recoder 2 (Node 2) | .. | Recoder N (Node N) |\n//|                    |     |                    |    |                    |\n//|    Net Device 2    |     |    Net Device 2    | .. |    Net Device 2    |\n//|    IP: 10.2.1.1    |     |    IP: 10.2.1.3    | .. |    IP: 10.2.1.2N+1 |\n//|                    |     |                    |    |                    |\n//|        +---+       |     |        +---+       |    |        +---+       |\n//|        |   |       |     |        |   |       |    |        |   |       |\n//+--------+-+-+-------+     +--------+-+-+-------+    +--------+-+-+-------+\n//           |                          |                         |\n//           +-----------+  eR-D        |  eR-D           +-------+  eR-D\n//                       |              |                 |\n//               +-----+-v-+----------+-v-+-------------+-v-+----+\n//               |     |   |          |   |             |   |    |\n//               |     +---+          +---+             +---+    |\n//               |                                               |\n//               |             Decoder (Node N+1)                |\n//               |                                               |\n//               | Net Device 1   Net Device 2  ..  Net Device N |\n//               | IP: 10.2.1.2   IP: 10.2.1.4  ..  IP: 10.2.1.2N|\n//               +-----------------------------------------------+\n//\n//                           N: Number of recoders\n//                           eE-R: errorRateEncoderRecoders\n//                           eR-D: errorRateRecodersDecoder\n//! [1]\n// By using the previous topology and IP addressing, we ensure that packets\n// are properly broadcasted to the recoders and each combination is sent from\n// the respective recoder to the decoder.\n//\n// You can modify any default parameter, by running (for example with a\n// different number of recoders):\n//\n// python waf --run kodo-recoders --command-template=\"%s\n// --recoders=MY_RECODER_COUNT\"\n//! [2]\n\n#include <iostream>\n#include <string>\n#include <vector>\n\n#include <ns3/config-store-module.h>\n#include <ns3/core-module.h>\n#include <ns3/internet-module.h>\n#include <ns3/network-module.h>\n#include <ns3/point-to-point-star.h>\n\n#include \"kodo-recoders.h\"\n#include <kodo/finite_field.hpp>\n//! [3]\nusing namespace ns3;\n\nint main(int argc, char* argv[])\n{\n    uint32_t packetSize = 1000;           // Application bytes per packet\n    double interval = 1.0;                // Time between events\n    uint32_t generationSize = 3;          // RLNC generation size\n    double errorRateEncoderRecoder = 0.4; // Error rate for encoder-recoder link\n    double errorRateRecoderDecoder = 0.2; // Error rate for recoder-decoder link\n    bool recodingFlag = true;             // Flag to control recoding\n    uint32_t recoders = 2;                // Number of recoders\n    std::string field = \"binary\";         // Finite field used\n    double transmitProbability = 0.5; // Transmit probability for the recoders\n\n    // Create a map for the field values\n    std::map<std::string, kodo::finite_field> fieldMap;\n    fieldMap[\"binary\"] = kodo::finite_field::binary;\n    fieldMap[\"binary4\"] = kodo::finite_field::binary4;\n    fieldMap[\"binary8\"] = kodo::finite_field::binary8;\n    fieldMap[\"binary16\"] = kodo::finite_field::binary16;\n\n    Time interPacketInterval = Seconds(interval);\n\n    CommandLine cmd;\n\n    cmd.AddValue(\"packetSize\", \"Size of application packet sent\", packetSize);\n    cmd.AddValue(\"interval\", \"Interval (seconds) between packets\", interval);\n    cmd.AddValue(\"generationSize\", \"Set the generation size to use\",\n                 generationSize);\n    cmd.AddValue(\"errorRateEncoderRecoder\",\n                 \"Packet erasure rate for the encoder-recoder link\",\n                 errorRateEncoderRecoder);\n    cmd.AddValue(\"errorRateRecoderDecoder\",\n                 \"Packet erasure rate for the recoder-decoder link\",\n                 errorRateRecoderDecoder);\n    cmd.AddValue(\"recodingFlag\", \"Enable packet recoding\", recodingFlag);\n    cmd.AddValue(\"recoders\", \"Amount of recoders\", recoders);\n    cmd.AddValue(\"field\", \"Finite field used\", field);\n    cmd.AddValue(\"transmitProbability\", \"Transmit probability from recoder\",\n                 transmitProbability);\n\n    cmd.Parse(argc, argv);\n\n    // Use the binary8 field in case of errors\n    if (fieldMap.find(field) == fieldMap.end())\n    {\n        field = \"binary8\";\n    }\n\n    Time::SetResolution(Time::NS);\n\n    //! [4]\n    // We group the nodes in different sets because\n    // we want many net devices per node. For the broadcast\n    // topology we create a subnet and for the recoders to\n    // the decoders, we create a secondary one. This in order to\n    // properly set the net devices and socket connections later\n\n    // First we set the basic helper for a single link.\n    PointToPointHelper ptp;\n\n    // Encoder to recoders\n    PointToPointStarHelper toRecoders(recoders, ptp);\n    NodeContainer decoder;\n    decoder.Create(1);\n\n    // Recoders to decoder\n    NetDeviceContainer recodersDecoderDev;\n\n    for (uint32_t n = 0; n < recoders; n++)\n    {\n        recodersDecoderDev.Add(ptp.Install(\n            NodeContainer(toRecoders.GetSpokeNode(n), decoder.Get(0))));\n    }\n\n    // Internet stack for the broadcast topology and decoder\n    InternetStackHelper internet;\n    toRecoders.InstallStack(internet);\n    internet.Install(decoder);\n\n    // Here, we first create a total of N net devices in the encoder\n    // (N = recoders amount) and a net device per recoder\n    // Second, we mirror this procedure in the second hop.\n    // Each net device in the recoder is in a different subnet.\n\n    toRecoders.AssignIpv4Addresses(\n        Ipv4AddressHelper(\"10.1.1.0\", \"255.255.255.0\"));\n\n    // The IP set of the recoders to the decoder is calculated\n    // in order to not collide with the one from the encoder\n    // to the recoders.\n    Ipv4AddressHelper fromRecoders(\"10.2.1.0\", \"255.255.255.0\");\n    fromRecoders.Assign(recodersDecoderDev);\n    //! [5]\n    // Set error model for the net devices\n    Config::SetDefault(\"ns3::RateErrorModel::ErrorUnit\",\n                       StringValue(\"ERROR_UNIT_PACKET\"));\n\n    // Create error rate models per branch\n    std::vector<Ptr<RateErrorModel>> errorEncoderRecoders(recoders);\n    std::vector<Ptr<RateErrorModel>> errorRecodersDecoder(recoders);\n\n    for (uint32_t n = 0; n < recoders; n++)\n    {\n        // Encoder to recoders branches\n        errorEncoderRecoders[n] = CreateObject<RateErrorModel>();\n        errorEncoderRecoders[n]->SetAttribute(\n            \"ErrorRate\", DoubleValue(errorRateEncoderRecoder));\n        toRecoders.GetSpokeNode(n)->GetDevice(0)->SetAttribute(\n            \"ReceiveErrorModel\", PointerValue(errorEncoderRecoders[n]));\n\n        // Recoders to decoder branches\n        errorRecodersDecoder[n] = CreateObject<RateErrorModel>();\n        errorRecodersDecoder[n]->SetAttribute(\n            \"ErrorRate\", DoubleValue(errorRateRecoderDecoder));\n        recodersDecoderDev.Get(2 * n + 1)->SetAttribute(\n            \"ReceiveErrorModel\", PointerValue(errorRecodersDecoder[n]));\n\n        // Activate models\n        errorEncoderRecoders[n]->Enable();\n        errorRecodersDecoder[n]->Enable();\n    }\n\n    // Setting up application sockets for recoder and decoder\n    uint16_t port = 80;\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n\n    Ipv4Address decoderAddress =\n        decoder.Get(0)->GetObject<Ipv4>()->GetAddress(1, 0).GetLocal();\n\n    // Socket connection addresses\n    InetSocketAddress decoderSocketAddress =\n        InetSocketAddress(decoderAddress, port);\n\n    // Socket bind address\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), port);\n\n    // Encoder connections to recoders\n    Ptr<Socket> encoderSocket = Socket::CreateSocket(toRecoders.GetHub(), tid);\n    encoderSocket->SetAllowBroadcast(true);\n    InetSocketAddress recodersSocketAddress =\n        InetSocketAddress(Ipv4Address(\"255.255.255.255\"), port);\n    encoderSocket->Connect(recodersSocketAddress);\n\n    // Recoders connections to decoder\n    std::vector<Ptr<Socket>> recodersSockets;\n\n    for (uint32_t n = 0; n < recoders; n++)\n    {\n        recodersSockets.push_back(\n            Socket::CreateSocket(toRecoders.GetSpokeNode(n), tid));\n        recodersSockets[n]->Bind(local);\n        recodersSockets[n]->Connect(decoderSocketAddress);\n    }\n\n    Recoders multihop(fieldMap[field], recoders, generationSize, packetSize,\n                      recodersSockets, recodingFlag, transmitProbability);\n\n    // Recoders callbacks\n    for (uint32_t n = 0; n < recoders; n++)\n    {\n        recodersSockets[n]->SetRecvCallback(\n            MakeCallback(&Recoders::ReceivePacketRecoder, &multihop));\n    }\n\n    // Decoder\n    Ptr<Socket> decoderSocket = Socket::CreateSocket(decoder.Get(0), tid);\n    decoderSocket->Bind(local);\n    decoderSocket->SetRecvCallback(\n        MakeCallback(&Recoders::ReceivePacketDecoder, &multihop));\n\n    // Turn on global static routing so we can actually be routed across the\n    // hops\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Do pcap tracing on all point-to-point devices on all nodes. File naming\n    // convention is: kodo-recoders-[NODE_NUMBER]-[DEVICE_NUMBER].pcap\n    // ptp.EnablePcapAll (\"kodo-recoders\");\n\n    // Schedule processes\n    // Encoder\n    Simulator::ScheduleWithContext(encoderSocket->GetNode()->GetId(),\n                                   Seconds(1.0), &Recoders::SendPacketEncoder,\n                                   &multihop, encoderSocket,\n                                   interPacketInterval);\n\n    //! [6]\n    // Recoders\n    for (auto recoderSocket : recodersSockets)\n    {\n        Simulator::ScheduleWithContext(recoderSocket->GetNode()->GetId(),\n                                       Seconds(1.5),\n                                       &Recoders::SendPacketRecoder, &multihop,\n                                       recoderSocket, interPacketInterval);\n    }\n    //! [7]\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/kodo-wifi-broadcast.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2014 Steinwurf ApS\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n// This example shows how to use the Kodo library in a ns-3 simulation.\n// The code below is inspired by the wifi-simple-adhoc example\n// (ns-3-dev/examples/wireless/wifi-simple-adhoc.cc).\n//\n// In this scenario, the sender transmits encoded packets from a single\n// block of data to N receivers (N=2 by default).\n// The sender continues until each receiver has all the packets.\n//\n// We define N + 1 nodes using the 802.11b physical layer in adhoc mode.\n// By default, the sender transmits one generation of 5 packets and 1000\n// (application) bytes to the other nodes.\n//\n// The considered topology is the following:\n//! [0]\n//                             +-------------------+\n//                             |  Encoder (Node 0) |\n//                             |                   |\n//                             |    Net Device 1   |\n//                             |    IP: 10.1.1.1   |\n//                             |                   |\n//                             |        +---+      |\n//                             |        |   |      |\n//                             +--------+-+-+------+\n//                                        |\n//                                        |\n//                  +---------------------v--------------------+\n//                  |                                          |\n//                  |  WiFi Standard: 802.11b                  |\n//                  |  Modulation: DSSS 1Mbps at 2.4 GHz       |\n//                  |  WiFi Channel: YansWiFi                  |\n//                  |  Propagation: Random loss                |\n//                  |  Delay: Constant                         |\n//                  |  WiFi MAC: Ad-Hoc                        |\n//                  |  RTS / CTS threshold: 2200 bytes         |\n//                  |  Framentation threshold: 2200 bytes      |\n//                  |  Non-unicast data rate: Same as unicast  |\n//                  |                                          |\n//                  +--------+--------------------------+------+\n//                           |                          |\n//                           |  loss                    |  loss\n//                +--------+-v-+-------+     +--------+-v-+---------+\n//                |        |   |       |     |        |   |         |\n//                |        +---+       |  .. |        +---+         |\n//                |                    |  .. |                      |\n//                | Decoder 1 (Node 1) |     | Decoder N (Node N+1) |\n//                |                    |     |                      |\n//                |    Net Device 1    |     |    Net Device 1      |\n//                |    IP: 10.1.1.2    |     |    IP: 10.1.1.N+1    |\n//                +--------------------+     +----------------------+\n//\n//                              N: number of decoders\n//! [1]\n//\n// The wifi channel uses the RandomPropagationLossModel with a\n// UniformRandomVariable that can be configured with the minLoss/maxLoss\n// parameters. Note that changing the position of the nodes has no effect.\n//\n// When setting a loss value, you need to consider the cutoff point is around\n// the 98 dBm. If the loss gets higher than this threshold, then the packet\n// will be dropped. We use a random variable that covers a range around this\n// threshold to simulate a randomized loss pattern. Note that this value\n// can change in future versions of ns-3.\n//\n// You can lower the effective packet loss rate by decreasing the minLoss\n// parameter of the simulation:\n//\n// python waf --run kodo-wifi-broadcast --command-template=\"%s --minLoss=30\"\n//! [2]\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n\n#include <ns3/config-store-module.h>\n#include <ns3/core-module.h>\n#include <ns3/internet-module.h>\n#include <ns3/mobility-module.h>\n#include <ns3/network-module.h>\n#include <ns3/wifi-module.h>\n\n#include \"kodo-broadcast.h\"\n#include <kodo/finite_field.hpp>\n//! [3]\nusing namespace ns3;\n\nint main(int argc, char* argv[])\n{\n    //! [4]\n    std::string phyMode(\"DsssRate1Mbps\");\n    // The default loss values aim for about 50% random packet loss\n    // A different loss rate can be achieved by moving the lower and upper\n    // limits relative to the detection threshold (T=98).\n    double minLoss = 98.0 - 40.0; // dBm\n    double maxLoss = 98.0 + 40.0; // dBm\n    uint32_t packetSize = 1000;   // bytes\n    double interval = 1.0;        // seconds\n    uint32_t generationSize = 5;\n    uint32_t users = 2;           // Number of users\n    std::string field = \"binary\"; // Finite field used\n\n    // Create a map for the field values\n    std::map<std::string, kodo::finite_field> fieldMap;\n    fieldMap[\"binary\"] = kodo::finite_field::binary;\n    fieldMap[\"binary4\"] = kodo::finite_field::binary4;\n    fieldMap[\"binary8\"] = kodo::finite_field::binary8;\n    fieldMap[\"binary16\"] = kodo::finite_field::binary16;\n\n    CommandLine cmd;\n\n    cmd.AddValue(\"phyMode\", \"Wifi Phy mode\", phyMode);\n    cmd.AddValue(\"minLoss\", \"Lower bound for receiver random loss\", minLoss);\n    cmd.AddValue(\"maxLoss\", \"Higher bound for receiver random loss\", maxLoss);\n    cmd.AddValue(\"packetSize\", \"size of application packet sent\", packetSize);\n    cmd.AddValue(\"interval\", \"interval (seconds) between packets\", interval);\n    cmd.AddValue(\"generationSize\", \"Set the generation size to use\",\n                 generationSize);\n    cmd.AddValue(\"users\", \"Number of receivers\", users);\n    cmd.AddValue(\"field\", \"Finite field used\", field);\n\n    cmd.Parse(argc, argv);\n\n    // Use the binary field in case of errors\n    if (fieldMap.find(field) == fieldMap.end())\n    {\n        field = \"binary\";\n    }\n\n    // Convert to time object\n    Time interPacketInterval = Seconds(interval);\n    //! [5]\n    // disable fragmentation for frames below 2200 bytes\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::FragmentationThreshold\",\n                       StringValue(\"2200\"));\n\n    // turn off RTS/CTS for frames below 2200 bytes\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\",\n                       StringValue(\"2200\"));\n\n    // Fix non-unicast data rate to be the same as that of unicast\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\",\n                       StringValue(phyMode));\n    //! [6]\n    // Source and destination\n    NodeContainer nodes;\n    nodes.Create(1 + users); // Sender + receivers\n\n    // The below set of helpers will help us to put together the wifi NICs\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b); // OFDM at 2.4 GHz\n\n    // The default error rate model is ns3::NistErrorRateModel\n    YansWifiPhyHelper wifiPhy;\n\n    // ns-3 supports RadioTap and Prism tracing extensions for 802.11g\n    wifiPhy.SetPcapDataLinkType(YansWifiPhyHelper::DLT_IEEE802_11_RADIO);\n\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n\n    // When using the RandomPropagationLossModel, the signal strength does not\n    // depend on the distance between the two nodes\n    Ptr<UniformRandomVariable> random = CreateObject<UniformRandomVariable>();\n    random->SetAttribute(\"Min\", DoubleValue(minLoss));\n    random->SetAttribute(\"Max\", DoubleValue(maxLoss));\n    wifiChannel.AddPropagationLoss(\"ns3::RandomPropagationLossModel\",\n                                   \"Variable\", PointerValue(random));\n    wifiPhy.SetChannel(wifiChannel.Create());\n    //! [7]\n    // Disable rate control\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\", \"DataMode\",\n                                 StringValue(phyMode), \"ControlMode\",\n                                 StringValue(phyMode));\n\n    // Set WiFi Mac type to adhoc mode\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    // Create the net devices\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n    //! [8]\n    // Note that the positions are not relevant for the received signal\n    // strength. However, they are required for the YansWiFiChannelHelper\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc =\n        CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0)); // Source node\n\n    for (uint32_t n = 1; n <= users; n++)\n    {\n        positionAlloc->Add(Vector(5.0, 5.0 * n, 0.0));\n    }\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n    //! [9]\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    ipv4.Assign(devices);\n    //! [10]\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n\n    // Transmitter socket\n    Ptr<Socket> source = Socket::CreateSocket(nodes.Get(0), tid);\n\n    // Receiver sockets\n    std::vector<Ptr<Socket>> sinks(users);\n\n    for (uint32_t n = 0; n < users; n++)\n    {\n        sinks[n] = Socket::CreateSocket(nodes.Get(1 + n), tid);\n    }\n    //! [11]\n    // Creates the Broadcast helper for this broadcast topology\n    Broadcast wifiBroadcast(fieldMap[field], users, generationSize, packetSize,\n                            source, sinks);\n    //! [12]\n    // Transmitter socket connections. Set transmitter for broadcasting\n    uint16_t port = 80;\n    InetSocketAddress remote =\n        InetSocketAddress(Ipv4Address(\"255.255.255.255\"), port);\n    source->SetAllowBroadcast(true);\n    source->Connect(remote);\n\n    // Receiver socket connections\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), port);\n    for (const auto sink : sinks)\n    {\n        sink->Bind(local);\n        sink->SetRecvCallback(\n            MakeCallback(&Broadcast::ReceivePacket, &wifiBroadcast));\n    }\n\n    // Turn on global static routing so we can be routed across the network\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n    //! [13]\n    // Pcap tracing\n    // wifiPhy.EnablePcap (\"kodo-wifi-broadcast\", devices);\n\n    Simulator::ScheduleWithContext(source->GetNode()->GetId(), Seconds(1.0),\n                                   &Broadcast::SendPacket, &wifiBroadcast,\n                                   source, interPacketInterval);\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n    //! [14]\n}\n"
    },
    {
      "file_path": "examples/kodo-wired-broadcast.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2014 Steinwurf ApS\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n// This example shows how to use the Kodo library in a broadcast rlnc scenario\n// within a ns-3 simulation. The code below is inspired in the\n// kodo-wifi-broadcast example, which can be found in the ns-3-dev repository.\n//\n// In this example, the sender transmits encoded packets from a block of\n// data to N receivers with the same packet erasure rate (errorRate).\n// The sender continues until all receivers have decoded all packets. By\n// default, the packets are sent using the binary field, GF(2) with a\n// generation of 5 packets and 1000 (application) bytes and an erasure rate\n// of 30% (0.3) for all the nodes. Here we have set the number of\n// receivers to 2 by default but it can changed.\n//\n// The considered topology is the following:\n//! [0]\n//                  +-----------------------------------------------+\n//                  |             Encoder (Node 0)                  |\n//                  |                                               |\n//                  | Net Device 1   Net Device 2  ..  Net Device N |\n//                  | IP: 10.1.1.1   IP: 10.1.2.1  ..  IP: 10.1.N.1 |\n//                  |                                               |\n//                  |     +---+         +---+             +---+     |\n//                  |     |   |         |   |             |   |     |\n//                  +-----+-+-+---------+-+-+-------------+-+-+-----+\n//                          |             |                 |\n//                          |             |                 |\n//          e  +------------+          e  |                 + ------+  e\n//             |                          |                         |\n//  +--------+-v-+-------+     +--------+-v-+-------+    +--------+-v-+-------+\n//  |        |   |       |     |        |   |       |    |        |   |       |\n//  |        +---+       |     |        +---+       |    |        +---+       |\n//  |                    |     |                    |    |                    |\n//  | Decoder 1 (Node 1) |     | Decoder 2 (Node 2) | .. | Decoder N (Node N) |\n//  |                    |     |                    |    |                    |\n//  |    Net Device 1    |     |    Net Device 1    | .. |    Net Device 1    |\n//  |    IP: 10.1.1.2    |     |    IP: 10.1.2.2    | .. |    IP: 10.1.N.N    |\n//  +--------------------+     +--------------------+    +--------------------+\n//\n//          N: number of decoders              e: errorRate\n//! [1]\n// By using the previous topology and IP addressing, we ensure that packets\n// are properly broadcasted within the network\n//\n// You can modify any default parameter, by running (for example with a\n// different error rate):\n//\n// python waf --run kodo-wired-broadcast --command-template=\"%s\n// --errorRate=MY_ERROR_RATE\"\n//\n// The parameters that can be modified are: generationSize, packetSize, ns-3\n// simulation interval, errorRate in the devices and total number of users.\n\n#include <iostream>\n#include <string>\n#include <vector>\n\n#include <ns3/config-store-module.h>\n#include <ns3/core-module.h>\n#include <ns3/internet-module.h>\n#include <ns3/network-module.h>\n#include <ns3/point-to-point-star.h>\n\n#include \"kodo-broadcast.h\"\n#include <kodo/finite_field.hpp>\n\nusing namespace ns3;\n\nint main(int argc, char* argv[])\n{\n    // Default values\n    uint32_t packetSize = 1000;   // Application bytes per packet\n    double interval = 1.0;        // Time between events\n    uint32_t generationSize = 5;  // RLNC generation size\n    double errorRate = 0.3;       // Error rate for all the links\n    uint32_t users = 2;           // Number of users\n    std::string field = \"binary\"; // Finite field used\n\n    // Create a map for the field values\n    std::map<std::string, kodo::finite_field> fieldMap;\n    fieldMap[\"binary\"] = kodo::finite_field::binary;\n    fieldMap[\"binary4\"] = kodo::finite_field::binary4;\n    fieldMap[\"binary8\"] = kodo::finite_field::binary8;\n    fieldMap[\"binary16\"] = kodo::finite_field::binary16;\n\n    Time interPacketInterval = Seconds(interval);\n\n    CommandLine cmd;\n\n    cmd.AddValue(\"packetSize\", \"Size of application packet sent\", packetSize);\n    cmd.AddValue(\"interval\", \"Interval (seconds) between packets\", interval);\n    cmd.AddValue(\"generationSize\", \"Set the generation size to use\",\n                 generationSize);\n    cmd.AddValue(\"errorRate\", \"Packet erasure rate for the links\", errorRate);\n    cmd.AddValue(\"users\", \"Number of receivers\", users);\n    cmd.AddValue(\"field\", \"Finite field used\", field);\n\n    cmd.Parse(argc, argv);\n\n    // Use the binary field in case of errors\n    if (fieldMap.find(field) == fieldMap.end())\n    {\n        field = \"binary\";\n    }\n\n    Time::SetResolution(Time::NS);\n    //! [2]\n    // Set the basic helper for a single link\n    PointToPointHelper pointToPoint;\n\n    // N receivers against a centralized hub.\n    PointToPointStarHelper star(users, pointToPoint);\n\n    // Set error model for the net devices\n    Config::SetDefault(\"ns3::RateErrorModel::ErrorUnit\",\n                       StringValue(\"ERROR_UNIT_PACKET\"));\n\n    std::vector<Ptr<RateErrorModel>> errorModel(users,\n                                                CreateObject<RateErrorModel>());\n\n    for (uint32_t n = 0; n < users; n++)\n    {\n        errorModel[n]->SetAttribute(\"ErrorRate\", DoubleValue(errorRate));\n        star.GetSpokeNode(n)->GetDevice(0)->SetAttribute(\n            \"ReceiveErrorModel\", PointerValue(errorModel[n]));\n        errorModel[n]->Enable();\n    }\n\n    // Setting IP protocol stack\n    InternetStackHelper internet;\n    star.InstallStack(internet);\n\n    // Set IP addresses\n    star.AssignIpv4Addresses(Ipv4AddressHelper(\"10.1.1.0\", \"255.255.255.0\"));\n    //! [3]\n    // Setting up application socket parameters for transmitter and\n    // receiver sockets\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n\n    // Transmitter socket\n    Ptr<Socket> source = Socket::CreateSocket(star.GetHub(), tid);\n\n    // Transmitter socket connections. Set transmitter for broadcasting\n    uint16_t port = 80;\n    InetSocketAddress remote =\n        InetSocketAddress(Ipv4Address(\"255.255.255.255\"), port);\n    source->SetAllowBroadcast(true);\n    source->Connect(remote);\n\n    // Receiver sockets\n    std::vector<Ptr<Socket>> sinks(users);\n\n    for (uint32_t n = 0; n < users; n++)\n    {\n        sinks[n] = Socket::CreateSocket(star.GetSpokeNode(n), tid);\n    }\n\n    // Check for finite field employed and\n    // Creates the Broadcast helper for this broadcast topology\n\n    Broadcast wiredBroadcast(fieldMap[field], users, generationSize, packetSize,\n                             source, sinks);\n\n    // Receiver socket connections\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), port);\n\n    for (const auto sink : sinks)\n    {\n        sink->Bind(local);\n        sink->SetRecvCallback(\n            MakeCallback(&Broadcast::ReceivePacket, &wiredBroadcast));\n    }\n\n    // Turn on global static routing so we can be routed across the network\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Do pcap tracing on all point-to-point devices on all nodes\n    // pointToPoint.EnablePcapAll (\"kodo-wired-broadcast\");\n\n    Simulator::ScheduleWithContext(source->GetNode()->GetId(), Seconds(1.0),\n                                   &Broadcast::SendPacket, &wiredBroadcast,\n                                   source, interPacketInterval);\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}\n"
    }
  ]
}