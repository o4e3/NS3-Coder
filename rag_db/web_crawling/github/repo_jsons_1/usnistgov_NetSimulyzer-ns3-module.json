{
  "repo_name": "usnistgov/NetSimulyzer-ns3-module",
  "github_url": "https://github.com/usnistgov/NetSimulyzer-ns3-module",
  "readme": "# NetSimulyzer ns-3 Module\nA flexible 3D visualizer for displaying, debugging, presenting, and understanding *ns-3* scenarios.\n\n![Application Screenshot](doc/source/_static/application-windows.png)\n\n\n# Table of Contents\n\n* [About](#about)\n* [Requirements](#requirements)\n* [Installation](#installation)\n    * [Clone (Recommended)](#clone-recommended)\n    * [Download ZIP](#download-zip)\n    * [Connecting the Module Quickly](#connecting-the-module-quickly)\n    * [Connecting the Module Safely](#connecting-the-module-safely)\n        * [Waf (Linking)](#waf-linking)\n        * [Code](#code)\n  * [Updating](#updating)\n    * [Clone](#clone)\n    * [ZIP](#zip)\n* [Documentation](#documentation)\n  * [Building the Documentation](#building-the-documentation)\n* [Configuration Options](#configuration-options)\n* [Running the Examples](#running-the-examples)\n  * [Application State Trace Example](#application-state-trace-example)\n  * [Lena Radio Link Failure](#lena-radio-link-failure)\n  * [Mobility Buildings Example](#mobility-buildings-example)\n  * [WiFi Bianchi](#wifi-bianchi)\n  * [Outdoor Random Walk](#outdoor-random-walk)\n* [Feature Overview](#feature-overview)\n  * [Showing Nodes](#showing-nodes)\n  * [Showing Buildings](#showing-buildings)\n  * [Decorations](#decorations)\n  * [Areas](#areas)\n  * [Log Streams](#log-streams)\n  * [Series](#series)\n\n\n# About\nThis is the [ns-3](https://www.nsnam.org/) companion module the\n[NetSimulyzer](https://github.com/usnistgov/NetSimulyzer).\nLink this module & run your scenario to see it in 3D.\n\n# Requirements\n* A C++ 17 compliant compiler\n    * Minimum supported compilers:\n        * GCC 10.5.0\n        * Clang 12.0.0\n\n# Installation\n## Clone (Recommended)\nClone the project into a directory called `netsimulyzer` in\nthe `contrib` directory of a supported version of ns-3\n\n1) `cd` into the `contrib` directory of `ns-3`\n\n```shell\ncd contrib/\n```\n\n2) Clone the project from one of the below URLs\n```shell\n# Pick one of the below\n# HTTPS (Choose this one if you're uncertain)\ngit clone https://github.com/usnistgov/NetSimulyzer-ns3-module netsimulyzer\n\n# SSH\ngit clone git@github.com:usnistgov/NetSimulyzer-ns3-module.git netsimulyzer\n```\n\n3) (Re)configure & (Re)build `ns-3`\nIf you're using a version of ns-3 without CMake, replace `./ns3 ` with `./waf`\n```shell\n# --enable-examples is optional, see `Running the Examples`\n# for how to run them\n./ns3 configure --enable-examples\n./ns3\n```\n\n## Download ZIP\nIf, for whatever reason, `git` is not available, download the\nproject & unzip it into the `contrib` directory of `ns-3`.\n\nNote that updates will have to be performed manually using this method\n\n1) Download the ZIP of the project from the url below:\n\nhttps://github.com/usnistgov/NetSimulyzer-ns3-module/archive/master.zip\n\n2) Unzip the file into the `ns-3` `contrib/` directory\n```shell\nunzip NetSimulyzer-ns3-module-master.zip\n```\n\n3) Rename the resulting directory to `netsimulyzer`, as ns-3 will not accept a module named differently\nthan its directory.\n```shell\nmv NetSimulyzer-ns3-module-master netsimulyzer\n```\n\n## Connecting the Module Quickly\nIf you are linking your module/program to the `netsimulyzer` module add the following to your `CMakeLists.txt`(CMake)\nor `wscript`(Waf)\n\n### CMake\nFor CMake, add the NetSimulyzer's target `${libnetsimulyzer}` to your `libraries_to_link` list\n```cmake\n# Example\nbuild_lib_example(\n  NAME your-example-name\n  SOURCE_FILES example.cc\n  LIBRARIES_TO_LINK\n    ${libnetsimulyzer}\n    # ...\n)\n\n# Module\nbuild_lib(\n  LIBNAME your-module-name\n  SOURCE_FILES\n    # ...\n  HEADER_FILES\n    # ...\n  LIBRARIES_TO_LINK\n    ${libnetsimulyzer}\n    # ...\n)\n```\n\n### waf (Legacy)\nFor waf, add the NetSimulyzer's module name `netsimulyzer` to the dependency list\n```python\n# Program\nobj = bld.create_ns3_program('program-name', ['netsimulyzer', '''...'''])\n\n\n# Module\nmodule = bld.create_ns3_module('module-name', ['netsimulyzer', '''...'''])\n```\n\nYou may now include & use the `netsimulyzer` module in code:\n```cpp\n#include <ns3/netsimulyzer-module.h>\n//...\n\nint main ()\n{\n    // ...\n    auto orchestrator = CreateObject<netsimulyzer::Orchestrator> (\"example.json\");\n    // ...\n}\n```\n\n## Connecting the Module Safely\nYou may wish for your module to not have a hard dependency on the `netsimulyzer` module.\nThe following steps will allow you to link the module & still allow your code to build &\nrun without the module being present.\n\n### Build System\n\n#### CMake\nCheck for the NetSimulyzer in the `ns3-all-enabled-modules` list to confirm\nif the module is present.\n\nNote: if the module linking to the NetSimulyzer module is in the `src/` directory,\nthen you'll need to add the `HAS_NETSIMULYZER` C++ define\nyourself when you check for the presence of the module.\nSee the N.B. comment in the example below\n\n```cmake\n# Create a list of your required modules to link\n# 'core' & 'mobility' are just examples here\nset(libraries_to_link \"${libcore};${libmobility}\")\n\nif(HAS_NETSIMULYZER)\n    # If it's there, then it's safe to add to the library list\n    list(APPEND libraries_to_link ${libnetsimulyzer})\n\n   # N.B if the module you're linking to is in the `src/` directory\n   # of ns-3, then (at least for now), you must also add the C++ define\n   # yourself, like this.\n   #\n   # There's no harm in repeated definitions of the same value, so there's no\n   # need to guard this statement\n   add_definitions(-DHAS_NETSIMULYZER)\nendif()\n\n# Use the `libraries_to_link` list as your dependency list\n\n# Module\nbuild_lib(\n  LIBNAME your-module \n  SOURCE_FILES\n    # ...\n  HEADER_FILES\n    # ...\n  LIBRARIES_TO_LINK\n    ${libraries_to_link}\n)\n\n# Example\nbuild_lib_example(\n  NAME your-scenario\n  SOURCE_FILES scenario.cc\n  LIBRARIES_TO_LINK\n    ${libraries_to_link}\n)\n\n```\n\n#### Waf\nIf you wish for your module/program to be able to build without the `netsimulyzer` module\nyou may check for its existence by reading `bld.env['HAS_NETSIMULYZER']` in your `wscript`. See below:\n\n```python\ndef build(bld):\n    # Create a list of your required modules to link\n    # 'core' & 'mobility' are just examples here\n    linked_modules = ['core', 'mobility']\n\n    # Check if 'HAS_NETSIMULYZER' was defined during configuration\n    if 'HAS_NETSIMULYZER' in bld.env:\n        # If it was defined, then the 'netsimulyzer' is present and we may link it\n        linked_modules.append('netsimulyzer')\n\n    # Be sure to pass your list of `linked_modules` to `create_ns3_program`\n    # or `create_ns3_module`\n    obj = bld.create_ns3_program('application-name', linked_modules)\n```\n\n### Code\nIn addition to the variable in the build environment, the module also defines a C++ macro\nalso named `HAS_NETSIMULYZER`. This macro may be used in C++ code to check for the presence\nof the `netsimulyzer` module.\n\nNote, if you're using CMake and the module is in the `src/` directory, you may have to add\nthis definition yourself (`scratch/` and module examples are fine).\nSee [the CMake build system section for more information](#build-system).\n\nSee the below code sample:\n```cpp\n// Guard the include with the macro\n#ifdef HAS_NETSIMULYZER\n#include <ns3/netsimulyzer-module.h>\n#endif\n\n// ...\n\nint main ()\n{\n    // ...\n\n    // Guard any NetSimulyzer references in code with the macro as well\n#ifdef HAS_NETSIMULYZER\n    auto orchestrator = CreateObject<netsimulyzer::Orchestrator> (\"example.json\");\n    // ...\n#endif\n}\n```\n\n## Updating\n### Clone\nTo update the cloned module, move to the module's root directory and perform a `git pull`\n```shell\n# From the ns-3 root\ncd contrib/netsimulyzer\ngit pull\n```\n\n### ZIP\nTo update a ZIP installation, remove the old module and replace it with the updated one.\n\n```shell\n# From the ns-3 root\ncd contrib\nrm -Rf netsimulyzer\n\n#use this command, or download manually\nwget https://github.com/usnistgov/NetSimulyzer-ns3-module/archive/refs/heads/master.zip -O NetSimulyzer-ns3-module-master.zip\nunzip NetSimulyzer-ns3-module-master.zip\n\n# Make sure the directory in the ns-3 contrib/ directory is\n# named `netsimulyzer`\nmv NetSimulyzer-ns3-module-master netsimulyzer\n\n\n```\n\n# Documentation\nFor prebuilt versions of the documentation, see the\n[Releases page on GitHub](https://github.com/usnistgov/NetSimulyzer-ns3-module/releases).\n\n## Building the Documentation\n[Sphinx](https://www.sphinx-doc.org/en/master/) is required to build the documentation.\n\nTo run Sphinx to build the documentation, cd into the `doc` directory in the module\nand run `make [type]` for the type of documentation you wish to build.\n\n```shell\n# From the ns-3 root directory\ncd contrib/netsimulyzer/doc\n\n# HTML (Several Pages)\nmake html\n\n# HTML (One Page)\nmake singlehtml\n\n# PDF\nmake latexpdf\n\n# To list other options, just run make\nmake\n```\n\nThe built documentation will now be found in `doc/build/[type]`.\n\n# Configuration Options\nTo configure the build, any of the below may be passed to the configuration stage of\nns-3 (`ns3 configure`) with `-- -D[Option1]=ON -D[Option2]=OFF` in the form:\n\n```shell\n./ns3 configure -- -DNETSIMULYZER_PRE_NS3_41_ENUM_VALUE=OFF\n```\n\nAll of the following are optional\n\n* `NETSIMULYZER_PRE_NS3_41_ENUM_VALUE`: Default `OFF`, set to `ON` to force compatibility with\n`EnumValue` with versions of ns-3 before ns-3.41.\n* `NETSIMULYZER_CRASH_HANDLER`: Default `ON`, set to `OFF` to disable the use of NetSimulyzer crash handler\nthat tries to write output in the event of some unusual exit conditions.\n\n# Running the Examples\nListed below are the commands to run the examples provided with the\nmodule:\n\nIf you're using a version of ns-3 without CMake, replace `./ns3 run ` with `./waf --run`.\nNote that some of these may be disabled for older versions of ns-3.\n\n## Application State Trace Example\nExample demonstrating tracing the state of a custom `ns3::Application` using the `StateTransitionSink`.\n```shell\n./ns3 run application-state-trace-example-netsimulyzer\n```\n\n## Lena Radio Link Failure\nAn adaptation of the 'lena-radio-link-failure' example from the `LTE` module with statistics\ntied into the NetSimulyzer\n```shell\n./ns3 run \"lena-radio-link-failure-netsimulyzer --simTime=20 --numberOfEnbs=2 --visual=true\"\n```\n\n## Mobility Buildings Example\nExample demonstrating topology/mobility output to the NetSimulyzer\n```shell\n./ns3 run mobility-buildings-example-netsimulyzer\n```\n\n## Throughput Sink Example\nExample demonstrating how to connect the `netsimulyzer::ThroughputSink`\nto the UDP Echo Client & Server applications to graph throughput.\n```shell\n./ns3 run throughput-sink-example-netsimulyzer\n```\n\n## WiFi Bianchi\nThe WiFi Bianchi example from the `wifi` module with topology, logs, and several statistics.\nNote: this example is disabled for `waf` builds (ns3-35 and prior)\n```shell\n./ns3 run \"wifi-bianchi-netsimulyzer --trials=1 --nMinStas=10 --nMaxStas=10 --visual=true\"\n```\n\n## Outdoor Random Walk\nA simple example from the `buildings` module demonstrating integration into an existing scenario\n```shell\n./ns3 run outdoor-random-walk-example-netsimulyzer\n```\n\n# Feature Overview\n\n## Showing Nodes\nCreate a `NodeConfigurationHelper`, set a model for the Nodes and `Install()`\non the Nodes you wish to be displayed in the application.\n\n```c++\nusing namespace ns3;\n\nnetsimulyzer::NodeConfigurationHelper nodeHelper{orchestrator};\nnodeHelper.Set (\"Model\", netsimulyzer::models::SMARTPHONE_VALUE);\n\n// Shows every Node in the scenario\nfor (auto node = NodeList::Begin (); node != NodeList::End (); node++)\n    nodeHelper.Install (*node);\n\n// Or install on a container\nNodeContainer containerNodes;\ncontainerNodes.Create (2);\nnodeHelper.Install (containerNodes);\n```\n\n### Logical Links Between Nodes\nTo show that two Nodes are 'linked' in some way, create a `LogicalLinkHelper`\nand pass in the two Nodes to link\n\n![Screenshot of two Nodes with a blue line between them](doc/source/_static/logical-link-example.png)\n\n```c++\nusing namespace ns3;\n\nNodeContainer containerNodes;\ncontainerNodes.Create (2);\n\n// Nodes should be configured by the `NodeHelper` before linking\nnetsimulyzer::NodeConfigurationHelper nodeHelper{orchestrator};\nnodeHelper.Set (\"Model\", netsimulyzer::models::SMARTPHONE_VALUE);\nnodeHelper.Install (containerNodes);\n\nnetsimulyzer::LogicalLinkHelper linkHelper{orchestrator};\nlinkHelper.Set (\"Color\", BLUE_VALUE);\n\n// Create a visual link between the Nodes\nauto link = LogicalLinkHelper.Link (containerNodes.Get (0), containerNodes.Get (1));\n\n// Later ...\n\nSimulator::Schedule(/* ... */, [link] () {\n  // Most properties may be changed during the simulation\n  link->SetColor(RED);\n  \n  // To remove the link, call `Deactivate()`\n  link->Deactivate();\n});\n\n\n```\n\n## Showing Buildings\nBuildings have a similar setup to Nodes, only there is no requirement for a model.\n\n```c++\nusing namespace ns3;\n\n// Show every building in the scenario\nnetsimulyzer::BuildingConfigurationHelper buildingHelper{orchestrator};\nfor (auto building = BuildingList::Begin (); building != BuildingList::End (); building++)\n    buildingHelper.Install (*building);\n```\n\n## Decorations\nFor purely visual elements add a `Decoration`. A Decoration\nis similar to a `NodeConfiguration` except its position is set manually.\n\n```c++\nauto decoration = CreateObject<netsimulyzer::Decoration>(orchestrator);\ndecoration->SetAttribute (\"Model\", netsimulyzer::models::CELL_TOWER_POLE_VALUE);\ndecoration->SetAttribute (\"Height\", OptionalValue<double>{250.0});\ndecoration->SetPosition ({5.0, 5.0, 0.0});\n\n```\n\n## Areas\nTo draw attention to certain areas in the topology, it may be defined as an area.\nA `RectangularArea` will draw a rectangle with a border at some defined coordinates\n\n```c++\n  // ns-3 Rectangle from the Mobility Model\n  // 5x5 area around the origin\nRectangle start{-5.0, 5.0, -5.0, 5.0};\nauto startingArea = CreateObject<netsimulyzer::RectangularArea>(orchestrator, start);\n\n// Optional (Default: Black)\nstartingArea->SetAttribute (\"BorderColor\", GREEN_VALUE);\n\n// The Rectangle may be constructed in place as well\nauto finishingArea = CreateObject<netsimulyzer::RectangularArea>(orchestrator, Rectangle{10.0, 7.0, 10.0, 7.0});\nfinishingArea->SetAttribute (\"BorderColor\", RED_VALUE);\n```\n\n## Log Streams\nA `LogStream` may be used to output messages at a given time during the scenario.\nA `LogStream` works similar to a C++ stream (e.g. `std::cout`).\n\n```c++\nauto infoLog = CreateObject<netsimulyzer::LogStream> (orchestrator);\n\n// Optional, but highly recommended you set a name for each stream\ninfoLog->SetAttribute (\"Name\", StringValue (\"Info\"));\n\n// Use like std::cout\n// Note the * at the beginning\n// and '\\n' at the end of the message\n*infoLog << \"Hello \"\n         << \"world!\\n\";\n\nint number = 5;\n*infoLog << \"Logs convert numbers to strings for you\\n\"\n         << \"See: \" << number << '\\n';\n```\n\n## Series\nA series is a collection of points which may be displayed\non a chart in the application.\n\nA series may be added to as the scenario runs and points\nare added at the same time during playback as they were added in\nthe simulation.\n\nThere are several types of series, but the simplest is the `XYSeries` shown below.\nFor the other series types, refer to the documentation.\n\n```c++\nauto xy = CreateObject<netsimulyzer::XYSeries> (orchestrator);\n\n// Optional, but highly recommended\nxy->SetAttribute (\"Name\", StringValue (\"XY Series Example\"));\n\n// Default is `Line` (line graph),\n// there is also `None` (scatter plot)\nxy->SetAttribute (\"Connection\", EnumValue (netsimulyzer::XYSeries::Line));\n\n// Points are added through `Append (x, y)` calls,\n// and may occur at any time\n// before or during the simulation\nxy->Append (1.0, 1.0);\n```\n",
  "examples": [
    {
      "file_path": "examples/application-state-trace-example.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * NIST-developed software is provided by NIST as a public\n * service. You may use, copy and distribute copies of the software in\n * any medium, provided that you keep intact this entire notice. You\n * may improve, modify and create derivative works of the software or\n * any portion of the software, and you may copy and distribute such\n * modifications or works. Modified works should carry a notice\n * stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the\n * National Institute of Standards and Technology as the source of the\n * software.\n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES\n * NO WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY\n * OPERATION OF LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n * WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n * NON-INFRINGEMENT AND DATA ACCURACY. NIST NEITHER REPRESENTS NOR\n * WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE UNINTERRUPTED\n * OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST DOES NOT\n * WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE\n * SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE\n * CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n *\n * You are solely responsible for determining the appropriateness of\n * using and distributing the software and you assume all risks\n * associated with its use, including but not limited to the risks and\n * costs of program errors, compliance with applicable laws, damage to\n * or loss of data, programs or equipment, and the unavailability or\n * interruption of operation. This software is not intended to be used\n * in any situation where a failure could cause risk of injury or\n * damage to property. The software developed by NIST employees is not\n * subject to copyright protection within the United States.\n *\n * Author: Evan Black <evan.black@nist.gov>\n */\n\n#include <ns3/applications-module.h>\n#include <ns3/core-module.h>\n#include <ns3/netsimulyzer-module.h>\n\n#include <string>\n#include <utility>\n\n// Example demonstrating tracing the state of a custom ns3::Application\n// using the StateTransitionSink.\n//\n// Node placement isn't considered here since it does not\n// affect simulation results\n\nusing namespace ns3;\n\n/**\n * Example application for the StateTransitionSink\n */\nclass DummyApplication : public Application\n{\n    const Time stateChangeDelay;\n\n  public:\n    // Keep a list of all possible states\n    // as strings\n    const static std::vector<std::string> States;\n\n    // States may be std::strings or enum/ints\n    typedef void (*StateChangedCallback)(const std::string& newState);\n\n    static TypeId GetTypeId(void)\n    {\n        static TypeId tid =\n            TypeId(\"DummyApplication\")\n                .SetParent<ns3::Application>()\n                .SetGroupName(\"netsimulyzer\")\n                // Provide some 'StateChanged' trace, or connect to the proper callbacks yourself\n                .AddTraceSource(\"StateChanged\",\n                                \"Trace called when the application changes states\",\n                                MakeTraceSourceAccessor(&DummyApplication::m_stateChangedTrace),\n                                \"DummyApplication::StateChangedCallback\");\n\n        return tid;\n    }\n\n    explicit DummyApplication(Time stateChangeDelay) // NOLINT(modernize-pass-by-value)\n        : stateChangeDelay(stateChangeDelay)\n    {\n    }\n\n    void Stop(void)\n    {\n        // \"Stopped\"\n        m_currentState = DummyApplication::States[0];\n        m_stateChangedTrace(m_currentState);\n    }\n\n    void Wait(void)\n    {\n        // \"Waiting\"\n        m_currentState = DummyApplication::States[1];\n        m_stateChangedTrace(m_currentState);\n    }\n\n    void Transmit(void)\n    {\n        // \"Transmitting\"\n        m_currentState = DummyApplication::States[2];\n        m_stateChangedTrace(m_currentState);\n    }\n\n    void ChangeState()\n    {\n        m_stateChangeCount++;\n\n        // Create a pattern between waiting and sending\n        // Toggling between the two\n        if (m_stateChangeCount % 2u)\n            Wait();\n        else\n            Transmit();\n\n        m_eventId = Simulator::Schedule(stateChangeDelay, &DummyApplication::ChangeState, this);\n    }\n\n  private:\n    std::string m_currentState{DummyApplication::States[0]};\n    unsigned int m_stateChangeCount{0};\n    EventId m_eventId;\n    TracedCallback<const std::string&> m_stateChangedTrace;\n\n    void StartApplication(void) override\n    {\n        ChangeState();\n    }\n\n    void StopApplication(void) override\n    {\n        Stop();\n        Simulator::Cancel(m_eventId);\n    }\n};\n\nconst std::vector<std::string> DummyApplication::States{\"Stopped\", \"Waiting\", \"Transmitting\"};\n\nint\nmain(int argc, char* argv[])\n{\n    double duration = 100;\n    std::string outputFileName = \"application-state-trace-example-netsimulyzer.json\";\n\n    CommandLine cmd{__FILE__};\n    cmd.AddValue(\"duration\", \"Duration (in Seconds) of the simulation\", duration);\n    cmd.AddValue(\"outputFileName\",\n                 \"The name of the file to write the NetSimulyzer trace info\",\n                 outputFileName);\n    cmd.Parse(argc, argv);\n\n    NS_ABORT_MSG_IF(duration < 2.0, \"Scenario must be at least two seconds long\");\n\n    auto node = CreateObject<Node>();\n\n    auto exampleApplication = CreateObject<DummyApplication>(Seconds(1.0));\n    exampleApplication->SetStartTime(Seconds(1.0));\n    exampleApplication->SetStopTime(Seconds(duration - 1.0));\n\n    node->AddApplication(exampleApplication);\n\n    auto orchestrator = CreateObject<netsimulyzer::Orchestrator>(outputFileName);\n\n    // No Nodes Move in this scenario\n    orchestrator->SetPollMobility(false);\n\n    netsimulyzer::NodeConfigurationHelper nodeHelper{orchestrator};\n    nodeHelper.Set(\"Model\", netsimulyzer::models::SERVER_VALUE);\n    nodeHelper.Install(node);\n\n    auto exampleStateSink = CreateObject<netsimulyzer::StateTransitionSink>(\n        orchestrator,               // Orchestrator for series & log\n        DummyApplication::States,   // Possible States (with optional IDs)\n        DummyApplication::States[0] // Initial state\n    );\n\n    exampleStateSink->SetAttribute(\"Name\", StringValue(\"Dummy Application\"));\n\n    // Use StateChangedName for string states\n    // & StateChangedId for enum/int states\n    exampleApplication->TraceConnectWithoutContext(\n        \"StateChanged\",\n        MakeCallback(&netsimulyzer::StateTransitionSink::StateChangedName, exampleStateSink));\n\n    Simulator::Stop(Seconds(duration));\n    Simulator::Run();\n    Simulator::Destroy();\n}\n"
    },
    {
      "file_path": "examples/ecdf-sink-example-netsimulyzer.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * NIST-developed software is provided by NIST as a public service. You may use,\n * copy and distribute copies of the software in any medium, provided that you\n * keep intact this entire notice. You may improve,modify and create derivative\n * works of the software or any portion of the software, and you may copy and\n * distribute such modifications or works. Modified works should carry a notice\n * stating that you changed the software and should note the date and nature of\n * any such change. Please explicitly acknowledge the National Institute of\n * Standards and Technology as the source of the software.\n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES NO\n * WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF\n * LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT\n * AND DATA ACCURACY. NIST NEITHER REPRESENTS NOR WARRANTS THAT THE\n * OPERATION OF THE SOFTWARE WILL BE UNINTERRUPTED OR ERROR-FREE, OR THAT\n * ANY DEFECTS WILL BE CORRECTED. NIST DOES NOT WARRANT OR MAKE ANY\n * REPRESENTATIONS REGARDING THE USE OF THE SOFTWARE OR THE RESULTS THEREOF,\n * INCLUDING BUT NOT LIMITED TO THE CORRECTNESS, ACCURACY, RELIABILITY,\n * OR USEFULNESS OF THE SOFTWARE.\n *\n * You are solely responsible for determining the appropriateness of using and\n * distributing the software and you assume all risks associated with its use,\n * including but not limited to the risks and costs of program errors,\n * compliance with applicable laws, damage to or loss of data, programs or\n * equipment, and the unavailability or interruption of operation. This\n * software is not intended to be used in any situation where a failure could\n * cause risk of injury or damage to property. The software developed by NIST\n * employees is not subject to copyright protection within the United States.\n *\n * Author: Evan Black <evan.black@nist.gov>\n */\n\n#include <ns3/applications-module.h>\n#include <ns3/core-module.h>\n#include <ns3/internet-module.h>\n#include <ns3/mobility-module.h>\n#include <ns3/netsimulyzer-module.h>\n#include <ns3/network-module.h>\n#include <ns3/point-to-point-module.h>\n\n#include <string>\n\n// Example demonstrating how to plot an\n// Empirical Cumulative Distribution Function (ECDF)\n// of transmitted packet sizes using the `netsimulyzer::EcdfSink`\n// and the `UdpTraceClient`\n//\n//\n//       10.1.1.0\n// n0 -------------- n1\n//    point-to-point\n//\n\nusing namespace ns3;\n\nvoid\nmacTxTrace(Ptr<netsimulyzer::EcdfSink> ecdf, Ptr<const Packet> packet)\n{\n    ecdf->Append(packet->GetSize());\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double duration = 20.0;\n    std::string connectionTypeUser = \"Line\";\n    CommandLine cmd{__FILE__};\n\n    cmd.AddValue(\"duration\", \"Duration (in Seconds) of the simulation\", duration);\n    cmd.AddValue(\"ConnectionType\",\n                 R\"(Type of connection to use for the plot. Possible values: [\"Line\", \"None\"])\",\n                 connectionTypeUser);\n\n    cmd.Parse(argc, argv);\n\n    auto connectionType = netsimulyzer::XYSeries::ConnectionType::Line;\n    if (connectionTypeUser == \"Line\")\n        connectionType = netsimulyzer::XYSeries::ConnectionType::Line;\n    else if (connectionTypeUser == \"None\")\n        connectionType = netsimulyzer::XYSeries::ConnectionType::None;\n    else\n    {\n        NS_ABORT_MSG(\"Unrecognised 'ConnectionType': \" + connectionTypeUser);\n    }\n\n    NS_ABORT_MSG_IF(duration < 1.0, \"Scenario must be at least one second long\");\n\n    // ----- Nodes -----\n    NodeContainer nodes{2u};\n\n    // ----- Mobility (Optional) -----\n    // Slightly separate the two nodes\n    // The positions here are arbitrary\n    auto positions = CreateObject<ListPositionAllocator>();\n    positions->Add(Vector3D{-1.0, 5.0, 0.0});\n    positions->Add(Vector3D{1.0, 5.0, 0.0});\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(positions);\n\n    mobility.Install(nodes);\n\n    // ----- Network -----\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"0ms\"));\n\n    auto netDevices = pointToPoint.Install(nodes);\n\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n\n    auto interfaces = address.Assign(netDevices);\n\n    // ----- Application -----\n\n    // Client\n    auto u = CreateObject<UdpTraceClient>();\n    u->SetStartTime(Seconds(0.5));\n    u->SetStopTime(Seconds(duration - 1.0));\n\n    // The destination does not particularly matter,\n    // as we don't set up anything to receive these packets\n    u->SetRemote(interfaces.GetAddress(1u));\n\n    // Load the default trace\n    u->SetTraceFile(\"\");\n\n    nodes.Get(0u)->AddApplication(u);\n\n    // ---- NetSimulyzer ----\n    auto orchestrator = CreateObject<netsimulyzer::Orchestrator>(\"ecdf-sink-example.json\");\n\n    // Show the two Nodes using the server model\n    netsimulyzer::NodeConfigurationHelper nodeHelper{orchestrator};\n    nodeHelper.Set(\"Model\", netsimulyzer::models::SERVER_VALUE);\n    nodeHelper.Install(nodes);\n\n    auto ecdf = CreateObject<netsimulyzer::EcdfSink>(orchestrator, \"UdpTraceClient Packet Size\");\n    ecdf->SetAttribute(\"Connection\", EnumValue(connectionType));\n    ecdf->GetXAxis()->SetAttribute(\"Name\", StringValue(\"Packet Size (Bytes)\"));\n\n    // ---- Callback ----\n    // The `UdpTraceClient` doesn't offer a 'Tx' trace,\n    // so we get the size from the 'MacTx' one.\n    netDevices.Get(0u)->TraceConnectWithoutContext(\"MacTx\", MakeBoundCallback(&macTxTrace, ecdf));\n\n    Simulator::Stop(Seconds(duration));\n    Simulator::Run();\n    Simulator::Destroy();\n}\n"
    },
    {
      "file_path": "examples/lena-radio-link-failure-netsimulyzer.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2018 Fraunhofer ESK\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Vignesh Babu <ns3-dev@esk.fraunhofer.de>\n * Modified by: NIST // Contributions may not be subject to US copyright.\n */\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <array>\n#include <cstdio>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\n#ifdef HAS_NETSIMULYZER\n#include \"ns3/netsimulyzer-module.h\"\n#endif\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LenaRadioLinkFailureNetSimulyzer\");\n\n// Global values to check the simulation\n// behavior during and after the simulation.\nuint16_t counterN310FirsteNB = 0;\nTime t310StartTimeFirstEnb = Seconds(0);\nuint32_t ByteCounter = 0;\nuint32_t oldByteCounter = 0;\n\n#ifdef HAS_NETSIMULYZER\n// Configuration parameters\nbool enableVisualization = true;\ndouble guiResolution = 20; // refresh time in ms\n\n// Visualizer components\nPtr<netsimulyzer::Orchestrator> orchestrator = nullptr;\nPtr<netsimulyzer::LogStream> applicationLog = nullptr;\nPtr<netsimulyzer::LogStream> ueLog = nullptr;\nPtr<netsimulyzer::LogStream> enbLog = nullptr;\n\n// Helper function to simplify writing to logs\nvoid\nWriteApplicationLog(std::string message)\n{\n    *applicationLog << \"At \" << Simulator::Now().GetSeconds() << \" \" << message;\n}\n\n// Statistics\nPtr<netsimulyzer::ThroughputSink> appRxTraceSeries;\nstd::map<uint32_t, Ptr<netsimulyzer::StateTransitionSink>> rrcStateMachines;\nstd::map<uint32_t, Ptr<netsimulyzer::SeriesCollection>> rsrpCollections;\nstd::map<uint32_t, std::map<uint32_t, Ptr<netsimulyzer::XYSeries>>>\n    rsrpSeries; // maps IMSI to map of CellId to series\n\nconst std::array<netsimulyzer::Color3Value, 3> g_colors{netsimulyzer::RED_VALUE,\n                                                        netsimulyzer::GREEN_VALUE,\n                                                        netsimulyzer::BLUE_VALUE};\n\n// Callback for UE PHY measurements\nvoid\nNotifyReportUeMeasurements(std::string path,\n                           uint16_t rnti,\n                           uint16_t cellId,\n                           double rsrp,\n                           double sinr,\n                           bool serving,\n                           uint8_t ccId)\n{\n    std::string uePath = path.substr(0, path.find(\"/$ns3::LteUeNetDevice\"));\n    Config::MatchContainer match = Config::LookupMatches(uePath);\n    uint64_t imsi = 0;\n    if (match.GetN() != 0)\n    {\n        Ptr<Object> ueNetDevice = match.Get(0);\n        NS_LOG_LOGIC(\"FindImsiFromLteNetDevice: \"\n                     << path << \", \" << ueNetDevice->GetObject<LteUeNetDevice>()->GetImsi());\n        imsi = ueNetDevice->GetObject<LteUeNetDevice>()->GetImsi();\n\n        std::map<uint32_t, std::map<uint32_t, Ptr<netsimulyzer::XYSeries>>>::iterator imsiToCellIt =\n            rsrpSeries.find(imsi);\n        std::map<uint32_t, Ptr<netsimulyzer::XYSeries>>::iterator cellIdToPlotIt;\n        if (imsiToCellIt != rsrpSeries.end())\n        {\n            cellIdToPlotIt = imsiToCellIt->second.find(cellId);\n        }\n        if (imsiToCellIt == rsrpSeries.end())\n        {\n            // Create collection to plot RSRP for cells detected by this IMSI\n            PointerValue xAxis;\n            PointerValue yAxis;\n            Ptr<netsimulyzer::SeriesCollection> rsrpCollection =\n                CreateObject<netsimulyzer::SeriesCollection>(orchestrator);\n            rsrpCollection->SetAttribute(\"Name\", StringValue(\"RSRP\"));\n            rsrpCollection->GetAttribute(\"XAxis\", xAxis);\n            xAxis.Get<netsimulyzer::ValueAxis>()->SetAttribute(\"Name\", StringValue(\"Time (s)\"));\n            rsrpCollection->GetAttribute(\"YAxis\", yAxis);\n            yAxis.Get<netsimulyzer::ValueAxis>()->SetAttribute(\"Name\", StringValue(\"RSRP (dBm)\"));\n            yAxis.Get<netsimulyzer::ValueAxis>()->SetAttribute(\"BoundMode\", StringValue(\"Fixed\"));\n            yAxis.Get<netsimulyzer::ValueAxis>()->SetAttribute(\"Maximum\", DoubleValue(-110));\n            yAxis.Get<netsimulyzer::ValueAxis>()->SetAttribute(\"Minimum\", DoubleValue(-140));\n            rsrpCollections[imsi] = rsrpCollection;\n        }\n        if (imsiToCellIt == rsrpSeries.end() || cellIdToPlotIt == imsiToCellIt->second.end())\n        {\n            // create new XY series to plot RSRP for this cellId\n            std::cout << \"Creating new entry for \" << imsi << \" cellId \" << cellId << std::endl;\n            rsrpSeries[imsi][cellId] = CreateObject<netsimulyzer::XYSeries>(orchestrator);\n            rsrpSeries[imsi][cellId]->SetAttribute(\n                \"Name\",\n                StringValue(\"Cell Id \" + std::to_string(cellId)));\n            rsrpSeries[imsi][cellId]->SetAttribute(\"LabelMode\", StringValue(\"Hidden\"));\n            rsrpSeries[imsi][cellId]->SetAttribute(\"Connection\", StringValue(\"None\"));\n            rsrpSeries[imsi][cellId]->SetAttribute(\"Color\", g_colors[cellId % g_colors.size()]);\n            rsrpCollections[imsi]->Add(rsrpSeries[imsi][cellId]);\n        }\n        // Update data point\n        rsrpSeries[imsi][cellId]->Append(Simulator::Now().GetSeconds(), rsrp);\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Lookup \" << path << \" got no matches\");\n    }\n}\n#endif\n\nvoid\nPrintUePosition(uint64_t imsi)\n{\n    for (NodeList::Iterator it = NodeList::Begin(); it != NodeList::End(); ++it)\n    {\n        Ptr<Node> node = *it;\n        int nDevs = node->GetNDevices();\n        for (int j = 0; j < nDevs; j++)\n        {\n            Ptr<LteUeNetDevice> uedev = node->GetDevice(j)->GetObject<LteUeNetDevice>();\n            if (uedev)\n            {\n                if (imsi == uedev->GetImsi())\n                {\n                    Vector pos = node->GetObject<MobilityModel>()->GetPosition();\n                    std::cout << \"IMSI : \" << uedev->GetImsi() << \" at \" << pos.x << \",\" << pos.y\n                              << std::endl;\n                }\n            }\n        }\n    }\n}\n\nvoid\nNotifyConnectionEstablishedUe(std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" \" << context << \" UE IMSI \" << imsi\n              << \": connected to cell id \" << cellid << \" with RNTI \" << rnti << std::endl;\n\n#ifdef HAS_NETSIMULYZER\n    if (enableVisualization)\n    {\n        *ueLog << Simulator::Now().GetSeconds() << \" \" << context << \" UE IMSI \" << imsi\n               << \": connected to cell id \" << cellid << \" with RNTI \" << rnti;\n    }\n#endif\n}\n\nvoid\nNotifyConnectionEstablishedEnb(std::string context, uint64_t imsi, uint16_t cellId, uint16_t rnti)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" \" << context << \" eNB cell id \" << cellId\n              << \": successful connection of UE with IMSI \" << imsi << \" RNTI \" << rnti\n              << std::endl;\n    // In this example, a UE should experience RLF at least one time in\n    // cell 1. For the case, when there is only one eNB with ideal RRC,\n    // a UE might reconnects to the eNB multiple times due to more than\n    // one RLF. To handle this, we reset the counter here so, even if the UE\n    // connects multiple time to cell 1 we count N310\n    // indication correctly, i.e., for each RLF UE RRC should receive\n    // configured number of N310 indications.\n    if (cellId == 1)\n    {\n        counterN310FirsteNB = 0;\n    }\n\n#ifdef HAS_NETSIMULYZER\n    if (enableVisualization)\n    {\n        *enbLog << Simulator::Now().GetSeconds() << \" \" << context << \" eNB cell id \" << cellId\n                << \": successful connection of UE with IMSI \" << imsi << \" RNTI \" << rnti;\n    }\n#endif\n}\n\n/// Map each of UE RRC states to its string representation.\nstatic const std::string g_ueRrcStateName[LteUeRrc::NUM_STATES] = {\"IDLE_START\",\n                                                                   \"IDLE_CELL_SEARCH\",\n                                                                   \"IDLE_WAIT_MIB_SIB1\",\n                                                                   \"IDLE_WAIT_MIB\",\n                                                                   \"IDLE_WAIT_SIB1\",\n                                                                   \"IDLE_CAMPED_NORMALLY\",\n                                                                   \"IDLE_WAIT_SIB2\",\n                                                                   \"IDLE_RANDOM_ACCESS\",\n                                                                   \"IDLE_CONNECTING\",\n                                                                   \"CONNECTED_NORMALLY\",\n                                                                   \"CONNECTED_HANDOVER\",\n                                                                   \"CONNECTED_PHY_PROBLEM\",\n                                                                   \"CONNECTED_REESTABLISHING\"};\n\n/**\n * \\param s The UE RRC state.\n * \\return The string representation of the given state.\n */\nstatic const std::string&\nToString(LteUeRrc::State s)\n{\n    return g_ueRrcStateName[s];\n}\n\nvoid\nUeStateTransition(uint64_t imsi,\n                  uint16_t cellId,\n                  uint16_t rnti,\n                  LteUeRrc::State oldState,\n                  LteUeRrc::State newState)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" UE with IMSI \" << imsi << \" RNTI \" << rnti\n              << \" connected to cell \" << cellId << \" transitions from \" << ToString(oldState)\n              << \" to \" << ToString(newState) << std::endl;\n#ifdef HAS_NETSIMULYZER\n    if (enableVisualization)\n    {\n        std::map<uint32_t, Ptr<netsimulyzer::StateTransitionSink>>::iterator it =\n            rrcStateMachines.find(imsi);\n        it->second->StateChangedId(newState);\n    }\n#endif\n}\n\nvoid\nEnbRrcTimeout(uint64_t imsi, uint16_t rnti, uint16_t cellId, std::string cause)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" IMSI \" << imsi << \", RNTI \" << rnti\n              << \", Cell id \" << cellId << \", ENB RRC \" << cause << std::endl;\n#ifdef HAS_NETSIMULYZER\n    if (enableVisualization)\n    {\n        *enbLog << Simulator::Now().GetSeconds() << \" IMSI \" << imsi << \", RNTI \" << rnti\n                << \", Cell id \" << cellId << \", ENB RRC \" << cause;\n    }\n#endif\n}\n\nvoid\nNotifyConnectionReleaseAtEnodeB(uint64_t imsi, uint16_t cellId, uint16_t rnti)\n{\n    std::cout << Simulator::Now() << \" IMSI \" << imsi << \", RNTI \" << rnti << \", Cell id \" << cellId\n              << \", UE context destroyed at eNodeB\" << std::endl;\n#ifdef HAS_NETSIMULYZER\n    if (enableVisualization)\n    {\n        *enbLog << Simulator::Now().GetSeconds() << \" IMSI \" << imsi << \", RNTI \" << rnti\n                << \", Cell id \" << cellId << \", UE context destroyed at eNodeB\";\n    }\n#endif\n}\n\nvoid\nPhySyncDetection(uint16_t n310,\n                 uint64_t imsi,\n                 uint16_t rnti,\n                 uint16_t cellId,\n                 std::string type,\n                 uint8_t count)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" IMSI \" << imsi << \", RNTI \" << rnti\n              << \", Cell id \" << cellId << \", \" << type << \", no of sync indications: \" << +count\n              << std::endl;\n\n    if (type == \"Notify out of sync\" && cellId == 1)\n    {\n        ++counterN310FirsteNB;\n        if (counterN310FirsteNB == n310)\n        {\n            t310StartTimeFirstEnb = Simulator::Now();\n        }\n        NS_LOG_DEBUG(\"counterN310FirsteNB = \" << counterN310FirsteNB);\n    }\n}\n\nvoid\nRadioLinkFailure(Time t310, uint64_t imsi, uint16_t cellId, uint16_t rnti)\n{\n    std::cout << Simulator::Now() << \" IMSI \" << imsi << \", RNTI \" << rnti << \", Cell id \" << cellId\n              << \", radio link failure detected\" << std::endl\n              << std::endl;\n\n    PrintUePosition(imsi);\n\n    if (cellId == 1)\n    {\n        NS_ABORT_MSG_IF((Simulator::Now() - t310StartTimeFirstEnb) != t310,\n                        \"T310 timer expired at wrong time\");\n    }\n#ifdef HAS_NETSIMULYZER\n    if (enableVisualization)\n    {\n        *ueLog << Simulator::Now().GetSeconds() << \" IMSI \" << imsi << \", RNTI \" << rnti\n               << \", Cell id \" << cellId << \", radio link failure detected\";\n    }\n#endif\n}\n\nvoid\nNotifyRandomAccessErrorUe(uint64_t imsi, uint16_t cellId, uint16_t rnti)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" IMSI \" << imsi << \", RNTI \" << rnti\n              << \", Cell id \" << cellId << \", UE RRC Random access Failed\" << std::endl;\n#ifdef HAS_NETSIMULYZER\n    if (enableVisualization)\n    {\n        *ueLog << Simulator::Now().GetSeconds() << \" IMSI \" << imsi << \", RNTI \" << rnti\n               << \", Cell id \" << cellId << \", UE RRC Random access Failed\";\n    }\n#endif\n}\n\nvoid\nNotifyConnectionTimeoutUe(uint64_t imsi, uint16_t cellId, uint16_t rnti, uint8_t connEstFailCount)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" IMSI \" << imsi << \", RNTI \" << rnti\n              << \", Cell id \" << cellId << \", T300 expiration counter \"\n              << (uint16_t)connEstFailCount << \", UE RRC Connection timeout\" << std::endl;\n#ifdef HAS_NETSIMULYZER\n    if (enableVisualization)\n    {\n        *ueLog << Simulator::Now().GetSeconds() << \" IMSI \" << imsi << \", RNTI \" << rnti\n               << \", Cell id \" << cellId << \", T300 expiration counter \"\n               << (uint16_t)connEstFailCount << \", UE RRC Connection timeout\";\n    }\n#endif\n}\n\nvoid\nNotifyRaResponseTimeoutUe(uint64_t imsi,\n                          bool contention,\n                          uint8_t preambleTxCounter,\n                          uint8_t maxPreambleTxLimit)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" IMSI \" << imsi << \", Contention flag \"\n              << contention << \", preamble Tx Counter \" << (uint16_t)preambleTxCounter\n              << \", Max Preamble Tx Limit \" << (uint16_t)maxPreambleTxLimit\n              << \", UE RA response timeout\" << std::endl;\n#ifdef HAS_NETSIMULYZER\n    if (enableVisualization)\n    {\n        *ueLog << Simulator::Now().GetSeconds() << \" IMSI \" << imsi << \", Contention flag \"\n               << contention << \", preamble Tx Counter \" << (uint16_t)preambleTxCounter\n               << \", Max Preamble Tx Limit \" << (uint16_t)maxPreambleTxLimit\n               << \", UE RA response timeout\";\n\n        // Write output, since we're about to crash (from `NS_FATAL_ERROR` below)\n        orchestrator->Flush();\n    }\n#endif\n\n    NS_FATAL_ERROR(\"NotifyRaResponseTimeoutUe\");\n}\n\nvoid\nReceivePacket(Ptr<const Packet> packet, const Address&)\n{\n    ByteCounter += packet->GetSize();\n#ifdef HAS_NETSIMULYZER\n    if (enableVisualization)\n    {\n        appRxTraceSeries->AddPacketSize(packet->GetSize());\n    }\n#endif\n}\n\nvoid\nThroughput(bool firstWrite, Time binSize, std::string fileName)\n{\n    std::ofstream output;\n\n    if (firstWrite == true)\n    {\n        output.open(fileName.c_str(), std::ofstream::out);\n        firstWrite = false;\n    }\n    else\n    {\n        output.open(fileName.c_str(), std::ofstream::app);\n    }\n\n    // Instantaneous throughput every 200 ms\n    double throughput = (ByteCounter - oldByteCounter) * 8 / binSize.GetSeconds() / 1024 / 1024;\n    output << Simulator::Now().GetSeconds() << \" \" << throughput << std::endl;\n    oldByteCounter = ByteCounter;\n    Simulator::Schedule(binSize, &Throughput, firstWrite, binSize, fileName);\n}\n\n/**\n * Sample simulation script for radio link failure.\n * By default, only one eNodeB and one UE is considered for verifying\n * radio link failure. The UE is initially in the coverage of\n * eNodeB and a RRC connection gets established.\n * As the UE moves away from the eNodeB, the signal degrades\n * and out-of-sync indications are counted. When the T310 timer\n * expires, radio link is considered to have failed and UE\n * leaves the CONNECTED_NORMALLY state and performs cell\n * selection again.\n *\n * The example can be run as follows:\n *\n * ./waf --run \"lena-radio-link-failure --numberOfEnbs=1 --simTime=25\"\n */\nint\nmain(int argc, char* argv[])\n{\n    // Configurable parameters\n    Time simTime = Seconds(25);\n    uint16_t numberOfEnbs = 1;\n    double interSiteDistance = 1200;\n    uint16_t n311 = 1;\n    uint16_t n310 = 1;\n    Time t310 = Seconds(1);\n    bool useIdealRrc = true;\n    bool enableCtrlErrorModel = true;\n    bool enableDataErrorModel = true;\n    bool enableNsLogs = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"simTime\", \"Total duration of the simulation (in seconds)\", simTime);\n    cmd.AddValue(\"numberOfEnbs\", \"Number of eNBs\", numberOfEnbs);\n    cmd.AddValue(\"n311\", \"Number of in-synch indication\", n311);\n    cmd.AddValue(\"n310\", \"Number of out-of-synch indication\", n310);\n    cmd.AddValue(\"t310\", \"Timer for detecting the Radio link failure (in seconds)\", t310);\n    cmd.AddValue(\"interSiteDistance\", \"Inter-site distance in meter\", interSiteDistance);\n    cmd.AddValue(\"useIdealRrc\", \"Use ideal RRC protocol\", useIdealRrc);\n    cmd.AddValue(\"enableCtrlErrorModel\", \"Enable control error model\", enableCtrlErrorModel);\n    cmd.AddValue(\"enableDataErrorModel\", \"Enable data error model\", enableDataErrorModel);\n    cmd.AddValue(\"enableNsLogs\", \"Enable ns-3 logging (debug builds)\", enableNsLogs);\n#ifdef HAS_NETSIMULYZER\n    cmd.AddValue(\"visual\", \"Generate visualization traces\", enableVisualization);\n#endif\n    cmd.Parse(argc, argv);\n\n    if (enableNsLogs)\n    {\n        LogLevel logLevel =\n            (LogLevel)(LOG_PREFIX_FUNC | LOG_PREFIX_NODE | LOG_PREFIX_TIME | LOG_LEVEL_ALL);\n        LogComponentEnable(\"LteUeRrc\", logLevel);\n        LogComponentEnable(\"LteUeMac\", logLevel);\n        LogComponentEnable(\"LteUePhy\", logLevel);\n\n        LogComponentEnable(\"LteEnbRrc\", logLevel);\n        LogComponentEnable(\"LteEnbMac\", logLevel);\n        LogComponentEnable(\"LteEnbPhy\", logLevel);\n\n        LogComponentEnable(\"LenaRadioLinkFailure\", logLevel);\n    }\n\n    uint16_t numberOfUes = 1;\n    uint16_t numBearersPerUe = 1;\n    double eNodeB_txPower = 43;\n\n    Config::SetDefault(\"ns3::LteHelper::UseIdealRrc\", BooleanValue(useIdealRrc));\n    Config::SetDefault(\"ns3::LteSpectrumPhy::CtrlErrorModelEnabled\",\n                       BooleanValue(enableCtrlErrorModel));\n    Config::SetDefault(\"ns3::LteSpectrumPhy::DataErrorModelEnabled\",\n                       BooleanValue(enableDataErrorModel));\n\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(60 * 1024));\n\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    lteHelper->SetPathlossModelType(TypeId::LookupByName(\"ns3::LogDistancePropagationLossModel\"));\n    lteHelper->SetPathlossModelAttribute(\"Exponent\", DoubleValue(3.9));\n    lteHelper->SetPathlossModelAttribute(\"ReferenceLoss\",\n                                         DoubleValue(38.57)); // ref. loss in dB at 1m for 2.025GHz\n    lteHelper->SetPathlossModelAttribute(\"ReferenceDistance\", DoubleValue(1));\n\n    //----power related (equal for all base stations)----\n    Config::SetDefault(\"ns3::LteEnbPhy::TxPower\", DoubleValue(eNodeB_txPower));\n    Config::SetDefault(\"ns3::LteUePhy::TxPower\", DoubleValue(23));\n    Config::SetDefault(\"ns3::LteUePhy::NoiseFigure\", DoubleValue(7));\n    Config::SetDefault(\"ns3::LteEnbPhy::NoiseFigure\", DoubleValue(2));\n    Config::SetDefault(\"ns3::LteUePhy::EnableUplinkPowerControl\", BooleanValue(true));\n    Config::SetDefault(\"ns3::LteUePowerControl::ClosedLoop\", BooleanValue(true));\n    Config::SetDefault(\"ns3::LteUePowerControl::AccumulationEnabled\", BooleanValue(true));\n\n    //----frequency related----\n    lteHelper->SetEnbDeviceAttribute(\"DlEarfcn\", UintegerValue(100));   // 2120MHz\n    lteHelper->SetEnbDeviceAttribute(\"UlEarfcn\", UintegerValue(18100)); // 1930MHz\n    lteHelper->SetEnbDeviceAttribute(\"DlBandwidth\", UintegerValue(25)); // 5MHz\n    lteHelper->SetEnbDeviceAttribute(\"UlBandwidth\", UintegerValue(25)); // 5MHz\n\n    //----others----\n    lteHelper->SetSchedulerType(\"ns3::PfFfMacScheduler\");\n    Config::SetDefault(\"ns3::LteAmc::AmcModel\", EnumValue(LteAmc::PiroEW2010));\n    Config::SetDefault(\"ns3::LteAmc::Ber\", DoubleValue(0.01));\n    Config::SetDefault(\"ns3::PfFfMacScheduler::HarqEnabled\", BooleanValue(true));\n\n    Config::SetDefault(\"ns3::FfMacScheduler::UlCqiFilter\", EnumValue(FfMacScheduler::SRS_UL_CQI));\n\n    // Radio link failure detection parameters\n    Config::SetDefault(\"ns3::LteUeRrc::N310\", UintegerValue(n310));\n    Config::SetDefault(\"ns3::LteUeRrc::N311\", UintegerValue(n311));\n    Config::SetDefault(\"ns3::LteUeRrc::T310\", TimeValue(t310));\n\n    NS_LOG_INFO(\"Create the internet\");\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    // Create a single RemoteHost0x18ab460\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(1500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.010)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress(1);\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n\n    NS_LOG_INFO(\"Create eNodeB and UE nodes\");\n    NodeContainer enbNodes;\n    NodeContainer ueNodes;\n    enbNodes.Create(numberOfEnbs);\n    ueNodes.Create(numberOfUes);\n\n    NS_LOG_INFO(\"Assign mobility\");\n    Ptr<ListPositionAllocator> positionAllocEnb = CreateObject<ListPositionAllocator>();\n\n    for (uint16_t i = 0; i < numberOfEnbs; i++)\n    {\n        positionAllocEnb->Add(Vector(interSiteDistance * i, 0, 0));\n    }\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(positionAllocEnb);\n    mobility.Install(enbNodes);\n\n    Ptr<ListPositionAllocator> positionAllocUe = CreateObject<ListPositionAllocator>();\n\n    for (int i = 0; i < numberOfUes; i++)\n    {\n        positionAllocUe->Add(Vector(200, 0, 0));\n    }\n\n    mobility.SetPositionAllocator(positionAllocUe);\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(ueNodes);\n\n    for (int i = 0; i < numberOfUes; i++)\n    {\n        ueNodes.Get(i)->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(\n            Vector(30, 0.0, 0.0));\n    }\n\n    NS_LOG_INFO(\"Install LTE Devices in eNB and UEs and fix random number stream\");\n    NetDeviceContainer enbDevs;\n    NetDeviceContainer ueDevs;\n\n    int64_t randomStream = 1;\n\n    enbDevs = lteHelper->InstallEnbDevice(enbNodes);\n    randomStream += lteHelper->AssignStreams(enbDevs, randomStream);\n    ueDevs = lteHelper->InstallUeDevice(ueNodes);\n    randomStream += lteHelper->AssignStreams(ueDevs, randomStream);\n\n    NS_LOG_INFO(\"Install the IP stack on the UEs\");\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpIfaces;\n    ueIpIfaces = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueDevs));\n\n    NS_LOG_INFO(\"Attach a UE to a eNB\");\n    lteHelper->Attach(ueDevs);\n\n    NS_LOG_INFO(\"Install and start applications on UEs and remote host\");\n    uint16_t dlPort = 10000;\n    uint16_t ulPort = 20000;\n\n    DataRateValue dataRateValue = DataRate(\"18.6Mbps\");\n\n    uint64_t bitRate = dataRateValue.Get().GetBitRate();\n\n    uint32_t packetSize = 1024; // bytes\n\n    NS_LOG_DEBUG(\"bit rate \" << bitRate);\n\n    double interPacketInterval = static_cast<double>(packetSize * 8) / bitRate;\n\n    Time udpInterval = Seconds(interPacketInterval);\n\n    NS_LOG_DEBUG(\"UDP will use application interval \" << udpInterval.GetSeconds() << \" sec\");\n\n    for (uint32_t u = 0; u < numberOfUes; ++u)\n    {\n        Ptr<Node> ue = ueNodes.Get(u);\n        // Set the default gateway for the UE\n        Ptr<Ipv4StaticRouting> ueStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(ue->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n\n        for (uint32_t b = 0; b < numBearersPerUe; ++b)\n        {\n            ApplicationContainer ulClientApps;\n            ApplicationContainer ulServerApps;\n            ApplicationContainer dlClientApps;\n            ApplicationContainer dlServerApps;\n\n            ++dlPort;\n            ++ulPort;\n\n            NS_LOG_LOGIC(\"installing UDP DL app for UE \" << u + 1);\n            UdpClientHelper dlClientHelper(ueIpIfaces.GetAddress(u), dlPort);\n            dlClientHelper.SetAttribute(\"Interval\", TimeValue(udpInterval));\n            dlClientHelper.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n            dlClientHelper.SetAttribute(\"MaxPackets\", UintegerValue(1000000));\n            dlClientApps.Add(dlClientHelper.Install(remoteHost));\n\n            PacketSinkHelper dlPacketSinkHelper(\"ns3::UdpSocketFactory\",\n                                                InetSocketAddress(Ipv4Address::GetAny(), dlPort));\n            dlServerApps.Add(dlPacketSinkHelper.Install(ue));\n\n            NS_LOG_LOGIC(\"installing UDP UL app for UE \" << u + 1);\n            UdpClientHelper ulClientHelper(remoteHostAddr, ulPort);\n            ulClientHelper.SetAttribute(\"Interval\", TimeValue(udpInterval));\n            dlClientHelper.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n            ulClientHelper.SetAttribute(\"MaxPackets\", UintegerValue(1000000));\n            ulClientApps.Add(ulClientHelper.Install(ue));\n\n            PacketSinkHelper ulPacketSinkHelper(\"ns3::UdpSocketFactory\",\n                                                InetSocketAddress(Ipv4Address::GetAny(), ulPort));\n            ulServerApps.Add(ulPacketSinkHelper.Install(remoteHost));\n\n            Ptr<EpcTft> tft = Create<EpcTft>();\n            EpcTft::PacketFilter dlpf;\n            dlpf.localPortStart = dlPort;\n            dlpf.localPortEnd = dlPort;\n            tft->Add(dlpf);\n            EpcTft::PacketFilter ulpf;\n            ulpf.remotePortStart = ulPort;\n            ulpf.remotePortEnd = ulPort;\n            tft->Add(ulpf);\n            EpsBearer bearer(EpsBearer::NGBR_IMS);\n            lteHelper->ActivateDedicatedEpsBearer(ueDevs.Get(u), bearer, tft);\n\n            dlServerApps.Start(Seconds(0.27));\n            dlClientApps.Start(Seconds(0.27));\n            ulServerApps.Start(Seconds(0.27));\n            ulClientApps.Start(Seconds(0.27));\n#ifdef HAS_NETSIMULYZER\n            if (enableVisualization)\n            {\n                std::ostringstream oss;\n                oss << \"Client \" << (u + 1) << \" starting\\n\";\n                Simulator::Schedule(Seconds(0.27), &WriteApplicationLog, oss.str());\n            }\n#endif\n        } // end for b\n    }\n    NS_LOG_INFO(\"Enable Lte traces and connect custom trace sinks\");\n\n    lteHelper->EnableTraces();\n    Ptr<RadioBearerStatsCalculator> rlcStats = lteHelper->GetRlcStats();\n    rlcStats->SetAttribute(\"EpochDuration\", TimeValue(Seconds(0.05)));\n    Ptr<RadioBearerStatsCalculator> pdcpStats = lteHelper->GetPdcpStats();\n    pdcpStats->SetAttribute(\"EpochDuration\", TimeValue(Seconds(0.05)));\n\n    Config::Connect(\"/NodeList/*/DeviceList/*/LteEnbRrc/ConnectionEstablished\",\n                    MakeCallback(&NotifyConnectionEstablishedEnb));\n    Config::Connect(\"/NodeList/*/DeviceList/*/LteUeRrc/ConnectionEstablished\",\n                    MakeCallback(&NotifyConnectionEstablishedUe));\n    Config::ConnectWithoutContext(\"/NodeList/*/DeviceList/*/LteUeRrc/StateTransition\",\n                                  MakeCallback(&UeStateTransition));\n    Config::ConnectWithoutContext(\"/NodeList/*/DeviceList/*/LteUeRrc/PhySyncDetection\",\n                                  MakeBoundCallback(&PhySyncDetection, n310));\n    Config::ConnectWithoutContext(\"/NodeList/*/DeviceList/*/LteUeRrc/RadioLinkFailure\",\n                                  MakeBoundCallback(&RadioLinkFailure, t310));\n    Config::ConnectWithoutContext(\"/NodeList/*/DeviceList/*/LteEnbRrc/NotifyConnectionRelease\",\n                                  MakeCallback(&NotifyConnectionReleaseAtEnodeB));\n    Config::ConnectWithoutContext(\"/NodeList/*/DeviceList/*/LteEnbRrc/RrcTimeout\",\n                                  MakeCallback(&EnbRrcTimeout));\n    Config::ConnectWithoutContext(\"/NodeList/*/DeviceList/*/LteUeRrc/RandomAccessError\",\n                                  MakeCallback(&NotifyRandomAccessErrorUe));\n    Config::ConnectWithoutContext(\"/NodeList/*/DeviceList/*/LteUeRrc/ConnectionTimeout\",\n                                  MakeCallback(&NotifyConnectionTimeoutUe));\n    Config::ConnectWithoutContext(\"/NodeList/*/DeviceList/*/$ns3::LteUeNetDevice/\"\n                                  \"ComponentCarrierMapUe/*/LteUeMac/RaResponseTimeout\",\n                                  MakeCallback(&NotifyRaResponseTimeoutUe));\n\n#ifdef HAS_NETSIMULYZER\n    Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::LteUeNetDevice/ComponentCarrierMapUe/*/\"\n                    \"LteUePhy/ReportUeMeasurements\",\n                    MakeCallback(&NotifyReportUeMeasurements));\n#endif\n\n    // Trace sink for the packet sink of UE\n    std::ostringstream oss;\n    oss << \"/NodeList/\" << ueNodes.Get(0)->GetId() << \"/ApplicationList/0/$ns3::PacketSink/Rx\";\n    Config::ConnectWithoutContext(oss.str(), MakeCallback(&ReceivePacket));\n\n    bool firstWrite = true;\n    std::string rrcType = useIdealRrc == 1 ? \"ideal_rrc\" : \"real_rrc\";\n    std::string fileName = \"rlf_dl_thrput_\" + std::to_string(enbNodes.GetN()) + \"_eNB_\" + rrcType;\n    Time binSize = Seconds(0.2);\n    Simulator::Schedule(Seconds(0.47), &Throughput, firstWrite, binSize, fileName);\n\n#ifdef HAS_NETSIMULYZER\n    /* Define graphs to visualize */\n    if (enableVisualization)\n    {\n        NS_LOG_INFO(\"Enabling visualization...\");\n\n        orchestrator = CreateObject<netsimulyzer::Orchestrator>(\"lena-radio-link-failure.json\");\n        orchestrator->SetAttribute(\"MobilityPollInterval\", TimeValue(MilliSeconds(guiResolution)));\n\n        // Configure nodes\n        netsimulyzer::NodeConfigurationHelper nodeConfigHelper(orchestrator);\n        nodeConfigHelper.Set(\"Scale\", DoubleValue(5));\n        for (uint32_t i = 0; i < ueNodes.GetN(); ++i)\n        {\n            nodeConfigHelper.Set(\"Model\", netsimulyzer::models::LAND_DRONE_VALUE);\n            nodeConfigHelper.Set(\"Name\", StringValue(\"UE \" + std::to_string(i)));\n            nodeConfigHelper.Install(ueNodes.Get(i));\n\n            // Add state machine graphs\n            std::vector<netsimulyzer::CategoryAxis::ValuePair> rrcStates;\n            netsimulyzer::CategoryAxis::ValuePair rrcStateValue;\n\n            for (uint32_t j = 0; j < LteUeRrc::NUM_STATES; j++)\n            {\n                rrcStateValue.key = j;\n                rrcStateValue.value = g_ueRrcStateName[j];\n                rrcStates.push_back(rrcStateValue);\n            }\n\n            Ptr<netsimulyzer::StateTransitionSink> rrcStateGraph =\n                CreateObject<netsimulyzer::StateTransitionSink>(orchestrator, rrcStates, 0);\n            rrcStateGraph->SetAttribute(\"Name\",\n                                        StringValue(\"UE \" + std::to_string(i + 1) + \" RRC State\"));\n            rrcStateGraph->SetAttribute(\"LoggingMode\", StringValue(\"None\"));\n            rrcStateMachines.insert(std::pair<uint32_t, Ptr<netsimulyzer::StateTransitionSink>>(\n                ueDevs.Get(i)->GetObject<LteUeNetDevice>()->GetImsi(),\n                rrcStateGraph));\n            PointerValue stateSeries;\n            rrcStateGraph->GetAttribute(\"Series\", stateSeries);\n            stateSeries.Get<netsimulyzer::CategoryValueSeries>()->SetAttribute(\n                \"Color\",\n                netsimulyzer::BLUE_VALUE);\n        }\n\n        // Network\n        for (uint32_t i = 0; i < enbNodes.GetN(); ++i)\n        {\n            nodeConfigHelper.Set(\"Model\", netsimulyzer::models::CELL_TOWER_POLE_VALUE);\n            nodeConfigHelper.Set(\"Name\", StringValue(\"Cell tower \" + std::to_string(i)));\n            nodeConfigHelper.Set(\"Height\", netsimulyzer::OptionalValue<double>(10));\n            nodeConfigHelper.Set(\"Orientation\", Vector3DValue(Vector3D(0, 0, 0)));\n            nodeConfigHelper.Install(enbNodes.Get(i));\n        }\n\n        // Logs\n        applicationLog = CreateObject<netsimulyzer::LogStream>(orchestrator);\n        applicationLog->SetAttribute(\"Name\", StringValue(\"Application log\"));\n        applicationLog->SetAttribute(\n            \"Color\",\n            netsimulyzer::OptionalValue<netsimulyzer::Color3>{netsimulyzer::GREEN});\n\n        ueLog = CreateObject<netsimulyzer::LogStream>(orchestrator);\n        ueLog->SetAttribute(\"Name\", StringValue(\"UE log\"));\n        ueLog->SetAttribute(\"Color\",\n                            netsimulyzer::OptionalValue<netsimulyzer::Color3>{netsimulyzer::BLUE});\n\n        enbLog = CreateObject<netsimulyzer::LogStream>(orchestrator);\n        enbLog->SetAttribute(\"Name\", StringValue(\"eNodeB log\"));\n        enbLog->SetAttribute(\"Color\",\n                             netsimulyzer::OptionalValue<netsimulyzer::Color3>{netsimulyzer::RED});\n\n        // Statistics\n        appRxTraceSeries = CreateObject<netsimulyzer::ThroughputSink>(orchestrator, \"Rx\");\n        appRxTraceSeries->SetAttribute(\"Unit\", StringValue(\"Mb/s\"));\n        appRxTraceSeries->SetAttribute(\"Interval\", TimeValue(Seconds(0.2)));\n        PointerValue rxXySeries;\n        appRxTraceSeries->GetAttribute(\"XYSeries\", rxXySeries);\n        rxXySeries.Get<netsimulyzer::XYSeries>()->SetAttribute(\"LabelMode\", StringValue(\"Hidden\"));\n        rxXySeries.Get<netsimulyzer::XYSeries>()->SetAttribute(\"Color\", netsimulyzer::BLUE_VALUE);\n    }\n#endif\n\n    NS_LOG_INFO(\"Starting simulation...\");\n\n    Simulator::Stop(simTime);\n\n    Simulator::Run();\n\n    NS_ABORT_MSG_IF(counterN310FirsteNB != n310,\n                    \"UE RRC should receive \" << n310\n                                             << \" out-of-sync indications in Cell 1.\"\n                                                \" Total received = \"\n                                             << counterN310FirsteNB);\n\n    Simulator::Destroy();\n\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/mobility-buildings-example.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * NIST-developed software is provided by NIST as a public\n * service. You may use, copy and distribute copies of the software in\n * any medium, provided that you keep intact this entire notice. You\n * may improve, modify and create derivative works of the software or\n * any portion of the software, and you may copy and distribute such\n * modifications or works. Modified works should carry a notice\n * stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the\n * National Institute of Standards and Technology as the source of the\n * software.\n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES\n * NO WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY\n * OPERATION OF LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n * WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n * NON-INFRINGEMENT AND DATA ACCURACY. NIST NEITHER REPRESENTS NOR\n * WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE UNINTERRUPTED\n * OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST DOES NOT\n * WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE\n * SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE\n * CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n *\n * You are solely responsible for determining the appropriateness of\n * using and distributing the software and you assume all risks\n * associated with its use, including but not limited to the risks and\n * costs of program errors, compliance with applicable laws, damage to\n * or loss of data, programs or equipment, and the unavailability or\n * interruption of operation. This software is not intended to be used\n * in any situation where a failure could cause risk of injury or\n * damage to property. The software developed by NIST employees is not\n * subject to copyright protection within the United States.\n *\n * Author: Evan Black <evan.black@nist.gov>\n */\n\n#include <ns3/core-module.h>\n#include <ns3/mobility-module.h>\n#include <ns3/netsimulyzer-module.h>\n#include <ns3/network-module.h>\n\n#include <string>\n\n// Example demonstrating mobility output to the NetSimulyzer\n// * Creates 2 buildings one the top right and the other in bottom left corner\n// * Creates 4 Nodes in 2 separate groups (Phones & Drones)\n// * The Nodes move in a random direction independently\n//     For the duration of the simulation\n//\n// --------------------------\n// |                      22| (Two Floor Building)\n// |                      22|\n// |   ~~~~~~~~~~~~~~~~~~   |\n// |   \\   Possible     \\   |\n// |   \\     Node       \\   |\n// |   \\   Positions    \\   |\n// |   \\                \\   |\n// |   ~~~~~~~~~~~~~~~~~~   |\n// |11                      |\n// |11                      |\n// --------------------------\n// (One Floor Building)\n\nusing namespace ns3;\n\nPtr<netsimulyzer::LogStream> eventLog;\n\nvoid\nCourseChanged(Ptr<const MobilityModel> model)\n{\n    const auto nodeId = model->GetObject<Node>()->GetId();\n    const auto position = model->GetPosition();\n    const auto velocity = model->GetVelocity();\n\n    *eventLog << Simulator::Now().GetMilliSeconds() << \": Node [\" << nodeId\n              << \"] Course Change Position: [\" << position.x << \", \" << position.y << \", \"\n              << position.z << \"] \"\n              << \"Velocity [\" << velocity.x << \", \" << velocity.y << \", \" << velocity.z << \"]\\n\";\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double minNodePosition = -100;\n    double maxNodePosition = 100;\n    // These must remain positive (since the RandomDirection2dMobilityModel only accepts positive\n    // values)\n    double minSpeed = .1;\n    double maxSpeed = 5;\n    double duration = 100;\n    std::string outputFileName = \"netsimulyzer-mobility-buildings-example.json\";\n    std::string phoneModelPath = netsimulyzer::models::SMARTPHONE;\n    std::string droneModelPath = netsimulyzer::models::LAND_DRONE;\n\n    CommandLine cmd;\n    cmd.AddValue(\"minNodePosition\", \"Minimum X/Y position a Node may move to\", minNodePosition);\n    cmd.AddValue(\"maxNodePosition\", \"Maximum X/Y position a Node may move to\", maxNodePosition);\n    cmd.AddValue(\"minSpeed\", \"Minimum X/Y speed a Node may move\", minSpeed);\n    cmd.AddValue(\"maxSpeed\", \"Maximum X/Y speed a Node may move\", maxSpeed);\n    cmd.AddValue(\"outputFileName\",\n                 \"The name of the file to write the NetSimulyzer trace info\",\n                 outputFileName);\n    cmd.AddValue(\"phoneModelPath\",\n                 \"The path to the model file to represent the Phone Nodes\",\n                 phoneModelPath);\n    cmd.AddValue(\"droneModelPath\",\n                 \"The path to the model file to represent the Drone Nodes\",\n                 droneModelPath);\n    cmd.AddValue(\"duration\", \"Duration (in Seconds) of the simulation\", duration);\n    cmd.Parse(argc, argv);\n\n    NS_ABORT_MSG_IF(duration < 1.0, \"Scenario must be at least one second long\");\n\n    // ---- Nodes ----\n    NodeContainer phones;\n    phones.Create(2);\n\n    NodeContainer drones;\n    drones.Create(2);\n\n    auto positionAllocator = CreateObject<RandomBoxPositionAllocator>();\n    auto positionStream = CreateObject<UniformRandomVariable>();\n    positionStream->SetAttribute(\"Min\", DoubleValue(minNodePosition));\n    positionStream->SetAttribute(\"Max\", DoubleValue(maxNodePosition));\n\n    // (Hopefully) start the Nodes at different positions\n    positionAllocator->SetX(positionStream);\n    positionAllocator->SetY(positionStream);\n    positionAllocator->SetAttribute(\"Z\", StringValue(\"ns3::ConstantRandomVariable[Constant=0.0])\"));\n\n    // Show the Nodes moving at different speeds\n    auto velocityStream = CreateObject<UniformRandomVariable>();\n    velocityStream->SetAttribute(\"Min\", DoubleValue(minSpeed));\n    velocityStream->SetAttribute(\"Max\", DoubleValue(maxSpeed));\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\n        \"ns3::RandomDirection2dMobilityModel\",\n        \"Bounds\",\n        RectangleValue({minNodePosition, maxNodePosition, minNodePosition, maxNodePosition}),\n        \"Speed\",\n        PointerValue(velocityStream),\n        \"Pause\",\n        StringValue(\"ns3::ConstantRandomVariable[Constant=1.0]\"));\n    mobility.SetPositionAllocator(positionAllocator);\n    mobility.Install(phones);\n    mobility.Install(drones);\n\n    for (auto iter = NodeList::Begin(); iter != NodeList::End(); iter++)\n    {\n        auto m = (*iter)->GetObject<MobilityModel>();\n        if (!m)\n            continue;\n        m->TraceConnectWithoutContext(\"CourseChange\", MakeCallback(&CourseChanged));\n    }\n\n    // ---- Buildings ----\n    BuildingContainer buildings;\n\n    Ptr<Building> simpleBuilding = CreateObject<Building>();\n    simpleBuilding->SetBoundaries({-150.0, -130.0, -150.0, -130.0, 0.0, 20.0});\n    buildings.Add(simpleBuilding);\n\n    Ptr<Building> twoFloorBuilding = CreateObject<Building>();\n    twoFloorBuilding->SetBoundaries({150.0, 130.0, 150.0, 130.0, 0.0, 40.0});\n    twoFloorBuilding->SetNFloors(2);\n    buildings.Add(twoFloorBuilding);\n\n    // ---- NetSimulyzer ----\n    auto orchestrator = CreateObject<netsimulyzer::Orchestrator>(outputFileName);\n\n    // Mark possible Node locations\n    auto possibleNodeLocations = CreateObject<netsimulyzer::RectangularArea>(\n        orchestrator,\n        Rectangle{minNodePosition, maxNodePosition, minNodePosition, maxNodePosition});\n\n    // Identify the area\n    possibleNodeLocations->SetAttribute(\"Name\", StringValue(\"Possible Node Locations\"));\n\n    // Mark with a light green color\n    possibleNodeLocations->SetAttribute(\"FillColor\", netsimulyzer::Color3Value{204u, 255u, 204u});\n\n    auto infoLog = CreateObject<netsimulyzer::LogStream>(orchestrator);\n    eventLog = CreateObject<netsimulyzer::LogStream>(orchestrator);\n\n    // Log the base configuration for the scenario\n    *infoLog << \"----- Scenario Settings -----\\n\";\n    *infoLog << \"Node Position Range: [\" << minNodePosition << ',' << maxNodePosition << \"]\\n\";\n    *infoLog << \"Node Speed Range: [\" << minSpeed << ',' << maxSpeed << \"]\\n\";\n    *infoLog << \"Models: Phone [\" << phoneModelPath << \"], Drone [\" << droneModelPath << \"]\\n\";\n    *infoLog << \"Scenario Duration (Seconds): \" << duration << '\\n';\n\n    netsimulyzer::NodeConfigurationHelper nodeConfigHelper(orchestrator);\n    nodeConfigHelper.Set(\"EnableMotionTrail\", BooleanValue(true));\n\n    nodeConfigHelper.Set(\"Model\", StringValue(phoneModelPath));\n    nodeConfigHelper.Install(phones);\n\n    nodeConfigHelper.Set(\"Model\", StringValue(droneModelPath));\n    nodeConfigHelper.Install(drones);\n\n    // Only explicitly configured items will be shown\n    // so, even if we don't have options to set\n    // the buildings bust be configured\n    netsimulyzer::BuildingConfigurationHelper buildingConfigHelper(orchestrator);\n    buildingConfigHelper.Install(buildings);\n\n    Simulator::Stop(Seconds(duration));\n    Simulator::Run();\n\n    *infoLog << \"Scenario Finished\\n\";\n    Simulator::Destroy();\n}\n"
    },
    {
      "file_path": "examples/outdoor-random-walk-example-netsimulyzer.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2012 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n * Copyright (c) 2019, University of Padova, Dep. of Information Engineering, SIGNET lab\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Nicola Baldo <nbaldo@cttc.es> for the code adapted from the lena-dual-stripe.cc example\n * Author: Michele Polese <michele.polese@gmail.com> for this version\n * Modified by: NIST // Contributions may not be subject to US copyright.\n */\n\n#include \"ns3/buildings-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n\n#ifdef HAS_NETSIMULYZER\n#include \"ns3/netsimulyzer-module.h\"\n#endif\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OutdoorRandomWalkExampleNetSimulyzer\");\n\nvoid\nPrintGnuplottableBuildingListToFile(std::string filename)\n{\n    std::ofstream outFile;\n    outFile.open(filename.c_str(), std::ios_base::out | std::ios_base::trunc);\n    if (!outFile.is_open())\n    {\n        NS_LOG_ERROR(\"Can't open file \" << filename);\n        return;\n    }\n    uint32_t index = 0;\n    for (BuildingList::Iterator it = BuildingList::Begin(); it != BuildingList::End(); ++it)\n    {\n        ++index;\n        Box box = (*it)->GetBoundaries();\n        outFile << \"set object \" << index << \" rect from \" << box.xMin << \",\" << box.yMin << \" to \"\n                << box.xMax << \",\" << box.yMax << std::endl;\n    }\n}\n\n#ifdef HAS_NETSIMULYZER\nvoid\n// Define callback function to track node mobility\nCourseChanged(Ptr<netsimulyzer::XYSeries> posSeries,\n              Ptr<netsimulyzer::LogStream> eventLog,\n              std::string context,\n              Ptr<const MobilityModel> model)\n{\n    const auto position = model->GetPosition();\n    // Write coordinates to log\n    *eventLog << Simulator::Now().GetSeconds() << \" Course Change Position: [\" << position.x << \", \"\n              << position.y << \", \" << position.z << \"]\\n\";\n    // Add data point to XYSeries\n    posSeries->Append(position.x, position.y);\n}\n#endif\n\n/**\n * This is an example on how to use the RandomWalk2dOutdoorMobilityModel class.\n * The script outdoor-random-walk-example.sh can be used to visualize the\n * positions visited by the random walk.\n */\nint\nmain(int argc, char* argv[])\n{\n    LogComponentEnable(\"RandomWalk2dOutdoor\", LOG_LEVEL_LOGIC);\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    // create a grid of buildings\n    double buildingSizeX = 100; // m\n    double buildingSizeY = 50;  // m\n    double streetWidth = 25;    // m\n    double buildingHeight = 10; // m\n    uint32_t numBuildingsX = 10;\n    uint32_t numBuildingsY = 10;\n    double maxAxisX = (buildingSizeX + streetWidth) * numBuildingsX;\n    double maxAxisY = (buildingSizeY + streetWidth) * numBuildingsY;\n\n    std::vector<Ptr<Building>> buildingVector;\n    for (uint32_t buildingIdX = 0; buildingIdX < numBuildingsX; ++buildingIdX)\n    {\n        for (uint32_t buildingIdY = 0; buildingIdY < numBuildingsY; ++buildingIdY)\n        {\n            Ptr<Building> building;\n            building = CreateObject<Building>();\n\n            building->SetBoundaries(Box(buildingIdX * (buildingSizeX + streetWidth),\n                                        buildingIdX * (buildingSizeX + streetWidth) + buildingSizeX,\n                                        buildingIdY * (buildingSizeY + streetWidth),\n                                        buildingIdY * (buildingSizeY + streetWidth) + buildingSizeY,\n                                        0.0,\n                                        buildingHeight));\n            building->SetNRoomsX(1);\n            building->SetNRoomsY(1);\n            building->SetNFloors(1);\n            buildingVector.push_back(building);\n        }\n    }\n\n    // print the list of buildings to file\n    PrintGnuplottableBuildingListToFile(\"buildings.txt\");\n\n    // create one node\n    NodeContainer nodes;\n    nodes.Create(1);\n\n    // set the RandomWalk2dOutdoorMobilityModel mobility model\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\n        \"ns3::RandomWalk2dOutdoorMobilityModel\",\n        \"Bounds\",\n        RectangleValue(Rectangle(-streetWidth, maxAxisX, -streetWidth, maxAxisY)));\n    // create an OutdoorPositionAllocator and set its boundaries to match those of the mobility\n    // model\n    Ptr<OutdoorPositionAllocator> position = CreateObject<OutdoorPositionAllocator>();\n    Ptr<UniformRandomVariable> xPos = CreateObject<UniformRandomVariable>();\n    xPos->SetAttribute(\"Min\", DoubleValue(-streetWidth));\n    xPos->SetAttribute(\"Max\", DoubleValue(maxAxisX));\n    Ptr<UniformRandomVariable> yPos = CreateObject<UniformRandomVariable>();\n    yPos->SetAttribute(\"Min\", DoubleValue(-streetWidth));\n    yPos->SetAttribute(\"Max\", DoubleValue(maxAxisY));\n    position->SetAttribute(\"X\", PointerValue(xPos));\n    position->SetAttribute(\"Y\", PointerValue(yPos));\n    mobility.SetPositionAllocator(position);\n    // install the mobility model\n    mobility.Install(nodes.Get(0));\n\n    // enable the traces for the mobility model\n    AsciiTraceHelper ascii;\n    MobilityHelper::EnableAsciiAll(ascii.CreateFileStream(\"mobility-trace-example.mob\"));\n\n#ifdef HAS_NETSIMULYZER\n    auto orchestrator =\n        CreateObject<netsimulyzer::Orchestrator>(\"outdoor-random-walk-example.json\");\n    // Use helper to define model for visualizing nodes and aggregate to Node object\n    netsimulyzer::NodeConfigurationHelper nodeHelper{orchestrator};\n    nodeHelper.Set(\"Model\", netsimulyzer::models::LAND_DRONE_VALUE);\n    nodeHelper.Set(\"Scale\", DoubleValue(4));\n    nodeHelper.Install(nodes);\n    // Use helper to configure buildings and export them\n    netsimulyzer::BuildingConfigurationHelper buildingHelper{orchestrator};\n    for (auto& building : buildingVector)\n        buildingHelper.Install(building);\n    // Create a LogStream to output mobility events\n    Ptr<netsimulyzer::LogStream> eventLog = CreateObject<netsimulyzer::LogStream>(orchestrator);\n    eventLog->SetAttribute(\"Name\", StringValue(\"Event Log\"));\n    // Create XYSeries that will be used to display mobility (similar to a 2D plot)\n    Ptr<netsimulyzer::XYSeries> posSeries = CreateObject<netsimulyzer::XYSeries>(orchestrator);\n    posSeries->SetAttribute(\"Name\", StringValue(\"Node position\"));\n    posSeries->SetAttribute(\"LabelMode\", StringValue(\"Hidden\"));\n    posSeries->SetAttribute(\"Color\", netsimulyzer::BLUE_VALUE);\n    posSeries->GetXAxis()->SetAttribute(\"Name\", StringValue(\"X position (m)\"));\n    posSeries->GetYAxis()->SetAttribute(\"Name\", StringValue(\"Y position (m)\"));\n\n    // Tie together the callback function, LogStream, and XYSeries\n    Config::Connect(\"/NodeList/*/$ns3::MobilityModel/CourseChange\",\n                    MakeBoundCallback(&CourseChanged, posSeries, eventLog));\n#endif\n\n    Simulator::Stop(Seconds(1e4));\n    Simulator::Run();\n    Simulator::Destroy();\n}"
    },
    {
      "file_path": "examples/throughput-sink-example-netsimulyzer.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * NIST-developed software is provided by NIST as a public\n * service. You may use, copy and distribute copies of the software in\n * any medium, provided that you keep intact this entire notice. You\n * may improve, modify and create derivative works of the software or\n * any portion of the software, and you may copy and distribute such\n * modifications or works. Modified works should carry a notice\n * stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the\n * National Institute of Standards and Technology as the source of the\n * software.\n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES\n * NO WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY\n * OPERATION OF LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n * WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,\n * NON-INFRINGEMENT AND DATA ACCURACY. NIST NEITHER REPRESENTS NOR\n * WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE UNINTERRUPTED\n * OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST DOES NOT\n * WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE\n * SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE\n * CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n *\n * You are solely responsible for determining the appropriateness of\n * using and distributing the software and you assume all risks\n * associated with its use, including but not limited to the risks and\n * costs of program errors, compliance with applicable laws, damage to\n * or loss of data, programs or equipment, and the unavailability or\n * interruption of operation. This software is not intended to be used\n * in any situation where a failure could cause risk of injury or\n * damage to property. The software developed by NIST employees is not\n * subject to copyright protection within the United States.\n *\n * Author: Evan Black <evan.black@nist.gov>\n */\n\n#include <ns3/applications-module.h>\n#include <ns3/core-module.h>\n#include <ns3/internet-module.h>\n#include <ns3/mobility-module.h>\n#include <ns3/netsimulyzer-module.h>\n#include <ns3/network-module.h>\n#include <ns3/point-to-point-module.h>\n\n#include <string>\n\n// Example demonstrating how to connect the `netsimulyzer::ThroughputSink`\n// to the UDP Echo Client & Server.\n//\n//\n//       10.1.1.0\n// n0 -------------- n1\n//    point-to-point\n//\n\nusing namespace ns3;\n\n// Custom function for the \"TxWithAddresses\" trace in `UdpEchoServer`\n// with the `ThroughputSink` as a bound parameter\nvoid\nWriteServerThroughput(Ptr<netsimulyzer::ThroughputSink> sink,\n                      Ptr<const Packet> packet,\n                      const Address&,\n                      const Address&)\n{\n    sink->AddPacket(packet);\n\n    // If this trace only provided the packet size,\n    // instead of the whole packet, then\n    // ThroughputSink::AddPacketSize could have\n    // been used.\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double durationUser = 20.0;\n    std::string outputFileName = \"netsimulyzer-throughput-sink-example.json\";\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"outputFileName\",\n                 \"The name of the file to write the NetSimulyzer trace info\",\n                 outputFileName);\n    cmd.AddValue(\"duration\", \"Duration (in Seconds) of the simulation\", durationUser);\n    cmd.Parse(argc, argv);\n\n    NS_ABORT_MSG_IF(durationUser < 3.0, \"Scenario must be at least three seconds long\");\n    const auto duration = Seconds(durationUser);\n\n    NS_ABORT_MSG_IF(outputFileName.empty(), \"`outputFileName` must not be empty\");\n\n    NodeContainer nodes{2u};\n\n    // ----- Mobility (Optional) -----\n    // Slightly separate the two nodes\n    // The positions here are arbitrary\n    auto positions = CreateObject<ListPositionAllocator>();\n    positions->Add(Vector3D{-1.0, 5.0, 0.0});\n    positions->Add(Vector3D{1.0, 5.0, 0.0});\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(positions);\n\n    mobility.Install(nodes);\n\n    // ----- Network -----\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"0ms\"));\n\n    auto netDevices = pointToPoint.Install(nodes);\n\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n\n    auto interfaces = address.Assign(netDevices);\n\n    // ----- Applications -----\n    const auto echoPort = 9u;\n    UdpEchoServerHelper echoServer{echoPort};\n\n    auto serverApp = echoServer.Install(nodes.Get(1u));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(duration - Seconds(1.0));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(1u), echoPort);\n\n    // Make sure a good number of packets are possible (we won't hit this high number though)\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10'000u));\n\n    // Sends a packet every two seconds\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(2.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024u));\n\n    auto clientApp = echoClient.Install(nodes.Get(0u));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(duration - Seconds(1.0));\n\n    // ----- NetSimulyzer -----\n    auto orchestrator = CreateObject<netsimulyzer::Orchestrator>(outputFileName);\n\n    // Suggest a faster playback, since not too much happens (optional)\n    orchestrator->SetTimeStep(MilliSeconds(100), Time::MS);\n\n    // The Nodes don't move during the simulation, so disable mobility polling (Optional)\n    orchestrator->SetAttribute(\"PollMobility\", BooleanValue(false));\n\n    // ---- Models (Optional) ----\n    netsimulyzer::NodeConfigurationHelper nodeHelper{orchestrator};\n\n    // Client\n    nodeHelper.Set(\"Model\", netsimulyzer::models::SMARTPHONE_VALUE);\n    nodeHelper.Set(\"HighlightColor\",\n                   netsimulyzer::OptionalValue<netsimulyzer::Color3>{\n                       netsimulyzer::BLUE}); // Match the plots below\n    nodeHelper.Install(nodes.Get(0u));\n\n    // Server\n    nodeHelper.Set(\"Model\", netsimulyzer::models::SERVER_VALUE);\n    nodeHelper.Set(\"HighlightColor\",\n                   netsimulyzer::OptionalValue<netsimulyzer::Color3>{\n                       netsimulyzer::RED}); // Match the plots below\n    nodeHelper.Install(nodes.Get(1u));\n\n    // ---- Throughput Sinks ----\n\n    // --- Client ---\n    auto clientThroughput =\n        CreateObject<netsimulyzer::ThroughputSink>(orchestrator, \"UDP Echo Client Throughput (TX)\");\n\n    // Match the model highlight colors above\n    clientThroughput->GetSeries()->SetAttribute(\"Color\", netsimulyzer::BLUE_VALUE);\n\n    // Different from the app's interval to show periods with 0 throughput\n    clientThroughput->SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n\n    // Optional Unit to display data in, does not change the values passed to the sink\n    clientThroughput->SetAttribute(\"Unit\", EnumValue(netsimulyzer::ThroughputSink::Unit::Byte));\n\n    // Unit to group time by, does not affect `Interval`\n    clientThroughput->SetAttribute(\"TimeUnit\", EnumValue(Time::Unit::S));\n\n    // Use ThroughputSink::AddPacket if the TX/RX trace passes a pointer to the packet\n    // If the model provides a trace with a different signature, see the\n    // server configuration below for how to hook it up\n    clientApp.Get(0u)->TraceConnectWithoutContext(\n        \"Tx\",\n        MakeCallback(&netsimulyzer::ThroughputSink::AddPacket, clientThroughput));\n\n    // --- Server ---\n    auto serverThroughput =\n        CreateObject<netsimulyzer::ThroughputSink>(orchestrator, \"UDP Echo Server Throughput (TX)\");\n\n    // Match the model highlight colors above\n    serverThroughput->GetSeries()->SetAttribute(\"Color\", netsimulyzer::RED_VALUE);\n\n    // Same basic configuration as the client\n    serverThroughput->SetAttribute(\"Unit\", EnumValue(netsimulyzer::ThroughputSink::Unit::Byte));\n    serverThroughput->SetAttribute(\"TimeUnit\", EnumValue(Time::Unit::S));\n\n    // Uses a custom function (above main()) to account for the extra parameters in\n    // the \"TxWithAddresses\" trace\n    // Note the bound parameter: `serverThroughput`\n    serverApp.Get(0u)->TraceConnectWithoutContext(\n        \"TxWithAddresses\",\n        MakeBoundCallback(&WriteServerThroughput, serverThroughput));\n\n    // --- Collection (Optional) ---\n    // Show both throughput plots together using a SeriesCollection\n\n    auto collection = CreateObject<netsimulyzer::SeriesCollection>(orchestrator);\n    collection->SetAttribute(\"Name\", StringValue(\"Client and Server Throughput (TX)\"));\n\n    // Keep the individual series above visible in the application\n    collection->SetAttribute(\"HideAddedSeries\", BooleanValue(false));\n\n    // Match the X & Y axes names with the sinks\n    // assumes both sinks use the same units\n    StringValue name;\n    serverThroughput->GetSeries()->GetXAxis()->GetAttribute(\"Name\", name);\n    collection->GetXAxis()->SetAttribute(\"Name\", name);\n\n    serverThroughput->GetSeries()->GetYAxis()->GetAttribute(\"Name\", name);\n    collection->GetYAxis()->SetAttribute(\"Name\", name);\n\n    // Add the series to the collection\n    collection->Add(clientThroughput->GetSeries());\n    collection->Add(serverThroughput->GetSeries());\n\n    // ----- Run The Simulation -----\n    Simulator::Stop(duration);\n    Simulator::Run();\n    Simulator::Destroy();\n}\n"
    },
    {
      "file_path": "examples/wifi-bianchi-netsimulyzer.cc",
      "code": "/*\n * Copyright (c) 2012 The Boeing Company\n *\n * SPDX-License-Identifier: GPL-2.0-only\n *\n * Author: Gary Pei <guangyu.pei@boeing.com>\n *\n * Updated by Tom Henderson, Rohan Patidar, Hao Yin and S\u00e9bastien Deronne\n */\n\n// This program conducts a Bianchi analysis of a wifi network.\n// Bianchi analysis involves saturating the network and observing how\n// the maximum achievable throughput is governed by the DCF or ECDA\n// channel access mechanisms.  This program offers many configurable\n// options, traces, and a validation option; the main output is a Gnuplot\n// plot file plotting throughput vs. number of nodes.\n\n#include \"ns3/ampdu-subframe-header.h\"\n#include \"ns3/application-container.h\"\n#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/integer.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/node-list.h\"\n#include \"ns3/packet-socket-client.h\"\n#include \"ns3/packet-socket-helper.h\"\n#include \"ns3/packet-socket-server.h\"\n#include \"ns3/propagation-delay-model.h\"\n#include \"ns3/propagation-loss-model.h\"\n#include \"ns3/queue-size.h\"\n#include \"ns3/rng-seed-manager.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/wifi-mac-header.h\"\n#include \"ns3/wifi-mac.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/wifi-phy-rx-trace-helper.h\"\n#include \"ns3/wifi-tx-stats-helper.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <fstream>\n#include <iomanip>\n#include <vector>\n\n#ifdef HAS_NETSIMULYZER\n#include \"ns3/netsimulyzer-module.h\"\n#include \"ns3/pointer.h\"\n#endif\n\n\n/// Avoid std::numbers::pi because it's C++20\n#define PI 3.1415926535\n\nNS_LOG_COMPONENT_DEFINE(\"WifiBianchi\");\n\nusing namespace ns3;\n\nstd::ofstream cwTraceFile;      ///< File that traces CW over time\nstd::ofstream backoffTraceFile; ///< File that traces backoff over time\nstd::ofstream phyTxTraceFile;   ///< File that traces PHY transmissions  over time\nstd::ofstream macTxTraceFile;   ///< File that traces MAC transmissions  over time\nstd::ofstream macRxTraceFile;   ///< File that traces MAC receptions  over time\nstd::ofstream\n    socketSendTraceFile; ///< File that traces packets transmitted by the application  over time\n\nstd::map<Mac48Address, uint64_t> packetsReceived; ///< Map that stores the total packets received\n                                                  ///< per STA (and addressed to that STA)\nstd::map<Mac48Address, uint64_t>\n    bytesReceived; ///< Map that stores the total bytes received per STA (and addressed to that STA)\nstd::map<Mac48Address, uint64_t>\n    packetsTransmitted; ///< Map that stores the total packets transmitted per STA\nstd::map<Mac48Address, uint64_t>\n    psduFailed; ///< Map that stores the total number of unsuccessfuly received PSDUS (for which\n                ///< the PHY header was successfully received)  per STA (including PSDUs not\n                ///< addressed to that STA)\nstd::map<Mac48Address, uint64_t>\n    psduSucceeded; ///< Map that stores the total number of successfully received PSDUs per STA\n                   ///< (including PSDUs not addressed to that STA)\nstd::map<Mac48Address, uint64_t> phyHeaderFailed; ///< Map that stores the total number of\n                                                  ///< unsuccessfuly received PHY headers per STA\nstd::map<Mac48Address, uint64_t>\n    rxEventWhileTxing; ///< Map that stores the number of reception events per STA that occurred\n                       ///< while PHY was already transmitting a PPDU\nstd::map<Mac48Address, uint64_t>\n    rxEventWhileRxing; ///< Map that stores the number of reception events per STA that occurred\n                       ///< while PHY was already receiving a PPDU\nstd::map<Mac48Address, uint64_t>\n    rxEventWhileDecodingPreamble; ///< Map that stores the number of reception events per STA that\n                                  ///< occurred while PHY was already decoding a preamble\nstd::map<Mac48Address, uint64_t>\n    rxEventAbortedByTx; ///< Map that stores the number of reception events aborted per STA because\n                        ///< the PHY has started to transmit\n\nstd::map<Mac48Address, Time>\n    timeFirstReceived; ///< Map that stores the time at which the first packet was received per STA\n                       ///< (and the packet is addressed to that STA)\nstd::map<Mac48Address, Time>\n    timeLastReceived; ///< Map that stores the time at which the last packet was received per STA\n                      ///< (and the packet is addressed to that STA)\nstd::map<Mac48Address, Time> timeFirstTransmitted; ///< Map that stores the time at which the first\n                                                   ///< packet was transmitted per STA\nstd::map<Mac48Address, Time> timeLastTransmitted;  ///< Map that stores the time at which the last\n                                                   ///< packet was transmitted per STA\n\nstd::set<uint32_t> associated; ///< Contains the IDs of the STAs that successfully associated to the\n                               ///< access point (in infrastructure mode only)\n\nbool tracing = false;    ///< Flag to enable/disable generation of tracing files\nuint32_t pktSize = 1500; ///< packet size used for the simulation (in bytes)\nuint8_t maxMpdus = 0;    ///< The maximum number of MPDUs in A-MPDUs (0 to disable MPDU aggregation)\nbool useTxHelper = false; ///< Flag to get MPDU statistics with WifiTxStatsHelper\nbool useRxHelper = false; ///< Flag to get PPDU statistics with WifiPhyRxTraceHelper\n\n#ifdef HAS_NETSIMULYZER\n// Configuration parameters\nbool enableVisualization = true;\ndouble guiResolution = 200; // refresh time in ms\n\n// Visualizer components\nPtr<netsimulyzer::Orchestrator> orchestrator;\nPtr<netsimulyzer::LogStream> applicationLog;\n\n// Utility function to automatically add time to log messages\nvoid\nWriteApplicationLog(std::string message)\n{\n    *applicationLog << \"At \" << Simulator::Now().GetSeconds() << \" \" << message;\n}\n\n// Define graphs to visualize */\nstd::map<uint32_t, Ptr<netsimulyzer::XYSeries>> cwTraceSeries;\nstd::map<uint32_t, Ptr<netsimulyzer::XYSeries>> backoffTraceSeries;\nstd::map<uint32_t, Ptr<netsimulyzer::ThroughputSink>> macTxTraceSeries;\nstd::map<uint32_t, Ptr<netsimulyzer::ThroughputSink>> macRxTraceSeries;\nstd::map<uint32_t, Ptr<netsimulyzer::SeriesCollection>> macCollections;\n\nPtr<netsimulyzer::ThroughputSink> macRxTotalTraceSeries;\n\nPtr<netsimulyzer::XYSeries> associatedSeries;\n\n#endif\n\n/// Table of the expected values for EIFS\nstd::map<std::string /* mode */,\n         std::map<unsigned int /* number of nodes */, double /* calculated throughput */>>\n    bianchiResultsEifs = {\n        /* 11b */\n        {\"DsssRate1Mbps\",\n         {\n             {5, 0.8418},\n             {10, 0.7831},\n             {15, 0.7460},\n             {20, 0.7186},\n             {25, 0.6973},\n             {30, 0.6802},\n             {35, 0.6639},\n             {40, 0.6501},\n             {45, 0.6386},\n             {50, 0.6285},\n         }},\n        {\"DsssRate2Mbps\",\n         {\n             {5, 1.6170},\n             {10, 1.5075},\n             {15, 1.4371},\n             {20, 1.3849},\n             {25, 1.3442},\n             {30, 1.3115},\n             {35, 1.2803},\n             {40, 1.2538},\n             {45, 1.2317},\n             {50, 1.2124},\n         }},\n        {\"DsssRate5_5Mbps\",\n         {\n             {5, 3.8565},\n             {10, 3.6170},\n             {15, 3.4554},\n             {20, 3.3339},\n             {25, 3.2385},\n             {30, 3.1613},\n             {35, 3.0878},\n             {40, 3.0249},\n             {45, 2.9725},\n             {50, 2.9266},\n         }},\n        {\"DsssRate11Mbps\",\n         {\n             {5, 6.3821},\n             {10, 6.0269},\n             {15, 5.7718},\n             {20, 5.5765},\n             {25, 5.4217},\n             {30, 5.2958},\n             {35, 5.1755},\n             {40, 5.0722},\n             {45, 4.9860},\n             {50, 4.9103},\n         }},\n        /* 11a */\n        {\"OfdmRate6Mbps\",\n         {\n             {5, 4.6899},\n             {10, 4.3197},\n             {15, 4.1107},\n             {20, 3.9589},\n             {25, 3.8478},\n             {30, 3.7490},\n             {35, 3.6618},\n             {40, 3.5927},\n             {45, 3.5358},\n             {50, 3.4711},\n         }},\n        {\"OfdmRate9Mbps\",\n         {\n             {5, 6.8188},\n             {10, 6.2885},\n             {15, 5.9874},\n             {20, 5.7680},\n             {25, 5.6073},\n             {30, 5.4642},\n             {35, 5.3378},\n             {40, 5.2376},\n             {45, 5.1551},\n             {50, 5.0612},\n         }},\n        {\"OfdmRate12Mbps\",\n         {\n             {5, 8.8972},\n             {10, 8.2154},\n             {15, 7.8259},\n             {20, 7.5415},\n             {25, 7.3329},\n             {30, 7.1469},\n             {35, 6.9825},\n             {40, 6.8521},\n             {45, 6.7447},\n             {50, 6.6225},\n         }},\n        {\"OfdmRate18Mbps\",\n         {\n             {5, 12.6719},\n             {10, 11.7273},\n             {15, 11.1814},\n             {20, 10.7810},\n             {25, 10.4866},\n             {30, 10.2237},\n             {35, 9.9910},\n             {40, 9.8061},\n             {45, 9.6538},\n             {50, 9.4804},\n         }},\n        {\"OfdmRate24Mbps\",\n         {\n             {5, 16.0836},\n             {10, 14.9153},\n             {15, 14.2327},\n             {20, 13.7300},\n             {25, 13.3595},\n             {30, 13.0281},\n             {35, 12.7343},\n             {40, 12.5008},\n             {45, 12.3083},\n             {50, 12.0889},\n         }},\n        {\"OfdmRate36Mbps\",\n         {\n             {5, 22.0092},\n             {10, 20.4836},\n             {15, 19.5743},\n             {20, 18.8997},\n             {25, 18.4002},\n             {30, 17.9524},\n             {35, 17.5545},\n             {40, 17.2377},\n             {45, 16.9760},\n             {50, 16.6777},\n         }},\n        {\"OfdmRate48Mbps\",\n         {\n             {5, 26.8382},\n             {10, 25.0509},\n             {15, 23.9672},\n             {20, 23.1581},\n             {25, 22.5568},\n             {30, 22.0165},\n             {35, 21.5355},\n             {40, 21.1519},\n             {45, 20.8348},\n             {50, 20.4729},\n         }},\n        {\"OfdmRate54Mbps\",\n         {\n             {5, 29.2861},\n             {10, 27.3763},\n             {15, 26.2078},\n             {20, 25.3325},\n             {25, 24.6808},\n             {30, 24.0944},\n             {35, 23.5719},\n             {40, 23.1549},\n             {45, 22.8100},\n             {50, 22.4162},\n         }},\n        /* 11g */\n        {\"ErpOfdmRate6Mbps\",\n         {\n             {5, 4.6899},\n             {10, 4.3197},\n             {15, 4.1107},\n             {20, 3.9589},\n             {25, 3.8478},\n             {30, 3.7490},\n             {35, 3.6618},\n             {40, 3.5927},\n             {45, 3.5358},\n             {50, 3.4711},\n         }},\n        {\"ErpOfdmRate9Mbps\",\n         {\n             {5, 6.8188},\n             {10, 6.2885},\n             {15, 5.9874},\n             {20, 5.7680},\n             {25, 5.6073},\n             {30, 5.4642},\n             {35, 5.3378},\n             {40, 5.2376},\n             {45, 5.1551},\n             {50, 5.0612},\n         }},\n        {\"ErpOfdmRate12Mbps\",\n         {\n             {5, 8.8972},\n             {10, 8.2154},\n             {15, 7.8259},\n             {20, 7.5415},\n             {25, 7.3329},\n             {30, 7.1469},\n             {35, 6.9825},\n             {40, 6.8521},\n             {45, 6.7447},\n             {50, 6.6225},\n         }},\n        {\"ErpOfdmRate18Mbps\",\n         {\n             {5, 12.6719},\n             {10, 11.7273},\n             {15, 11.1814},\n             {20, 10.7810},\n             {25, 10.4866},\n             {30, 10.2237},\n             {35, 9.9910},\n             {40, 9.8061},\n             {45, 9.6538},\n             {50, 9.4804},\n         }},\n        {\"ErpOfdmRate24Mbps\",\n         {\n             {5, 16.0836},\n             {10, 14.9153},\n             {15, 14.2327},\n             {20, 13.7300},\n             {25, 13.3595},\n             {30, 13.0281},\n             {35, 12.7343},\n             {40, 12.5008},\n             {45, 12.3083},\n             {50, 12.0889},\n         }},\n        {\"ErpOfdmRate36Mbps\",\n         {\n             {5, 22.0092},\n             {10, 20.4836},\n             {15, 19.5743},\n             {20, 18.8997},\n             {25, 18.4002},\n             {30, 17.9524},\n             {35, 17.5545},\n             {40, 17.2377},\n             {45, 16.9760},\n             {50, 16.6777},\n         }},\n        {\"ErpOfdmRate48Mbps\",\n         {\n             {5, 26.8382},\n             {10, 25.0509},\n             {15, 23.9672},\n             {20, 23.1581},\n             {25, 22.5568},\n             {30, 22.0165},\n             {35, 21.5355},\n             {40, 21.1519},\n             {45, 20.8348},\n             {50, 20.4729},\n         }},\n        {\"ErpOfdmRate54Mbps\",\n         {\n             {5, 29.2861},\n             {10, 27.3763},\n             {15, 26.2078},\n             {20, 25.3325},\n             {25, 24.6808},\n             {30, 24.0944},\n             {35, 23.5719},\n             {40, 23.1549},\n             {45, 22.8100},\n             {50, 22.4162},\n         }},\n        /* 11ax, no frame aggregation */\n        {\"HeMcs0_20MHz\",\n         {\n             {5, 6.3381},\n             {10, 5.8172},\n             {15, 5.5223},\n             {20, 5.3146},\n             {25, 5.1525},\n             {30, 5.0187},\n             {35, 4.9039},\n             {40, 4.8034},\n             {45, 4.7134},\n             {50, 4.6317},\n         }},\n        {\"HeMcs1_20MHz\",\n         {\n             {5, 11.6580},\n             {10, 10.7369},\n             {15, 10.2068},\n             {20, 9.8309},\n             {25, 9.5365},\n             {30, 9.2930},\n             {35, 9.0837},\n             {40, 8.9001},\n             {45, 8.7355},\n             {50, 8.5860},\n         }},\n        {\"HeMcs2_20MHz\",\n         {\n             {5, 15.8572},\n             {10, 14.6445},\n             {15, 13.9367},\n             {20, 13.4323},\n             {25, 13.0361},\n             {30, 12.7076},\n             {35, 12.4249},\n             {40, 12.1766},\n             {45, 11.9538},\n             {50, 11.7511},\n         }},\n        {\"HeMcs3_20MHz\",\n         {\n             {5, 19.7457},\n             {10, 18.2820},\n             {15, 17.4163},\n             {20, 16.7963},\n             {25, 16.3078},\n             {30, 15.9021},\n             {35, 15.5524},\n             {40, 15.2449},\n             {45, 14.9687},\n             {50, 14.7173},\n         }},\n        {\"HeMcs4_20MHz\",\n         {\n             {5, 25.8947},\n             {10, 24.0721},\n             {15, 22.9698},\n             {20, 22.1738},\n             {25, 21.5437},\n             {30, 21.0186},\n             {35, 20.5650},\n             {40, 20.1654},\n             {45, 19.8059},\n             {50, 19.4784},\n         }},\n        {\"HeMcs5_20MHz\",\n         {\n             {5, 30.0542},\n             {10, 28.0155},\n             {15, 26.7625},\n             {20, 25.8523},\n             {25, 25.1295},\n             {30, 24.5258},\n             {35, 24.0034},\n             {40, 23.5426},\n             {45, 23.1277},\n             {50, 22.7492},\n         }},\n        {\"HeMcs6_20MHz\",\n         {\n             {5, 32.6789},\n             {10, 30.5150},\n             {15, 29.1708},\n             {20, 28.1907},\n             {25, 27.4107},\n             {30, 26.7583},\n             {35, 26.1931},\n             {40, 25.6941},\n             {45, 25.2446},\n             {50, 24.8343},\n         }},\n        {\"HeMcs7_20MHz\",\n         {\n             {5, 34.1710},\n             {10, 31.9398},\n             {15, 30.5451},\n             {20, 29.5261},\n             {25, 28.7140},\n             {30, 28.0342},\n             {35, 27.4449},\n             {40, 26.9245},\n             {45, 26.4554},\n             {50, 26.0271},\n         }},\n        {\"HeMcs8_20MHz\",\n         {\n             {5, 37.6051},\n             {10, 35.2296},\n             {15, 33.7228},\n             {20, 32.6160},\n             {25, 31.7314},\n             {30, 30.9895},\n             {35, 30.3455},\n             {40, 29.7760},\n             {45, 29.2623},\n             {50, 28.7929},\n         }},\n        {\"HeMcs9_20MHz\",\n         {\n             {5, 39.5947},\n             {10, 37.1424},\n             {15, 35.5731},\n             {20, 34.4169},\n             {25, 33.4911},\n             {30, 32.7138},\n             {35, 32.0385},\n             {40, 31.4410},\n             {45, 30.9016},\n             {50, 30.4086},\n         }},\n        {\"HeMcs10_20MHz\",\n         {\n             {5, 39.5947},\n             {10, 37.1424},\n             {15, 35.5731},\n             {20, 34.4169},\n             {25, 33.4911},\n             {30, 32.7138},\n             {35, 32.0385},\n             {40, 31.4410},\n             {45, 30.9016},\n             {50, 30.4086},\n         }},\n        {\"HeMcs11_20MHz\",\n         {\n             {5, 41.8065},\n             {10, 39.2749},\n             {15, 37.6383},\n             {20, 36.4282},\n             {25, 35.4575},\n             {30, 34.6414},\n             {35, 33.9316},\n             {40, 33.3031},\n             {45, 32.7355},\n             {50, 32.2164},\n         }},\n        {\"HeMcs0_40MHz\",\n         {\n             {5, 11.4999},\n             {10, 10.5902},\n             {15, 10.0669},\n             {20, 9.6960},\n             {25, 9.4055},\n             {30, 9.1652},\n             {35, 8.9587},\n             {40, 8.7775},\n             {45, 8.6151},\n             {50, 8.4676},\n         }},\n        {\"HeMcs1_40MHz\",\n         {\n             {5, 19.5937},\n             {10, 18.1394},\n             {15, 17.2798},\n             {20, 16.6642},\n             {25, 16.1793},\n             {30, 15.7766},\n             {35, 15.4295},\n             {40, 15.1242},\n             {45, 14.8502},\n             {50, 14.6007},\n         }},\n        {\"HeMcs2_40MHz\",\n         {\n             {5, 25.6338},\n             {10, 23.8255},\n             {15, 22.7329},\n             {20, 21.9442},\n             {25, 21.3200},\n             {30, 20.7999},\n             {35, 20.3506},\n             {40, 19.9549},\n             {45, 19.5990},\n             {50, 19.2746},\n         }},\n        {\"HeMcs3_40MHz\",\n         {\n             {5, 30.0542},\n             {10, 28.0155},\n             {15, 26.7625},\n             {20, 25.8523},\n             {25, 25.1295},\n             {30, 24.5258},\n             {35, 24.0034},\n             {40, 23.5426},\n             {45, 23.1277},\n             {50, 22.7492},\n         }},\n        {\"HeMcs4_40MHz\",\n         {\n             {5, 37.6051},\n             {10, 35.2296},\n             {15, 33.7228},\n             {20, 32.6160},\n             {25, 31.7314},\n             {30, 30.9895},\n             {35, 30.3455},\n             {40, 29.7760},\n             {45, 29.2623},\n             {50, 28.7929},\n         }},\n        {\"HeMcs5_40MHz\",\n         {\n             {5, 41.8065},\n             {10, 39.2749},\n             {15, 37.6383},\n             {20, 36.4282},\n             {25, 35.4575},\n             {30, 34.6414},\n             {35, 33.9316},\n             {40, 33.3031},\n             {45, 32.7355},\n             {50, 32.2164},\n         }},\n        {\"HeMcs6_40MHz\",\n         {\n             {5, 44.2801},\n             {10, 41.6672},\n             {15, 39.9580},\n             {20, 38.6892},\n             {25, 37.6692},\n             {30, 36.8103},\n             {35, 36.0625},\n             {40, 35.3998},\n             {45, 34.8008},\n             {50, 34.2528},\n         }},\n        {\"HeMcs7_40MHz\",\n         {\n             {5, 44.2801},\n             {10, 41.6672},\n             {15, 39.9580},\n             {20, 38.6892},\n             {25, 37.6692},\n             {30, 36.8103},\n             {35, 36.0625},\n             {40, 35.3998},\n             {45, 34.8008},\n             {50, 34.2528},\n         }},\n        {\"HeMcs8_40MHz\",\n         {\n             {5, 47.0648},\n             {10, 44.3699},\n             {15, 42.5825},\n             {20, 41.2495},\n             {25, 40.1751},\n             {30, 39.2689},\n             {35, 38.4790},\n             {40, 37.7781},\n             {45, 37.1443},\n             {50, 36.5639},\n         }},\n        {\"HeMcs9_40MHz\",\n         {\n             {5, 50.2233},\n             {10, 47.4474},\n             {15, 45.5760},\n             {20, 44.1727},\n             {25, 43.0382},\n             {30, 42.0794},\n             {35, 41.2425},\n             {40, 40.4991},\n             {45, 39.8262},\n             {50, 39.2095},\n         }},\n        {\"HeMcs10_40MHz\",\n         {\n             {5, 50.2233},\n             {10, 47.4474},\n             {15, 45.5760},\n             {20, 44.1727},\n             {25, 43.0382},\n             {30, 42.0794},\n             {35, 41.2425},\n             {40, 40.4991},\n             {45, 39.8262},\n             {50, 39.2095},\n         }},\n        {\"HeMcs11_40MHz\",\n         {\n             {5, 50.2233},\n             {10, 47.4474},\n             {15, 45.5760},\n             {20, 44.1727},\n             {25, 43.0382},\n             {30, 42.0794},\n             {35, 41.2425},\n             {40, 40.4991},\n             {45, 39.8262},\n             {50, 39.2095},\n         }},\n        {\"HeMcs0_80MHz\",\n         {\n             {5, 19.6542},\n             {10, 18.1962},\n             {15, 17.3342},\n             {20, 16.7168},\n             {25, 16.2305},\n             {30, 15.8265},\n             {35, 15.4784},\n             {40, 15.1723},\n             {45, 14.8973},\n             {50, 14.6471},\n         }},\n        {\"HeMcs1_80MHz\",\n         {\n             {5, 30.9311},\n             {10, 28.8495},\n             {15, 27.5657},\n             {20, 26.6320},\n             {25, 25.8899},\n             {30, 25.2699},\n             {35, 24.7332},\n             {40, 24.2595},\n             {45, 23.8330},\n             {50, 23.4439},\n         }},\n        {\"HeMcs2_80MHz\",\n         {\n             {5, 37.0575},\n             {10, 34.7039},\n             {15, 33.2146},\n             {20, 32.1216},\n             {25, 31.2485},\n             {30, 30.5164},\n             {35, 29.8811},\n             {40, 29.3194},\n             {45, 28.8127},\n             {50, 28.3499},\n         }},\n        {\"HeMcs3_80MHz\",\n         {\n             {5, 41.8065},\n             {10, 39.2749},\n             {15, 37.6383},\n             {20, 36.4282},\n             {25, 35.4575},\n             {30, 34.6414},\n             {35, 33.9316},\n             {40, 33.3031},\n             {45, 32.7355},\n             {50, 32.2164},\n         }},\n        {\"HeMcs4_80MHz\",\n         {\n             {5, 47.0648},\n             {10, 44.3699},\n             {15, 42.5825},\n             {20, 41.2495},\n             {25, 40.1751},\n             {30, 39.2689},\n             {35, 38.4790},\n             {40, 37.7781},\n             {45, 37.1443},\n             {50, 36.5639},\n         }},\n        {\"HeMcs5_80MHz\",\n         {\n             {5, 50.2233},\n             {10, 47.4474},\n             {15, 45.5760},\n             {20, 44.1727},\n             {25, 43.0382},\n             {30, 42.0794},\n             {35, 41.2425},\n             {40, 40.4991},\n             {45, 39.8262},\n             {50, 39.2095},\n         }},\n        {\"HeMcs6_80MHz\",\n         {\n             {5, 53.8362},\n             {10, 50.9837},\n             {15, 49.0221},\n             {20, 47.5418},\n             {25, 46.3407},\n             {30, 45.3233},\n             {35, 44.4337},\n             {40, 43.6425},\n             {45, 42.9255},\n             {50, 42.2678},\n         }},\n        {\"HeMcs7_80MHz\",\n         {\n             {5, 53.8362},\n             {10, 50.9837},\n             {15, 49.0221},\n             {20, 47.5418},\n             {25, 46.3407},\n             {30, 45.3233},\n             {35, 44.4337},\n             {40, 43.6425},\n             {45, 42.9255},\n             {50, 42.2678},\n         }},\n        {\"HeMcs8_80MHz\",\n         {\n             {5, 53.8362},\n             {10, 50.9837},\n             {15, 49.0221},\n             {20, 47.5418},\n             {25, 46.3407},\n             {30, 45.3233},\n             {35, 44.4337},\n             {40, 43.6425},\n             {45, 42.9255},\n             {50, 42.2678},\n         }},\n        {\"HeMcs9_80MHz\",\n         {\n             {5, 58.0092},\n             {10, 55.0896},\n             {15, 53.0321},\n             {20, 51.4672},\n             {25, 50.1922},\n             {30, 49.1091},\n             {35, 48.1601},\n             {40, 47.3148},\n             {45, 46.5478},\n             {50, 45.8436},\n         }},\n        {\"HeMcs10_80MHz\",\n         {\n             {5, 58.0092},\n             {10, 55.0896},\n             {15, 53.0321},\n             {20, 51.4672},\n             {25, 50.1922},\n             {30, 49.1091},\n             {35, 48.1601},\n             {40, 47.3148},\n             {45, 46.5478},\n             {50, 45.8436},\n         }},\n        {\"HeMcs11_80MHz\",\n         {\n             {5, 58.0092},\n             {10, 55.0896},\n             {15, 53.0321},\n             {20, 51.4672},\n             {25, 50.1922},\n             {30, 49.1091},\n             {35, 48.1601},\n             {40, 47.3148},\n             {45, 46.5478},\n             {50, 45.8436},\n         }},\n        {\"HeMcs0_160MHz\",\n         {\n             {5, 29.8428},\n             {10, 27.8145},\n             {15, 26.5689},\n             {20, 25.6645},\n             {25, 24.9463},\n             {30, 24.3466},\n             {35, 23.8276},\n             {40, 23.3699},\n             {45, 22.9578},\n             {50, 22.5819},\n         }},\n        {\"HeMcs1_160MHz\",\n         {\n             {5, 41.1308},\n             {10, 38.6227},\n             {15, 37.0064},\n             {20, 35.8126},\n             {25, 34.8556},\n             {30, 34.0513},\n             {35, 33.3520},\n             {40, 32.7329},\n             {45, 32.1739},\n             {50, 31.6628},\n         }},\n        {\"HeMcs2_160MHz\",\n         {\n             {5, 46.2101},\n             {10, 43.5393},\n             {15, 41.7755},\n             {20, 40.4620},\n             {25, 39.4041},\n             {30, 38.5123},\n             {35, 37.7353},\n             {40, 37.0461},\n             {45, 36.4229},\n             {50, 35.8524},\n         }},\n        {\"HeMcs3_160MHz\",\n         {\n             {5, 50.2233},\n             {10, 47.4474},\n             {15, 45.5760},\n             {20, 44.1727},\n             {25, 43.0382},\n             {30, 42.0794},\n             {35, 41.2425},\n             {40, 40.4991},\n             {45, 39.8262},\n             {50, 39.2095},\n         }},\n        {\"HeMcs4_160MHz\",\n         {\n             {5, 53.8362},\n             {10, 50.9837},\n             {15, 49.0221},\n             {20, 47.5418},\n             {25, 46.3407},\n             {30, 45.3233},\n             {35, 44.4337},\n             {40, 43.6425},\n             {45, 42.9255},\n             {50, 42.2678},\n         }},\n        {\"HeMcs5_160MHz\",\n         {\n             {5, 58.0092},\n             {10, 55.0896},\n             {15, 53.0321},\n             {20, 51.4672},\n             {25, 50.1922},\n             {30, 49.1091},\n             {35, 48.1601},\n             {40, 47.3148},\n             {45, 46.5478},\n             {50, 45.8436},\n         }},\n        {\"HeMcs6_160MHz\",\n         {\n             {5, 58.0092},\n             {10, 55.0896},\n             {15, 53.0321},\n             {20, 51.4672},\n             {25, 50.1922},\n             {30, 49.1091},\n             {35, 48.1601},\n             {40, 47.3148},\n             {45, 46.5478},\n             {50, 45.8436},\n         }},\n        {\"HeMcs7_160MHz\",\n         {\n             {5, 58.0092},\n             {10, 55.0896},\n             {15, 53.0321},\n             {20, 51.4672},\n             {25, 50.1922},\n             {30, 49.1091},\n             {35, 48.1601},\n             {40, 47.3148},\n             {45, 46.5478},\n             {50, 45.8436},\n         }},\n        {\"HeMcs8_160MHz\",\n         {\n             {5, 58.0092},\n             {10, 55.0896},\n             {15, 53.0321},\n             {20, 51.4672},\n             {25, 50.1922},\n             {30, 49.1091},\n             {35, 48.1601},\n             {40, 47.3148},\n             {45, 46.5478},\n             {50, 45.8436},\n         }},\n        {\"HeMcs9_160MHz\",\n         {\n             {5, 62.8834},\n             {10, 59.9147},\n             {15, 57.7564},\n             {20, 56.0992},\n             {25, 54.7419},\n             {30, 53.5850},\n             {35, 52.5689},\n             {40, 51.6620},\n             {45, 50.8379},\n             {50, 50.0803},\n         }},\n        {\"HeMcs10_160MHz\",\n         {\n             {5, 62.8834},\n             {10, 59.9147},\n             {15, 57.7564},\n             {20, 56.0992},\n             {25, 54.7419},\n             {30, 53.5850},\n             {35, 52.5689},\n             {40, 51.6620},\n             {45, 50.8379},\n             {50, 50.0803},\n         }},\n        {\"HeMcs11_160MHz\",\n         {\n             {5, 62.8834},\n             {10, 59.9147},\n             {15, 57.7564},\n             {20, 56.0992},\n             {25, 54.7419},\n             {30, 53.5850},\n             {35, 52.5689},\n             {40, 51.6620},\n             {45, 50.8379},\n             {50, 50.0803},\n         }},\n};\n\n/// Table of the expected values for DIFS\nstd::map<std::string /* mode */,\n         std::map<unsigned int /* number of nodes */, double /* calculated throughput */>>\n    bianchiResultsDifs = {\n        /* 11b */\n        {\"DsssRate1Mbps\",\n         {\n             {5, 0.8437},\n             {10, 0.7861},\n             {15, 0.7496},\n             {20, 0.7226},\n             {25, 0.7016},\n             {30, 0.6847},\n             {35, 0.6686},\n             {40, 0.6549},\n             {45, 0.6435},\n             {50, 0.6336},\n         }},\n        {\"DsssRate2Mbps\",\n         {\n             {5, 1.6228},\n             {10, 1.5168},\n             {15, 1.4482},\n             {20, 1.3972},\n             {25, 1.3574},\n             {30, 1.3253},\n             {35, 1.2947},\n             {40, 1.2687},\n             {45, 1.2469},\n             {50, 1.2279},\n         }},\n        {\"DsssRate5_5Mbps\",\n         {\n             {5, 3.8896},\n             {10, 3.6707},\n             {15, 3.5203},\n             {20, 3.4063},\n             {25, 3.3161},\n             {30, 3.2429},\n             {35, 3.1729},\n             {40, 3.1128},\n             {45, 3.0625},\n             {50, 3.0184},\n         }},\n        {\"DsssRate11Mbps\",\n         {\n             {5, 6.4734},\n             {10, 6.1774},\n             {15, 5.9553},\n             {20, 5.7819},\n             {25, 5.6429},\n             {30, 5.5289},\n             {35, 5.4191},\n             {40, 5.3243},\n             {45, 5.2446},\n             {50, 5.1745},\n         }},\n        /* 11a */\n        {\"OfdmRate6Mbps\",\n         {\n             {5, 4.7087},\n             {10, 4.3453},\n             {15, 4.1397},\n             {20, 3.9899},\n             {25, 3.8802},\n             {30, 3.7824},\n             {35, 3.6961},\n             {40, 3.6276},\n             {45, 3.5712},\n             {50, 3.5071},\n         }},\n        {\"OfdmRate9Mbps\",\n         {\n             {5, 6.8586},\n             {10, 6.3431},\n             {15, 6.0489},\n             {20, 5.8340},\n             {25, 5.6762},\n             {30, 5.5355},\n             {35, 5.4110},\n             {40, 5.3122},\n             {45, 5.2307},\n             {50, 5.1380},\n         }},\n        {\"OfdmRate12Mbps\",\n         {\n             {5, 8.9515},\n             {10, 8.2901},\n             {15, 7.9102},\n             {20, 7.6319},\n             {25, 7.4274},\n             {30, 7.2447},\n             {35, 7.0829},\n             {40, 6.9544},\n             {45, 6.8485},\n             {50, 6.7278},\n         }},\n        {\"OfdmRate18Mbps\",\n         {\n             {5, 12.7822},\n             {10, 11.8801},\n             {15, 11.3543},\n             {20, 10.9668},\n             {25, 10.6809},\n             {30, 10.4249},\n             {35, 10.1978},\n             {40, 10.0171},\n             {45, 9.8679},\n             {50, 9.6978},\n         }},\n        {\"OfdmRate24Mbps\",\n         {\n             {5, 16.2470},\n             {10, 15.1426},\n             {15, 14.4904},\n             {20, 14.0072},\n             {25, 13.6496},\n             {30, 13.3288},\n             {35, 13.0436},\n             {40, 12.8164},\n             {45, 12.6286},\n             {50, 12.4144},\n         }},\n        {\"OfdmRate36Mbps\",\n         {\n             {5, 22.3164},\n             {10, 20.9147},\n             {15, 20.0649},\n             {20, 19.4289},\n             {25, 18.9552},\n             {30, 18.5284},\n             {35, 18.1476},\n             {40, 17.8434},\n             {45, 17.5915},\n             {50, 17.3036},\n         }},\n        {\"OfdmRate48Mbps\",\n         {\n             {5, 27.2963},\n             {10, 25.6987},\n             {15, 24.7069},\n             {20, 23.9578},\n             {25, 23.3965},\n             {30, 22.8891},\n             {35, 22.4350},\n             {40, 22.0713},\n             {45, 21.7696},\n             {50, 21.4243},\n         }},\n        {\"OfdmRate54Mbps\",\n         {\n             {5, 29.8324},\n             {10, 28.1519},\n             {15, 27.0948},\n             {20, 26.2925},\n             {25, 25.6896},\n             {30, 25.1434},\n             {35, 24.6539},\n             {40, 24.2613},\n             {45, 23.9353},\n             {50, 23.5618},\n         }},\n        /* 11g */\n        {\"ErpOfdmRate6Mbps\",\n         {\n             {5, 4.7087},\n             {10, 4.3453},\n             {15, 4.1397},\n             {20, 3.9899},\n             {25, 3.8802},\n             {30, 3.7824},\n             {35, 3.6961},\n             {40, 3.6276},\n             {45, 3.5712},\n             {50, 3.5071},\n         }},\n        {\"ErpOfdmRate9Mbps\",\n         {\n             {5, 6.8586},\n             {10, 6.3431},\n             {15, 6.0489},\n             {20, 5.8340},\n             {25, 5.6762},\n             {30, 5.5355},\n             {35, 5.4110},\n             {40, 5.3122},\n             {45, 5.2307},\n             {50, 5.1380},\n         }},\n        {\"ErpOfdmRate12Mbps\",\n         {\n             {5, 8.9515},\n             {10, 8.2901},\n             {15, 7.9102},\n             {20, 7.6319},\n             {25, 7.4274},\n             {30, 7.2447},\n             {35, 7.0829},\n             {40, 6.9544},\n             {45, 6.8485},\n             {50, 6.7278},\n         }},\n        {\"ErpOfdmRate18Mbps\",\n         {\n             {5, 12.7822},\n             {10, 11.8801},\n             {15, 11.3543},\n             {20, 10.9668},\n             {25, 10.6809},\n             {30, 10.4249},\n             {35, 10.1978},\n             {40, 10.0171},\n             {45, 9.8679},\n             {50, 9.6978},\n         }},\n        {\"ErpOfdmRate24Mbps\",\n         {\n             {5, 16.2470},\n             {10, 15.1426},\n             {15, 14.4904},\n             {20, 14.0072},\n             {25, 13.6496},\n             {30, 13.3288},\n             {35, 13.0436},\n             {40, 12.8164},\n             {45, 12.6286},\n             {50, 12.4144},\n         }},\n        {\"ErpOfdmRate36Mbps\",\n         {\n             {5, 22.3164},\n             {10, 20.9147},\n             {15, 20.0649},\n             {20, 19.4289},\n             {25, 18.9552},\n             {30, 18.5284},\n             {35, 18.1476},\n             {40, 17.8434},\n             {45, 17.5915},\n             {50, 17.3036},\n         }},\n        {\"ErpOfdmRate48Mbps\",\n         {\n             {5, 27.2963},\n             {10, 25.6987},\n             {15, 24.7069},\n             {20, 23.9578},\n             {25, 23.3965},\n             {30, 22.8891},\n             {35, 22.4350},\n             {40, 22.0713},\n             {45, 21.7696},\n             {50, 21.4243},\n         }},\n        {\"ErpOfdmRate54Mbps\",\n         {\n             {5, 29.8324},\n             {10, 28.1519},\n             {15, 27.0948},\n             {20, 26.2925},\n             {25, 25.6896},\n             {30, 25.1434},\n             {35, 24.6539},\n             {40, 24.2613},\n             {45, 23.9353},\n             {50, 23.5618},\n         }},\n        /* 11ax, no frame aggregation */\n        {\"HeMcs0_20MHz\",\n         {\n             {5, 6.3746},\n             {10, 5.8670},\n             {15, 5.5782},\n             {20, 5.3742},\n             {25, 5.2147},\n             {30, 5.0829},\n             {35, 4.9696},\n             {40, 4.8703},\n             {45, 4.7813},\n             {50, 4.7004},\n         }},\n        {\"HeMcs1_20MHz\",\n         {\n             {5, 11.7574},\n             {10, 10.8735},\n             {15, 10.3606},\n             {20, 9.9954},\n             {25, 9.7084},\n             {30, 9.4704},\n             {35, 9.2654},\n             {40, 9.0853},\n             {45, 8.9235},\n             {50, 8.7763},\n         }},\n        {\"HeMcs2_20MHz\",\n         {\n             {5, 16.0419},\n             {10, 14.8998},\n             {15, 14.2252},\n             {20, 13.7413},\n             {25, 13.3594},\n             {30, 13.0417},\n             {35, 12.7674},\n             {40, 12.5258},\n             {45, 12.3086},\n             {50, 12.1107},\n         }},\n        {\"HeMcs3_20MHz\",\n         {\n             {5, 20.0089},\n             {10, 18.6480},\n             {15, 17.8309},\n             {20, 17.2410},\n             {25, 16.7736},\n             {30, 16.3837},\n             {35, 16.0465},\n             {40, 15.7491},\n             {45, 15.4813},\n             {50, 15.2369},\n         }},\n        {\"HeMcs4_20MHz\",\n         {\n             {5, 26.3492},\n             {10, 24.7107},\n             {15, 23.6964},\n             {20, 22.9553},\n             {25, 22.3640},\n             {30, 21.8683},\n             {35, 21.4379},\n             {40, 21.0571},\n             {45, 20.7134},\n             {50, 20.3991},\n         }},\n        {\"HeMcs5_20MHz\",\n         {\n             {5, 30.6683},\n             {10, 28.8843},\n             {15, 27.7540},\n             {20, 26.9210},\n             {25, 26.2528},\n             {30, 25.6906},\n             {35, 25.2012},\n             {40, 24.7671},\n             {45, 24.3746},\n             {50, 24.0151},\n         }},\n        {\"HeMcs6_20MHz\",\n         {\n             {5, 33.4062},\n             {10, 31.5485},\n             {15, 30.3527},\n             {20, 29.4662},\n             {25, 28.7527},\n             {30, 28.1508},\n             {35, 27.6259},\n             {40, 27.1597},\n             {45, 26.7376},\n             {50, 26.3507},\n         }},\n        {\"HeMcs7_20MHz\",\n         {\n             {5, 34.9671},\n             {10, 33.0739},\n             {15, 31.8436},\n             {20, 30.9282},\n             {25, 30.1900},\n             {30, 29.5665},\n             {35, 29.0221},\n             {40, 28.5382},\n             {45, 28.0997},\n             {50, 27.6975},\n         }},\n        {\"HeMcs8_20MHz\",\n         {\n             {5, 38.5714},\n             {10, 36.6144},\n             {15, 35.3124},\n             {20, 34.3355},\n             {25, 33.5438},\n             {30, 32.8728},\n             {35, 32.2854},\n             {40, 31.7623},\n             {45, 31.2874},\n             {50, 30.8512},\n         }},\n        {\"HeMcs9_20MHz\",\n         {\n             {5, 40.6674},\n             {10, 38.6851},\n             {15, 37.3466},\n             {20, 36.3371},\n             {25, 35.5165},\n             {30, 34.8197},\n             {35, 34.2087},\n             {40, 33.6638},\n             {45, 33.1688},\n             {50, 32.7137},\n         }},\n        {\"HeMcs10_20MHz\",\n         {\n             {5, 40.6674},\n             {10, 38.6851},\n             {15, 37.3466},\n             {20, 36.3371},\n             {25, 35.5165},\n             {30, 34.8197},\n             {35, 34.2087},\n             {40, 33.6638},\n             {45, 33.1688},\n             {50, 32.7137},\n         }},\n        {\"HeMcs11_20MHz\",\n         {\n             {5, 43.0043},\n             {10, 41.0039},\n             {15, 39.6294},\n             {20, 38.5865},\n             {25, 37.7358},\n             {30, 37.0116},\n             {35, 36.3756},\n             {40, 35.8076},\n             {45, 35.2909},\n             {50, 34.8154},\n         }},\n        {\"HeMcs0_40MHz\",\n         {\n             {5, 11.6208},\n             {10, 10.7566},\n             {15, 10.2544},\n             {20, 9.8965},\n             {25, 9.6151},\n             {30, 9.3815},\n             {35, 9.1804},\n             {40, 9.0035},\n             {45, 8.8446},\n             {50, 8.7000},\n         }},\n        {\"HeMcs1_40MHz\",\n         {\n             {5, 19.8764},\n             {10, 18.5328},\n             {15, 17.7255},\n             {20, 17.1424},\n             {25, 16.6803},\n             {30, 16.2947},\n             {35, 15.9612},\n             {40, 15.6668},\n             {45, 15.4018},\n             {50, 15.1599},\n         }},\n        {\"HeMcs2_40MHz\",\n         {\n             {5, 26.1198},\n             {10, 24.5088},\n             {15, 23.5107},\n             {20, 22.7810},\n             {25, 22.1986},\n             {30, 21.7101},\n             {35, 21.2858},\n             {40, 20.9104},\n             {45, 20.5714},\n             {50, 20.2613},\n         }},\n        {\"HeMcs3_40MHz\",\n         {\n             {5, 30.6683},\n             {10, 28.8843},\n             {15, 27.7540},\n             {20, 26.9210},\n             {25, 26.2528},\n             {30, 25.6906},\n             {35, 25.2012},\n             {40, 24.7671},\n             {45, 24.3746},\n             {50, 24.0151},\n         }},\n        {\"HeMcs4_40MHz\",\n         {\n             {5, 38.5714},\n             {10, 36.6144},\n             {15, 35.3124},\n             {20, 34.3355},\n             {25, 33.5438},\n             {30, 32.8728},\n             {35, 32.2854},\n             {40, 31.7623},\n             {45, 31.2874},\n             {50, 30.8512},\n         }},\n        {\"HeMcs5_40MHz\",\n         {\n             {5, 43.0043},\n             {10, 41.0039},\n             {15, 39.6294},\n             {20, 38.5865},\n             {25, 37.7358},\n             {30, 37.0116},\n             {35, 36.3756},\n             {40, 35.8076},\n             {45, 35.2909},\n             {50, 34.8154},\n         }},\n        {\"HeMcs6_40MHz\",\n         {\n             {5, 45.6261},\n             {10, 43.6185},\n             {15, 42.2095},\n             {20, 41.1328},\n             {25, 40.2509},\n             {30, 39.4981},\n             {35, 38.8356},\n             {40, 38.2430},\n             {45, 37.7032},\n             {50, 37.2058},\n         }},\n        {\"HeMcs7_40MHz\",\n         {\n             {5, 45.6261},\n             {10, 43.6185},\n             {15, 42.2095},\n             {20, 41.1328},\n             {25, 40.2509},\n             {30, 39.4981},\n             {35, 38.8356},\n             {40, 38.2430},\n             {45, 37.7032},\n             {50, 37.2058},\n         }},\n        {\"HeMcs8_40MHz\",\n         {\n             {5, 48.5883},\n             {10, 46.5892},\n             {15, 45.1489},\n             {20, 44.0388},\n             {25, 43.1252},\n             {30, 42.3428},\n             {35, 41.6525},\n             {40, 41.0338},\n             {45, 40.4694},\n             {50, 39.9486},\n         }},\n        {\"HeMcs9_40MHz\",\n         {\n             {5, 51.9619},\n             {10, 49.9941},\n             {15, 48.5284},\n             {20, 47.3867},\n             {25, 46.4416},\n             {30, 45.6290},\n             {35, 44.9099},\n             {40, 44.2640},\n             {45, 43.6736},\n             {50, 43.1279},\n         }},\n        {\"HeMcs10_40MHz\",\n         {\n             {5, 51.9619},\n             {10, 49.9941},\n             {15, 48.5284},\n             {20, 47.3867},\n             {25, 46.4416},\n             {30, 45.6290},\n             {35, 44.9099},\n             {40, 44.2640},\n             {45, 43.6736},\n             {50, 43.1279},\n         }},\n        {\"HeMcs11_40MHz\",\n         {\n             {5, 51.9619},\n             {10, 49.9941},\n             {15, 48.5284},\n             {20, 47.3867},\n             {25, 46.4416},\n             {30, 45.6290},\n             {35, 44.9099},\n             {40, 44.2640},\n             {45, 43.6736},\n             {50, 43.1279},\n         }},\n        {\"HeMcs0_80MHz\",\n         {\n             {5, 20.0101},\n             {10, 18.6928},\n             {15, 17.8976},\n             {20, 17.3219},\n             {25, 16.8648},\n             {30, 16.4830},\n             {35, 16.1523},\n             {40, 15.8603},\n             {45, 15.5971},\n             {50, 15.3567},\n         }},\n        {\"HeMcs1_80MHz\",\n         {\n             {5, 31.6415},\n             {10, 29.8575},\n             {15, 28.7177},\n             {20, 27.8747},\n             {25, 27.1971},\n             {30, 26.6261},\n             {35, 26.1283},\n             {40, 25.6865},\n             {45, 25.2866},\n             {50, 24.9200},\n         }},\n        {\"HeMcs2_80MHz\",\n         {\n             {5, 38.0818},\n             {10, 36.1730},\n             {15, 34.9016},\n             {20, 33.9470},\n             {25, 33.1729},\n             {30, 32.5165},\n             {35, 31.9417},\n             {40, 31.4295},\n             {45, 30.9645},\n             {50, 30.5372},\n         }},\n        {\"HeMcs3_80MHz\",\n         {\n             {5, 43.0043},\n             {10, 41.0039},\n             {15, 39.6294},\n             {20, 38.5865},\n             {25, 37.7358},\n             {30, 37.0116},\n             {35, 36.3756},\n             {40, 35.8076},\n             {45, 35.2909},\n             {50, 34.8154},\n         }},\n        {\"HeMcs4_80MHz\",\n         {\n             {5, 48.5883},\n             {10, 46.5892},\n             {15, 45.1489},\n             {20, 44.0388},\n             {25, 43.1252},\n             {30, 42.3428},\n             {35, 41.6525},\n             {40, 41.0338},\n             {45, 40.4694},\n             {50, 39.9486},\n         }},\n        {\"HeMcs5_80MHz\",\n         {\n             {5, 51.9619},\n             {10, 49.9941},\n             {15, 48.5284},\n             {20, 47.3867},\n             {25, 46.4416},\n             {30, 45.6290},\n             {35, 44.9099},\n             {40, 44.2640},\n             {45, 43.6736},\n             {50, 43.1279},\n         }},\n        {\"HeMcs6_80MHz\",\n         {\n             {5, 55.8389},\n             {10, 53.9360},\n             {15, 52.4548},\n             {20, 51.2855},\n             {25, 50.3106},\n             {30, 49.4682},\n             {35, 48.7201},\n             {40, 48.0462},\n             {45, 47.4288},\n             {50, 46.8571},\n         }},\n        {\"HeMcs7_80MHz\",\n         {\n             {5, 55.8389},\n             {10, 53.9360},\n             {15, 52.4548},\n             {20, 51.2855},\n             {25, 50.3106},\n             {30, 49.4682},\n             {35, 48.7201},\n             {40, 48.0462},\n             {45, 47.4288},\n             {50, 46.8571},\n         }},\n        {\"HeMcs8_80MHz\",\n         {\n             {5, 55.8389},\n             {10, 53.9360},\n             {15, 52.4548},\n             {20, 51.2855},\n             {25, 50.3106},\n             {30, 49.4682},\n             {35, 48.7201},\n             {40, 48.0462},\n             {45, 47.4288},\n             {50, 46.8571},\n         }},\n        {\"HeMcs9_80MHz\",\n         {\n             {5, 60.3411},\n             {10, 58.5527},\n             {15, 57.0724},\n             {20, 55.8834},\n             {25, 54.8827},\n             {30, 54.0128},\n             {35, 53.2368},\n             {40, 52.5352},\n             {45, 51.8906},\n             {50, 51.2922},\n         }},\n        {\"HeMcs10_80MHz\",\n         {\n             {5, 60.3411},\n             {10, 58.5527},\n             {15, 57.0724},\n             {20, 55.8834},\n             {25, 54.8827},\n             {30, 54.0128},\n             {35, 53.2368},\n             {40, 52.5352},\n             {45, 51.8906},\n             {50, 51.2922},\n         }},\n        {\"HeMcs11_80MHz\",\n         {\n             {5, 60.3411},\n             {10, 58.5527},\n             {15, 57.0724},\n             {20, 55.8834},\n             {25, 54.8827},\n             {30, 54.0128},\n             {35, 53.2368},\n             {40, 52.5352},\n             {45, 51.8906},\n             {50, 51.2922},\n         }},\n        {\"HeMcs0_160MHz\",\n         {\n             {5, 30.6710},\n             {10, 28.9919},\n             {15, 27.9160},\n             {20, 27.1188},\n             {25, 26.4770},\n             {30, 25.9355},\n             {35, 25.4630},\n             {40, 25.0432},\n             {45, 24.6629},\n             {50, 24.3141},\n         }},\n        {\"HeMcs1_160MHz\",\n         {\n             {5, 42.3965},\n             {10, 40.4510},\n             {15, 39.1127},\n             {20, 38.0965},\n             {25, 37.2670},\n             {30, 36.5606},\n             {35, 35.9398},\n             {40, 35.3852},\n             {45, 34.8806},\n             {50, 34.4160},\n         }},\n        {\"HeMcs2_160MHz\",\n         {\n             {5, 47.8139},\n             {10, 45.8767},\n             {15, 44.4795},\n             {20, 43.4017},\n             {25, 42.5141},\n             {30, 41.7535},\n             {35, 41.0821},\n             {40, 40.4801},\n             {45, 39.9307},\n             {50, 39.4236},\n         }},\n        {\"HeMcs3_160MHz\",\n         {\n             {5, 51.9619},\n             {10, 49.9941},\n             {15, 48.5284},\n             {20, 47.3867},\n             {25, 46.4416},\n             {30, 45.6290},\n             {35, 44.9099},\n             {40, 44.2640},\n             {45, 43.6736},\n             {50, 43.1279},\n         }},\n        {\"HeMcs4_160MHz\",\n         {\n             {5, 55.8389},\n             {10, 53.9360},\n             {15, 52.4548},\n             {20, 51.2855},\n             {25, 50.3106},\n             {30, 49.4682},\n             {35, 48.7201},\n             {40, 48.0462},\n             {45, 47.4288},\n             {50, 46.8571},\n         }},\n        {\"HeMcs5_160MHz\",\n         {\n             {5, 60.3411},\n             {10, 58.5527},\n             {15, 57.0724},\n             {20, 55.8834},\n             {25, 54.8827},\n             {30, 54.0128},\n             {35, 53.2368},\n             {40, 52.5352},\n             {45, 51.8906},\n             {50, 51.2922},\n         }},\n        {\"HeMcs6_160MHz\",\n         {\n             {5, 60.3411},\n             {10, 58.5527},\n             {15, 57.0724},\n             {20, 55.8834},\n             {25, 54.8827},\n             {30, 54.0128},\n             {35, 53.2368},\n             {40, 52.5352},\n             {45, 51.8906},\n             {50, 51.2922},\n         }},\n        {\"HeMcs7_160MHz\",\n         {\n             {5, 60.3411},\n             {10, 58.5527},\n             {15, 57.0724},\n             {20, 55.8834},\n             {25, 54.8827},\n             {30, 54.0128},\n             {35, 53.2368},\n             {40, 52.5352},\n             {45, 51.8906},\n             {50, 51.2922},\n         }},\n        {\"HeMcs8_160MHz\",\n         {\n             {5, 60.3411},\n             {10, 58.5527},\n             {15, 57.0724},\n             {20, 55.8834},\n             {25, 54.8827},\n             {30, 54.0128},\n             {35, 53.2368},\n             {40, 52.5352},\n             {45, 51.8906},\n             {50, 51.2922},\n         }},\n        {\"HeMcs9_160MHz\",\n         {\n             {5, 65.6329},\n             {10, 64.0336},\n             {15, 62.5814},\n             {20, 61.3869},\n             {25, 60.3690},\n             {30, 59.4769},\n             {35, 58.6764},\n             {40, 57.9495},\n             {45, 57.2790},\n             {50, 56.6548},\n         }},\n        {\"HeMcs10_160MHz\",\n         {\n             {5, 65.6329},\n             {10, 64.0336},\n             {15, 62.5814},\n             {20, 61.3869},\n             {25, 60.3690},\n             {30, 59.4769},\n             {35, 58.6764},\n             {40, 57.9495},\n             {45, 57.2790},\n             {50, 56.6548},\n         }},\n        {\"HeMcs11_160MHz\",\n         {\n             {5, 65.6329},\n             {10, 64.0336},\n             {15, 62.5814},\n             {20, 61.3869},\n             {25, 60.3690},\n             {30, 59.4769},\n             {35, 58.6764},\n             {40, 57.9495},\n             {45, 57.2790},\n             {50, 56.6548},\n         }},\n};\n\n/**\n * Parse context strings of the form \"/NodeList/x/DeviceList/x/...\" to extract the NodeId integer\n *\n * @param context The context to parse.\n * @return the NodeId\n */\nuint32_t\nContextToNodeId(std::string context)\n{\n    std::string sub = context.substr(10);\n    uint32_t pos = sub.find(\"/Device\");\n    return std::stoi(sub.substr(0, pos));\n}\n\n/**\n * Parse context strings of the form \"/NodeList/x/DeviceList/x/...\" and fetch the Mac address\n *\n * @param context The context to parse.\n * @return the device MAC address\n */\nMac48Address\nContextToMac(std::string context)\n{\n    std::string sub = context.substr(10);\n    uint32_t pos = sub.find(\"/Device\");\n    uint32_t nodeId = std::stoi(sub.substr(0, pos));\n    Ptr<Node> n = NodeList::GetNode(nodeId);\n    Ptr<WifiNetDevice> d;\n    for (uint32_t i = 0; i < n->GetNDevices(); i++)\n    {\n        d = n->GetDevice(i)->GetObject<WifiNetDevice>();\n        if (d)\n        {\n            break;\n        }\n    }\n    return Mac48Address::ConvertFrom(d->GetAddress());\n}\n\n// Functions for tracing.\n\n/**\n * Increment the counter for a given address.\n *\n * @param [out] counter The counter to increment.\n * @param addr The address to increment the counter for.\n * @param increment The increment (1 if omitted).\n */\nvoid\nIncrementCounter(std::map<Mac48Address, uint64_t>& counter,\n                 Mac48Address addr,\n                 uint64_t increment = 1)\n{\n    auto it = counter.find(addr);\n    if (it != counter.end())\n    {\n        it->second += increment;\n    }\n    else\n    {\n        counter.insert(std::make_pair(addr, increment));\n    }\n}\n\n/**\n * Trace a packet reception.\n *\n * @param context The context.\n * @param p The packet.\n * @param channelFreqMhz The channel frequqncy.\n * @param txVector The TX vector.\n * @param aMpdu The AMPDU.\n * @param signalNoise The signal and noise dBm.\n * @param staId The STA ID.\n */\nvoid\nTracePacketReception(std::string context,\n                     Ptr<const Packet> p,\n                     uint16_t channelFreqMhz,\n                     WifiTxVector txVector,\n                     MpduInfo aMpdu,\n                     SignalNoiseDbm signalNoise,\n                     uint16_t staId)\n{\n    Ptr<Packet> packet = p->Copy();\n    if (txVector.IsAggregation())\n    {\n        AmpduSubframeHeader subHdr;\n        uint32_t extractedLength;\n        packet->RemoveHeader(subHdr);\n        extractedLength = subHdr.GetLength();\n        packet = packet->CreateFragment(0, static_cast<uint32_t>(extractedLength));\n    }\n    WifiMacHeader hdr;\n    packet->PeekHeader(hdr);\n    // hdr.GetAddr1() is the receiving MAC address\n    if (hdr.GetAddr1() != ContextToMac(context))\n    {\n        return;\n    }\n    // hdr.GetAddr2() is the sending MAC address\n    if (packet->GetSize() >= pktSize) // ignore non-data frames\n    {\n        IncrementCounter(packetsReceived, hdr.GetAddr2());\n        IncrementCounter(bytesReceived, hdr.GetAddr2(), pktSize);\n        auto itTimeFirstReceived = timeFirstReceived.find(hdr.GetAddr2());\n        if (itTimeFirstReceived == timeFirstReceived.end())\n        {\n            timeFirstReceived.insert(std::make_pair(hdr.GetAddr2(), Simulator::Now()));\n        }\n        auto itTimeLastReceived = timeLastReceived.find(hdr.GetAddr2());\n        if (itTimeLastReceived != timeLastReceived.end())\n        {\n            itTimeLastReceived->second = Simulator::Now();\n        }\n        else\n        {\n            timeLastReceived.insert(std::make_pair(hdr.GetAddr2(), Simulator::Now()));\n        }\n    }\n}\n\n/**\n * Contention window trace.\n *\n * @param context The context.\n * @param cw The contention window.\n */\nvoid\nCwTrace(std::string context, uint32_t cw, uint8_t /* linkId */)\n{\n    NS_LOG_INFO(\"CW time=\" << Simulator::Now() << \" node=\" << ContextToNodeId(context)\n                           << \" val=\" << cw);\n    if (tracing)\n    {\n        cwTraceFile << Simulator::Now().GetSeconds() << \" \" << ContextToNodeId(context) << \" \" << cw\n                    << std::endl;\n    }\n\n#ifdef HAS_NETSIMULYZER\n    if (enableVisualization)\n    {\n        cwTraceSeries.find(ContextToNodeId(context))\n            ->second->Append(Simulator::Now().GetSeconds(), cw);\n    }\n#endif\n}\n\n/**\n * Backoff trace.\n *\n * @param context The context.\n * @param newVal The backoff value.\n */\nvoid\nBackoffTrace(std::string context, uint32_t newVal, uint8_t /* linkId */)\n{\n    NS_LOG_INFO(\"Backoff time=\" << Simulator::Now() << \" node=\" << ContextToNodeId(context)\n                                << \" val=\" << newVal);\n    if (tracing)\n    {\n        backoffTraceFile << Simulator::Now().GetSeconds() << \" \" << ContextToNodeId(context) << \" \"\n                         << newVal << std::endl;\n    }\n\n#ifdef HAS_NETSIMULYZER\n    if (enableVisualization)\n    {\n        backoffTraceSeries.find(ContextToNodeId(context))\n            ->second->Append(Simulator::Now().GetSeconds(), newVal);\n    }\n#endif\n}\n\n/**\n * PHY Rx trace.\n *\n * @param context The context.\n * @param p The packet.\n * @param power The Rx power.\n */\nvoid\nPhyRxTrace(std::string context, Ptr<const Packet> p, RxPowerWattPerChannelBand power)\n{\n    NS_LOG_INFO(\"PHY-RX-START time=\" << Simulator::Now() << \" node=\" << ContextToNodeId(context)\n                                     << \" size=\" << p->GetSize());\n}\n\n/**\n * PHY Rx trace.\n *\n * @param context The context.\n * @param txVector The TX vector.\n * @param psduDuration The PDSU diration.\n */\nvoid\nPhyRxPayloadTrace(std::string context, WifiTxVector txVector, Time psduDuration)\n{\n    NS_LOG_INFO(\"PHY-RX-PAYLOAD-START time=\" << Simulator::Now()\n                                             << \" node=\" << ContextToNodeId(context)\n                                             << \" psduDuration=\" << psduDuration);\n}\n\n/**\n * PHY Drop trace.\n *\n * @param context The context.\n * @param p The packet.\n * @param reason The drop reason.\n */\nvoid\nPhyRxDropTrace(std::string context, Ptr<const Packet> p, WifiPhyRxfailureReason reason)\n{\n    NS_LOG_INFO(\"PHY-RX-DROP time=\" << Simulator::Now() << \" node=\" << ContextToNodeId(context)\n                                    << \" size=\" << p->GetSize() << \" reason=\" << reason);\n    Mac48Address addr = ContextToMac(context);\n    switch (reason)\n    {\n    case UNSUPPORTED_SETTINGS:\n        NS_FATAL_ERROR(\"RX packet with unsupported settings!\");\n        break;\n    case CHANNEL_SWITCHING:\n        NS_FATAL_ERROR(\"Channel is switching!\");\n        break;\n    case BUSY_DECODING_PREAMBLE: {\n        if (p->GetSize() >= pktSize) // ignore non-data frames\n        {\n            IncrementCounter(rxEventWhileDecodingPreamble, addr);\n        }\n        break;\n    }\n    case RXING: {\n        if (p->GetSize() >= pktSize) // ignore non-data frames\n        {\n            IncrementCounter(rxEventWhileRxing, addr);\n        }\n        break;\n    }\n    case TXING: {\n        if (p->GetSize() >= pktSize) // ignore non-data frames\n        {\n            IncrementCounter(rxEventWhileTxing, addr);\n        }\n        break;\n    }\n    case SLEEPING:\n        NS_FATAL_ERROR(\"Device is sleeping!\");\n        break;\n    case PREAMBLE_DETECT_FAILURE:\n        NS_FATAL_ERROR(\"Preamble should always be detected!\");\n        break;\n    case RECEPTION_ABORTED_BY_TX: {\n        if (p->GetSize() >= pktSize) // ignore non-data frames\n        {\n            IncrementCounter(rxEventAbortedByTx, addr);\n        }\n        break;\n    }\n    case L_SIG_FAILURE: {\n        if (p->GetSize() >= pktSize) // ignore non-data frames\n        {\n            IncrementCounter(phyHeaderFailed, addr);\n        }\n        break;\n    }\n    case HT_SIG_FAILURE:\n    case SIG_A_FAILURE:\n    case SIG_B_FAILURE:\n        NS_FATAL_ERROR(\"Unexpected PHY header failure!\");\n    case PREAMBLE_DETECTION_PACKET_SWITCH:\n        NS_FATAL_ERROR(\"All devices should send with same power, so no packet switch during \"\n                       \"preamble detection should occur!\");\n        break;\n    case FRAME_CAPTURE_PACKET_SWITCH:\n        NS_FATAL_ERROR(\"Frame capture should be disabled!\");\n        break;\n    case OBSS_PD_CCA_RESET:\n        NS_FATAL_ERROR(\"Unexpected CCA reset!\");\n        break;\n    case SIGNAL_DETECTION_ABORTED_BY_TX:\n        break;\n    case UNKNOWN:\n    default:\n        NS_FATAL_ERROR(\"Unknown drop reason!\");\n        break;\n    }\n}\n\n/**\n * PHY RX end trace\n *\n * @param context The context.\n * @param p The packet.\n */\nvoid\nPhyRxDoneTrace(std::string context, Ptr<const Packet> p)\n{\n    NS_LOG_INFO(\"PHY-RX-END time=\" << Simulator::Now() << \" node=\" << ContextToNodeId(context)\n                                   << \" size=\" << p->GetSize());\n}\n\n/**\n * PHY successful RX trace\n *\n * @param context The context.\n * @param p The packet.\n * @param snr The SNR.\n * @param mode The WiFi mode.\n * @param preamble The preamble.\n */\nvoid\nPhyRxOkTrace(std::string context,\n             Ptr<const Packet> p,\n             double snr,\n             WifiMode mode,\n             WifiPreamble preamble)\n{\n    uint8_t nMpdus = (p->GetSize() / pktSize);\n    NS_LOG_INFO(\"PHY-RX-OK time=\" << Simulator::Now().As(Time::S) << \" node=\"\n                                  << ContextToNodeId(context) << \" size=\" << p->GetSize()\n                                  << \" nMPDUs=\" << +nMpdus << \" snr=\" << snr << \" mode=\" << mode\n                                  << \" preamble=\" << preamble);\n    if ((maxMpdus != 0) && (nMpdus != 0) && (nMpdus != maxMpdus))\n    {\n        if (nMpdus > maxMpdus)\n        {\n            NS_FATAL_ERROR(\"A-MPDU settings not properly applied: maximum configured MPDUs is \"\n                           << +maxMpdus << \" but received an A-MPDU containing \" << +nMpdus\n                           << \" MPDUs\");\n        }\n        NS_LOG_WARN(\"Warning: less MPDUs aggregated in a received A-MPDU (\"\n                    << +nMpdus << \") than configured (\" << +maxMpdus << \")\");\n    }\n    if (p->GetSize() >= pktSize) // ignore non-data frames\n    {\n        Mac48Address addr = ContextToMac(context);\n        IncrementCounter(psduSucceeded, addr);\n    }\n}\n\n/**\n * PHY RX error trace\n *\n * @param context The context.\n * @param p The packet.\n * @param snr The SNR.\n */\nvoid\nPhyRxErrorTrace(std::string context, Ptr<const Packet> p, double snr)\n{\n    NS_LOG_INFO(\"PHY-RX-ERROR time=\" << Simulator::Now() << \" node=\" << ContextToNodeId(context)\n                                     << \" size=\" << p->GetSize() << \" snr=\" << snr);\n    if (p->GetSize() >= pktSize) // ignore non-data frames\n    {\n        Mac48Address addr = ContextToMac(context);\n        IncrementCounter(psduFailed, addr);\n    }\n}\n\n/**\n * PHY TX trace\n *\n * @param context The context.\n * @param p The packet.\n * @param txPowerW The TX power.\n */\nvoid\nPhyTxTrace(std::string context, Ptr<const Packet> p, double txPowerW)\n{\n    NS_LOG_INFO(\"PHY-TX-START time=\" << Simulator::Now() << \" node=\" << ContextToNodeId(context)\n                                     << \" size=\" << p->GetSize() << \" \" << txPowerW);\n    if (tracing)\n    {\n        phyTxTraceFile << Simulator::Now().GetSeconds() << \" \" << ContextToNodeId(context)\n                       << \" size=\" << p->GetSize() << \" \" << txPowerW << std::endl;\n    }\n    if (p->GetSize() >= pktSize) // ignore non-data frames\n    {\n        Mac48Address addr = ContextToMac(context);\n        IncrementCounter(packetsTransmitted, addr);\n    }\n}\n\n/**\n * PHY TX end trace.\n *\n * @param context The context.\n * @param p The packet.\n */\nvoid\nPhyTxDoneTrace(std::string context, Ptr<const Packet> p)\n{\n    NS_LOG_INFO(\"PHY-TX-END time=\" << Simulator::Now() << \" node=\" << ContextToNodeId(context)\n                                   << \" \" << p->GetSize());\n}\n\n/**\n * MAC TX trace.\n *\n * @param context The context.\n * @param p The packet.\n */\nvoid\nMacTxTrace(std::string context, Ptr<const Packet> p)\n{\n    if (tracing)\n    {\n        macTxTraceFile << Simulator::Now().GetSeconds() << \" \" << ContextToNodeId(context) << \" \"\n                       << p->GetSize() << std::endl;\n    }\n\n#ifdef HAS_NETSIMULYZER\n    if (enableVisualization)\n    {\n        const auto it = macTxTraceSeries.find(ContextToNodeId(context));\n        it->second->AddPacketSize(p->GetSize());\n    }\n#endif\n}\n\n/**\n * MAC RX trace.\n *\n * @param context The context.\n * @param p The packet.\n */\nvoid\nMacRxTrace(std::string context, Ptr<const Packet> p)\n{\n    if (tracing)\n    {\n        macRxTraceFile << Simulator::Now().GetSeconds() << \" \" << ContextToNodeId(context) << \" \"\n                       << p->GetSize() << std::endl;\n    }\n#ifdef HAS_NETSIMULYZER\n    if (enableVisualization)\n    {\n        const auto it = macRxTraceSeries.find(ContextToNodeId(context));\n        it->second->AddPacketSize(p->GetSize());\n        macRxTotalTraceSeries->AddPacketSize(p->GetSize());\n    }\n#endif\n}\n\n/**\n * Socket send trace.\n *\n * @param context The context.\n * @param p The packet.\n * @param addr destination address.\n */\nvoid\nSocketSendTrace(std::string context, Ptr<const Packet> p, const Address& addr)\n{\n    if (tracing)\n    {\n        socketSendTraceFile << Simulator::Now().GetSeconds() << \" \" << ContextToNodeId(context)\n                            << \" \" << p->GetSize() << \" \" << addr << std::endl;\n    }\n}\n\n/**\n * Association log trace.\n *\n * @param context The context.\n * @param address The MAC address.\n */\nvoid\nAssociationLog(std::string context, Mac48Address address)\n{\n    uint32_t nodeId = ContextToNodeId(context);\n    auto it = associated.find(nodeId);\n    if (it == associated.end())\n    {\n        NS_LOG_DEBUG(\"Association: time=\" << Simulator::Now() << \" node=\" << nodeId);\n        associated.insert(it, nodeId);\n    }\n    else\n    {\n        NS_FATAL_ERROR(nodeId << \" is already associated!\");\n    }\n#ifdef HAS_NETSIMULYZER\n    if (enableVisualization)\n    {\n        associatedSeries->Append(Simulator::Now().GetSeconds(), static_cast<double>(associated.size()));\n    }\n#endif\n}\n\n/**\n * Deassociation log trace.\n *\n * @param context The context.\n * @param address The MAC address.\n */\nvoid\nDisassociationLog(std::string context, Mac48Address address)\n{\n    uint32_t nodeId = ContextToNodeId(context);\n    NS_LOG_DEBUG(\"Disassociation: time=\" << Simulator::Now() << \" node=\" << nodeId);\n    NS_FATAL_ERROR(\"Device should not disassociate!\");\n}\n\n/**\n * Reset the stats.\n */\nvoid\nRestartCalc()\n{\n    bytesReceived.clear();\n    packetsReceived.clear();\n    packetsTransmitted.clear();\n    psduFailed.clear();\n    psduSucceeded.clear();\n    phyHeaderFailed.clear();\n    timeFirstReceived.clear();\n    timeLastReceived.clear();\n    rxEventWhileDecodingPreamble.clear();\n    rxEventWhileRxing.clear();\n    rxEventWhileTxing.clear();\n    rxEventAbortedByTx.clear();\n}\n\n/**\n * Class to configure and run an experiment.\n */\nclass Experiment\n{\n  public:\n    Experiment();\n\n    /**\n     * Configure and run the experiment.\n     *\n     * @param wifi the pre-configured WifiHelper\n     * @param wifiPhy the pre-configured YansWifiPhyHelper\n     * @param wifiMac the pre-configured WifiMacHelper\n     * @param wifiChannel the pre-configured YansWifiChannelHelper\n     * @param trialNumber the trial index\n     * @param networkSize the number of stations\n     * @param duration the duration of each simulation run\n     * @param pcap flag to enable/disable PCAP files generation\n     * @param infra flag to enable infrastructure model, ring adhoc network if not set\n     * @param guardIntervalNs the guard interval in ns\n     * @param distance the distance\n     * @param apTxPower the AP transmit power\n     * @param staTxPower the STA transmit power\n     * @param pktInterval the packet interval\n     * @return 0 if all went well\n     */\n    int Run(const WifiHelper& wifi,\n            const YansWifiPhyHelper& wifiPhy,\n            const WifiMacHelper& wifiMac,\n            const YansWifiChannelHelper& wifiChannel,\n            uint32_t trialNumber,\n            uint32_t networkSize,\n            Time duration,\n            bool pcap,\n            bool infra,\n            uint16_t guardIntervalNs,\n            meter_u distance,\n            dBm_u apTxPower,\n            dBm_u staTxPower,\n            Time pktInterval);\n};\n\nExperiment::Experiment()\n{\n}\n\nint\nExperiment::Run(const WifiHelper& helper,\n                const YansWifiPhyHelper& wifiPhy,\n                const WifiMacHelper& wifiMac,\n                const YansWifiChannelHelper& wifiChannel,\n                uint32_t trialNumber,\n                uint32_t networkSize,\n                Time duration,\n                bool pcap,\n                bool infra,\n                uint16_t guardIntervalNs,\n                meter_u distance,\n                dBm_u apTxPower,\n                dBm_u staTxPower,\n                Time pktInterval)\n{\n    RngSeedManager::SetSeed(10);\n    RngSeedManager::SetRun(10);\n\n    NodeContainer wifiNodes;\n    if (infra)\n    {\n        wifiNodes.Create(networkSize + 1);\n    }\n    else\n    {\n        wifiNodes.Create(networkSize);\n    }\n\n    YansWifiPhyHelper phy = wifiPhy;\n    phy.SetErrorRateModel(\"ns3::NistErrorRateModel\");\n    phy.SetChannel(wifiChannel.Create());\n    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n\n    WifiMacHelper mac = wifiMac;\n    const auto& wifi = helper;\n    NetDeviceContainer devices;\n    uint32_t nNodes = wifiNodes.GetN();\n    if (infra)\n    {\n        Ssid ssid = Ssid(\"wifi-bianchi\");\n        uint64_t beaconInterval = std::min<uint64_t>(\n            (ceil((duration.GetSeconds() * 1000000) / 1024) * 1024),\n            (65535 * 1024)); // beacon interval needs to be a multiple of time units (1024 us)\n        mac.SetType(\"ns3::ApWifiMac\",\n                    \"BeaconInterval\",\n                    TimeValue(MicroSeconds(beaconInterval)),\n                    \"Ssid\",\n                    SsidValue(ssid));\n        phy.Set(\"TxPowerStart\", DoubleValue(apTxPower));\n        phy.Set(\"TxPowerEnd\", DoubleValue(apTxPower));\n        devices = wifi.Install(phy, mac, wifiNodes.Get(0));\n\n        mac.SetType(\"ns3::StaWifiMac\",\n                    \"MaxMissedBeacons\",\n                    UintegerValue(std::numeric_limits<uint32_t>::max()),\n                    \"Ssid\",\n                    SsidValue(ssid));\n        phy.Set(\"TxPowerStart\", DoubleValue(staTxPower));\n        phy.Set(\"TxPowerEnd\", DoubleValue(staTxPower));\n        for (uint32_t i = 1; i < nNodes; ++i)\n        {\n            devices.Add(wifi.Install(phy, mac, wifiNodes.Get(i)));\n        }\n    }\n    else\n    {\n        mac.SetType(\"ns3::AdhocWifiMac\");\n        phy.Set(\"TxPowerStart\", DoubleValue(staTxPower));\n        phy.Set(\"TxPowerEnd\", DoubleValue(staTxPower));\n        devices = wifi.Install(phy, mac, wifiNodes);\n    }\n\n    WifiHelper::AssignStreams(devices, trialNumber);\n\n    Config::Set(\n        \"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HtConfiguration/ShortGuardIntervalSupported\",\n        BooleanValue(guardIntervalNs == 400));\n    Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HeConfiguration/GuardInterval\",\n                TimeValue(NanoSeconds(guardIntervalNs)));\n\n    // Configure aggregation\n    for (uint32_t i = 0; i < nNodes; ++i)\n    {\n        Ptr<NetDevice> dev = wifiNodes.Get(i)->GetDevice(0);\n        Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n        wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\",\n                                         UintegerValue(maxMpdus * (pktSize + 50)));\n        wifi_dev->GetMac()->SetAttribute(\"BK_MaxAmpduSize\",\n                                         UintegerValue(maxMpdus * (pktSize + 50)));\n        wifi_dev->GetMac()->SetAttribute(\"VO_MaxAmpduSize\",\n                                         UintegerValue(maxMpdus * (pktSize + 50)));\n        wifi_dev->GetMac()->SetAttribute(\"VI_MaxAmpduSize\",\n                                         UintegerValue(maxMpdus * (pktSize + 50)));\n    }\n\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    // Set position for AP\n    positionAlloc->Add(Vector(1.0, 1.0, 0.0));\n\n    // Set position for STAs\n    const auto angle = (static_cast<degree_u>(360) / (nNodes - 1));\n    for (uint32_t i = 0; i < (nNodes - 1); ++i)\n    {\n        positionAlloc->Add(Vector(1.0 + (distance * cos((i * angle * PI) / 180)),\n                                  1.0 + (distance * sin((i * angle * PI) / 180)),\n                                  0.0));\n    }\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(wifiNodes);\n\n    PacketSocketHelper packetSocket;\n    packetSocket.Install(wifiNodes);\n\n    ApplicationContainer apps;\n    Ptr<UniformRandomVariable> startTime = CreateObject<UniformRandomVariable>();\n    startTime->SetAttribute(\"Stream\", IntegerValue(trialNumber));\n    startTime->SetAttribute(\"Max\", DoubleValue(5.0));\n#ifdef HAS_NETSIMULYZER\n    // To better view impact of growing number of transmitting devices, we spread the start time\n    // more\n    startTime->SetAttribute(\"Max\", DoubleValue(duration.GetSeconds() * 0.75));\n#endif\n\n    uint32_t i = infra ? 1 : 0;\n    for (; i < nNodes; ++i)\n    {\n        uint32_t j = infra ? 0 : (i + 1) % nNodes;\n        PacketSocketAddress socketAddr;\n        socketAddr.SetSingleDevice(devices.Get(i)->GetIfIndex());\n        socketAddr.SetPhysicalAddress(devices.Get(j)->GetAddress());\n        socketAddr.SetProtocol(1);\n\n        Ptr<PacketSocketClient> client = CreateObject<PacketSocketClient>();\n        client->SetRemote(socketAddr);\n        wifiNodes.Get(i)->AddApplication(client);\n        client->SetAttribute(\"PacketSize\", UintegerValue(pktSize));\n        client->SetAttribute(\"MaxPackets\", UintegerValue(0));\n        client->SetAttribute(\"Interval\", TimeValue(pktInterval));\n        double start = startTime->GetValue();\n        NS_LOG_DEBUG(\"Client \" << i << \" starting at \" << start);\n#ifdef HAS_NETSIMULYZER\n        if (enableVisualization)\n        {\n            std::ostringstream oss;\n            oss << \"Client \" << i << \" starting\\n\";\n            Simulator::Schedule(Seconds(start), &WriteApplicationLog, oss.str());\n        }\n#endif\n        client->SetStartTime(Seconds(start));\n\n        Ptr<PacketSocketServer> server = CreateObject<PacketSocketServer>();\n        server->SetLocal(socketAddr);\n        wifiNodes.Get(j)->AddApplication(server);\n    }\n\n    // Log packet receptions\n    Config::Connect(\n        \"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/MonitorSnifferRx\",\n        MakeCallback(&TracePacketReception));\n\n    // Log association and disassociation\n    if (infra)\n    {\n        Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/$ns3::StaWifiMac/Assoc\",\n                        MakeCallback(&AssociationLog));\n        Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/$ns3::StaWifiMac/DeAssoc\",\n                        MakeCallback(&DisassociationLog));\n    }\n\n    std::string txop =\n        StaticCast<WifiNetDevice>(wifiNodes.Get(0)->GetDevice(0))->GetMac()->GetQosSupported()\n            ? \"BE_Txop\"\n            : \"Txop\";\n    // Trace CW evolution\n    Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/$ns3::WifiMac/\" + txop +\n                        \"/CwTrace\",\n                    MakeCallback(&CwTrace));\n    // Trace backoff evolution\n    Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/$ns3::WifiMac/\" + txop +\n                        \"/BackoffTrace\",\n                    MakeCallback(&BackoffTrace));\n    // Trace PHY Tx start events\n    Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/PhyTxBegin\",\n                    MakeCallback(&PhyTxTrace));\n    // Trace PHY Tx end events\n    Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/PhyTxEnd\",\n                    MakeCallback(&PhyTxDoneTrace));\n    // Trace PHY Rx start events\n    Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/PhyRxBegin\",\n                    MakeCallback(&PhyRxTrace));\n    // Trace PHY Rx payload start events\n    Config::Connect(\n        \"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/PhyRxPayloadBegin\",\n        MakeCallback(&PhyRxPayloadTrace));\n    // Trace PHY Rx drop events\n    Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/PhyRxDrop\",\n                    MakeCallback(&PhyRxDropTrace));\n    // Trace PHY Rx end events\n    Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/PhyRxEnd\",\n                    MakeCallback(&PhyRxDoneTrace));\n    // Trace PHY Rx error events\n    Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/State/RxError\",\n                    MakeCallback(&PhyRxErrorTrace));\n    // Trace PHY Rx success events\n    Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/State/RxOk\",\n                    MakeCallback(&PhyRxOkTrace));\n    // Trace packet transmission by the device\n    Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/MacTx\",\n                    MakeCallback(&MacTxTrace));\n    // Trace packet receptions to the device\n    Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/MacRx\",\n                    MakeCallback(&MacRxTrace));\n    // Trace packets transmitted by the application\n    Config::Connect(\"/NodeList/*/$ns3::Node/ApplicationList/*/$ns3::PacketSocketClient/Tx\",\n                    MakeCallback(&SocketSendTrace));\n\n    WifiTxStatsHelper wifiTxStats;\n    if (useTxHelper)\n    {\n        // Setup Wi-Fi Transmission Statistics Helper (WifiTxStatsHelper) for all devices\n        wifiTxStats.Enable(devices);\n        wifiTxStats.Start(Seconds(10));\n        wifiTxStats.Stop(Seconds(10) + duration);\n    }\n\n    WifiPhyRxTraceHelper rxTraceHelper;\n    if (useRxHelper)\n    {\n        // Setup Wi-Fi PHY Reception Trace Helper (WifiPhyRxTraceHelper) for all devices\n        rxTraceHelper.Enable(devices);\n        rxTraceHelper.Start(Seconds(10));\n        rxTraceHelper.Stop(Seconds(10) + duration);\n    }\n\n    Simulator::Schedule(Seconds(10), &RestartCalc);\n    Simulator::Stop(Seconds(10) + duration);\n\n    if (pcap)\n    {\n        phy.EnablePcap(\"wifi_bianchi_pcap\", devices);\n    }\n\n#ifdef HAS_NETSIMULYZER\n    /* Define graphs to visualize */\n    if (enableVisualization)\n    {\n        NS_LOG_INFO(\"Enabling visualization...\");\n\n        std::ostringstream oss;\n        oss << \"Bianchi-\" << trialNumber << \"-\" << networkSize << \"-\" << infra << \".json\";\n        orchestrator = CreateObject<netsimulyzer::Orchestrator>(\n            oss.str()); /** make name include trial and network size **/\n        orchestrator->SetAttribute(\"MobilityPollInterval\", TimeValue(MilliSeconds(guiResolution)));\n\n        // Configure nodes\n        netsimulyzer::NodeConfigurationHelper nodeConfigHelper(orchestrator);\n        nodeConfigHelper.Set(\"Scale\", DoubleValue(0.05));\n        if (infra)\n        {\n            // First node is AP\n            nodeConfigHelper.Set(\"Model\", netsimulyzer::models::SERVER_VALUE);\n            nodeConfigHelper.Set(\"Name\", StringValue(\"AP \"));\n            nodeConfigHelper.Install(wifiNodes.Get(0));\n        }\n        i = infra ? 1 : 0;\n        for (; i < nNodes; ++i)\n        {\n            nodeConfigHelper.Set(\"Model\", netsimulyzer::models::SMARTPHONE_VALUE);\n            nodeConfigHelper.Set(\"Name\", StringValue(\"Station \" + std::to_string(i)));\n            // Give each phone a different shade of grey\n            nodeConfigHelper.Set(\n                \"BaseColor\",\n                netsimulyzer::OptionalValue<netsimulyzer::Color3>{(100 + 150.0 / (i + 1)),\n                                                                  (100 + 150.0 / (i + 1)),\n                                                                  (100 + 150.0 / (i + 1))});\n            // Highlight the nodes used for demo\n            if (i == 7)\n            {\n                nodeConfigHelper.Set(\n                    \"HighlightColor\",\n                    netsimulyzer::OptionalValue<netsimulyzer::Color3>{netsimulyzer::BLUE});\n            }\n            else if (i == 8)\n            {\n                nodeConfigHelper.Set(\n                    \"HighlightColor\",\n                    netsimulyzer::OptionalValue<netsimulyzer::Color3>{netsimulyzer::GREEN});\n            }\n            else\n            {\n                nodeConfigHelper.Set(\n                    \"HighlightColor\",\n                    netsimulyzer::OptionalValue<netsimulyzer::Color3>{netsimulyzer::GRAY_80});\n            }\n\n            nodeConfigHelper.Install(wifiNodes.Get(i));\n        }\n\n        // Log\n        applicationLog = CreateObject<netsimulyzer::LogStream>(orchestrator);\n        applicationLog->SetAttribute(\"Name\", StringValue(\"Application log\"));\n        applicationLog->SetAttribute(\n            \"Color\",\n            netsimulyzer::OptionalValue<netsimulyzer::Color3>{100u, 150u, 100u});\n\n        // Statistics\n        PointerValue xAxis;\n        PointerValue yAxis;\n\n        associatedSeries = CreateObject<netsimulyzer::XYSeries>(orchestrator);\n        associatedSeries->SetAttribute(\"Name\", StringValue(\"Number of associated STAs\"));\n        associatedSeries->SetAttribute(\"Color\", netsimulyzer::Color3Value{204u, 111u, 4u});\n\n        for (i = 0; i < nNodes; ++i)\n        {\n            Ptr<netsimulyzer::XYSeries> cwTrace =\n                CreateObject<netsimulyzer::XYSeries>(orchestrator);\n            cwTrace->SetAttribute(\"Name\", StringValue(\"CW for node \" + std::to_string(i)));\n            cwTrace->SetAttribute(\"LabelMode\", StringValue(\"Hidden\"));\n            PointerValue cwYAxis;\n            cwTrace->GetAttribute(\"YAxis\", cwYAxis);\n            cwYAxis.Get<netsimulyzer::ValueAxis>()->SetAttribute(\"Name\", StringValue(\"Slots\"));\n\n            cwTraceSeries.insert(std::pair<uint32_t, Ptr<netsimulyzer::XYSeries>>(i, cwTrace));\n\n            Ptr<netsimulyzer::XYSeries> backoffTrace =\n                CreateObject<netsimulyzer::XYSeries>(orchestrator);\n            backoffTrace->SetAttribute(\"Name\",\n                                       StringValue(\"Backoff for node \" + std::to_string(i)));\n            backoffTrace->SetAttribute(\"LabelMode\", StringValue(\"Hidden\"));\n            PointerValue bYAxis;\n            backoffTrace->GetAttribute(\"YAxis\", bYAxis);\n            bYAxis.Get<netsimulyzer::ValueAxis>()->SetAttribute(\"Name\", StringValue(\"Slots\"));\n            backoffTraceSeries.insert(\n                std::pair<uint32_t, Ptr<netsimulyzer::XYSeries>>(i, backoffTrace));\n\n            Ptr<netsimulyzer::ThroughputSink> macTxTrace =\n                CreateObject<netsimulyzer::ThroughputSink>(orchestrator, \"Tx\");\n            macTxTrace->SetAttribute(\"Unit\", StringValue(\"Mb/s\"));\n            PointerValue txXySeries;\n            macTxTrace->GetAttribute(\"XYSeries\", txXySeries);\n            txXySeries.Get<netsimulyzer::XYSeries>()->SetAttribute(\"LabelMode\",\n                                                                   StringValue(\"Hidden\"));\n            macTxTraceSeries.insert(\n                std::pair<uint32_t, Ptr<netsimulyzer::ThroughputSink>>(i, macTxTrace));\n\n            Ptr<netsimulyzer::ThroughputSink> macRxTrace =\n                CreateObject<netsimulyzer::ThroughputSink>(orchestrator, \"Rx\");\n            macRxTrace->SetAttribute(\"Unit\", StringValue(\"Mb/s\"));\n            PointerValue rxXySeries;\n            macRxTrace->GetAttribute(\"XYSeries\", rxXySeries);\n            rxXySeries.Get<netsimulyzer::XYSeries>()->SetAttribute(\"LabelMode\",\n                                                                   StringValue(\"Hidden\"));\n            rxXySeries.Get<netsimulyzer::XYSeries>()->SetAttribute(\"Color\",\n                                                                   netsimulyzer::GREEN_VALUE);\n            macRxTraceSeries.insert(\n                std::pair<uint32_t, Ptr<netsimulyzer::ThroughputSink>>(i, macRxTrace));\n        }\n\n        // Add collection to group Tx/Rx per flow (i.e. Tx node 0 -> Rx node 1, etc...)\n        for (i = 0; i < nNodes; ++i)\n        {\n            Ptr<netsimulyzer::SeriesCollection> macCollection =\n                CreateObject<netsimulyzer::SeriesCollection>(orchestrator);\n            macCollection->SetAttribute(\"Name\",\n                                        StringValue(\"MAC Traffic \" + std::to_string(i) + \" to \" +\n                                                    std::to_string((i + 1) % nNodes)));\n            macCollection->GetAttribute(\"XAxis\", xAxis);\n            xAxis.Get<netsimulyzer::ValueAxis>()->SetAttribute(\"Name\", StringValue(\"Time (s)\"));\n            macCollection->GetAttribute(\"YAxis\", yAxis);\n            yAxis.Get<netsimulyzer::ValueAxis>()->SetAttribute(\"Name\",\n                                                               StringValue(\"Throughput (Mb/s)\"));\n\n            // Add Tx graph (this node)\n            macCollection->Add(macTxTraceSeries.find(i)->second->GetSeries());\n            // Add Rx graph (previous node)\n            macCollection->Add(macRxTraceSeries.find((i + 1) % nNodes)->second->GetSeries());\n            macCollections.insert(\n                std::pair<uint32_t, Ptr<netsimulyzer::SeriesCollection>>(i, macCollection));\n        }\n\n        // Total MAC Rx throughput\n        macRxTotalTraceSeries =\n            CreateObject<netsimulyzer::ThroughputSink>(orchestrator, \"Total MAC Rx\");\n        macRxTotalTraceSeries->SetAttribute(\"Unit\", StringValue(\"Mb/s\"));\n        PointerValue rxXySeries;\n        macRxTotalTraceSeries->GetAttribute(\"XYSeries\", rxXySeries);\n        rxXySeries.Get<netsimulyzer::XYSeries>()->SetAttribute(\"LabelMode\", StringValue(\"Hidden\"));\n\n    } // end if enableVisualization\n#endif\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    if (useTxHelper)\n    {\n        // Get results from WifiTxStatsHelper\n        const auto numSuccessPerNodeDevice = wifiTxStats.GetSuccessesByNodeDevice();\n        const auto numFailurePerNodeDevice = wifiTxStats.GetFailuresByNodeDevice();\n        const auto numFailureDueToFailedEnqueuePerNodeDevice =\n            wifiTxStats.GetFailuresByNodeDevice(WIFI_MAC_DROP_FAILED_ENQUEUE);\n        const auto numFailureDueToExpiredLifetimePerNodeDevice =\n            wifiTxStats.GetFailuresByNodeDevice(WIFI_MAC_DROP_EXPIRED_LIFETIME);\n        const auto numFailureDueToRetryLimitReachedPerNodeDevice =\n            wifiTxStats.GetFailuresByNodeDevice(WIFI_MAC_DROP_REACHED_RETRY_LIMIT);\n        const auto numFailureDueToQosOldPacketPerNodeDevice =\n            wifiTxStats.GetFailuresByNodeDevice(WIFI_MAC_DROP_QOS_OLD_PACKET);\n        const auto numRetransPerNodeDevice = wifiTxStats.GetRetransmissionsByNodeDevice();\n        std::cout << \"WifiTxStatsHelper: node to number of MPDUs acked during (10, \"\n                  << 10 + duration.ToInteger(Time::S) << \"] s:\" << std::endl;\n        if (numSuccessPerNodeDevice.empty())\n        {\n            std::cout << \"none\\n\";\n        }\n        else\n        {\n            std::cout << std::setw(5) << \"node\" << std::setw(10) << \"nSuccess\" << std::endl;\n            for (const auto& [nodeDevTuple, nSuccess] : numSuccessPerNodeDevice)\n            {\n                std::cout << std::setw(5) << std::get<0>(nodeDevTuple) << std::setw(10) << nSuccess\n                          << std::endl;\n            }\n        }\n        std::cout\n            << \"WifiTxStatsHelper: node to number of MPDUs failed (due to any reason) during (10, \"\n            << 10 + duration.ToInteger(Time::S) << \"] s:\" << std::endl;\n        if (numFailurePerNodeDevice.empty())\n        {\n            std::cout << \"none\\n\";\n        }\n        else\n        {\n            std::cout << std::setw(5) << \"node\" << std::setw(10) << \"nFailed\" << std::endl;\n            for (const auto& [nodeDevTuple, nFailure] : numFailurePerNodeDevice)\n            {\n                std::cout << std::setw(5) << std::get<0>(nodeDevTuple) << std::setw(10) << nFailure\n                          << std::endl;\n            }\n            std::cout << \"WifiTxStatsHelper: node to number of MPDUs failed (due to \"\n                         \"WIFI_MAC_DROP_FAILED_ENQUEUE) during (10, \"\n                      << 10 + duration.ToInteger(Time::S) << \"] s:\" << std::endl;\n            if (numFailureDueToFailedEnqueuePerNodeDevice.empty())\n            {\n                std::cout << \"none\\n\";\n            }\n            else\n            {\n                std::cout << std::setw(5) << \"node\" << std::setw(10) << \"nFailed\" << std::endl;\n                for (const auto& [nodeDevTuple, nFailure] :\n                     numFailureDueToFailedEnqueuePerNodeDevice)\n                {\n                    std::cout << std::setw(5) << std::get<0>(nodeDevTuple) << std::setw(10)\n                              << nFailure << std::endl;\n                }\n            }\n            std::cout << \"WifiTxStatsHelper: node to number of MPDUs failed (due to \"\n                         \"WIFI_MAC_DROP_EXPIRED_LIFETIME) during (10, \"\n                      << 10 + duration.ToInteger(Time::S) << \"] s:\" << std::endl;\n            if (numFailureDueToExpiredLifetimePerNodeDevice.empty())\n            {\n                std::cout << \"none\\n\";\n            }\n            else\n            {\n                std::cout << std::setw(5) << \"node\" << std::setw(10) << \"nFailed\" << std::endl;\n                for (const auto& [nodeDevTuple, nFailure] :\n                     numFailureDueToExpiredLifetimePerNodeDevice)\n                {\n                    std::cout << std::setw(5) << std::get<0>(nodeDevTuple) << std::setw(10)\n                              << nFailure << std::endl;\n                }\n            }\n            std::cout << \"WifiTxStatsHelper: node to number of MPDUs failed (due to \"\n                         \"WIFI_MAC_DROP_REACHED_RETRY_LIMIT) during (10, \"\n                      << 10 + duration.ToInteger(Time::S) << \"] s:\" << std::endl;\n            if (numFailureDueToRetryLimitReachedPerNodeDevice.empty())\n            {\n                std::cout << \"none\\n\";\n            }\n            else\n            {\n                std::cout << std::setw(5) << \"node\" << std::setw(10) << \"nFailed\" << std::endl;\n                for (const auto& [nodeDevTuple, nFailure] :\n                     numFailureDueToRetryLimitReachedPerNodeDevice)\n                {\n                    std::cout << std::setw(5) << std::get<0>(nodeDevTuple) << std::setw(10)\n                              << nFailure << std::endl;\n                }\n            }\n            std::cout << \"WifiTxStatsHelper: node to number of MPDUs failed (due to \"\n                         \"WIFI_MAC_DROP_QOS_OLD_PACKET) during (10, \"\n                      << 10 + duration.ToInteger(Time::S) << \"] s:\" << std::endl;\n            if (numFailureDueToQosOldPacketPerNodeDevice.empty())\n            {\n                std::cout << \"none\\n\";\n            }\n            else\n            {\n                std::cout << std::setw(5) << \"node\" << std::setw(10) << \"nFailed\" << std::endl;\n                for (const auto& [nodeDevTuple, nFailure] :\n                     numFailureDueToQosOldPacketPerNodeDevice)\n                {\n                    std::cout << std::setw(5) << std::get<0>(nodeDevTuple) << std::setw(10)\n                              << nFailure << std::endl;\n                }\n            }\n        }\n        std::cout << \"WifiTxStatsHelper: node to number of retransmissions of MPDUs \"\n                     \"Acked during (10, \"\n                  << 10 + duration.ToInteger(Time::S) << \"] s:\" << std::endl;\n        if (numRetransPerNodeDevice.empty())\n        {\n            std::cout << \"none\\n\";\n        }\n        else\n        {\n            std::cout << std::setw(5) << \"node\" << std::setw(10) << \"nRetrans\" << std::endl;\n            for (const auto& [nodeDevTuple, nRetrans] : numRetransPerNodeDevice)\n            {\n                std::cout << std::setw(5) << std::get<0>(nodeDevTuple) << std::setw(10) << nRetrans\n                          << std::endl;\n            }\n        }\n    }\n\n    if (useRxHelper)\n    {\n        // Get results from WifiPhyRxTraceHelper\n        std::cout << \"\\nWifiPhyRxTraceHelper: overall statistics\" << std::endl;\n        rxTraceHelper.PrintStatistics();\n        for (uint32_t nodeIndex = 0; nodeIndex < nNodes; ++nodeIndex)\n        {\n            std::cout << \"\\nWifiPhyRxTraceHelper: per-node statistics for node \" << nodeIndex\n                      << std::endl;\n            rxTraceHelper.PrintStatistics(nodeIndex);\n        }\n        std::cout << std::endl;\n    }\n\n    if (tracing)\n    {\n        cwTraceFile.flush();\n        backoffTraceFile.flush();\n        phyTxTraceFile.flush();\n        macTxTraceFile.flush();\n        macRxTraceFile.flush();\n        socketSendTraceFile.flush();\n    }\n\n    return 0;\n}\n\n/**\n * Get the Counter associated with a MAC address.\n *\n * @param counter The map of counters to inspect.\n * @param addr The MAC address.\n * @return the value of the counter,\n */\nuint64_t\nGetCount(const std::map<Mac48Address, uint64_t>& counter, Mac48Address addr)\n{\n    uint64_t count = 0;\n    auto it = counter.find(addr);\n    if (it != counter.end())\n    {\n        count = it->second;\n    }\n    return count;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t nMinStas = 5;  ///< Minimum number of STAs to start with\n    uint32_t nMaxStas = 50; ///< Maximum number of STAs to end with\n    uint32_t nStepSize = 5; ///< Number of stations to add at each step\n    uint32_t verbose = 0;   ///< verbosity level that increases the number of debugging traces\n    double duration = 100; ///< duration (in seconds) of each simulation run (i.e. per trial and per\n                           ///< number of stations)\n    uint32_t trials = 1;   ///< Number of runs per point in the plot\n    bool pcap = false;     ///< Flag to enable/disable PCAP files generation\n    bool infra = false;    ///< Flag to enable infrastructure model, ring adhoc network if not set\n    std::string workDir = \"./\"; ///< the working directory to store generated files\n    std::string phyMode =\n        \"OfdmRate54Mbps\";        ///< the constant PHY mode string used to transmit frames\n    std::string standard(\"11a\"); ///< the 802.11 standard\n    bool validate = false; ///< Flag used for regression in order to verify ns-3 results are in the\n                           ///< expected boundaries\n    uint16_t plotBianchiModel =\n        0x01; ///< First bit corresponds to the DIFS model, second bit to the EIFS model\n    double maxRelativeError =\n        0.015; ///< Maximum relative error tolerated between ns-3 results and the Bianchi model\n               ///< (used for regression, i.e. when the validate flag is set)\n    double frequency = 5;           ///< The operating frequency band in GHz: 2.4, 5 or 6\n    uint16_t channelWidth = 20;     ///< The constant channel width in MHz (only for 11n/ac/ax)\n    uint16_t guardIntervalNs = 800; ///< The guard interval in nanoseconds (800 or 400 for 11n/ac,\n                                    ///< 800 or 1600 or 3200 for 11 ax)\n    uint16_t pktInterval =\n        1000; ///< The socket packet interval in microseconds (a higher value is needed to reach\n              ///< saturation conditions as the channel bandwidth or the MCS increases)\n    meter_u distance = 0.001; ///< The distance in meters between the AP and the STAs\n    dBm_u apTxPower{16};      ///< The transmit power of the AP (if infrastructure only)\n    dBm_u staTxPower{16};     ///< The transmit power of each STA (or all STAs if adhoc)\n#ifdef HAS_NETSIMULYZER\n    // Give slightly more distance between devices for visualization\n    distance = 0.1;\n#endif\n\n    // Disable fragmentation and RTS/CTS\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::FragmentationThreshold\",\n                       StringValue(\"22000\"));\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"22000\"));\n    // Make CW stay equal to CWmax until a packet is acknowledged\n    Config::SetDefault(\"ns3::WifiMac::FrameRetryLimit\", UintegerValue(65535));\n    // Set maximum queue size to the largest value and set maximum queue delay to be larger than the\n    // simulation time\n    Config::SetDefault(\n        \"ns3::WifiMacQueue::MaxSize\",\n        QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, std::numeric_limits<uint32_t>::max())));\n    Config::SetDefault(\"ns3::WifiMacQueue::MaxDelay\", TimeValue(Seconds(2 * duration)));\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\",\n                 \"Logging level (0: no log - 1: simulation script logs - 2: all logs)\",\n                 verbose);\n    cmd.AddValue(\"tracing\", \"Generate trace files\", tracing);\n    cmd.AddValue(\"useTxHelper\", \"Enable WifiTxStatsHelper on all devices\", useTxHelper);\n    cmd.AddValue(\"useRxHelper\", \"Enable WifiPhyRxTraceHelper on all devices\", useRxHelper);\n    cmd.AddValue(\"pktSize\", \"The packet size in bytes\", pktSize);\n    cmd.AddValue(\"trials\", \"The maximal number of runs per network size\", trials);\n    cmd.AddValue(\"duration\", \"Time duration for each trial in seconds\", duration);\n    cmd.AddValue(\"pcap\", \"Enable/disable PCAP tracing\", pcap);\n    cmd.AddValue(\"infra\", \"True to use infrastructure mode, false to use ring adhoc mode\", infra);\n    cmd.AddValue(\"workDir\", \"The working directory used to store generated files\", workDir);\n    cmd.AddValue(\"phyMode\", \"Set the constant PHY mode string used to transmit frames\", phyMode);\n    cmd.AddValue(\"standard\", \"Set the standard (11a, 11b, 11g, 11n, 11ac, 11ax)\", standard);\n    cmd.AddValue(\"nMinStas\", \"Minimum number of stations to start with\", nMinStas);\n    cmd.AddValue(\"nMaxStas\", \"Maximum number of stations to start with\", nMaxStas);\n    cmd.AddValue(\"nStepSize\", \"Number of stations to add at each step\", nStepSize);\n    cmd.AddValue(\"plotBianchiModel\",\n                 \"First bit corresponds to the DIFS model, second bit to the EIFS model\",\n                 plotBianchiModel);\n    cmd.AddValue(\"validate\",\n                 \"Enable/disable validation of the ns-3 simulations against the Bianchi model\",\n                 validate);\n    cmd.AddValue(\"maxRelativeError\",\n                 \"The maximum relative error tolerated between ns-3 results and the Bianchi model \"\n                 \"(used for regression, i.e. when the validate flag is set)\",\n                 maxRelativeError);\n    cmd.AddValue(\"frequency\", \"Set the operating frequency band in GHz: 2.4, 5 or 6\", frequency);\n    cmd.AddValue(\"channelWidth\",\n                 \"Set the constant channel width in MHz (only for 11n/ac/ax)\",\n                 channelWidth);\n    cmd.AddValue(\"guardIntervalNs\",\n                 \"Set the the guard interval in nanoseconds (800 or 400 for 11n/ac, 800 or 1600 or \"\n                 \"3200 for 11 ax)\",\n                 guardIntervalNs);\n    cmd.AddValue(\"maxMpdus\",\n                 \"Set the maximum number of MPDUs in A-MPDUs (0 to disable MPDU aggregation)\",\n                 maxMpdus);\n    cmd.AddValue(\"distance\", \"Set the distance in meters between the AP and the STAs\", distance);\n    cmd.AddValue(\"apTxPower\",\n                 \"Set the transmit power of the AP in dBm (if infrastructure only)\",\n                 apTxPower);\n    cmd.AddValue(\"staTxPower\",\n                 \"Set the transmit power of each STA in dBm (or all STAs if adhoc)\",\n                 staTxPower);\n    cmd.AddValue(\"pktInterval\", \"Set the socket packet interval in microseconds\", pktInterval);\n#ifdef HAS_NETSIMULYZER\n    cmd.AddValue(\"visual\", \"Generate visualization traces\", enableVisualization);\n#endif\n    cmd.Parse(argc, argv);\n\n    if (tracing)\n    {\n        cwTraceFile.open(\"wifi-bianchi-cw-trace.out\");\n        if (!cwTraceFile.is_open())\n        {\n            NS_FATAL_ERROR(\"Failed to open file wifi-bianchi-cw-trace.out\");\n        }\n        backoffTraceFile.open(\"wifi-bianchi-backoff-trace.out\");\n        if (!backoffTraceFile.is_open())\n        {\n            NS_FATAL_ERROR(\"Failed to open file wifi-bianchi-backoff-trace.out\");\n        }\n        phyTxTraceFile.open(\"wifi-bianchi-phy-tx-trace.out\");\n        if (!phyTxTraceFile.is_open())\n        {\n            NS_FATAL_ERROR(\"Failed to open file wifi-bianchi-phy-tx-trace.out\");\n        }\n        macTxTraceFile.open(\"wifi-bianchi-mac-tx-trace.out\");\n        if (!macTxTraceFile.is_open())\n        {\n            NS_FATAL_ERROR(\"Failed to open file wifi-bianchi-mac-tx-trace.out\");\n        }\n        macRxTraceFile.open(\"wifi-bianchi-mac-rx-trace.out\");\n        if (!macRxTraceFile.is_open())\n        {\n            NS_FATAL_ERROR(\"Failed to open file wifi-bianchi-mac-rx-trace.out\");\n        }\n        socketSendTraceFile.open(\"wifi-bianchi-socket-send-trace.out\");\n        if (!socketSendTraceFile.is_open())\n        {\n            NS_FATAL_ERROR(\"Failed to open file wifi-bianchi-socket-send-trace.out\");\n        }\n    }\n\n    if (verbose >= 1)\n    {\n        LogComponentEnable(\"WifiBianchi\", LOG_LEVEL_ALL);\n    }\n    else\n    {\n        LogComponentEnable(\"WifiBianchi\", LOG_LEVEL_WARN);\n    }\n    if (verbose >= 2)\n    {\n        WifiHelper::EnableLogComponents();\n    }\n\n    std::stringstream phyModeStr;\n    phyModeStr << phyMode;\n    if (phyMode.find(\"Mcs\") != std::string::npos)\n    {\n        phyModeStr << \"_\" << channelWidth << \"MHz\";\n    }\n\n    std::stringstream ss;\n    ss << \"wifi-\" << standard << \"-p-\" << pktSize << (infra ? \"-infrastructure\" : \"-adhoc\") << \"-r-\"\n       << phyModeStr.str() << \"-min-\" << nMinStas << \"-max-\" << nMaxStas << \"-step-\" << nStepSize\n       << \"-throughput.plt\";\n    std::ofstream throughputPlot(ss.str());\n    ss.str(\"\");\n    ss << \"wifi-\" << standard << \"-p-\" << pktSize << (infra ? \"-infrastructure\" : \"-adhoc\") << \"-r-\"\n       << phyModeStr.str() << \"-min-\" << nMinStas << \"-max-\" << nMaxStas << \"-step-\" << nStepSize\n       << \"-throughput.eps\";\n    Gnuplot gnuplot = Gnuplot(ss.str());\n\n    WifiStandard wifiStandard;\n    if (standard == \"11a\")\n    {\n        wifiStandard = WIFI_STANDARD_80211a;\n        frequency = 5;\n        channelWidth = 20;\n    }\n    else if (standard == \"11b\")\n    {\n        wifiStandard = WIFI_STANDARD_80211b;\n        frequency = 2.4;\n        channelWidth = 22;\n    }\n    else if (standard == \"11g\")\n    {\n        wifiStandard = WIFI_STANDARD_80211g;\n        frequency = 2.4;\n        channelWidth = 20;\n    }\n    else if (standard == \"11n\")\n    {\n        if (frequency == 2.4 || frequency == 5)\n        {\n            wifiStandard = WIFI_STANDARD_80211n;\n        }\n        else\n        {\n            NS_FATAL_ERROR(\"Unsupported frequency band \" << frequency << \" GHz for standard \"\n                                                         << standard);\n        }\n    }\n    else if (standard == \"11ac\")\n    {\n        wifiStandard = WIFI_STANDARD_80211ac;\n        frequency = 5;\n    }\n    else if (standard == \"11ax\")\n    {\n        if (frequency == 2.4 || frequency == 5 || frequency == 6)\n        {\n            wifiStandard = WIFI_STANDARD_80211ax;\n        }\n        else\n        {\n            NS_FATAL_ERROR(\"Unsupported frequency band \" << frequency << \" GHz for standard \"\n                                                         << standard);\n        }\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Unsupported standard: \" << standard);\n    }\n\n    std::string channelStr = \"{0, \" + std::to_string(channelWidth) + \", BAND_\" +\n                             (frequency == 2.4 ? \"2_4\" : (frequency == 5 ? \"5\" : \"6\")) + \"GHZ, 0}\";\n    Config::SetDefault(\"ns3::WifiPhy::ChannelSettings\", StringValue(channelStr));\n\n    YansWifiPhyHelper wifiPhy;\n    wifiPhy.DisablePreambleDetectionModel();\n\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    if (frequency == 6)\n    {\n        // Reference Loss for Friss at 1 m with 6.0 GHz\n        wifiChannel.AddPropagationLoss(\"ns3::LogDistancePropagationLossModel\",\n                                       \"Exponent\",\n                                       DoubleValue(2.0),\n                                       \"ReferenceDistance\",\n                                       DoubleValue(1.0),\n                                       \"ReferenceLoss\",\n                                       DoubleValue(49.013));\n    }\n    else if (frequency == 5)\n    {\n        // Reference Loss for Friss at 1 m with 5.15 GHz\n        wifiChannel.AddPropagationLoss(\"ns3::LogDistancePropagationLossModel\",\n                                       \"Exponent\",\n                                       DoubleValue(2.0),\n                                       \"ReferenceDistance\",\n                                       DoubleValue(1.0),\n                                       \"ReferenceLoss\",\n                                       DoubleValue(46.6777));\n    }\n    else\n    {\n        // Reference Loss for Friss at 1 m with 2.4 GHz\n        wifiChannel.AddPropagationLoss(\"ns3::LogDistancePropagationLossModel\",\n                                       \"Exponent\",\n                                       DoubleValue(2.0),\n                                       \"ReferenceDistance\",\n                                       DoubleValue(1.0),\n                                       \"ReferenceLoss\",\n                                       DoubleValue(40.046));\n    }\n\n    WifiHelper wifi;\n    wifi.SetStandard(wifiStandard);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(phyMode),\n                                 \"ControlMode\",\n                                 StringValue(phyMode));\n\n    Gnuplot2dDataset dataset;\n    Gnuplot2dDataset datasetBianchiEifs;\n    Gnuplot2dDataset datasetBianchiDifs;\n    dataset.SetErrorBars(Gnuplot2dDataset::Y);\n    dataset.SetStyle(Gnuplot2dDataset::LINES_POINTS);\n    datasetBianchiEifs.SetStyle(Gnuplot2dDataset::LINES_POINTS);\n    datasetBianchiDifs.SetStyle(Gnuplot2dDataset::LINES_POINTS);\n\n    Experiment experiment;\n    WifiMacHelper wifiMac;\n    double averageThroughput;\n    std::vector<double> throughputArray(trials);\n    for (uint32_t n = nMinStas; n <= nMaxStas; n += nStepSize)\n    {\n        averageThroughput = 0;\n        double throughput;\n        for (uint32_t runIndex = 0; runIndex < trials; runIndex++)\n        {\n            packetsReceived.clear();\n            bytesReceived.clear();\n            packetsTransmitted.clear();\n            psduFailed.clear();\n            psduSucceeded.clear();\n            phyHeaderFailed.clear();\n            timeFirstReceived.clear();\n            timeLastReceived.clear();\n            rxEventWhileDecodingPreamble.clear();\n            rxEventWhileRxing.clear();\n            rxEventWhileTxing.clear();\n            rxEventAbortedByTx.clear();\n            associated.clear();\n            throughput = 0;\n            std::cout << \"Trial \" << runIndex + 1 << \" of \" << trials << \"; \" << phyModeStr.str()\n                      << \" for \" << n << \" nodes \" << std::endl;\n            if (tracing)\n            {\n                cwTraceFile << \"# Trial \" << runIndex + 1 << \" of \" << trials << \"; \"\n                            << phyModeStr.str() << \" for \" << n << \" nodes\" << std::endl;\n                backoffTraceFile << \"# Trial \" << runIndex + 1 << \" of \" << trials << \"; \"\n                                 << phyModeStr.str() << \" for \" << n << \" nodes\" << std::endl;\n                phyTxTraceFile << \"# Trial \" << runIndex + 1 << \" of \" << trials << \"; \"\n                               << phyModeStr.str() << \" for \" << n << \" nodes\" << std::endl;\n                macTxTraceFile << \"# Trial \" << runIndex + 1 << \" of \" << trials << \"; \"\n                               << phyModeStr.str() << \" for \" << n << \" nodes\" << std::endl;\n                macRxTraceFile << \"# Trial \" << runIndex + 1 << \" of \" << trials << \"; \"\n                               << phyModeStr.str() << \" for \" << n << \" nodes\" << std::endl;\n                socketSendTraceFile << \"# Trial \" << runIndex + 1 << \" of \" << trials << \"; \"\n                                    << phyModeStr.str() << \" for \" << n << \" nodes\" << std::endl;\n            }\n            experiment.Run(wifi,\n                           wifiPhy,\n                           wifiMac,\n                           wifiChannel,\n                           runIndex,\n                           n,\n                           Seconds(duration),\n                           pcap,\n                           infra,\n                           guardIntervalNs,\n                           distance,\n                           apTxPower,\n                           staTxPower,\n                           MicroSeconds(pktInterval));\n            uint32_t k = 0;\n            if (bytesReceived.size() != n)\n            {\n                NS_FATAL_ERROR(\"Not all stations got traffic!\");\n            }\n            for (auto it = bytesReceived.begin(); it != bytesReceived.end(); it++, k++)\n            {\n                Time first = timeFirstReceived.find(it->first)->second;\n                Time last = timeLastReceived.find(it->first)->second;\n                Time dataTransferDuration = last - first;\n                double nodeThroughput =\n                    (it->second * 8 / static_cast<double>(dataTransferDuration.GetMicroSeconds()));\n                throughput += nodeThroughput;\n                uint64_t nodeTxPackets = GetCount(packetsTransmitted, it->first);\n                uint64_t nodeRxPackets = GetCount(packetsReceived, it->first);\n                uint64_t nodePhyHeaderFailures = GetCount(phyHeaderFailed, it->first);\n                uint64_t nodePsduFailures = GetCount(psduFailed, it->first);\n                uint64_t nodePsduSuccess = GetCount(psduSucceeded, it->first);\n                uint64_t nodeRxEventWhileDecodingPreamble =\n                    GetCount(rxEventWhileDecodingPreamble, it->first);\n                uint64_t nodeRxEventWhileRxing = GetCount(rxEventWhileRxing, it->first);\n                uint64_t nodeRxEventWhileTxing = GetCount(rxEventWhileTxing, it->first);\n                uint64_t nodeRxEventAbortedByTx = GetCount(rxEventAbortedByTx, it->first);\n                uint64_t nodeRxEvents = nodePhyHeaderFailures + nodePsduFailures + nodePsduSuccess +\n                                        nodeRxEventWhileDecodingPreamble + nodeRxEventWhileRxing +\n                                        nodeRxEventWhileTxing + nodeRxEventAbortedByTx;\n                std::cout << \"Node \" << it->first << \": TX packets \" << nodeTxPackets\n                          << \"; RX packets \" << nodeRxPackets << \"; PHY header failures \"\n                          << nodePhyHeaderFailures << \"; PSDU failures \" << nodePsduFailures\n                          << \"; PSDU success \" << nodePsduSuccess\n                          << \"; RX events while decoding preamble \"\n                          << nodeRxEventWhileDecodingPreamble << \"; RX events while RXing \"\n                          << nodeRxEventWhileRxing << \"; RX events while TXing \"\n                          << nodeRxEventWhileTxing << \"; RX events aborted by TX \"\n                          << nodeRxEventAbortedByTx << \"; total RX events \" << nodeRxEvents\n                          << \"; total events \" << nodeTxPackets + nodeRxEvents << \"; time first RX \"\n                          << first << \"; time last RX \" << last << \"; dataTransferDuration \"\n                          << dataTransferDuration << \"; throughput \" << nodeThroughput << \" Mbps\"\n                          << std::endl;\n            }\n            std::cout << \"Total throughput: \" << throughput << \" Mbps\" << std::endl;\n            averageThroughput += throughput;\n            throughputArray[runIndex] = throughput;\n        }\n        averageThroughput = averageThroughput / trials;\n\n        bool rateFound = false;\n        double relativeErrorDifs = 0;\n        double relativeErrorEifs = 0;\n        auto itDifs = bianchiResultsDifs.find(phyModeStr.str());\n        if (itDifs != bianchiResultsDifs.end())\n        {\n            rateFound = true;\n            auto it = itDifs->second.find(n);\n            if (it != itDifs->second.end())\n            {\n                relativeErrorDifs = (std::abs(averageThroughput - it->second) / it->second);\n                std::cout << \"Relative error (DIFS): \" << 100 * relativeErrorDifs << \"%\"\n                          << std::endl;\n            }\n            else if (validate)\n            {\n                NS_FATAL_ERROR(\"No Bianchi results (DIFS) calculated for that number of stations!\");\n            }\n        }\n        auto itEifs = bianchiResultsEifs.find(phyModeStr.str());\n        if (itEifs != bianchiResultsEifs.end())\n        {\n            rateFound = true;\n            auto it = itEifs->second.find(n);\n            if (it != itEifs->second.end())\n            {\n                relativeErrorEifs = (std::abs(averageThroughput - it->second) / it->second);\n                std::cout << \"Relative error (EIFS): \" << 100 * relativeErrorEifs << \"%\"\n                          << std::endl;\n            }\n            else if (validate)\n            {\n                NS_FATAL_ERROR(\"No Bianchi results (EIFS) calculated for that number of stations!\");\n            }\n        }\n        if (!rateFound && validate)\n        {\n            NS_FATAL_ERROR(\"No Bianchi results calculated for that rate!\");\n        }\n        double relativeError = std::min(relativeErrorDifs, relativeErrorEifs);\n        if (validate && (relativeError > maxRelativeError))\n        {\n            NS_FATAL_ERROR(\"Relative error is too high!\");\n        }\n\n        double stDev = 0;\n        for (uint32_t i = 0; i < trials; ++i)\n        {\n            stDev += pow(throughputArray[i] - averageThroughput, 2);\n        }\n        stDev = sqrt(stDev / (trials - 1));\n        dataset.Add(n, averageThroughput, stDev);\n    }\n    dataset.SetTitle(\"ns-3\");\n\n    auto itDifs = bianchiResultsDifs.find(phyModeStr.str());\n    if (itDifs != bianchiResultsDifs.end())\n    {\n        for (uint32_t i = nMinStas; i <= nMaxStas; i += nStepSize)\n        {\n            double value = 0.0;\n            auto it = itDifs->second.find(i);\n            if (it != itDifs->second.end())\n            {\n                value = it->second;\n            }\n            datasetBianchiDifs.Add(i, value);\n        }\n    }\n    else\n    {\n        for (uint32_t i = nMinStas; i <= nMaxStas; i += nStepSize)\n        {\n            datasetBianchiDifs.Add(i, 0.0);\n        }\n    }\n\n    auto itEifs = bianchiResultsEifs.find(phyModeStr.str());\n    if (itEifs != bianchiResultsEifs.end())\n    {\n        for (uint32_t i = nMinStas; i <= nMaxStas; i += nStepSize)\n        {\n            double value = 0.0;\n            auto it = itEifs->second.find(i);\n            if (it != itEifs->second.end())\n            {\n                value = it->second;\n            }\n            datasetBianchiEifs.Add(i, value);\n        }\n    }\n    else\n    {\n        for (uint32_t i = nMinStas; i <= nMaxStas; i += nStepSize)\n        {\n            datasetBianchiEifs.Add(i, 0.0);\n        }\n    }\n\n    datasetBianchiEifs.SetTitle(\"Bianchi (EIFS - lower bound)\");\n    datasetBianchiDifs.SetTitle(\"Bianchi (DIFS - upper bound)\");\n    gnuplot.AddDataset(dataset);\n    gnuplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    gnuplot.SetLegend(\"Number of competing stations\", \"Throughput (Mbps)\");\n    ss.str(\"\");\n    ss << \"Frame size \" << pktSize << \" bytes\";\n    gnuplot.SetTitle(ss.str());\n    ss.str(\"\");\n    ss << \"set xrange [\" << nMinStas << \":\" << nMaxStas << \"]\\n\"\n       << \"set xtics \" << nStepSize << \"\\n\"\n       << \"set grid xtics ytics\\n\"\n       << \"set mytics\\n\"\n       << \"set style line 1 linewidth 5\\n\"\n       << \"set style line 2 linewidth 5\\n\"\n       << \"set style line 3 linewidth 5\\n\"\n       << \"set style line 4 linewidth 5\\n\"\n       << \"set style line 5 linewidth 5\\n\"\n       << \"set style line 6 linewidth 5\\n\"\n       << \"set style line 7 linewidth 5\\n\"\n       << \"set style line 8 linewidth 5\\n\"\n       << \"set style increment user\";\n    gnuplot.SetExtra(ss.str());\n    if (plotBianchiModel & 0x0001)\n    {\n        datasetBianchiDifs.SetTitle(\"Bianchi\");\n        gnuplot.AddDataset(datasetBianchiDifs);\n    }\n    if (plotBianchiModel & 0x0002)\n    {\n        datasetBianchiEifs.SetTitle(\"Bianchi\");\n        gnuplot.AddDataset(datasetBianchiEifs);\n    }\n    if (plotBianchiModel == 0x0003)\n    {\n        datasetBianchiEifs.SetTitle(\"Bianchi (EIFS - lower bound)\");\n        datasetBianchiDifs.SetTitle(\"Bianchi (DIFS - upper bound)\");\n    }\n    gnuplot.GenerateOutput(throughputPlot);\n    throughputPlot.close();\n\n    if (tracing)\n    {\n        cwTraceFile.close();\n        backoffTraceFile.close();\n        phyTxTraceFile.close();\n        macTxTraceFile.close();\n        macRxTraceFile.close();\n        socketSendTraceFile.close();\n    }\n\n    return 0;\n}\n"
    }
  ]
}