{
  "repo_name": "usnistgov/ns3-cosim",
  "github_url": "https://github.com/usnistgov/ns3-cosim",
  "readme": "# Co-Simulation of ns-3 Network Models\n\nThis repository contains software that enables the co-simulation of ns-3 network models with other simulation software.\nCo-simulation is a modeling and simulation technique to develop high-fidelity simulations through the integration and\njoint operation of multiple simulators running in parallel. A co-simulation requires middleware (this repository) to\ndefine a shared time reference and the mechanisms for data exchange between simulators.\n\nFor a practical example, [Simulation of Urban Mobility (SUMO)](https://eclipse.dev/sumo/) is a popular traffic simulator\nthat can model transportation networks of on-road vehicles. An ns-3 model for vehicle-to-vehicle communications could\nlet SUMO handle node mobility rather than trying to implement its own approach to vehicle motion. This allows ns-3 to\nfocus on just the communication network, with any domain-specific functionality outsourced to specialized simulators\nsuch as SUMO. In a co-simulation, the integration between ns-3 and SUMO is online where both simulators run in parallel\nwith periodic synchronization at runtime for data exchange. This is more dynamic than offline approaches that exchange\npre-recorded data, as the performance of the communications network in ns-3 can affect the on-going traffic simulation\nin SUMO and vice versa.\n\n![Gateway Architecture Diagram](gateway.png)\n\nThe following new classes are provided:\n  - a [gateway](model/gateway.h) for integrating ns-3 with other software using a local TCP/IP socket connection\n  - a [triggered send application](model/triggered-send-application.h) that lets external code broadcast messages\n  - an [external mobility model](model/external-mobility-model.h) that lets external code manage ns-3 node mobility\n\n# Gateway Architecture\n\nThe gateway is an abstract class with two pure virtual functions (`Gateway::DoInitialize` and `Gateway::DoUpdate`). It\nmaintains a TCP/IP socket connection to a remote server, defines a simple string-based application layer protocol for\ndata exchange, and synchronizes the ns-3 simulation time with time values received from the remote server.\n\nA brief introduction to the gateway architecture is presented in the sections below. Before using the gateway, refer to\nits [documentation](model/gateway.h) and the simple gateway example introduced later in this document.\n\n## Data Exchange\n\nThe following sequence diagram shows how a single message is processed:\n\n![Gateway Sequence Diagram](sequence-diagram.svg)\n\nThe remote server sends a message to the gateway. This message is a string, with the format:\n\n    time(seconds),time(nanoseconds),received_value_1,...,received_value_n;\n\nThis message contains two delimiters: a field delimiter (`,`) that separates the values, and a message delimiter (`;`)\nthat indicates the end-of-message. These delimiters are the C++ `std::string` type and are configured when the gateway\nis constructed. The default values are a space (for the field) and `\\r\\n` (for the message).\n\nThe `time(seconds)` and `time(nanoseconds)` values are considered the message header, and are stripped from the message\nbefore any further processing. These values represent the seconds component (signed 32-bit integer) and the nanoseconds\ncomponent (unsigned 32-bit integer in the range [0,10e9)) of a single time value. This format was selected to match\nthe Robot Operating System (ROS2) [Time](https://docs.ros2.org/latest/api/builtin_interfaces/msg/Time.html) format.\n\nWhen the gateway receives a new message, it schedules the `Gateway::HandleUpdate` function to be executed at the\n`ns3::Time` equivalent of the message header. This handle update function delegates processing the message to the\nuser-defined `DoUpdate` function. The rest of the sequence diagram is a suggested implementation of `DoUpdate`.\n\nThe gateway will send a response when `Gateway::SendResponse` is called. This message is a string, with the format:\n\n    value_1,value_2,...,value_m;\n\nThis message re-uses the same field delimiter (`,`) and end-of-message delimiter (`;`) as above. It will always contain\n`m` values, where `m` is specified in the gateway constructor. Unless otherwise set, these values will default to an\nempty string. The individual values can be set using the `Gateway::SetValue` function. Once set, each element retains\nits value between consecutive calls to `Gateway::SendResponse`.\n\n## Time Management\n\nThis section gives a coarse summary of the elements of time management relevant to using the gateway.\n\nWhen `Gateway::Connect` is called, ns-3 time progression is immediately paused at the current simulation time forever.\nThe function `Gateway::WaitForNextUpdate` is scheduled to execute now, and this function recursively schedules itself\nto execute now (forever). Time progression cannot resume until the scheduled `WaitForNextUpdate` event is cancelled.\n\nWhen the gateway receives a new message from the remote server (see Data Exchange above), it cancels the currently\nscheduled `WaitForNextUpdate` event and re-schedules it to execute at the time indicated in the received time stamp.\nThis allows ns-3 to simulate up to the time of the last received message, after which time progression will once again\npause until a new time stamp is received. This creates a leader-follower approach to time synchronization, where the\nremote server acting as the leader controls ns-3 time progression through the sending of time stamped messages.\n\nNote that, when implementing a remote server, the gateway operates on time relative to the first received time stamp.\nSuppose that `Gateway::Connect` is called at an ns-3 simulation time of 5 seconds, and the first received message from\nthe remote server has the time stamp (10 seconds, 0 nanoseconds). This first message received from the remote server is\nused to initialize the gateway, and does not cancel the `WaitForNextUpdate` event. If the next message received from\nthe remote server has a time stamp of (11 seconds, 0 nanoseconds), ns-3 will compute the time difference between the\ntime stamps and advance 1 second to an internal ns-3 simulation time of 6 seconds.\n\nUntil this documentation is revised with additional detail on time management, the simple gateway example is a good\nreference to better understand time management.\n\n# Installation\n\nThis code was developed for an ns-3 fork that supports vehicle-to-everything (V2X) communications, which is co-located\nwith the ns-3 [3GPP NR module](https://gitlab.com/cttc-lena). This code was not tested with, and may not support,\nother versions of ns-3 (including the official releases).\n\n## Requirements\n\nThis code was tested using:\n  - Ubuntu 22.04\n  - [ns-3-dev-v2x-v1.1](https://gitlab.com/cttc-lena/ns-3-dev/-/tree/ns-3-dev-v2x-v1.1)\n  - [nr-v2x-v1.1](https://gitlab.com/cttc-lena/nr/-/tree/v2x-1.1)\n  - [netsimulyzer-v1.0.13](https://github.com/usnistgov/NetSimulyzer-ns3-module/tree/v1.0.13)\n\nThese instructions require:\n  - cmake 3.13 (or newer)\n  - g++ 10.5.0 (or newer)\n  - git (any version)\n  - make (any version)\n  - python 3.8 (or newer)\n\n## Download Dependencies\n\nRun the following commands, ignoring any comments (lines starting with #):\n\n    # install the dependencies for the ns-3 NR module\n    apt install libc6-dev libeigen3-dev sqlite sqlite3 libsqlite3-dev\n\n    # download the custom ns-3 development branch for V2X communications\n    git clone --branch ns-3-dev-v2x-v1.1 https://gitlab.com/cttc-lena/ns-3-dev.git\n    \n    # download additional ns-3 modules\n    cd ns-3-dev/contrib\n    git clone https://github.com/usnistgov/ns3-cosim.git\n\n    # optional (for V2X examples using sidelink)\n    git clone --branch v2x-1.1 https://gitlab.com/cttc-lena/nr.git\n    # optional (for visualization of network models)\n    git clone --branch v1.0.13 https://github.com/usnistgov/NetSimulyzer-ns3-module netsimulyzer\n\nEnsure the directory structure matches, exactly:\n\n    ns-3-dev\n     - contrib\n      - netsimulyzer\n      - nr\n      - ns3-cosim\n\n## Compile ns-3\n\nFrom the ns-3-dev directory, run:\n\n    ./ns3 configure --enable-tests --enable-examples\n\nVerify that the output under `Modules configured to be built:` includes `ns3-cosim`.\n\nFrom the same ns-3-dev directory, run:\n\n    ./ns3 build\n\n# Examples\n\nAll examples must be run from the root `ns-3-dev` directory, which is not the directory where this README is located.\n\n## External Mobility Example\n\nThe [external mobility example](examples/external-mobility-example.cc) shows how to set the position and velocity of\nthe new external mobility model. It can be run with the command:\n\n    ./ns3 run external-mobility-example\n\nThis example contains two nodes. A periodic function is scheduled to update the mobility of each node. When a mobility\nmodel is updated, its current position and velocity information is output to the ns-3 logger. The updates are:\n  - Node 0 is updated every 2 seconds to increase the x-dimension of its position and velocity by 1.\n  - Node 1 is updated every 1 second to increase the z-dimension of its position and velocity by 1.\n\n## Triggered Send Example\n\nThe [triggered send example](examples/triggered-send-example.cc) shows how to start sending messages using the new\ntriggered send application, and its behavior when triggered under different conditions. It can be run with the command:\n\n    ./ns3 run triggered-send-example\n\nThis example contains two nodes connected by a point-to-point channel. The first node (`192.168.0.1`) is a client with\na triggered send application, and the second node (`192.168.0.2`) is a server with a packet sink application. The first\nnode is triggered to send messages to the packet sink at different times during the simulation. When the packet sink\nreceives these messages, it outputs the current time to the ns-3 logger.\n\nThe `TriggeredSendApplication::Send` function takes the number of packets to send as an argument. The application also\nhas a `PacketInterval` attribute that specifies the time delay between sending two consecutive packets. In this example,\nthe client attempts to send 5 packets with a 200 ms packet interval. Refer to the code for the 4 different cases shown\nin this example, and why in some cases the client doesn't send all 5 packets.\n\n## Simple Gateway\n\nThis example shows how to create a simple gateway to communicate with external code. It consists of an ns-3 model that\nimplements the [gateway](examples/simple-gateway.cc) and a simple server that represents the\n[external code](examples/simple-gateway-server.cc).\n\nFirst, run the simple server:\n\n    ./ns3 run simple-gateway-server\n\nThen, run the ns-3 model in a separate terminal:\n\n    ./ns3 run simple-gateway\n\nThe server by default runs a 20 time step simulation of 3 vehicles, where the position and velocity information for the\nvehicles are randomized each step. Every 5 time steps (starting at step 6), the vehicles have a chance to broadcast a\nmessage to the network. The server starts at time 0, with a step size of 1 second.\n\nThe ns-3 model contains 3 nodes to represent the vehicles, and the gateway implementation. Each node has an external\nmobility model, a triggered send application for sending packets, and a packet sink for receiving packets. The gateway\nimplementation connects to the simple server, and uses the position and velocity information received from the server\nto update the external mobility models. When the server indicates one of the vehicles has started broadcasting, the\ngateway triggers the corresponding triggered send application. When a packet sink receives a packet, it outputs the\ncurrent simulation time to the ns-3 logger.\n\nThis example includes command line arguments to adjust the behavior of the server and the gateway. To specify the\ncommand line arguments (and to see the list of possible arguments), use the format:\n\n    ./ns3 run \"simple-gateway --help\"\n    ./ns3 run \"simple-gateway-server --help\"\n    ./ns3 run \"<program_name> --<option_name>=<value>\"\n\n# Additional Information\n\n## Third-Party Licenses\n\nThis repository includes modified ns-3 source code distributed under the GNU General Public License, Version 2.\nAll modified files include their original attributions in a comment header, and their respective licensing statements\ncan be found in the [LICENSES](LICENSES/) directory.\n\n## Contact Information\n\nThis repository is maintained by:\n  - Thomas Roth (@tpr1)\n\n## Citation Information\n\nYou can cite this software in technical publications as:\n\n`Thomas Roth (2025), Gateway for Co-Simulation using ns-3, National Institute of Standards and Technology, https://doi.org/10.18434/mds2-3738`\n\n## References\n\nns-3 NR module\n: https://gitlab.com/cttc-lena/nr\n\nns-3 NetSimulyzer module\n: https://github.com/usnistgov/NetSimulyzer-ns3-module\n\nNetSimulyzer standalone\n: https://github.com/usnistgov/NetSimulyzer\n",
  "examples": [
    {
      "file_path": "examples/external-mobility-example.cc",
      "code": "/*\n * NIST-developed software is provided by NIST as a public service. You may use,\n * copy, and distribute copies of the software in any medium, provided that you\n * keep intact this entire notice. You may improve, modify, and create\n * derivative works of the software or any portion of the software, and you may\n * copy and distribute such modifications or works. Modified works should carry\n * a notice stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the National\n * Institute of Standards and Technology as the source of the software. \n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES NO WARRANTY\n * OF ANY KIND, EXPRESS, IMPLIED, IN FACT, OR ARISING BY OPERATION OF LAW,\n * INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, AND DATA ACCURACY. NIST\n * NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE\n * UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST DOES\n * NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE SOFTWARE OR\n * THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE CORRECTNESS, ACCURACY,\n * RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n * \n * You are solely responsible for determining the appropriateness of using and\n * distributing the software and you assume all risks associated with its use,\n * including but not limited to the risks and costs of program errors,\n * compliance with applicable laws, damage to or loss of data, programs or\n * equipment, and the unavailability or interruption of operation. This software \n * is not intended to be used in any situation where a failure could cause risk\n * of injury or damage to property. The software developed by NIST employees is\n * not subject to copyright protection within the United States.\n *\n * Author: Thomas Roth <thomas.roth@nist.gov>\n*/\n\n#include \"ns3/core-module.h\"\n#include \"ns3/mobility-module.h\"\n\n#include \"ns3/external-mobility-model.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ExternalMobilityExample\");\n\nvoid\nUpdateMobility(NodeContainer nodes, const Vector & positionDelta, const Vector & velocityDelta, Time timeDelta)\n{\n    for (NodeContainer::Iterator it = nodes.Begin(); it != nodes.End(); it++)\n    {\n        Ptr<ExternalMobilityModel> mobility = (*it)->GetObject<ExternalMobilityModel>();\n        mobility->SetPosition(mobility->GetPosition() + positionDelta); // will not notify course change\n        mobility->SetVelocity(mobility->GetVelocity() + velocityDelta); // will notify course change\n    }\n    Simulator::Schedule(timeDelta, &UpdateMobility, nodes, positionDelta, velocityDelta, timeDelta);\n}\n\nvoid\nReportMobility(Ptr<const MobilityModel> mobility)\n{\n    NS_LOG_INFO(\"At time \" << Simulator::Now().As(Time::S)\n        << \", Node \" << mobility->GetObject<Node>()->GetId()\n        << \", Position \" << mobility->GetPosition()\n        << \", Velocity \" << mobility->GetVelocity());\n}\n\nint\nmain(int argc, char* argv[])\n{\n    LogComponentEnable(\"ExternalMobilityExample\", LOG_LEVEL_INFO);\n\n    NodeContainer nodesA; // nodes with mobility updates every 2 seconds \n    nodesA.Create(1);\n\n    NodeContainer nodesB; // nodes with mobility updates every 1 second\n    nodesB.Create(1);\n\n    NodeContainer allNodes;\n    allNodes.Add(nodesA);\n    allNodes.Add(nodesB);\n\n    Ptr<ListPositionAllocator> positionAllocator = CreateObject<ListPositionAllocator>();\n    positionAllocator->Add(Vector(0, 0, 0)); // all nodes start at origin\n\n    MobilityHelper mobilityHelper;\n    mobilityHelper.SetMobilityModel(\"ns3::ExternalMobilityModel\");\n    mobilityHelper.SetPositionAllocator(positionAllocator);\n    mobilityHelper.Install(allNodes); // all nodes use the ExternalMobilityModel\n\n    for (NodeContainer::Iterator it = allNodes.Begin(); it != allNodes.End(); it++)\n    {\n        // call ReportMobility whenever there is a CourseChange event\n        Ptr<ExternalMobilityModel> mobility = (*it)->GetObject<ExternalMobilityModel>();\n        mobility->TraceConnectWithoutContext(\"CourseChange\", MakeBoundCallback(&ReportMobility));\n    }\n\n    // schedule the recursive UpdateMobility function for both sets of nodes\n    Simulator::Schedule(Seconds(2), &UpdateMobility, nodesA, Vector(1, 0, 0), Vector(1, 0, 0), Seconds(2));\n    Simulator::Schedule(Seconds(1), &UpdateMobility, nodesB, Vector(0, 0, 1), Vector(0, 0, 1), Seconds(1));\n\n    Simulator::Stop(Seconds(10)); // prevent infinite recursion of UpdateMobility\n    Simulator::Run();\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/simple-gateway-server.cc",
      "code": "/*\n * NIST-developed software is provided by NIST as a public service. You may use,\n * copy, and distribute copies of the software in any medium, provided that you\n * keep intact this entire notice. You may improve, modify, and create\n * derivative works of the software or any portion of the software, and you may\n * copy and distribute such modifications or works. Modified works should carry\n * a notice stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the National\n * Institute of Standards and Technology as the source of the software. \n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES NO WARRANTY\n * OF ANY KIND, EXPRESS, IMPLIED, IN FACT, OR ARISING BY OPERATION OF LAW,\n * INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, AND DATA ACCURACY. NIST\n * NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE\n * UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST DOES\n * NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE SOFTWARE OR\n * THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE CORRECTNESS, ACCURACY,\n * RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n * \n * You are solely responsible for determining the appropriateness of using and\n * distributing the software and you assume all risks associated with its use,\n * including but not limited to the risks and costs of program errors,\n * compliance with applicable laws, damage to or loss of data, programs or\n * equipment, and the unavailability or interruption of operation. This software \n * is not intended to be used in any situation where a failure could cause risk\n * of injury or damage to property. The software developed by NIST employees is\n * not subject to copyright protection within the United States.\n *\n * Author: Thomas Roth <thomas.roth@nist.gov>\n*/\n\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\n#include <cstdlib>\n#include <ctime>\n#include <string>\n#include <vector>\n\n#include \"ns3/core-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleGatewayServer\");\n\nint\nmain(int argc, char* argv[])\n{\n    bool verboseLogs        = false;\n    uint32_t timeStart      = 0;    // s\n    uint32_t timeDelta      = 1;    // s\n    uint32_t iterations     = 20;\n    uint16_t numberOfNodes  = 3;\n    uint16_t positionDeltaX = 25;   // m\n    uint16_t serverPort     = 8000;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"Enable/disable detailed log output\", verboseLogs);\n    cmd.AddValue(\"timeStart\", \"Starting simulation time in seconds\", timeStart);\n    cmd.AddValue(\"timeDelta\", \"Simulation step size in seconds\", timeDelta);\n    cmd.AddValue(\"iterations\", \"Number of time steps to simulate\", iterations);\n    cmd.AddValue(\"numberOfNodes\", \"Number of vehicle nodes to simulate\", numberOfNodes);\n    cmd.AddValue(\"positionDeltaX\", \"Maximum increase per time step to a node's x-coordinate\", positionDeltaX);\n    cmd.AddValue(\"serverPort\", \"Port number of the UDP Server\", serverPort);\n    cmd.Parse(argc, argv);\n\n    std::srand(std::time(NULL));\n\n    if (verboseLogs)\n    {\n        LogComponentEnable(\"SimpleGatewayServer\", LOG_LEVEL_ALL);\n    }\n    else\n    {\n        LogComponentEnable(\"SimpleGatewayServer\", LOG_LEVEL_INFO);\n    }\n\n    // create the server socket\n    int serverSocket = socket(AF_INET, SOCK_STREAM, 0);\n    if (serverSocket == -1)\n    {\n        NS_FATAL_ERROR(\"ERROR: failed to create the socket\");\n    }\n    int reuse = 1;\n    if (setsockopt(serverSocket, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse)) == -1)\n    {\n        NS_FATAL_ERROR(\"ERROR: failed to set the socket options\");\n    }\n\n    // set the server address\n    struct sockaddr_in serverAddress;\n    serverAddress.sin_family = AF_INET;\n    serverAddress.sin_port = htons(serverPort);\n    serverAddress.sin_addr.s_addr = INADDR_ANY;\n\n    // bind the socket to the server address\n    if (bind(serverSocket, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) == -1)\n    {\n        NS_FATAL_ERROR(\"ERROR: failed to bind the socket to port \" << serverPort);\n    }\n    \n    // listen for client connections\n    if (listen(serverSocket, 1) == -1)\n    {\n        NS_FATAL_ERROR(\"ERROR: failed to listen for client connections\");\n    }\n    NS_LOG_INFO(\"Started server on Port \" << serverPort);\n\n    // accept a client connection\n    int clientSocket = accept(serverSocket, NULL, NULL);\n    if (clientSocket == -1)\n    {\n        NS_FATAL_ERROR(\"ERROR: failed to accept the client connection\");\n    }\n    NS_LOG_INFO(\"Accepted a client connection\");\n\n    /* ========== START MESSAGE PROTOCOL =====================================*/\n\n    const size_t BUFFER_SIZE = 4096;\n    char recvBuffer[BUFFER_SIZE];\n\n    std::vector<uint16_t> xVelocity(numberOfNodes, 0);\n    std::vector<uint16_t> xPosition(numberOfNodes, 0);\n    std::vector<uint16_t> broadcast(numberOfNodes, 0);\n    \n    for (uint32_t i = 0; i < iterations; i++)\n    {\n        uint32_t timeNow = timeStart + timeDelta * i;\n        NS_LOG_INFO(\"t = \" << timeNow);\n\n        // create the next message\n        std::string message = std::to_string(timeNow) + \" 0\";                               // timestamp header\n        for (uint16_t n = 0; n < numberOfNodes; n++)\n        {\n            message += \" \" + std::to_string(xPosition[n]) + \" \" + std::to_string(n) + \" 0\"; // position vector\n            message += \" \" + std::to_string(xVelocity[n]) + \" 0 0\";                         // velocity vector\n            message += \" \" + std::to_string(broadcast[n]);                                  // broadcast bool\n        }\n        NS_LOG_DEBUG(\"next message: \" << message);\n        message += \"\\r\\n\";                                                                  // end of message\n\n        // send the next message\n        if (send(clientSocket, message.c_str(), message.size(), 0) == -1)\n        {\n            NS_FATAL_ERROR(\"ERROR: failed to send a message\");\n        }\n\n        // receive client response\n        int bytesReceived = recv(clientSocket, recvBuffer, BUFFER_SIZE - 1, 0);\n        if (bytesReceived == -1)\n        {\n            NS_FATAL_ERROR(\"ERROR: failed to receive response\");\n        }\n        else if (bytesReceived == 0)\n        {\n            NS_LOG_WARN(\"WARNING: client socket terminated connection\");\n            break;\n        }\n        else\n        {\n            recvBuffer[bytesReceived] = '\\0'; // bytesReceived < BUFFER_SIZE\n            NS_LOG_DEBUG(\"received message: \" << recvBuffer);\n        }\n\n        if (i == iterations - 1) // last iteration\n        {\n            message = \"-1 0\\r\\n\"; // terminate message\n            if (send(clientSocket, message.c_str(), message.size(), 0) == -1)\n            {\n                NS_FATAL_ERROR(\"ERROR: failed to send a message\");\n            }\n            NS_LOG_INFO(\"Sent terminate message\");\n        }\n        else\n        {\n            // simulate node movement\n            for (uint16_t n = 0; n < numberOfNodes; n++)\n            {\n                xVelocity[n] = std::rand() % positionDeltaX + 1;\n                xPosition[n] = xPosition[n] + xVelocity[n];\n                broadcast[n] = (i % 5 == 0) && (std::rand() % 2 == 0); // on multiples of 5, 50 % chance\n            }\n        }\n    }\n\n    close(clientSocket);\n    close(serverSocket);\n\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/simple-gateway.cc",
      "code": "/*\n * NIST-developed software is provided by NIST as a public service. You may use,\n * copy, and distribute copies of the software in any medium, provided that you\n * keep intact this entire notice. You may improve, modify, and create\n * derivative works of the software or any portion of the software, and you may\n * copy and distribute such modifications or works. Modified works should carry\n * a notice stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the National\n * Institute of Standards and Technology as the source of the software. \n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES NO WARRANTY\n * OF ANY KIND, EXPRESS, IMPLIED, IN FACT, OR ARISING BY OPERATION OF LAW,\n * INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, AND DATA ACCURACY. NIST\n * NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE\n * UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST DOES\n * NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE SOFTWARE OR\n * THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE CORRECTNESS, ACCURACY,\n * RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n * \n * You are solely responsible for determining the appropriateness of using and\n * distributing the software and you assume all risks associated with its use,\n * including but not limited to the risks and costs of program errors,\n * compliance with applicable laws, damage to or loss of data, programs or\n * equipment, and the unavailability or interruption of operation. This software \n * is not intended to be used in any situation where a failure could cause risk\n * of injury or damage to property. The software developed by NIST employees is\n * not subject to copyright protection within the United States.\n *\n * Author: Thomas Roth <thomas.roth@nist.gov>\n*/\n\n#include <string>\n#include <vector>\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n\n#include \"ns3/external-mobility-model.h\"\n#include \"ns3/triggered-send-application.h\"\n#include \"ns3/triggered-send-helper.h\"\n\n#include \"ns3/gateway.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleGateway\");\n\n/*\n * An example that manages a set of nodes (representing vehicles) whose mobility is controlled by the remote server.\n *\n * The received data format is:\n *  {P_X1, P_Y1, P_Z1, V_X1, V_Y1, V_Z1, Send_1, ..., P_Xn, P_Yn, P_Zn, V_X1n, V_Yn, V_Zn, Send_n}\n * where:\n *  {P_Xi, P_Yi, P_Zi} is a Vector that represents the Position of vehicle i\n *  {V_Xi, V_Yi, V_Zi} is a Vector that represents the Velocity of vehicle i\n *  Send_i is a boolean that indicates whether vehicle i should broadcast\n *\n * The response data format is:\n *  {recvCount_1, ..., recvCount_n}\n * where:\n *  recvCount_i is the number of times vehicle i has received a broadcast\n *\n * A response is sent each time data is received.\n */\nclass SimpleGateway : public Gateway\n{\n    public:\n        // initialize a simple gateway where n = vehicles.GetN()\n        SimpleGateway(NodeContainer vehicles);\n\n        // this function handles receiving broadcast messages from ns-3 (not the remote server)\n        //  id indicates the vehicle index that received the message; the other arguments are ignored\n        void HandleReceive(std::string id, Ptr<const Packet> packet, const Address &clientAddress);\n    private:\n        // this function handles processing the first message received from the remote server\n        //  the simple gateway doesn't require any initialization, so this just calls DoUpdate\n        virtual void DoInitialize(const std::vector<std::string> & data);\n\n        // this function handles processing messages received from the remote server\n        virtual void DoUpdate(const std::vector<std::string> & data);\n\n        NodeContainer m_vehicles;       // the nodes representing vehicles that are managed by the gateway\n        std::vector<uint16_t> m_count;  // the number of times each vehicle has received a broadcast\n};\n\nSimpleGateway::SimpleGateway(NodeContainer vehicles):\n    Gateway(vehicles.GetN()),\n    m_vehicles(vehicles),\n    m_count(vehicles.GetN(), 0)\n{\n    // do nothing\n}\n\nvoid\nSimpleGateway::HandleReceive(std::string id, Ptr<const Packet> packet, const Address &clientAddress)\n{\n    NS_LOG_INFO(\"At time \" << Simulator::Now().As(Time::S) << \", Node \" << id << \" received a broadcast\");\n    m_count.at(std::stoi(id)) += 1;\n}\n\nvoid\nSimpleGateway::DoInitialize(const std::vector<std::string> & data)\n{\n    DoUpdate(data);\n}\n\nvoid\nSimpleGateway::DoUpdate(const std::vector<std::string> & data)\n{\n    NS_LOG_FUNCTION(this << data);\n\n    static const uint32_t ELEMENTS_PER_VEHICLE = 7; // Position_{x,y,z} + Velocity_{x,y,z} + SendFlag\n    \n    for (uint32_t i = 0; i < m_vehicles.GetN(); i++)\n    {\n        Ptr<Node> vehicle = m_vehicles.Get(i);\n        uint32_t dataIndex = i * ELEMENTS_PER_VEHICLE;\n        \n        if (dataIndex + ELEMENTS_PER_VEHICLE > data.size())\n        {\n            NS_FATAL_ERROR(\"ERROR: received data has insufficient size\");\n        }\n\n        // update the vehicle position\n        Vector position(std::stoi(data[dataIndex]), std::stoi(data[dataIndex+1]), std::stoi(data[dataIndex+2]));\n        vehicle->GetObject<ExternalMobilityModel>()->SetPosition(position);\n\n        // update the vehicle velocity\n        Vector velocity(std::stoi(data[dataIndex+3]), std::stoi(data[dataIndex+4]), std::stoi(data[dataIndex+5]));\n        vehicle->GetObject<ExternalMobilityModel>()->SetVelocity(velocity);\n        \n        // handle the send flag\n        if (std::stoi(data[dataIndex+6]))\n        {\n            // the index '0' here is because the TriggeredSendApplication is the first application installed in main\n            DynamicCast<TriggeredSendApplication>(vehicle->GetApplication(0))->Send(3); // broadcast 3 packets\n            NS_LOG_INFO(\"At time \" << Simulator::Now().As(Time::S) << \", Node \" << i << \" sent a broadcast\");\n        }\n\n        SetValue(i, std::to_string(m_count[i])); // update the received broadcast count\n    }\n    SendResponse(); // format and send a response based on the most recent SetValue\n}\n\nvoid\nReportMobility(Ptr<const MobilityModel> mobility)\n{\n    NS_LOG_DEBUG(\"At time \" << Simulator::Now().As(Time::S)\n        << \", Node \" << mobility->GetObject<Node>()->GetId()\n        << \", Position \" << mobility->GetPosition()\n        << \", Velocity \" << mobility->GetVelocity());\n}\n\nint\nmain(int argc, char* argv[])\n{\n    bool verboseLogs            = false;\n    uint16_t numberOfNodes      = 3;\n    uint16_t serverPort         = 8000;\n    std::string serverAddress   = \"127.0.0.1\";\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"Enable/disable detailed log output\", verboseLogs);\n    cmd.AddValue(\"numberOfNodes\", \"Number of vehicle nodes to simulate\", numberOfNodes);\n    cmd.AddValue(\"serverPort\", \"Port number of the UDP Server\", serverPort);\n    cmd.AddValue(\"serverAddress\", \"Address of the UDP Server\", serverAddress);\n    cmd.Parse(argc, argv);\n\n    Time::SetResolution(Time::NS); // timestamp has nanosecond resolution\n\n    if (verboseLogs)\n    {\n        LogComponentEnable(\"Gateway\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"SimpleGateway\", LOG_LEVEL_ALL);\n    }\n    else\n    {\n        LogComponentEnable(\"Gateway\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"SimpleGateway\", LOG_LEVEL_INFO);\n    }\n\n    NodeContainer vehicles;\n    vehicles.Create(numberOfNodes);\n    NS_LOG_DEBUG(\"Creating \" << numberOfNodes << \" nodes to represent vehicles\");\n\n    // generate a list of initial positions for the mobility models\n    Ptr<ListPositionAllocator> positionAllocator = CreateObject<ListPositionAllocator>();\n    for (uint16_t i = 0; i < numberOfNodes; i++)\n    {\n        positionAllocator->Add(Vector(0, i, 0));\n    }\n\n    // install the external mobility model\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ExternalMobilityModel\");\n    mobility.SetPositionAllocator(positionAllocator);\n    mobility.Install(vehicles);\n\n    // install an Ethernet-like bus network\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    NetDeviceContainer devices = csma.Install(vehicles);\n\n    // install an IP network stack\n    InternetStackHelper stack;\n    stack.Install(vehicles);\n\n    // allocate IPv4 Addresses from 192.168.1.0/24 \n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    const Ipv4Address broadcastAddress(\"192.168.1.255\");\n    const uint16_t applicationPort = 8000;\n    SimpleGateway gateway(vehicles);\n\n    // install the applications\n    for (uint32_t i = 0; i < vehicles.GetN(); i++)\n    {\n        Ptr<Node> vehicle = vehicles.Get(i);\n\n        // call ReportMobility when the external mobility model reports a CourseChange\n        Ptr<ExternalMobilityModel> mobilityModel = vehicle->GetObject<ExternalMobilityModel>();\n        mobilityModel->TraceConnectWithoutContext(\"CourseChange\", MakeCallback(&ReportMobility));\n\n        // install a triggered send application that can be triggered to broadcast messages to the bus\n        TriggeredSendHelper sendHelper(\"ns3::UdpSocketFactory\", InetSocketAddress(broadcastAddress, applicationPort));\n        sendHelper.SetAttribute(\"PacketInterval\", TimeValue(MilliSeconds(100)));\n        ApplicationContainer clientApps = sendHelper.Install(vehicle);\n        clientApps.Start(Time(0));\n\n        // install a packet sink that calls HandleReceive when it receives a broadcasted message\n        PacketSinkHelper sinkHelper(\"ns3::UdpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), applicationPort));\n        ApplicationContainer serverApps = sinkHelper.Install(vehicle);\n        serverApps.Get(0)->TraceConnect(\"Rx\", std::to_string(i), MakeCallback(&SimpleGateway::HandleReceive, &gateway));\n        serverApps.Start(Time(0));\n    }\n\n    gateway.Connect(serverAddress, serverPort); // server must be running before this line (or error)\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/triggered-send-example.cc",
      "code": "/*\n * NIST-developed software is provided by NIST as a public service. You may use,\n * copy, and distribute copies of the software in any medium, provided that you\n * keep intact this entire notice. You may improve, modify, and create\n * derivative works of the software or any portion of the software, and you may\n * copy and distribute such modifications or works. Modified works should carry\n * a notice stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the National\n * Institute of Standards and Technology as the source of the software. \n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES NO WARRANTY\n * OF ANY KIND, EXPRESS, IMPLIED, IN FACT, OR ARISING BY OPERATION OF LAW,\n * INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, AND DATA ACCURACY. NIST\n * NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE\n * UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST DOES\n * NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE SOFTWARE OR\n * THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE CORRECTNESS, ACCURACY,\n * RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n * \n * You are solely responsible for determining the appropriateness of using and\n * distributing the software and you assume all risks associated with its use,\n * including but not limited to the risks and costs of program errors,\n * compliance with applicable laws, damage to or loss of data, programs or\n * equipment, and the unavailability or interruption of operation. This software \n * is not intended to be used in any situation where a failure could cause risk\n * of injury or damage to property. The software developed by NIST employees is\n * not subject to copyright protection within the United States.\n *\n * Author: Thomas Roth <thomas.roth@nist.gov>\n*/\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/triggered-send-application.h\"\n#include \"ns3/triggered-send-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TriggeredSendExample\");\n\nvoid\nTransmit(Ptr<Application> sendingApplication)\n{\n    // trigger the application to send 5 packets\n    DynamicCast<TriggeredSendApplication>(sendingApplication)->Send(5);\n}\n\nvoid\nPacketSinkTrace(Ptr<const Packet> pkt, const Address &addr)\n{\n    NS_LOG_INFO(\"\\t received at time \" << Simulator::Now().As(Time::S));\n}\n\nint\nmain(int argc, char* argv[])\n{\n    LogComponentEnable(\"TriggeredSendExample\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"TriggeredSendApplication\", LOG_LEVEL_INFO);\n\n    // Create the network topology: N0 (UDP Client) ---> N1 (UDP Server)\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Allocate IPv4 Addresses from 192.168.0.1/24 \n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.0.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n    Ipv4Address serverAddress = interfaces.GetAddress(1); // N1 is the server\n\n    // Create a packet sink application for the server using PacketSinkTrace as the callback when packets are received\n    PacketSinkHelper server(\"ns3::UdpSocketFactory\", InetSocketAddress(serverAddress, 8000));\n\n    ApplicationContainer serverApps = server.Install(nodes.Get(1)); // N1 is the server\n    serverApps.Get(0)->TraceConnectWithoutContext(\"Rx\", MakeCallback(&PacketSinkTrace));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Create a triggered send application for the client with a 200 ms interval between sent packets\n    TriggeredSendHelper client(\"ns3::UdpSocketFactory\", InetSocketAddress(serverAddress, 8000));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    client.SetAttribute(\"PacketInterval\", TimeValue(MilliSeconds(200)));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0)); // N0 is the client\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(12.0));\n\n    // Case 1: the send completes without interruption\n    // For this case, packets will be sent at {3.0, 3.2, 3.4, 3.6, 3.8}\n    Simulator::Schedule(Seconds(3.0), &Transmit, clientApps.Get(0));\n\n    // Case 2: the first send is interrupted before sending all of its packets\n    // For this case, packets will be sent at {4.0, 4.2, 4.4} and {4.6, 4.8, 5.0, 5.2, 5.4}\n    Simulator::Schedule(Seconds(4.0), &Transmit, clientApps.Get(0));  \n    Simulator::Schedule(Seconds(4.5), &Transmit, clientApps.Get(0));\n\n    // Case 3: the first send is interrupted while sending its final packet\n    // For this case, packets will be sent at {6.0, 6.2, 6.4, 6.6, 6.8} and {7.0, 7.2, 7.4, 7.6, 7.8}\n    Simulator::Schedule(Seconds(6.0), &Transmit, clientApps.Get(0));\n    Simulator::Schedule(Seconds(6.9), &Transmit, clientApps.Get(0));\n\n    // Case 4: the first send is interrupted at the exact time its next packet should be sent\n    // For this case, packets will be sent at {8.0, 8.2, 8.4} and {8.6, 8.8, 9.0, 9.2, 9.4}\n    Simulator::Schedule(Seconds(8.0), &Transmit, clientApps.Get(0));\n    Simulator::Schedule(Seconds(8.4), &Transmit, clientApps.Get(0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n    return 0;\n}\n"
    }
  ]
}