{
  "repo_name": "usnistgov/ns3-oran",
  "github_url": "https://github.com/usnistgov/ns3-oran",
  "readme": "# ORAN ns-3 Module\nA module that can be used in [ns-3](https://www.nsnam.org/) to simulate and\nmodel behavior based on the [O-RAN](https://www.o-ran.org) specifications.\nA conference paper that describes the model and its use in a case study can\nbe found here: [https://doi.org/10.1145/3592149.3592157](https://doi.org/10.1145/3592149.3592157)\n\n# Table of Contents\n* [Project Overview](#project-overview)\n  * [Contact](#contact)\n* [Model Description](#model-description)\n* [Features](#features)\n* [Minimum Requirements](#minimum-requirements)\n  * [Optional Dependencies](#optional-dependencies)\n* [Installation](#installation)\n  * [Clone (Recommended)](#clone-recommended)\n  * [Download ZIP](#download-zip)\n  * [Connecting the Module Quickly](#connecting-the-module-quickly)\n    * [Cmake](#cmake-quick-connect)\n    * [Code](#code-quick-connect)\n  * [Connecting the Module Safely](#connecting-the-module-safely)\n    * [Cmake](#cmake-safe-connect)\n    * [Code](#code-safe-connect)\n* [Updating](#updating)\n  * [Clone](#clone)\n  * [ZIP](#zip)\n* [ML Support](#ml-support)\n  * [ONNX](#onnx)\n  * [PyTorch](#pytorch)\n* [Documentation](#documentation)\n* [Running the Examples](#running-the-examples)\n  * [Random Walk Example](#random-walk-example)\n  * [LTE to LTE Distance Handover Example](#lte-to-lte-distance-handover-example)\n  * [LTE to LTE Distance Handover With Helper Example](#lte-to-lte-distance-handover-with-helper-example)\n  * [LTE to LTE Distance Handover With LM Processing Delay Example](#lte-to-lte-distance-handover-with-lm-processing-delay-example)\n  * [LTE to LTE Distance Handover With LM Query Trigger Example](#lte-to-lte-distance-handover-with-lm-query-trigger-example)\n  * [Keep-Alive Example](#keep-alive-example)\n  * [Data Repository Example](#data-repository-example)\n  * [Multiple Network Devices Example](#multiple-network-devices-example)\n  * [LTE to LTE ML Handover Example](#lte-to-lte-ml-handover-example)\n  * [LTE to LTE RSRP Handover LM Example](#lte-to-lte-rsrp-handover-lm-example)\n\n# Project Overview\nThis project has been developed by the National Institute of Standards and Technology (NIST)\nCommunications Technology Lab (CTL) Wireless Networks Division (WND).\n\nThis project includes open source, third party dependencies. For details of the licenses of these\ndependencies see [THIRD_PARTY_LICENSES.md](THIRD_PARTY_LICENSES.md)\n\nCertain equipment, instruments, software, or materials, commercial or non-commercial, are used in this project. Such\nusage is not intended to imply recommendation or endorsement of any product or service by NIST, nor is it intended to\nimply that the software, materials, or equipment identified are necessarily the best available for the purpose.\n\nThis project is considered feature complete, and will be maintained on a 'best effort' basis.\n\n## Contact\nTo report a bug, please open a [GitHub Issue](https://github.com/usnistgov/ns3-oran/issues/new).\nThe point of contact for this project is Evan Black ([evan.black@nist.gov](mailto:evan.black@nist.gov))\n\n\n# Model Description\nThe `oran` module for `ns-3` implements the classes required to model a\nnetwork architecture based on the O-RAN specifications. These models include\na RAN Intelligent Controller (RIC) that is functionally equivalent to\nO-RAN's Near-Real Time (Near-RT) RIC, and reporting modules that attach to\nsimulation nodes and serve as communication endpoints with the RIC in a\nsimilar fashion as the E2 Terminators in O-RAN.\n\nThese models have been designed to provide the infrastructure and access to\ndata so that developers and researchers can focus on implementing their\nsolutions, and minimize the time and effort spent on handling interactions\nbetween models. With this in mind, all the components that contain logic that\nmay be modified by end users have been modeled hierarchically (so that parent\nclasses can take care of common actions and methods and leave child models to\nfocus on the logic itself), and at least one example is provided, to serve as\nreference for new models.\n\nThe RIC model uses a data repository to store all the information exchanged\nbetween the RIC and the modules, as well as to serve as a logging endpoint.\nThis release provides an [SQLite](https://www.sqlite.org) storage backend for\nthe data repository. The database file is accessible after the simulation and\ncan be accessed by any SQLite-compatible tool and interface.\n\nModeling of the reporting and communication models for the simulation nodes\nhas been implemented using existing traces and methods, which means there is\nno need to modify the models provided by the `ns-3` distribution to make use\nof the full capabilities of this module.\n\n# Features\nThis release of the `oran` module contains the following features:\n- Near-RT RIC model, including:\n  - Data access API independent of the data repository backend\n  - SQLite database repository implementation for Reports, Commands, and\n    logging\n  - Support for Logic Modules that serve as O-RAN's `xApps`\n  - Separation of Logic Modules into `default` (only one, mandatory) and\n    `additional` (zero to many, optional)\n  - Support for addition and removal of Logic Modules during the simulation\n  - Conflict Mitigation API\n  - Logic Module and Conflict Mitigation logic logging to the data repository\n  - Periodic invocation of the Logic Module's algorithms\n- Periodic reporting of metrics from the simulation nodes to the Near-RT RIC\n- Reporting capabilities for node location (any simulation node) and LTE cell\n  attachment (LTE UE nodes)\n- Generation and execution of LTE-to-LTE handover Commands\n- Activation and deactivation for individual components and RIC\n- Periodic node registration and de-registration with the RIC\n- Integration with [ONNX Runtime](https://onnxruntime.ai/) and\n  [PyTorch](https://pytorch.org/) to support Machine Learning (ML)\n\n# Minimum Requirements\n* ns-3.42\n* SQLite 3.7.17\n\n## Optional Dependencies\n* ONNX Runtime 1.14.1\n* PyTorch 2.2.2\n\n# Installation\n## Clone (Recommended)\nClone the project into a directory called `oran` in the `contrib` directory\nof a supported version of `ns-3`.\n\n1) `cd` into the `contrib` directory of `ns-3`\n\n```shell\ncd contrib/\n```\n\n2) Clone the project from one of the below URLs\n\n```shell\n# Pick one of the below\n# HTTPS (Choose this one if you're uncertain)\ngit clone https://github.com/usnistgov/ns3-oran.git oran\n\n# SSH\ngit clone git@github.com:usnistgov/ns3-oran.git oran\n```\n\n3) (Re)configure and (Re)build `ns-3`\n\n```shell\n# --enable-examples is optional, see `Running the Examples`\n# for how to run them\n./ns3 configure --enable-examples\n./ns3\n```\n\n## Download ZIP\nIf, for whatever reason, `git` is not available, download the\nproject and unzip it into the `contrib` directory of `ns-3`.\n\nNote: Updates will have to be performed manually using this method.\n\n1) Download the ZIP of the project from the url below\n\n```shell\nwget https://github.com/usnistgov/ns3-oran/archive/refs/heads/master.zip\n```\n\n2) Unzip the file into the `ns-3` `contrib/` directory\n\n```shell\nunzip ns3-oran-master.zip\n```\n\n3) Rename the resulting directory to `oran`, as `ns-3` will not accept a\nmodule named differently than its directory\n\n```shell\nmv ns3-oran-master oran\n```\n\n## Connecting the Module Quickly\nIf you are linking your module/program to the `oran` module add the following\nto your `CMakeLists.txt`(CMake).\n\n### CMake (Quick Connect)\nFor CMake, add `oran`'s target `${liboran}` to your `libraries_to_link` list.\n\n```cmake\n# Example\nbuild_lib_example(\n  NAME your-example-name\n  SOURCE_FILES example.cc\n  LIBRARIES_TO_LINK\n    ${liboran}\n    # ...\n)\n\n# Module\nbuild_lib(\n  LIBNAME your-module-name\n  SOURCE_FILES\n    # ...\n  HEADER_FILES\n    # ...\n  LIBRARIES_TO_LINK\n    ${liboran}\n    # ...\n)\n```\n\n## Connecting the Module Safely\nYou may wish for your module to not have a hard dependency on the `oran`\nmodule. The following steps will link the `oran` module, but still allow you\nto build and run your module without the `oran` module present.\n\n### CMake (Safe Connect)\nCheck for `oran` in the `ns3-all-enabled-modules` list to confirm that the\nmodule is present.\n\nNote: If the module that links to the `oran` module is in the `src/`\ndirectory, then you will need to add the `ENABLE_ORAN` C++ define yourself when\nyou check for the presence of the module.\n\n```cmake\n# Create a list of your required modules to link\n# 'core' and 'mobility' are just examples here\n  set(libraries_to_link \"${libcore};${libmobility}\")\n\n# Check if the `oran` module is in the enabled modules list\nif(\"oran\" IN_LIST ns3-all-enabled-modules)\n  # If it is there, then it is safe to add it to the library list\n  list(APPEND libraries_to_link ${liboran})\n\n  # N.B. if the module you are linking to is in the `src/` directory\n  # of ns-3, then (at least for now), you must also add the C++ define\n  # yourself, like this.\n  #\n  # There is no harm in repeated definitions of the same value, so there is no\n  # need to guard this statement\n  add_definitions(-DENABLE_ORAN)\nendif()\n\n# Use the `libraries_to_link` list as your dependency list\n\n# Module\nbuild_lib(\n  LIBNAME your-module\n  SOURCE_FILES\n    # ...\n  HEADER_FILES\n    # ...\n  LIBRARIES_TO_LINK\n    ${libraries_to_link}\n)\n\n# Example\nbuild_lib_example(\n  NAME your-scenario\n  SOURCE_FILES scenario.cc\n  LIBRARIES_TO_LINK\n    ${libraries_to_link}\n)\n```\n\n### Code (Safe Connect)\nIn addition to the variable in the build environment, the module also defines\na C++ macro also named `ENABLE_ORAN`. This macro may be used in C++ code to\ncheck for the presence of the `oran` module.\n\nNote: If you are using CMake and the module is in the `src/` directory, you\nmay have to add this definition yourself (`scratch/` and module examples are\nfine). See\n[the CMake build system section for more information](#build-system).\n\n```cpp\n// Guard the include with the macro\n#ifdef ENABLE_ORAN\n#include <ns3/oran-module.h>\n#endif\n\n// ...\n\nint main ()\n{\n  // ...\n\n  // Guard any oran references in code with the macro as well\n#ifdef ENABLE_ORAN\n  auto oranHelper = CreateObject<OranHelper> ();\n  // ...\n#endif\n}\n```\n\n# Updating\n## Clone\nTo update the cloned module, move to the module's root directory and perform\na `git pull`.\n\n```shell\n# From the ns-3 root\ncd contrib/oran\ngit pull\n```\n\n## ZIP\nTo update a ZIP installation, remove the old module and replace it with the\nupdated one.\n\n```shell\n# From the ns-3 root\ncd contrib\nrm -Rf oran\n\n# Use this command, or download manually\nwget https://github.com/usnistgov/ns3-oran/archive/refs/heads/master.zip \\\n  -O ns3-oran-master.zip\nunzip ns3-oran-master.zip\n\n# Make sure the directory in the ns-3 contrib/ directory is named `oran`\nmv ns3-oran-master oran\n```\n# ML Support\nML is not required to use this module, however, we provide a means of\nintegration for both ONNX and PyTorch so that it is possible to use ML to\nmake inferences when running simulations. Therefore, users who wish to\nsimulate O-RAN based solutions that leverage ML may do so using this module.\nIt does however require the extra step of making at least one of these\nlibraries accessible to our module so that we can link and compile against it.\nThis also means that while these tools may be installed and accessible system\nwide, this is not a requirement as it is possible to have a locally compiled\nversion of the library and source files in a user's working space. Please note\nthat when using these tools with our module, the expectation is that the user\nwill have already trained and created an ML model outside of the O-RAN\nsimulations, but once this is done, that model may be used via the ONNX or\nPyTorch C++ API from the simulation. We provide a class for each tool to\ndemonstrate the use of both ONNX and PyTorch, respectively:\n- OranLmLte2LteOnnxHandover\n- OranLmLte2LteTorchHandover\n\nOranLmLte2LteOnnxHandover is defined by the files:\n- 'model/oran-lm-lte-2-lte-onnx-handover.h'\n- 'model/oran-lm-lte-2-lte-onnx-handover.cc'\n\nOranLmLte2LteTorchHandover is defined by the files:\n- 'model/oran-lm-lte-2-lte-torch-handover.h'\n- 'model/oran-lm-lte-2-lte-torch-handover.cc'\n\nThere is also the\n[LTE to LTE ML Handover Example](#lte-to-lte-ml-handover-example)\nthat we will discuss later that demonstrates the use\nof these two classes using existing ML models included with this module.\n\n## ONNX\nAt the time that this documentation was created, not very many linux\ndistributions provide ONNX packages. However, the use of ONNX for this module\nis attractive since models that are created using other tools, such as\nPyTorch, can be exported to ONNX. Therfore, integration with ONNX was desired\nwith the hopes that it can be used to provide the flexibility needed to\nsupport more than one type of ML model without having to integrate each\nindividually. To make use of ONNX with this module, one simply needs to\ndownload the ONNX libraries that are distributed on the ONNX webiste\n([https://onnxruntime.ai/](https://onnxruntime.ai/)), and export the location\nof the extracted library to the `LIBONNXPATH` environment variable. For\nexample,\n\n```shell\n# Download the library files\nwget \"https://github.com/microsoft/onnxruntime/releases/download/v1.14.1/onnxruntime-linux-x64-1.14.1.tgz\"\n\n# Extract the library files\ntar xzf onnxruntime-linux-x64-1.14.1.tgz\n\n# Create environment variable with library location so that cmake knows where\n# to find it\nexport LIBONNXPATH=\"$(pwd)/onnxruntime-linux-x64-1.14.1\"\n\n```\n\nAt this point, the user should be able to navigate to their working directory\nof `ns-3` and run\n\n```shell\n./ns3 configure\n```\n\nThe output of this command should include the text \"find_external_library:\nOnnxRuntime was found,\" indicating that the library and necessary source\nfiles were discovered.\n\n## PyTorch\nPyTorch is widely available through most linux distribution package bases.\nTherefore, a user should simply be able to install the desired\n\"python-pytorch\" package with no further steps being required. However, if\nthe user cannot or does not wish to install the package, one simply can\ndownload the PyTorch libraries that are distrubited on the PyTorch webiste\n([https://pytorch.org/](https://pytorch.org/)), and export the location of the\nextracted library to the `LIBTORCHPATH` environment variable. For example,\n\n```shell\n# Download the library files\nwget \"https://download.pytorch.org/libtorch/cpu/libtorch-cxx11-abi-shared-with-deps-2.2.2%2Bcpu.zip\"\n\n# Extract the library files\nunzip libtorch-cxx11-abi-shared-with-deps-2.2.2+cpu.zip\n\n# Create environment variable with library location so that cmake knows where\n# to find it\nexport LIBTORCHPATH=\"$(pwd)/libtorch\"\n\n```\nAt this point, the accessibility of the library can be verified by navigating\nto the working directory of `ns-3` and running the following command.\n\n```shell\n./ns3 configure\n```\n\nThe output of this command should include the text \"find_external_library:\nTorch was found,\" indicating that the library and necessary source\nfiles were discovered.\n\n# Documentation\n[Sphinx](https://www.sphinx-doc.org/en/master/) is required to build the\ndocumentation.\n\nTo run Sphinx to build the documentation, cd into the `doc` directory in the\nmodule and run `make [type]` for the type of documentation you wish to build.\n\n```shell\n\n# From the ns-3 root directory\ncd contrib/oran/doc\n\n# HTML (Several Pages)\nmake html\n\n# HTML (One Page)\nmake singlehtml\n\n# PDF\nmake latexpdf\n\n# To list other options, just run make\nmake\n```\n\nThe built documentation can now be found in `doc/build/[type]`.\n\n# Running the Examples\nListed below are the commands to run the examples provided with the module.\n\n## Random Walk Example\nExample with a very simple topology in which `ns-3` nodes move randomly and\nperiodically report their position to the Near-RT RIC.\n\n```shell\n./ns3 run \"oran-random-walk-example --verbose\"\n```\n\n## LTE to LTE Distance Handover Example\nA complex scenario that shows how to configure and deploy each of the models\nmanually, without using the `oran`'s helper. This scenario consists of 2 LTE\neNBs and 1 LTE UE that moves back and forth between both eNBs. The UE is\ninitially attached to the closest eNB, but as it moves closer to the other\neNB, the Logic Module in the RIC will issue a handover Command and the UE\nwill be handed over to the other eNB.\n\n```shell\n./ns3 run \"oran-lte-2-lte-distance-handover-example\"\n```\n\n## LTE to LTE Distance Handover With Helper Example\nFunctionally the same scenario as the\n[LTE to LTE Distance Handover Example](#lte-to-lte-distance-handover-example),\nhowever, in this scenario the helper is used to configure and deploy the\nmodels.\n\n```shell\n./ns3 run \"oran-lte-2-lte-distance-handover-helper-example\"\n```\n\n## LTE to LTE Distance Handover With LM Processing Delay Example\nSimilar to the\n[LTE to LTE Distance Handover With Helper Example](#lte-to-lte-distance-handover-with-helper-example),\nhowever, in this scenario the Logic Module is configured with a processing\ndelay.\n\n```shell\n./ns3 run \"oran-lte-2-lte-distance-handover-lm-processing-delay-example\"\n```\n\n## LTE to LTE Distance Handover With LM Query Trigger Example\nSimilar to the\n[LTE to LTE Distance Handover With Helper Example](#lte-to-lte-distance-handover-with-helper-example)\nexample, however, in this scenario the Near-RT RIC is configured with a\ncustom Query Trigger (provided in the scenario) that may initiate the Logic\nModule querying process as soon as Reports with certain characteristics are\nreceived by the Near-RT RIC.\n\n```shell\n./ns3 run \"oran-lte-2-lte-distance-handover-lm-query-trigger-example\"\n```\n\n## Keep-Alive Example\nThis example showcases how the keep-alive mechanism works. A single node\nmoving in a straight line periodically reports its position to the Near-RT\nRIC. However, not all of these Reports will be accepted by the Near-RT RIC\nbecause the configuration of the timing for sending Registration messages in\nthe node means that the node will frequently be marked as \u2019inactive\u2019 by the\nNear-RT RIC.\n\n```shell\nNS_LOG=\"OranE2NodeTerminator=prefix_time|warn\" ./ns3 run \"oran-keep-alive-example\"\n```\n\n## Data Repository Example\nThis example showcases how the Data Repository API can be used to store and\nretrieve information. This example performs all these operations from the\nscenario for simplicity, but the same methods can be used by any model in the\nsimulation that can access the RIC. This will be important when developing\ncustom Logic Modules, and can also be used in scenarios for debugging,\ntesting and validation.\n\n```shell\n./ns3 run \"oran-data-repository-example\"\n```\n\n## Multiple Network Devices Example\nSimilar to the\n[LTE to LTE Distance Handover Wth Helper Example](#lte-to-lte-distance-handover-with-helper-example)\nthis example showcases how a node with several network devices can interact\nwith the Near-RT RIC separately.\n\n```shell\n./ns3 run \"oran-multiple-net-devices-example\"\n```\n\n## LTE to LTE ML Handover Example\nNote that in order to run this example using the flag, `--use-onnx-lm`, the\nONNX libraries must be found during the configuration of `ns-3`, and it is\nassumed that the ML model file \"saved_trained_model_pytorch.onnx\" has been\ncopied from the example directory to the working directory. In order to run\nthis example using the flag, `--use-torch-lm`, the PyTorch libraries must be\nfound during the configuration of `ns-3`, and it is assumed that the ML model\nfile \"saved_trained_model_pytorch.pt\" has been copied from the example\ndirectory to the working directory.\n\nThis example showcases how pretrained ONNX and PyTorch ML Models can be used\nto initiate handovers based on location and packet loss data. It consists of\nfour UEs and two eNBs, where UE 1 and UE 4 are configured to move only within\ncoverage of eNB 1 or eNB 2, respectively, while UE 2 and UE 3 move around in\nan area where the coverage of eNB 1 and eNB 2 overlap. As the simulation\nprogresses with UEs moving and receiving data, the distances of all four UEs\nas well as the recorded packet loss for each UE are fed to an ML model that\nreturns a desired configuration that indicates which eNB UE 2 and UE 3 should\nbe attached to minimize the overall packet loss. The models that we provide\nare for demonstration purposes only and have not been thoroughly developed. It\nshould also be noted that \"saved_trained_model_pytorch.onnx\" is the same\ntrained model as \"saved_trained_model_pytorch.pt\" only it  has been exported\nto the ONNX format.\n\n```shell\n./ns3 run \"oran-lte-2-lte-ml-handover-example\"\n```\n\nWithout going into too many details, there is also a script included in the\nexamples folder called,\n\"oran-lte-2-lte-ml-handover-example-generate-training-data.sh,\" that can be\nused as a start to generate data using this same example to train an ML model.\nFurthermore, once the training data has been generated, the file\n\"oran-lte-2-lte-ml-handover-example-classifier.py\" that is also included in\nthe example folder, can be used to produce a PyTorch ML model using the\ntraining data that is generated.\n\n## LTE to LTE RSRP Handover LM Example\nIn this scenario the Near-RT RIC is configured with an LM that uses RSRP\nmeasurements that are reported by the UE to trigger handovers.\n\n```shell\n./ns3 run \"oran-lte-2-lte-rsrp-handover-lm-example\"\n```\n",
  "examples": [
    {
      "file_path": "examples/oran-data-repository-example.cc",
      "code": "/**\n * NIST-developed software is provided by NIST as a public service. You may\n * use, copy and distribute copies of the software in any medium, provided that\n * you keep intact this entire notice. You may improve, modify and create\n * derivative works of the software or any portion of the software, and you may\n * copy and distribute such modifications or works. Modified works should carry\n * a notice stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the National\n * Institute of Standards and Technology as the source of the software.\n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES NO\n * WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF\n * LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT AND DATA ACCURACY. NIST\n * NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE\n * UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST\n * DOES NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE\n * SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE\n * CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n *\n * You are solely responsible for determining the appropriateness of using and\n * distributing the software and you assume all risks associated with its use,\n * including but not limited to the risks and costs of program errors,\n * compliance with applicable laws, damage to or loss of data, programs or\n * equipment, and the unavailability or interruption of operation. This\n * software is not intended to be used in any situation where a failure could\n * cause risk of injury or damage to property. The software developed by NIST\n * employees is not subject to copyright protection within the United States.\n */\n\n#include \"ns3/oran-module.h\"\n\n#include <iostream>\n#include <sqlite3.h>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OranDataRepositoryExample\");\n\n/**\n * Short example that demonstrates how the data storage API can be used to\n * store and load information. In this example 3 notional nodes are\n * registered (1 wired node, 1 LTE eNB, and 1 LTE UE). After that the wired\n * node is then deregistered. Following notional positions at notional times\n * are saved for the LTE UE. These positions are then retrieved and reported\n * if they fall in a given time range. After that, notional LTE UE cell\n * information is stored, retrieved, and then reported.\n */\nint\nmain(int argc, char* argv[])\n{\n    // Make sure we are not using an old DB file\n    std::remove(\"oran-repository.db\");\n\n    // In this particular case we are using an SQLITE backend.\n    Ptr<OranDataRepository> repository = CreateObject<OranDataRepositorySqlite>();\n\n    // Initialize and activate the data store.\n    repository->Activate();\n\n    // Register three nodes\n    // Register wired node\n    uint64_t wiredE2NodeId = repository->RegisterNode(OranNearRtRic::NodeType::WIRED, 1);\n    // Registere LTE eNB with\n    repository->RegisterNodeLteUe(2, 1);\n    // Register LTE UE\n    uint64_t lteUeE2NodeId = repository->RegisterNodeLteUe(3, 1);\n\n    // Check if the wired node is registered and report it's status\n    if (repository->IsNodeRegistered(wiredE2NodeId))\n    {\n        std::cout << \"E2 Node with ID = \" << wiredE2NodeId << \" is registered.\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"E2 Node with ID = \" << wiredE2NodeId << \" is NOT registered.\" << std::endl;\n    }\n\n    // Deregister the wired node.\n    repository->DeregisterNode(wiredE2NodeId);\n\n    // Check if the wired node is registered and report it's status\n    if (repository->IsNodeRegistered(wiredE2NodeId))\n    {\n        std::cout << \"E2 Node with ID = \" << wiredE2NodeId << \" is registered.\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"E2 Node with ID = \" << wiredE2NodeId << \" is NOT registered.\" << std::endl;\n    }\n\n    // Store some reported locations for the LTE UE.\n    repository->SavePosition(lteUeE2NodeId, Vector(0, 0, 1.5), Seconds(0));\n    repository->SavePosition(lteUeE2NodeId, Vector(10, 10, 1.5), Seconds(10));\n    repository->SavePosition(lteUeE2NodeId, Vector(100, 100, 1.5), Seconds(100));\n\n    // Get all positions for the LTE UE that fall within 0 s and 15 s of time.\n    std::map<Time, Vector> lteUeNodePositions =\n        repository->GetNodePositions(lteUeE2NodeId, Seconds(0), Seconds(15));\n\n    // Report the retrieved positions.\n    for (auto it = lteUeNodePositions.begin(); it != lteUeNodePositions.end(); it++)\n    {\n        std::cout << \"E2 Node with ID = \" << lteUeE2NodeId << \" located at (\" << it->second.x\n                  << \", \" << it->second.y << \", \" << it->second.z << \")\"\n                  << \" at time t = \" << it->first.As(Time::S) << std::endl;\n    }\n\n    // Save information about the cell that the UE is currently connected.\n    repository->SaveLteUeCellInfo(lteUeE2NodeId, 1, 1, Seconds(10));\n\n    uint16_t rnti;\n    uint16_t cellId;\n    // Get the cell information that was stored for the UE and report it if it\n    // was found.\n    bool found;\n    std::tie(found, cellId, rnti) = repository->GetLteUeCellInfo(lteUeE2NodeId);\n    if (found)\n    {\n        std::cout << \"LTE UE with E2 Node ID = \" << lteUeE2NodeId\n                  << \" and RNTI = \" << (uint32_t)rnti\n                  << \" is connected to cell with Cell ID = \" << (uint32_t)cellId << std::endl;\n    }\n\n    return (0);\n}\n"
    },
    {
      "file_path": "examples/oran-keep-alive-example.cc",
      "code": "/**\n * NIST-developed software is provided by NIST as a public service. You may\n * use, copy and distribute copies of the software in any medium, provided that\n * you keep intact this entire notice. You may improve, modify and create\n * derivative works of the software or any portion of the software, and you may\n * copy and distribute such modifications or works. Modified works should carry\n * a notice stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the National\n * Institute of Standards and Technology as the source of the software.\n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES NO\n * WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF\n * LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT AND DATA ACCURACY. NIST\n * NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE\n * UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST\n * DOES NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE\n * SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE\n * CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n *\n * You are solely responsible for determining the appropriateness of using and\n * distributing the software and you assume all risks associated with its use,\n * including but not limited to the risks and costs of program errors,\n * compliance with applicable laws, damage to or loss of data, programs or\n * equipment, and the unavailability or interruption of operation. This\n * software is not intended to be used in any situation where a failure could\n * cause risk of injury or damage to property. The software developed by NIST\n * employees is not subject to copyright protection within the United States.\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/oran-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OranKeepAliveExample\");\n\n/**\n * Example to show how the Keep-Alive feature of the ORAN models works.\n * The E2 Node is set to send a Registration (aka Keep-Alive) message\n * every 2 to 3 seconds. However, the RIC will consider any E2 Node that\n * hasn't updated its registration in the last second as Deregistered.\n *\n * We can see the effects on the Database (multiple location entries will\n * be missing), and activating the WARN log in the OranE2NodeTerminator,\n * which will report each registration interval that is greater than the\n * RIC's threshold\n */\n\nint\nmain(int argc, char* argv[])\n{\n    uint16_t numberOfNodes = 1;\n    Time simTime = Seconds(105);\n    bool verbose = false;\n    std::string dbFileName = \"oran-repository.db\";\n\n    // Command line arguments\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"duration\", \"The length of the simulation.\", simTime);\n    cmd.AddValue(\"verbose\", \"Enable printing node location.\", verbose);\n    cmd.Parse(argc, argv);\n\n    // Create nodes.\n    NodeContainer nodes;\n    nodes.Create(numberOfNodes);\n\n    // Setup mobility model.\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0, 0, 0));\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(nodes);\n    nodes.Get(0)->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(1, 0, 0));\n\n    // Deploy ORAN\n    Ptr<OranNearRtRic> nearRtRic = nullptr;\n    OranE2NodeTerminatorContainer e2NodeTerminators;\n    Ptr<OranHelper> oranHelper = CreateObject<OranHelper>();\n    oranHelper->SetAttribute(\"Verbose\", BooleanValue(true));\n    oranHelper->SetAttribute(\"E2NodeInactivityThreshold\", TimeValue(Seconds(1)));\n    oranHelper->SetAttribute(\"E2NodeInactivityIntervalRv\",\n                             StringValue(\"ns3::ConstantRandomVariable[Constant=0.5]\"));\n\n    // RIC setup\n    if (!dbFileName.empty())\n    {\n        std::remove(dbFileName.c_str());\n    }\n\n    oranHelper->SetDataRepository(\"ns3::OranDataRepositorySqlite\",\n                                  \"DatabaseFile\",\n                                  StringValue(dbFileName));\n    oranHelper->SetDefaultLogicModule(\"ns3::OranLmNoop\");\n    oranHelper->SetConflictMitigationModule(\"ns3::OranCmmNoop\");\n\n    nearRtRic = oranHelper->CreateNearRtRic();\n\n    // Terminator nodes setup\n    oranHelper->SetE2NodeTerminator(\"ns3::OranE2NodeTerminatorWired\",\n                                    \"RegistrationIntervalRv\",\n                                    StringValue(\"ns3::UniformRandomVariable[Min=2|Max=3]\"),\n                                    \"SendIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=2]\"));\n\n    oranHelper->AddReporter(\"ns3::OranReporterLocation\",\n                            \"Trigger\",\n                            StringValue(\"ns3::OranReportTriggerPeriodic\"));\n\n    e2NodeTerminators.Add(oranHelper->DeployTerminators(nearRtRic, nodes));\n\n    // Activate and the components\n    Simulator::Schedule(Seconds(1), &OranHelper::ActivateAndStartNearRtRic, oranHelper, nearRtRic);\n    Simulator::Schedule(Seconds(5),\n                        &OranHelper::ActivateE2NodeTerminators,\n                        oranHelper,\n                        e2NodeTerminators);\n\n    // Run the simulation.\n    Simulator::Stop(simTime);\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/oran-lte-2-lte-distance-handover-example.cc",
      "code": "/**\n * NIST-developed software is provided by NIST as a public service. You may\n * use, copy and distribute copies of the software in any medium, provided that\n * you keep intact this entire notice. You may improve, modify and create\n * derivative works of the software or any portion of the software, and you may\n * copy and distribute such modifications or works. Modified works should carry\n * a notice stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the National\n * Institute of Standards and Technology as the source of the software.\n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES NO\n * WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF\n * LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT AND DATA ACCURACY. NIST\n * NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE\n * UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST\n * DOES NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE\n * SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE\n * CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n *\n * You are solely responsible for determining the appropriateness of using and\n * distributing the software and you assume all risks associated with its use,\n * including but not limited to the risks and costs of program errors,\n * compliance with applicable laws, damage to or loss of data, programs or\n * equipment, and the unavailability or interruption of operation. This\n * software is not intended to be used in any situation where a failure could\n * cause risk of injury or damage to property. The software developed by NIST\n * employees is not subject to copyright protection within the United States.\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/oran-module.h\"\n\n#include <stdio.h>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OranLte2LteDistanceHandoverExample\");\n\n/**\n * Usage example of the ORAN models.\n *\n * The scenario consists of an LTE UE moving back and forth\n * between 2 LTE eNBs. The LTE UE reports to the RIC its location\n * and current Cell ID. In the RIC, an LM will periodically check\n * the position, and if needed, issue a handover command.\n */\n\nvoid\nNotifyHandoverEndOkEnb(std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" \" << context << \" eNB CellId \" << cellid\n              << \": completed handover of UE with IMSI \" << imsi << \" RNTI \" << rnti << std::endl;\n}\n\nvoid\nReverseVelocity(NodeContainer nodes, Time interval)\n{\n    for (uint32_t idx = 0; idx < nodes.GetN(); idx++)\n    {\n        Ptr<ConstantVelocityMobilityModel> mobility =\n            nodes.Get(idx)->GetObject<ConstantVelocityMobilityModel>();\n        mobility->SetVelocity(Vector(mobility->GetVelocity().x * -1, 0, 0));\n    }\n\n    Simulator::Schedule(interval, &ReverseVelocity, nodes, interval);\n}\n\nvoid\nQueryRcSink(std::string query, std::string args, int rc)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" Query \"\n              << ((rc == SQLITE_OK || rc == SQLITE_DONE) ? \"OK\" : \"ERROR\") << \"(\" << rc << \"): \\\"\"\n              << query << \"\\\"\";\n\n    if (!args.empty())\n    {\n        std::cout << \" (\" << args << \")\";\n    }\n    std::cout << std::endl;\n}\n\n/**\n * ORAN handover example. Based on the LTE module's \"lena-x2-handover.cc\".\n */\nint\nmain(int argc, char* argv[])\n{\n    uint16_t numberOfUes = 1;\n    uint16_t numberOfEnbs = 2;\n    Time simTime = Seconds(50);\n    double distance = 50;\n    Time interval = Seconds(15);\n    double speed = 1.5;\n    bool verbose = false;\n    std::string dbFileName = \"oran-repository.db\";\n\n    // Command line arguments\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"Enable printing SQL queries results\", verbose);\n    cmd.Parse(argc, argv);\n\n    Config::SetDefault(\"ns3::LteHelper::UseIdealRrc\", BooleanValue(false));\n\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n    lteHelper->SetSchedulerType(\"ns3::RrFfMacScheduler\");\n    lteHelper->SetHandoverAlgorithmType(\"ns3::NoOpHandoverAlgorithm\"); // disable automatic handover\n\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n\n    NodeContainer ueNodes;\n    NodeContainer enbNodes;\n    enbNodes.Create(numberOfEnbs);\n    ueNodes.Create(numberOfUes);\n\n    // Install Mobility Model\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    for (uint16_t i = 0; i < numberOfEnbs; i++)\n    {\n        positionAlloc->Add(Vector(distance * i, 0, 20));\n    }\n\n    for (uint16_t i = 0; i < numberOfUes; i++)\n    {\n        // Coordinates of the middle point between the eNBs, minus the distance covered\n        // in half of the interval for switching directions\n        positionAlloc->Add(Vector((distance / 2) - (speed * (interval.GetSeconds() / 2)), 0, 1.5));\n    }\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(enbNodes);\n\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(ueNodes);\n\n    for (uint32_t idx = 0; idx < ueNodes.GetN(); idx++)\n    {\n        Ptr<ConstantVelocityMobilityModel> mobility =\n            ueNodes.Get(idx)->GetObject<ConstantVelocityMobilityModel>();\n        mobility->SetVelocity(Vector(speed, 0, 0));\n    }\n\n    // Schedule the first direction switch\n    Simulator::Schedule(interval, &ReverseVelocity, ueNodes, interval);\n\n    // Install LTE Devices in eNB and UEs\n    NetDeviceContainer enbLteDevs = lteHelper->InstallEnbDevice(enbNodes);\n    NetDeviceContainer ueLteDevs = lteHelper->InstallUeDevice(ueNodes);\n    // Install the IP stack on the UEs\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpIfaces;\n    ueIpIfaces = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueLteDevs));\n\n    // Attach all UEs to the first eNodeB\n    for (uint16_t i = 0; i < numberOfUes; i++)\n    {\n        lteHelper->Attach(ueLteDevs.Get(i), enbLteDevs.Get(0));\n    }\n\n    // Add X2 interface\n    lteHelper->AddX2Interface(enbNodes);\n\n    // ORAN Models -- BEGIN\n    if (!dbFileName.empty())\n    {\n        std::remove(dbFileName.c_str());\n    }\n    Ptr<OranDataRepository> dataRepository = CreateObject<OranDataRepositorySqlite>();\n    Ptr<OranLm> defaultLm = CreateObject<OranLmLte2LteDistanceHandover>();\n    Ptr<OranCmm> cmm = CreateObject<OranCmmNoop>();\n    Ptr<OranNearRtRic> nearRtRic = CreateObject<OranNearRtRic>();\n    Ptr<OranNearRtRicE2Terminator> nearRtRicE2Terminator =\n        CreateObject<OranNearRtRicE2Terminator>();\n\n    dataRepository->SetAttribute(\"DatabaseFile\", StringValue(dbFileName));\n    if (verbose)\n    {\n        dataRepository->TraceConnectWithoutContext(\"QueryRc\", MakeCallback(&QueryRcSink));\n    }\n\n    defaultLm->SetAttribute(\"Verbose\", BooleanValue(true));\n    defaultLm->SetAttribute(\"NearRtRic\", PointerValue(nearRtRic));\n    defaultLm->SetAttribute(\"ProcessingDelayRv\",\n                            StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    cmm->SetAttribute(\"NearRtRic\", PointerValue(nearRtRic));\n    cmm->SetAttribute(\"Verbose\", BooleanValue(true));\n\n    nearRtRicE2Terminator->SetAttribute(\"NearRtRic\", PointerValue(nearRtRic));\n    nearRtRicE2Terminator->SetAttribute(\"DataRepository\", PointerValue(dataRepository));\n    nearRtRicE2Terminator->SetAttribute(\"TransmissionDelayRv\",\n                                        StringValue(\"ns3::ConstantRandomVariable[Constant=0.001]\"));\n\n    nearRtRic->SetAttribute(\"DefaultLogicModule\", PointerValue(defaultLm));\n    nearRtRic->SetAttribute(\"E2Terminator\", PointerValue(nearRtRicE2Terminator));\n    nearRtRic->SetAttribute(\"DataRepository\", PointerValue(dataRepository));\n    nearRtRic->SetAttribute(\"LmQueryInterval\", TimeValue(Seconds(5)));\n    nearRtRic->SetAttribute(\"ConflictMitigationModule\", PointerValue(cmm));\n    nearRtRic->SetAttribute(\"E2NodeInactivityThreshold\", TimeValue(Seconds(2)));\n    nearRtRic->SetAttribute(\"E2NodeInactivityIntervalRv\",\n                            StringValue(\"ns3::ConstantRandomVariable[Constant=2]\"));\n    nearRtRic->SetAttribute(\"LmQueryMaxWaitTime\",\n                            TimeValue(Seconds(0))); // 0 means wait for all LMs to finish\n    nearRtRic->SetAttribute(\"LmQueryLateCommandPolicy\", EnumValue(OranNearRtRic::DROP));\n\n    Simulator::Schedule(Seconds(1), &OranNearRtRic::Start, nearRtRic);\n\n    for (uint32_t idx = 0; idx < ueNodes.GetN(); idx++)\n    {\n        Ptr<OranReporterLocation> locationReporter = CreateObject<OranReporterLocation>();\n        Ptr<OranReporterLteUeCellInfo> lteUeCellInfoReporter =\n            CreateObject<OranReporterLteUeCellInfo>();\n        Ptr<OranE2NodeTerminatorLteUe> lteUeTerminator = CreateObject<OranE2NodeTerminatorLteUe>();\n\n        locationReporter->SetAttribute(\"Terminator\", PointerValue(lteUeTerminator));\n        locationReporter->SetAttribute(\"Trigger\", StringValue(\"ns3::OranReportTriggerPeriodic\"));\n\n        lteUeCellInfoReporter->SetAttribute(\"Terminator\", PointerValue(lteUeTerminator));\n        lteUeCellInfoReporter->SetAttribute(\n            \"Trigger\",\n            StringValue(\"ns3::OranReportTriggerLteUeHandover[InitialReport=true]\"));\n\n        lteUeTerminator->SetAttribute(\"NearRtRic\", PointerValue(nearRtRic));\n        lteUeTerminator->SetAttribute(\"RegistrationIntervalRv\",\n                                      StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n        lteUeTerminator->SetAttribute(\"SendIntervalRv\",\n                                      StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n        lteUeTerminator->SetAttribute(\"TransmissionDelayRv\",\n                                      StringValue(\"ns3::ConstantRandomVariable[Constant=0.001]\"));\n\n        lteUeTerminator->AddReporter(locationReporter);\n        lteUeTerminator->AddReporter(lteUeCellInfoReporter);\n\n        lteUeTerminator->Attach(ueNodes.Get(idx));\n\n        Simulator::Schedule(Seconds(2), &OranE2NodeTerminatorLteUe::Activate, lteUeTerminator);\n    }\n\n    for (uint32_t idx = 0; idx < enbNodes.GetN(); idx++)\n    {\n        Ptr<OranReporterLocation> locationReporter = CreateObject<OranReporterLocation>();\n        Ptr<OranE2NodeTerminatorLteEnb> lteEnbTerminator =\n            CreateObject<OranE2NodeTerminatorLteEnb>();\n\n        locationReporter->SetAttribute(\"Terminator\", PointerValue(lteEnbTerminator));\n        locationReporter->SetAttribute(\"Trigger\", StringValue(\"ns3::OranReportTriggerPeriodic\"));\n\n        lteEnbTerminator->SetAttribute(\"NearRtRic\", PointerValue(nearRtRic));\n        lteEnbTerminator->SetAttribute(\"RegistrationIntervalRv\",\n                                       StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n        lteEnbTerminator->SetAttribute(\"SendIntervalRv\",\n                                       StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n        lteEnbTerminator->SetAttribute(\"TransmissionDelayRv\",\n                                       StringValue(\"ns3::ConstantRandomVariable[Constant=0.001]\"));\n\n        lteEnbTerminator->AddReporter(locationReporter);\n\n        lteEnbTerminator->Attach(enbNodes.Get(idx));\n\n        Simulator::Schedule(Seconds(1.5), &OranE2NodeTerminatorLteEnb::Activate, lteEnbTerminator);\n    }\n\n    // ORAN Models -- END\n\n    // Trace the end of handovers\n    Config::Connect(\"/NodeList/*/DeviceList/*/LteEnbRrc/HandoverEndOk\",\n                    MakeCallback(&NotifyHandoverEndOkEnb));\n\n    Simulator::Stop(simTime);\n    Simulator::Run();\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/oran-lte-2-lte-distance-handover-helper-example.cc",
      "code": "/**\n * NIST-developed software is provided by NIST as a public service. You may\n * use, copy and distribute copies of the software in any medium, provided that\n * you keep intact this entire notice. You may improve, modify and create\n * derivative works of the software or any portion of the software, and you may\n * copy and distribute such modifications or works. Modified works should carry\n * a notice stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the National\n * Institute of Standards and Technology as the source of the software.\n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES NO\n * WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF\n * LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT AND DATA ACCURACY. NIST\n * NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE\n * UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST\n * DOES NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE\n * SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE\n * CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n *\n * You are solely responsible for determining the appropriateness of using and\n * distributing the software and you assume all risks associated with its use,\n * including but not limited to the risks and costs of program errors,\n * compliance with applicable laws, damage to or loss of data, programs or\n * equipment, and the unavailability or interruption of operation. This\n * software is not intended to be used in any situation where a failure could\n * cause risk of injury or damage to property. The software developed by NIST\n * employees is not subject to copyright protection within the United States.\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/oran-module.h\"\n\n#include <stdio.h>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OranLte2LteDistanceHandoverHelperExample\");\n\n/**\n * Usage example of the ORAN models, configured with the ORAN Helper.\n *\n * The scenario consists of an LTE UE moving back and forth\n * between 2 LTE eNBs. The LTE UE reports to the RIC its location\n * and current Cell ID. In the RIC, an LM will periodically check\n * the position, and if needed, issue a handover command.\n */\n\nvoid\nNotifyHandoverEndOkEnb(std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" \" << context << \" eNB CellId \" << cellid\n              << \": completed handover of UE with IMSI \" << imsi << \" RNTI \" << rnti << std::endl;\n}\n\nvoid\nReverseVelocity(NodeContainer nodes, Time interval)\n{\n    for (uint32_t idx = 0; idx < nodes.GetN(); idx++)\n    {\n        Ptr<ConstantVelocityMobilityModel> mobility =\n            nodes.Get(idx)->GetObject<ConstantVelocityMobilityModel>();\n        mobility->SetVelocity(Vector(mobility->GetVelocity().x * -1, 0, 0));\n    }\n\n    Simulator::Schedule(interval, &ReverseVelocity, nodes, interval);\n}\n\nvoid\nQueryRcSink(std::string query, std::string args, int rc)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" Query \"\n              << ((rc == SQLITE_OK || rc == SQLITE_DONE) ? \"OK\" : \"ERROR\") << \"(\" << rc << \"): \\\"\"\n              << query << \"\\\"\";\n\n    if (!args.empty())\n    {\n        std::cout << \" (\" << args << \")\";\n    }\n    std::cout << std::endl;\n}\n\n/**\n * ORAN handover example. Based on the LTE module's \"lena-x2-handover.cc\".\n */\nint\nmain(int argc, char* argv[])\n{\n    uint16_t numberOfUes = 1;\n    uint16_t numberOfEnbs = 2;\n    Time simTime = Seconds(50);\n    double distance = 50;\n    Time interval = Seconds(15);\n    double speed = 1.5;\n    bool verbose = false;\n    std::string dbFileName = \"oran-repository.db\";\n\n    // Command line arguments\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"Enable printing SQL queries results\", verbose);\n    cmd.Parse(argc, argv);\n\n    Config::SetDefault(\"ns3::LteHelper::UseIdealRrc\", BooleanValue(false));\n\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n    lteHelper->SetSchedulerType(\"ns3::RrFfMacScheduler\");\n    lteHelper->SetHandoverAlgorithmType(\"ns3::NoOpHandoverAlgorithm\"); // disable automatic handover\n\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n\n    NodeContainer ueNodes;\n    NodeContainer enbNodes;\n    enbNodes.Create(numberOfEnbs);\n    ueNodes.Create(numberOfUes);\n\n    // Install Mobility Model\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    for (uint16_t i = 0; i < numberOfEnbs; i++)\n    {\n        positionAlloc->Add(Vector(distance * i, 0, 20));\n    }\n\n    for (uint16_t i = 0; i < numberOfUes; i++)\n    {\n        // Coordinates of the middle point between the eNBs, minus the distance covered\n        // in half of the interval for switching directions\n        positionAlloc->Add(Vector((distance / 2) - (speed * (interval.GetSeconds() / 2)), 0, 1.5));\n    }\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(enbNodes);\n\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(ueNodes);\n\n    for (uint32_t idx = 0; idx < ueNodes.GetN(); idx++)\n    {\n        Ptr<ConstantVelocityMobilityModel> mobility =\n            ueNodes.Get(idx)->GetObject<ConstantVelocityMobilityModel>();\n        mobility->SetVelocity(Vector(speed, 0, 0));\n    }\n\n    // Schedule the first direction switch\n    Simulator::Schedule(interval, &ReverseVelocity, ueNodes, interval);\n\n    // Install LTE Devices in eNB and UEs\n    NetDeviceContainer enbLteDevs = lteHelper->InstallEnbDevice(enbNodes);\n    NetDeviceContainer ueLteDevs = lteHelper->InstallUeDevice(ueNodes);\n    // Install the IP stack on the UEs\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpIfaces;\n    ueIpIfaces = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueLteDevs));\n\n    // Attach all UEs to the first eNodeB\n    for (uint16_t i = 0; i < numberOfUes; i++)\n    {\n        lteHelper->Attach(ueLteDevs.Get(i), enbLteDevs.Get(0));\n    }\n\n    // Add X2 interface\n    lteHelper->AddX2Interface(enbNodes);\n\n    // ORAN Models -- BEGIN\n    Ptr<OranNearRtRic> nearRtRic = nullptr;\n    OranE2NodeTerminatorContainer e2NodeTerminatorsEnbs;\n    OranE2NodeTerminatorContainer e2NodeTerminatorsUes;\n    Ptr<OranHelper> oranHelper = CreateObject<OranHelper>();\n\n    oranHelper->SetAttribute(\"Verbose\", BooleanValue(true));\n    oranHelper->SetAttribute(\"LmQueryInterval\", TimeValue(Seconds(5)));\n    oranHelper->SetAttribute(\"E2NodeInactivityThreshold\", TimeValue(Seconds(2)));\n    oranHelper->SetAttribute(\"E2NodeInactivityIntervalRv\",\n                             StringValue(\"ns3::ConstantRandomVariable[Constant=2]\"));\n    oranHelper->SetAttribute(\"LmQueryMaxWaitTime\",\n                             TimeValue(Seconds(0))); // 0 means wait for all LMs to finish\n    oranHelper->SetAttribute(\"LmQueryLateCommandPolicy\", EnumValue(OranNearRtRic::DROP));\n    oranHelper->SetAttribute(\"RicTransmissionDelayRv\",\n                             StringValue(\"ns3::ConstantRandomVariable[Constant=0.001]\"));\n\n    // RIC setup\n    if (!dbFileName.empty())\n    {\n        std::remove(dbFileName.c_str());\n    }\n\n    oranHelper->SetDataRepository(\"ns3::OranDataRepositorySqlite\",\n                                  \"DatabaseFile\",\n                                  StringValue(dbFileName));\n    oranHelper->SetDefaultLogicModule(\"ns3::OranLmLte2LteDistanceHandover\",\n                                      \"ProcessingDelayRv\",\n                                      StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    oranHelper->SetConflictMitigationModule(\"ns3::OranCmmNoop\");\n\n    nearRtRic = oranHelper->CreateNearRtRic();\n\n    // UE Nodes setup\n    oranHelper->SetE2NodeTerminator(\"ns3::OranE2NodeTerminatorLteUe\",\n                                    \"RegistrationIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"),\n                                    \"SendIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"),\n                                    \"TransmissionDelayRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=0.001]\"));\n\n    oranHelper->AddReporter(\"ns3::OranReporterLocation\",\n                            \"Trigger\",\n                            StringValue(\"ns3::OranReportTriggerPeriodic\"));\n\n    oranHelper->AddReporter(\"ns3::OranReporterLteUeCellInfo\",\n                            \"Trigger\",\n                            StringValue(\"ns3::OranReportTriggerLteUeHandover[InitialReport=true]\"));\n\n    e2NodeTerminatorsUes.Add(oranHelper->DeployTerminators(nearRtRic, ueNodes));\n\n    // ENb Nodes setup\n    oranHelper->SetE2NodeTerminator(\"ns3::OranE2NodeTerminatorLteEnb\",\n                                    \"RegistrationIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"),\n                                    \"SendIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"),\n                                    \"TransmissionDelayRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=0.001]\"));\n\n    oranHelper->AddReporter(\"ns3::OranReporterLocation\",\n                            \"Trigger\",\n                            StringValue(\"ns3::OranReportTriggerPeriodic\"));\n\n    e2NodeTerminatorsEnbs.Add(oranHelper->DeployTerminators(nearRtRic, enbNodes));\n\n    // DB logging to the terminal\n    if (verbose)\n    {\n        nearRtRic->Data()->TraceConnectWithoutContext(\"QueryRc\", MakeCallback(&QueryRcSink));\n    }\n\n    // Activate and the components\n    Simulator::Schedule(Seconds(1), &OranHelper::ActivateAndStartNearRtRic, oranHelper, nearRtRic);\n    Simulator::Schedule(Seconds(1.5),\n                        &OranHelper::ActivateE2NodeTerminators,\n                        oranHelper,\n                        e2NodeTerminatorsEnbs);\n    Simulator::Schedule(Seconds(2),\n                        &OranHelper::ActivateE2NodeTerminators,\n                        oranHelper,\n                        e2NodeTerminatorsUes);\n    // ORAN Models -- END\n\n    // Trace the end of handovers\n    Config::Connect(\"/NodeList/*/DeviceList/*/LteEnbRrc/HandoverEndOk\",\n                    MakeCallback(&NotifyHandoverEndOkEnb));\n\n    Simulator::Stop(simTime);\n    Simulator::Run();\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/oran-lte-2-lte-distance-handover-lm-processing-delay-example.cc",
      "code": "/**\n * NIST-developed software is provided by NIST as a public service. You may\n * use, copy and distribute copies of the software in any medium, provided that\n * you keep intact this entire notice. You may improve, modify and create\n * derivative works of the software or any portion of the software, and you may\n * copy and distribute such modifications or works. Modified works should carry\n * a notice stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the National\n * Institute of Standards and Technology as the source of the software.\n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES NO\n * WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF\n * LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT AND DATA ACCURACY. NIST\n * NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE\n * UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST\n * DOES NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE\n * SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE\n * CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n *\n * You are solely responsible for determining the appropriateness of using and\n * distributing the software and you assume all risks associated with its use,\n * including but not limited to the risks and costs of program errors,\n * compliance with applicable laws, damage to or loss of data, programs or\n * equipment, and the unavailability or interruption of operation. This\n * software is not intended to be used in any situation where a failure could\n * cause risk of injury or damage to property. The software developed by NIST\n * employees is not subject to copyright protection within the United States.\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/oran-module.h\"\n\n#include <stdio.h>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OranLte2LteDistanceHandoverLmProcessingDelayExample\");\n\n/**\n * Example of the ORAN models.\n *\n * The scenario consists of an LTE UE moving back and forth\n * between 2 LTE eNBs. The LTE UE reports to the RIC its location\n * and current Cell ID. In the RIC, an LM will periodically check\n * the position, and if needed, issue a handover command.\n *\n * This example demonstrates how to configure processing delays for the LMs.\n */\n\nvoid\nNotifyHandoverEndOkEnb(std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti)\n{\n    std::cout << Simulator::Now().As(Time::S) << \" \" << context << \" eNB CellId \" << cellid\n              << \": completed handover of UE with IMSI \" << imsi << \" RNTI \" << rnti << std::endl;\n}\n\nvoid\nReverseVelocity(NodeContainer nodes, Time interval)\n{\n    for (uint32_t idx = 0; idx < nodes.GetN(); idx++)\n    {\n        Ptr<ConstantVelocityMobilityModel> mobility =\n            nodes.Get(idx)->GetObject<ConstantVelocityMobilityModel>();\n        mobility->SetVelocity(Vector(mobility->GetVelocity().x * -1, 0, 0));\n    }\n\n    Simulator::Schedule(interval, &ReverseVelocity, nodes, interval);\n}\n\nvoid\nQueryRcSink(std::string query, std::string args, int rc)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" Query \"\n              << ((rc == SQLITE_OK || rc == SQLITE_DONE) ? \"OK\" : \"ERROR\") << \"(\" << rc << \"): \\\"\"\n              << query << \"\\\"\";\n\n    if (!args.empty())\n    {\n        std::cout << \" (\" << args << \")\";\n    }\n    std::cout << std::endl;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint16_t numberOfUes = 1;\n    uint16_t numberOfEnbs = 2;\n    Time simTime = Seconds(50);\n    Time maxWaitTime = Seconds(0.010);\n    std::string processingDelayRv = \"ns3::NormalRandomVariable[Mean=0.005|Variance=0.000031]\";\n    double distance = 50; // distance between eNBs\n    Time interval = Seconds(15);\n    double speed = 1.5; // speed of the ue\n    bool dbLog = false;\n    Time lmQueryInterval = Seconds(5);\n    std::string dbFileName = \"oran-repository.db\";\n    std::string lateCommandPolicy = \"DROP\";\n\n    // Command line arguments\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"db-log\", \"Enable printing SQL queries results\", dbLog);\n    cmd.AddValue(\"max-wait-time\", \"The maximum amount of time an LM has to run\", maxWaitTime);\n    cmd.AddValue(\"processing-delay-rv\",\n                 \"The random variable that represents the LMs processing delay\",\n                 processingDelayRv);\n    cmd.AddValue(\"lm-query-interval\",\n                 \"The interval at which to query the LM for commands\",\n                 lmQueryInterval);\n    cmd.AddValue(\"late-command-policy\",\n                 \"The policy to use for handling commands received after the maximum wait time \"\n                 \"(\\\"DROP\\\" or \\\"SAVE\\\")\",\n                 lateCommandPolicy);\n    cmd.AddValue(\"sim-time\", \"The amount of time to simulate\", simTime);\n    cmd.Parse(argc, argv);\n\n    LogComponentEnable(\"OranNearRtRic\", (LogLevel)(LOG_PREFIX_TIME | LOG_WARN));\n\n    Config::SetDefault(\"ns3::LteHelper::UseIdealRrc\", BooleanValue(false));\n\n    /*--- lte and epc helper ---*/\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>(); // create lteHelper\n    Ptr<PointToPointEpcHelper> epcHelper =\n        CreateObject<PointToPointEpcHelper>(); // create epcHelper\n    lteHelper->SetEpcHelper(\n        epcHelper); // connect lte to the evolved packet core, which is the core network\n    lteHelper->SetSchedulerType(\"ns3::RrFfMacScheduler\"); // Round-robin Frequency-first Mac\n                                                          // Scheduler for resource distribution\n    lteHelper->SetHandoverAlgorithmType(\"ns3::NoOpHandoverAlgorithm\"); // disable automatic handover\n\n    // Getting the PGW node; it acts as a gateway between LTE and external network, such as-\n    // internet.\n    Ptr<Node> pgw = epcHelper->GetPgwNode(); // PGW: Packet Data Network Gateway\n\n    /*---- Creating RAN nodes using NodeContainer ----*/\n    NodeContainer ueNodes;\n    NodeContainer enbNodes;\n    enbNodes.Create(numberOfEnbs);\n    ueNodes.Create(numberOfUes);\n\n    // Install Mobility Model\n    Ptr<ListPositionAllocator> positionAlloc =\n        CreateObject<ListPositionAllocator>(); // ListPositionAllocator class defines x,y,z position\n                                               // for network node\n    for (uint16_t i = 0; i < numberOfEnbs; i++)\n    {\n        positionAlloc->Add(Vector(distance * i, 0, 20));\n    }\n\n    for (uint16_t i = 0; i < numberOfUes; i++)\n    {\n        // Coordinates of the middle point between the eNBs, minus the distance covered\n        // in half of the interval for switching directions\n        positionAlloc->Add(Vector((distance / 2) - (speed * (interval.GetSeconds() / 2)), 0, 1.5));\n    }\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(enbNodes);\n\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(ueNodes);\n\n    for (uint32_t idx = 0; idx < ueNodes.GetN(); idx++)\n    {\n        Ptr<ConstantVelocityMobilityModel> mobility =\n            ueNodes.Get(idx)->GetObject<ConstantVelocityMobilityModel>();\n        mobility->SetVelocity(Vector(speed, 0, 0));\n    }\n\n    // Schedule the first direction switch\n    Simulator::Schedule(interval, &ReverseVelocity, ueNodes, interval);\n\n    // Install LTE Devices in eNB and UEs\n    NetDeviceContainer enbLteDevs = lteHelper->InstallEnbDevice(enbNodes);\n    NetDeviceContainer ueLteDevs = lteHelper->InstallUeDevice(ueNodes);\n    // Install the IP stack on the UEs\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpIfaces;\n    ueIpIfaces = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueLteDevs));\n\n    // Attach all UEs to the first eNodeB\n    for (uint16_t i = 0; i < numberOfUes; i++)\n    {\n        lteHelper->Attach(ueLteDevs.Get(i), enbLteDevs.Get(0));\n    }\n\n    // Add X2 interface\n    lteHelper->AddX2Interface(enbNodes);\n\n    // ORAN Models -- BEGIN\n    Ptr<OranNearRtRic> nearRtRic = nullptr;\n    OranE2NodeTerminatorContainer e2NodeTerminatorsEnbs;\n    OranE2NodeTerminatorContainer e2NodeTerminatorsUes;\n    Ptr<OranHelper> oranHelper = CreateObject<OranHelper>();\n\n    oranHelper->SetAttribute(\"Verbose\", BooleanValue(true));\n    oranHelper->SetAttribute(\"LmQueryInterval\", TimeValue(lmQueryInterval));\n    oranHelper->SetAttribute(\"E2NodeInactivityThreshold\", TimeValue(Seconds(2)));\n    oranHelper->SetAttribute(\"E2NodeInactivityIntervalRv\",\n                             StringValue(\"ns3::ConstantRandomVariable[Constant=2]\"));\n    oranHelper->SetAttribute(\"LmQueryMaxWaitTime\",\n                             TimeValue(maxWaitTime)); // 0 means wait for all LMs to finish\n    oranHelper->SetAttribute(\"LmQueryLateCommandPolicy\", StringValue(lateCommandPolicy));\n\n    // RIC setup\n    if (!dbFileName.empty())\n    {\n        std::remove(dbFileName.c_str());\n    }\n\n    oranHelper->SetDataRepository(\"ns3::OranDataRepositorySqlite\",\n                                  \"DatabaseFile\",\n                                  StringValue(dbFileName));\n    oranHelper->SetDefaultLogicModule(\"ns3::OranLmLte2LteDistanceHandover\",\n                                      \"ProcessingDelayRv\",\n                                      StringValue(processingDelayRv));\n    oranHelper->SetConflictMitigationModule(\"ns3::OranCmmNoop\");\n\n    nearRtRic = oranHelper->CreateNearRtRic();\n\n    // UE Nodes setup\n    oranHelper->SetE2NodeTerminator(\"ns3::OranE2NodeTerminatorLteUe\",\n                                    \"RegistrationIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"),\n                                    \"SendIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n\n    oranHelper->AddReporter(\"ns3::OranReporterLocation\",\n                            \"Trigger\",\n                            StringValue(\"ns3::OranReportTriggerPeriodic\"));\n\n    oranHelper->AddReporter(\"ns3::OranReporterLteUeCellInfo\",\n                            \"Trigger\",\n                            StringValue(\"ns3::OranReportTriggerLteUeHandover[InitialReport=true]\"));\n\n    e2NodeTerminatorsUes.Add(oranHelper->DeployTerminators(nearRtRic, ueNodes));\n\n    // ENb Nodes setup\n    oranHelper->SetE2NodeTerminator(\"ns3::OranE2NodeTerminatorLteEnb\",\n                                    \"RegistrationIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"),\n                                    \"SendIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n\n    oranHelper->AddReporter(\"ns3::OranReporterLocation\",\n                            \"Trigger\",\n                            StringValue(\"ns3::OranReportTriggerPeriodic\"));\n\n    e2NodeTerminatorsEnbs.Add(oranHelper->DeployTerminators(nearRtRic, enbNodes));\n\n    // DB logging to the terminal\n    if (dbLog)\n    {\n        nearRtRic->Data()->TraceConnectWithoutContext(\"QueryRc\", MakeCallback(&QueryRcSink));\n    }\n\n    // Activate and the components\n    Simulator::Schedule(Seconds(1), &OranHelper::ActivateAndStartNearRtRic, oranHelper, nearRtRic);\n    Simulator::Schedule(Seconds(1.5),\n                        &OranHelper::ActivateE2NodeTerminators,\n                        oranHelper,\n                        e2NodeTerminatorsEnbs);\n    Simulator::Schedule(Seconds(2),\n                        &OranHelper::ActivateE2NodeTerminators,\n                        oranHelper,\n                        e2NodeTerminatorsUes);\n    // ORAN Models -- END\n\n    // Trace the end of handovers\n    Config::Connect(\"/NodeList/*/DeviceList/*/LteEnbRrc/HandoverEndOk\",\n                    MakeCallback(&NotifyHandoverEndOkEnb));\n\n    Simulator::Stop(simTime);\n    Simulator::Run();\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/oran-lte-2-lte-distance-handover-lm-query-trigger-example.cc",
      "code": "/**\n * NIST-developed software is provided by NIST as a public service. You may\n * use, copy and distribute copies of the software in any medium, provided that\n * you keep intact this entire notice. You may improve, modify and create\n * derivative works of the software or any portion of the software, and you may\n * copy and distribute such modifications or works. Modified works should carry\n * a notice stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the National\n * Institute of Standards and Technology as the source of the software.\n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES NO\n * WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF\n * LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT AND DATA ACCURACY. NIST\n * NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE\n * UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST\n * DOES NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE\n * SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE\n * CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n *\n * You are solely responsible for determining the appropriateness of using and\n * distributing the software and you assume all risks associated with its use,\n * including but not limited to the risks and costs of program errors,\n * compliance with applicable laws, damage to or loss of data, programs or\n * equipment, and the unavailability or interruption of operation. This\n * software is not intended to be used in any situation where a failure could\n * cause risk of injury or damage to property. The software developed by NIST\n * employees is not subject to copyright protection within the United States.\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/oran-module.h\"\n\n#include <stdio.h>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OranLte2LteDistanceHandoverLmQueryTriggerExample\");\n\n/**\n * ORAN handover example.\n *\n * This example demonstrates how the use of a custom LM query trigger in the\n * Near-RT RIC can trigger a query outside of the periodic query interval\n * based on a report and the information that it contains that was received\n * by the Near-RT RIC.\n */\n\nvoid\nNotifyHandoverEndOkEnb(std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" \" << context << \" eNB CellId \" << cellid\n              << \": completed handover of UE with IMSI \" << imsi << \" RNTI \" << rnti << std::endl;\n}\n\nvoid\nReverseVelocity(NodeContainer nodes, Time interval)\n{\n    for (uint32_t idx = 0; idx < nodes.GetN(); idx++)\n    {\n        Ptr<ConstantVelocityMobilityModel> mobility =\n            nodes.Get(idx)->GetObject<ConstantVelocityMobilityModel>();\n        mobility->SetVelocity(Vector(mobility->GetVelocity().x * -1, 0, 0));\n    }\n\n    Simulator::Schedule(interval, &ReverseVelocity, nodes, interval);\n}\n\nvoid\nQueryRcSink(std::string query, std::string args, int rc)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" Query \"\n              << ((rc == SQLITE_OK || rc == SQLITE_DONE) ? \"OK\" : \"ERROR\") << \"(\" << rc << \"): \\\"\"\n              << query << \"\\\"\";\n\n    if (!args.empty())\n    {\n        std::cout << \" (\" << args << \")\";\n    }\n    std::cout << std::endl;\n}\n\nbool\nCustomLmQueryTriggerCallback(Ptr<OranReport> report)\n{\n    // A flag to indicate if the LMs should be queried.\n    bool shouldQueryLms = false;\n    // The center location of the two eNBs.\n    Vector center = Vector(25, 0, 1.5);\n\n    // Static variable to keep track of the UE's last location.\n    static Vector lastLocation = Vector(0, 0, 1.5);\n\n    // Check if the report is from the UE node and if the report is a location report.\n    if (report->GetReporterE2NodeId() == 5 &&\n        report->GetInstanceTypeId() == TypeId::LookupByName(\"ns3::OranReportLocation\"))\n    {\n        // Get the location report instance so we can access the location.\n        Ptr<OranReportLocation> locationReport = report->GetObject<OranReportLocation>();\n        // Get the location from the report instance.\n        Vector location = locationReport->GetLocation();\n\n        // Check if the last location and the current location are equal which\n        // likely means that the UE has crossed over the center point\n        if ((uint32_t)CalculateDistance(lastLocation, center) ==\n            (uint32_t)CalculateDistance(location, center))\n        { // If it is, then that means the UE just crossed over the center\n            // Therefore query the LMs so that a hand over is issued.\n            shouldQueryLms = true;\n        }\n\n        // Update the last known location.\n        lastLocation = location;\n    }\n\n    // Indicate if the LMs should be queried\n    return shouldQueryLms;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint16_t numberOfUes = 1;\n    uint16_t numberOfEnbs = 2;\n    Time simTime = Seconds(50);\n    double distance = 50;\n    Time interval = Seconds(15);\n    double speed = 1.5;\n    bool verbose = false;\n    std::string dbFileName = \"oran-repository.db\";\n\n    // Command line arguments\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"Enable printing SQL queries results\", verbose);\n    cmd.Parse(argc, argv);\n\n    Config::SetDefault(\"ns3::LteHelper::UseIdealRrc\", BooleanValue(false));\n\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n    lteHelper->SetSchedulerType(\"ns3::RrFfMacScheduler\");\n    lteHelper->SetHandoverAlgorithmType(\"ns3::NoOpHandoverAlgorithm\"); // disable automatic handover\n\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n\n    NodeContainer ueNodes;\n    NodeContainer enbNodes;\n    enbNodes.Create(numberOfEnbs);\n    ueNodes.Create(numberOfUes);\n\n    // Install Mobility Model\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    for (uint16_t i = 0; i < numberOfEnbs; i++)\n    {\n        positionAlloc->Add(Vector(distance * i, 0, 20));\n    }\n\n    for (uint16_t i = 0; i < numberOfUes; i++)\n    {\n        // Coordinates of the middle point between the eNBs, minus the distance covered\n        // in half of the interval for switching directions\n        positionAlloc->Add(Vector((distance / 2) - (speed * (interval.GetSeconds() / 2)), 0, 1.5));\n    }\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(enbNodes);\n\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(ueNodes);\n\n    for (uint32_t idx = 0; idx < ueNodes.GetN(); idx++)\n    {\n        Ptr<ConstantVelocityMobilityModel> mobility =\n            ueNodes.Get(idx)->GetObject<ConstantVelocityMobilityModel>();\n        mobility->SetVelocity(Vector(speed, 0, 0));\n    }\n\n    // Schedule the first direction switch\n    Simulator::Schedule(interval, &ReverseVelocity, ueNodes, interval);\n\n    // Install LTE Devices in eNB and UEs\n    NetDeviceContainer enbLteDevs = lteHelper->InstallEnbDevice(enbNodes);\n    NetDeviceContainer ueLteDevs = lteHelper->InstallUeDevice(ueNodes);\n    // Install the IP stack on the UEs\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpIfaces;\n    ueIpIfaces = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueLteDevs));\n\n    // Attach all UEs to the first eNodeB\n    for (uint16_t i = 0; i < numberOfUes; i++)\n    {\n        lteHelper->Attach(ueLteDevs.Get(i), enbLteDevs.Get(0));\n    }\n\n    // Add X2 interface\n    lteHelper->AddX2Interface(enbNodes);\n\n    // ORAN Models -- BEGIN\n    Ptr<OranNearRtRic> nearRtRic = nullptr;\n    OranE2NodeTerminatorContainer e2NodeTerminatorsEnbs;\n    OranE2NodeTerminatorContainer e2NodeTerminatorsUes;\n    Ptr<OranHelper> oranHelper = CreateObject<OranHelper>();\n\n    oranHelper->SetAttribute(\"Verbose\", BooleanValue(true));\n    oranHelper->SetAttribute(\"LmQueryInterval\", TimeValue(Seconds(5)));\n    oranHelper->SetAttribute(\"E2NodeInactivityThreshold\", TimeValue(Seconds(2)));\n    oranHelper->SetAttribute(\"E2NodeInactivityIntervalRv\",\n                             StringValue(\"ns3::ConstantRandomVariable[Constant=2]\"));\n    oranHelper->SetAttribute(\"LmQueryMaxWaitTime\",\n                             TimeValue(Seconds(0))); // 0 means wait for all LMs to finish\n    oranHelper->SetAttribute(\"LmQueryLateCommandPolicy\", EnumValue(OranNearRtRic::DROP));\n\n    // RIC setup\n    if (!dbFileName.empty())\n    {\n        std::remove(dbFileName.c_str());\n    }\n\n    oranHelper->SetDataRepository(\"ns3::OranDataRepositorySqlite\",\n                                  \"DatabaseFile\",\n                                  StringValue(dbFileName));\n    oranHelper->SetDefaultLogicModule(\"ns3::OranLmLte2LteDistanceHandover\",\n                                      \"ProcessingDelayRv\",\n                                      StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    oranHelper->SetConflictMitigationModule(\"ns3::OranCmmNoop\");\n    oranHelper->AddQueryTrigger(\"Crossover\",\n                                \"ns3::OranQueryTriggerCustom\",\n                                \"CustomCallback\",\n                                CallbackValue(MakeCallback(&CustomLmQueryTriggerCallback)));\n\n    nearRtRic = oranHelper->CreateNearRtRic();\n\n    // UE Nodes setup\n    oranHelper->SetE2NodeTerminator(\"ns3::OranE2NodeTerminatorLteUe\",\n                                    \"RegistrationIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"),\n                                    \"SendIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n\n    oranHelper->AddReporter(\"ns3::OranReporterLocation\",\n                            \"Trigger\",\n                            StringValue(\"ns3::OranReportTriggerPeriodic\"));\n\n    oranHelper->AddReporter(\"ns3::OranReporterLteUeCellInfo\",\n                            \"Trigger\",\n                            StringValue(\"ns3::OranReportTriggerLteUeHandover[InitialReport=true]\"));\n\n    e2NodeTerminatorsUes.Add(oranHelper->DeployTerminators(nearRtRic, ueNodes));\n\n    // ENb Nodes setup\n    oranHelper->SetE2NodeTerminator(\"ns3::OranE2NodeTerminatorLteEnb\",\n                                    \"RegistrationIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"),\n                                    \"SendIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n\n    oranHelper->AddReporter(\"ns3::OranReporterLocation\",\n                            \"Trigger\",\n                            StringValue(\"ns3::OranReportTriggerPeriodic\"));\n\n    e2NodeTerminatorsEnbs.Add(oranHelper->DeployTerminators(nearRtRic, enbNodes));\n\n    // DB logging to the terminal\n    if (verbose)\n    {\n        nearRtRic->Data()->TraceConnectWithoutContext(\"QueryRc\", MakeCallback(&QueryRcSink));\n    }\n\n    // Activate and the components\n    Simulator::Schedule(Seconds(1), &OranHelper::ActivateAndStartNearRtRic, oranHelper, nearRtRic);\n    Simulator::Schedule(Seconds(1.5),\n                        &OranHelper::ActivateE2NodeTerminators,\n                        oranHelper,\n                        e2NodeTerminatorsEnbs);\n    Simulator::Schedule(Seconds(2),\n                        &OranHelper::ActivateE2NodeTerminators,\n                        oranHelper,\n                        e2NodeTerminatorsUes);\n    // ORAN Models -- END\n\n    // Trace the end of handovers\n    Config::Connect(\"/NodeList/*/DeviceList/*/LteEnbRrc/HandoverEndOk\",\n                    MakeCallback(&NotifyHandoverEndOkEnb));\n\n    Simulator::Stop(simTime);\n    Simulator::Run();\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/oran-lte-2-lte-ml-handover-example-classifier.py",
      "code": "# NIST-developed software is provided by NIST as a public service. You may\n# use, copy and distribute copies of the software in any medium, provided that\n# you keep intact this entire notice. You may improve, modify and create\n# derivative works of the software or any portion of the software, and you may\n# copy and distribute such modifications or works. Modified works should carry\n# a notice stating that you changed the software and should note the date and\n# nature of any such change. Please explicitly acknowledge the National\n# Institute of Standards and Technology as the source of the software.\n#\n# NIST-developed software is expressly provided \"AS IS.\" NIST MAKES NO\n# WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF\n# LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT AND DATA ACCURACY. NIST\n# NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE\n# UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST\n# DOES NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE\n# SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE\n# CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n#\n# You are solely responsible for determining the appropriateness of using and\n# distributing the software and you assume all risks associated with its use,\n# including but not limited to the risks and costs of program errors,\n# compliance with applicable laws, damage to or loss of data, programs or\n# equipment, and the unavailability or interruption of operation. This\n# software is not intended to be used in any situation where a failure could\n# cause risk of injury or damage to property. The software developed by NIST\n# employees is not subject to copyright protection within the United States.\n\nimport pandas as pd\nimport numpy as np\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.model_selection import train_test_split\nimport time\n\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom torch.utils.data import Dataset, DataLoader, WeightedRandomSampler\n\n\n# DataSet class that will be used to feed data to the neural network\n# dynamically, according to the training speed and available memory\n# We just need to implement the methods shown here and perform any\n# processing if needed\nclass ClassifierDataset(Dataset):\n\n    def __init__(self, X_data, Y_data):\n        self.X_data = X_data\n        self.Y_data = Y_data\n\n    def __getitem__(self, index):\n        return self.X_data[index], self.Y_data[index]\n\n    def __len__ (self):\n        return len(self.X_data)\n\n\n# Class that implements the neural network model\n# This is a simple 4-layer neural network that inherits\n# from MulticlassClassification\nclass MulticlassClassification(nn.Module):\n    def __init__(self, num_feature, num_class):\n        super(MulticlassClassification, self).__init__()\n\n        self.layer_1 = nn.Linear(num_feature, 512)\n        self.layer_2 = nn.Linear(512, 128)\n        self.layer_3 = nn.Linear(128, 64)\n        self.layer_out = nn.Linear(64, num_class)\n\n        self.relu = nn.ReLU()\n\n    # The forward method defines the topology, the connections\n    # between the layers and components defined in the __init__\n    # method\n    def forward(self, x):\n        x = self.layer_1(x)\n        x = self.relu(x)\n\n        x = self.layer_2(x)\n        x = self.relu(x)\n\n        x = self.layer_3(x)\n        x = self.relu(x)\n\n        x = self.layer_out(x)\n\n        return x\n\n# Method that defines the accuracy calculation for the training iterations\n# In this case, we compare the predicted classes with the true classes,\n# count the correct classifications, and get the ratio of correct over total\ndef multi_acc(Y_pred, Y_test):\n    Y_pred_softmax = torch.log_softmax(Y_pred, dim = 1)\n    _, Y_pred_tags = torch.max(Y_pred_softmax, dim = 1)\n\n    correct_pred = (Y_pred_tags == Y_test).float()\n    acc = correct_pred.sum() / len(correct_pred)\n\n    acc = torch.round(acc) * 100\n\n    return acc\n\n# Method that gets the class distribution in the training dataset.\n# This is used to set the class weights for random sampling during training\ndef get_class_distribution(obj):\n    count_dict = {\n        \"A\": 0,\n        \"B\": 0,\n        \"C\": 0,\n        \"D\": 0,\n    }\n\n    for i in obj:\n        if i == 0:\n            count_dict[\"A\"] += 1\n        elif i == 1:\n            count_dict[\"B\"] += 1\n        elif i == 2:\n            count_dict[\"C\"] += 1\n        elif i == 3:\n            count_dict[\"D\"] += 1\n        else:\n            print(\"Check classes.\")\n\n    return count_dict\n\n\n# Read the training and evaluation dataset. In this case we are using a single file\n# that will be split in 3 sets\ndf = pd.read_csv (\"training.data\", delim_whitespace=True, header=None)\n# Columns 1 to 12 are inputs\nX = df.iloc [:,0:-1]\n# Column 13 is the true class\nY = df.iloc [:,-1]\n\n# Split the dataset: 20 % of the entries will be used for testing\nX_trainval, X_test, Y_trainval, Y_test = train_test_split (X, Y, test_size = 0.2, stratify = Y, random_state = 10)\n# Split the other 80 % between training and validation\nX_train, X_val, Y_train, Y_val = train_test_split (X_trainval, Y_trainval, random_state = 20)\n\n# Format conversion to NumPy arrays\nX_train, Y_train = np.array (X_train), np.array (Y_train)\nX_val, Y_val = np.array (X_val), np.array (Y_val)\nX_test, Y_test = np.array (X_test), np.array (Y_test)\n\n# Convert the raw input into PyTorch datasets.\n# These datasets will be managed by DataLoaders that will throttle the speed at which the input file is read\n# depending on parallelization capabilities, training speed, and memory available\ntrain_dataset = ClassifierDataset(torch.from_numpy(X_train).float(), torch.from_numpy(Y_train).long())\nval_dataset = ClassifierDataset(torch.from_numpy(X_val).float(), torch.from_numpy(Y_val).long())\ntest_dataset = ClassifierDataset(torch.from_numpy(X_test).float(), torch.from_numpy(Y_test).long())\n\n# Create a list of classes in the training dataset\ntarget_list = []\nfor _, t in train_dataset:\n    target_list.append(t)\n\n# And use the list to randomly select the order of the\n# classes for the output\ntarget_list = torch.tensor(target_list)\ntarget_list = target_list[torch.randperm(len(target_list))]\n\n# Compute the class weights for the random sampling\nclass_count = [i for i in get_class_distribution(Y_train).values()]\nclass_weights = 1./torch.tensor(class_count, dtype=torch.float)\n\n# Create a weighted random sampler for out training data\nclass_weights_all = class_weights[target_list]\nweighted_sampler = WeightedRandomSampler(\n    weights=class_weights_all,\n    num_samples=len(class_weights_all),\n    replacement=True\n)\n\n# Set training parameters\nEPOCHS = 3\nBATCH_SIZE = 10\nLEARNING_RATE = 0.0007\nNUM_FEATURES = len(X.columns)\nNUM_CLASSES = 4\n\n# Initialize the data loaders for each dataset\ntrain_loader = DataLoader(dataset=train_dataset, batch_size=BATCH_SIZE, sampler=weighted_sampler)\nval_loader = DataLoader(dataset=val_dataset, batch_size=1)\ntest_loader = DataLoader(dataset=test_dataset, batch_size=1)\n\n# Set the context for the model: if hardware acceleration is available, use it\n# Otherwise, use the CPU\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\n# Instantiate the Neural Network\nmodel = MulticlassClassification (num_feature = NUM_FEATURES, num_class = NUM_CLASSES)\nmodel.to (device)\n\n# Define the Loss metric and the optimizer\ncriterion = nn.CrossEntropyLoss(weight=class_weights.to(device))\noptimizer = optim.Adam(model.parameters(), lr=LEARNING_RATE)\n\n\n# Create dictionaries to keep track of the training statistics\naccuracy_stats = {\n    'train': [],\n    \"val\": []\n}\nloss_stats = {\n    'train': [],\n    \"val\": []\n}\n\nprint (\"Begin Training\")\n\n# Train the model\nfor e in  (range (1, EPOCHS + 1)):\n    start_time = time.time ()\n    train_epoch_loss = 0\n    train_epoch_acc = 0\n\n    # Set the model in training mode\n    model.train ()\n    # For as long as the training data loader has data ....\n    for X_train_batch, Y_train_batch in train_loader:\n        # Load the data in the proper device ...\n        X_train_batch, Y_train_batch = X_train_batch.to(device), Y_train_batch.to(device)\n        # Reset the optimizer gradients to 0...\n        optimizer.zero_grad()\n\n        # Train the model\n        Y_train_pred = model(X_train_batch)\n\n        # Compute loss and accuracy for the batch\n        train_loss = criterion(Y_train_pred, Y_train_batch)\n        train_acc = multi_acc(Y_train_pred, Y_train_batch)\n\n        # Perform backpropagation\n        train_loss.backward()\n        # Update optimizer gradients\n        optimizer.step()\n\n        # Update training statistics\n        train_epoch_loss += train_loss.item()\n        train_epoch_acc += train_acc.item()\n\n    # In each epoch, after training we do validation. We set the environment\n    # in a state in which the gradients will not be updated\n    with torch.no_grad():\n\n        val_epoch_loss = 0\n        val_epoch_acc = 0\n\n        # Set the model in no-training mode\n        model.eval()\n        # Load the data from the validation loader\n        for X_val_batch, Y_val_batch in val_loader:\n            X_val_batch, Y_val_batch = X_val_batch.to(device), Y_val_batch.to(device)\n\n            # Run the inputs through the model\n            Y_val_pred = model(X_val_batch)\n\n            # Compute loss and accuracy\n            val_loss = criterion(Y_val_pred, Y_val_batch)\n            val_acc = multi_acc(Y_val_pred, Y_val_batch)\n\n            # Accumulate statistics\n            val_epoch_loss += val_loss.item()\n            val_epoch_acc += val_acc.item()\n\n    # Print the training and validation statistics for this epoch\n    loss_stats['train'].append(train_epoch_loss/len(train_loader))\n    loss_stats['val'].append(val_epoch_loss/len(val_loader))\n    accuracy_stats['train'].append(train_epoch_acc/len(train_loader))\n    accuracy_stats['val'].append(val_epoch_acc/len(val_loader))\n    total_time = time.time () - start_time\n\n    print(f'Epoch {e+0:03}: | Train Loss: {train_epoch_loss/len(train_loader):.5f} | Val Loss: {val_epoch_loss/len(val_loader):.5f} | Train Acc: {train_epoch_acc/len(train_loader):.3f}| Val Acc: {val_epoch_acc/len(val_loader):.3f}| Time: {total_time:.5f}')\n\n\n# After the training is complete, we perform the testing\n# We will also save the trained model. As the gradients use lazy\n# evaluation, we need to run at least one input through the model\n# after setting the environment and the model in no-training mode\n# before we can save the model\nprint (\"Begin Testing\")\ntest_loss = 0\ntest_acc = 0\nsave_pending = True\n# Set the environment in no-training mode\nwith torch.no_grad():\n    # Set the model in no-training mode\n    model.eval()\n    for X_batch, Y_batch in test_loader:\n        X_batch, Y_batch = X_batch.to(device), Y_batch.to(device)\n        # Run the input through the trained model\n        Y_test_pred = model(X_batch)\n        # Compute accuracy\n        test_acc += multi_acc(Y_test_pred, Y_batch)\n        # If this is the first input, we can now save the model\n        if save_pending:\n            traced_script_module = torch.jit.trace(model, X_batch)\n            traced_script_module.save (\"saved_trained_classification_pytorch.pt\")\n            save_pending = False\n\n    # Print the testing statistics\n    print(f'Test Acc: {test_acc/len(test_loader):.5f}')\n\n"
    },
    {
      "file_path": "examples/oran-lte-2-lte-ml-handover-example.cc",
      "code": "/**\n * NIST-developed software is provided by NIST as a public service. You may\n * use, copy and distribute copies of the software in any medium, provided that\n * you keep intact this entire notice. You may improve, modify and create\n * derivative works of the software or any portion of the software, and you may\n * copy and distribute such modifications or works. Modified works should carry\n * a notice stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the National\n * Institute of Standards and Technology as the source of the software.\n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES NO\n * WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF\n * LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT AND DATA ACCURACY. NIST\n * NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE\n * UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST\n * DOES NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE\n * SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE\n * CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n *\n * You are solely responsible for determining the appropriateness of using and\n * distributing the software and you assume all risks associated with its use,\n * including but not limited to the risks and costs of program errors,\n * compliance with applicable laws, damage to or loss of data, programs or\n * equipment, and the unavailability or interruption of operation. This\n * software is not intended to be used in any situation where a failure could\n * cause risk of injury or damage to property. The software developed by NIST\n * employees is not subject to copyright protection within the United States.\n */\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/oran-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <math.h>\n\nusing namespace ns3;\n\nstatic std::string s_trafficTraceFile = \"traffic-trace.tr\";\nstatic std::string s_positionTraceFile = \"position-trace.tr\";\nstatic std::string s_handoverTraceFile = \"handover-trace.tr\";\n\n// Function that will save the traces of RX'd packets\nvoid\nRxTrace(Ptr<const Packet> p, const Address& from, const Address& to)\n{\n    uint16_t ueId = (InetSocketAddress::ConvertFrom(to).GetPort() / 1000);\n\n    std::ofstream rxOutFile(s_trafficTraceFile, std::ios_base::app);\n    rxOutFile << Simulator::Now().GetSeconds() << \" \" << ueId << \" RX \" << p->GetSize()\n              << std::endl;\n}\n\n// Function that will save the traces of TX'd packets\nvoid\nTxTrace(Ptr<const Packet> p, const Address& from, const Address& to)\n{\n    uint16_t ueId = (InetSocketAddress::ConvertFrom(to).GetPort() / 1000);\n\n    std::ofstream rxOutFile(s_trafficTraceFile, std::ios_base::app);\n    rxOutFile << Simulator::Now().GetSeconds() << \" \" << ueId << \" TX \" << p->GetSize()\n              << std::endl;\n}\n\n// Trace each node's location\nvoid\nTracePositions(NodeContainer nodes)\n{\n    std::ofstream posOutFile(s_positionTraceFile, std::ios_base::app);\n\n    posOutFile << Simulator::Now().GetSeconds();\n    for (uint32_t i = 0; i < nodes.GetN(); i++)\n    {\n        Vector pos = nodes.Get(i)->GetObject<MobilityModel>()->GetPosition();\n        posOutFile << \" \" << pos.x << \" \" << pos.y;\n    }\n    posOutFile << std::endl;\n\n    Simulator::Schedule(Seconds(1), &TracePositions, nodes);\n}\n\nvoid\nNotifyHandoverEndOkEnb(std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti)\n{\n    std::ofstream hoOutFile(s_handoverTraceFile, std::ios_base::app);\n    hoOutFile << Simulator::Now().GetSeconds() << \" \" << imsi << \" \" << cellid << \" \" << rnti\n              << std::endl;\n}\n\nNS_LOG_COMPONENT_DEFINE(\"OranLte2LteMlHandoverExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    bool verbose = false;\n    bool useOran = true;\n    bool useOnnx = false;\n    bool useTorch = false;\n    bool useDistance = false;\n    uint32_t startConfig = 1;\n    double lmQueryInterval = 1;\n    double txDelay = 0;\n    std::string handoverAlgorithm = \"ns3::NoOpHandoverAlgorithm\";\n    Time simTime = Seconds(100);\n    std::string dbFileName = \"oran-repository.db\";\n\n    CommandLine cmd;\n    cmd.AddValue(\"verbose\", \"Enable printing SQL queries results\", verbose);\n    cmd.AddValue(\"use-oran\", \"Indicates whether ORAN should be used or not\", useOran);\n    cmd.AddValue(\"use-onnx-lm\", \"Indicates whether the ONNX LM should be used or not\", useOnnx);\n    cmd.AddValue(\"use-torch-lm\",\n                 \"Indicates whether the PyTorch LM should be used or not\",\n                 useTorch);\n    cmd.AddValue(\"use-distance-lm\",\n                 \"Indicates whether the distance LM should be used or not\",\n                 useDistance);\n    cmd.AddValue(\"start-config\", \"The starting configuration\", startConfig);\n    cmd.AddValue(\"sim-time\", \"The duration for which traffic should flow\", simTime);\n    cmd.AddValue(\"lm-query-interval\", \"The LM query interval\", lmQueryInterval);\n    cmd.AddValue(\"tx-delay\", \"The E2 termiantor's transmission delay\", txDelay);\n    cmd.AddValue(\"handover-algorithm\",\n                 \"Specify which handover algorithm to use\",\n                 handoverAlgorithm);\n    cmd.AddValue(\"db-file\", \"Specify the DB file to create\", dbFileName);\n    cmd.AddValue(\"traffic-trace-file\",\n                 \"Specify the traffic trace file to create\",\n                 s_trafficTraceFile);\n    cmd.AddValue(\"position-trace-file\",\n                 \"Specify the position trace file to create\",\n                 s_positionTraceFile);\n    cmd.AddValue(\"handover-trace-file\",\n                 \"Specify the handover trace file to create\",\n                 s_handoverTraceFile);\n    cmd.Parse(argc, argv);\n\n    NS_ABORT_MSG_IF(useOran == false && (useOnnx || useTorch || useDistance),\n                    \"Cannot use ML LM or distance LM without enabling O-RAN.\");\n    NS_ABORT_MSG_IF((useOnnx + useTorch + useDistance) > 1,\n                    \"Cannot use more than one LM simultaneously.\");\n    NS_ABORT_MSG_IF(handoverAlgorithm != \"ns3::NoOpHandoverAlgorithm\" &&\n                        (useOnnx || useTorch || useDistance),\n                    \"Cannot use non-noop handover algorithm with ML LM or distance LM.\");\n\n    // Increase the buffer size to accomodate the application demand\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(1000 * 1024));\n    // Disabled to prevent the automatic cell reselection when signal quality is bad.\n    Config::SetDefault(\"ns3::LteUePhy::EnableRlfDetection\", BooleanValue(false));\n\n    // Configure the LTE parameters (pathloss, bandwidth, scheduler)\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    lteHelper->SetAttribute(\"PathlossModel\", StringValue(\"ns3::Cost231PropagationLossModel\"));\n    lteHelper->SetEnbDeviceAttribute(\"DlBandwidth\", UintegerValue(50));\n    lteHelper->SetEnbDeviceAttribute(\"UlBandwidth\", UintegerValue(50));\n    lteHelper->SetSchedulerType(\"ns3::RrFfMacScheduler\");\n    lteHelper->SetSchedulerAttribute(\"HarqEnabled\", BooleanValue(true));\n    lteHelper->SetHandoverAlgorithmType(handoverAlgorithm);\n\n    // Deploy the EPC\n    Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n\n    // Create a single remote host\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // IP configuration\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(65000));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(0)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n\n    // Create eNB and UE\n    NodeContainer ueNodes;\n    NodeContainer enbNodes;\n    enbNodes.Create(2);\n    ueNodes.Create(4);\n\n    // Install Mobility Model for eNB (Constant Position at (0, 0, 0)\n    Ptr<ListPositionAllocator> positionAllocEnbs = CreateObject<ListPositionAllocator>();\n    positionAllocEnbs->Add(Vector(0, 0, 0));\n    positionAllocEnbs->Add(Vector(265, 0, 0));\n    MobilityHelper mobilityEnbs;\n    mobilityEnbs.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobilityEnbs.SetPositionAllocator(positionAllocEnbs);\n    mobilityEnbs.Install(enbNodes);\n\n    // Install Mobility Model for UE (Constant Positions)\n    Ptr<ListPositionAllocator> positionAllocUes = CreateObject<ListPositionAllocator>();\n    positionAllocUes->Add(Vector(100, 0, 0));\n    positionAllocUes->Add(Vector(190, 0, 0));\n    positionAllocUes->Add(Vector(210, 0, 0));\n    positionAllocUes->Add(Vector(300, 0, 0));\n    MobilityHelper mobilityUes;\n\n    // Mobility Model for UE 0\n    Ptr<RandomVariableStream> speedRvs =\n        CreateObjectWithAttributes<UniformRandomVariable>(\"Min\",\n                                                          DoubleValue(1),\n                                                          \"Max\",\n                                                          DoubleValue(2.5));\n    Ptr<RandomVariableStream> pauseRvs =\n        CreateObjectWithAttributes<UniformRandomVariable>(\"Min\",\n                                                          DoubleValue(1),\n                                                          \"Max\",\n                                                          DoubleValue(6));\n    mobilityUes.SetMobilityModel(\"ns3::RandomDirection2dMobilityModel\",\n                                 \"Bounds\",\n                                 RectangleValue(Rectangle(-180, -10, -120, 120)),\n                                 \"Speed\",\n                                 PointerValue(speedRvs),\n                                 \"Pause\",\n                                 PointerValue(pauseRvs));\n    mobilityUes.Install(ueNodes.Get(0));\n\n    // Mobility Model for UE 1\n    mobilityUes.SetMobilityModel(\"ns3::RandomDirection2dMobilityModel\",\n                                 \"Bounds\",\n                                 RectangleValue(Rectangle(60, 190, -60, 80)),\n                                 \"Speed\",\n                                 PointerValue(speedRvs),\n                                 \"Pause\",\n                                 PointerValue(pauseRvs));\n    mobilityUes.Install(ueNodes.Get(1));\n\n    // Mobility Model for UE 2\n    mobilityUes.SetMobilityModel(\"ns3::RandomDirection2dMobilityModel\",\n                                 \"Bounds\",\n                                 RectangleValue(Rectangle(120, 180, -120, 110)),\n                                 \"Speed\",\n                                 PointerValue(speedRvs),\n                                 \"Pause\",\n                                 PointerValue(pauseRvs));\n    mobilityUes.Install(ueNodes.Get(2));\n\n    // Mobility Model for UE 3\n    mobilityUes.SetMobilityModel(\"ns3::RandomDirection2dMobilityModel\",\n                                 \"Bounds\",\n                                 RectangleValue(Rectangle(230, 390, -180, 120)),\n                                 \"Speed\",\n                                 PointerValue(speedRvs),\n                                 \"Pause\",\n                                 PointerValue(pauseRvs));\n    mobilityUes.Install(ueNodes.Get(3));\n\n    // Install LTE Devices to the nodes\n    NetDeviceContainer enbLteDevs = lteHelper->InstallEnbDevice(enbNodes);\n    NetDeviceContainer ueLteDevs = lteHelper->InstallUeDevice(ueNodes);\n\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueLteDevs));\n    // Assign IP address to UEs, and install applications\n    for (uint32_t u = 0; u < ueNodes.GetN(); ++u)\n    {\n        Ptr<Node> ueNode = ueNodes.Get(u);\n        // Set the default gateway for the UE\n        Ptr<Ipv4StaticRouting> ueStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(ueNode->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    switch (startConfig)\n    {\n    case 0:\n        lteHelper->Attach(ueLteDevs.Get(0), enbLteDevs.Get(0));\n        lteHelper->Attach(ueLteDevs.Get(1), enbLteDevs.Get(0));\n        lteHelper->Attach(ueLteDevs.Get(2), enbLteDevs.Get(0));\n        lteHelper->Attach(ueLteDevs.Get(3), enbLteDevs.Get(1));\n        break;\n    case 1:\n        lteHelper->Attach(ueLteDevs.Get(0), enbLteDevs.Get(0));\n        lteHelper->Attach(ueLteDevs.Get(1), enbLteDevs.Get(0));\n        lteHelper->Attach(ueLteDevs.Get(2), enbLteDevs.Get(1));\n        lteHelper->Attach(ueLteDevs.Get(3), enbLteDevs.Get(1));\n        break;\n    case 2:\n        lteHelper->Attach(ueLteDevs.Get(0), enbLteDevs.Get(0));\n        lteHelper->Attach(ueLteDevs.Get(1), enbLteDevs.Get(1));\n        lteHelper->Attach(ueLteDevs.Get(2), enbLteDevs.Get(0));\n        lteHelper->Attach(ueLteDevs.Get(3), enbLteDevs.Get(1));\n        break;\n    case 3:\n        lteHelper->Attach(ueLteDevs.Get(0), enbLteDevs.Get(0));\n        lteHelper->Attach(ueLteDevs.Get(1), enbLteDevs.Get(1));\n        lteHelper->Attach(ueLteDevs.Get(2), enbLteDevs.Get(1));\n        lteHelper->Attach(ueLteDevs.Get(3), enbLteDevs.Get(1));\n        break;\n    default:\n        NS_ABORT_MSG(\"Starting configuration \" << startConfig << \" not supported.\");\n    }\n\n    lteHelper->AddX2Interface(enbNodes);\n\n    // Install and start applications on UEs and remote host\n    uint16_t basePort = 1000;\n    ApplicationContainer remoteApps;\n    ApplicationContainer ueApps;\n\n    Ptr<RandomVariableStream> onTimeRv = CreateObject<UniformRandomVariable>();\n    onTimeRv->SetAttribute(\"Min\", DoubleValue(1.0));\n    onTimeRv->SetAttribute(\"Max\", DoubleValue(5.0));\n    Ptr<RandomVariableStream> offTimeRv = CreateObject<UniformRandomVariable>();\n    offTimeRv->SetAttribute(\"Min\", DoubleValue(1.0));\n    offTimeRv->SetAttribute(\"Max\", DoubleValue(5.0));\n\n    for (uint16_t i = 0; i < ueNodes.GetN(); i++)\n    {\n        uint16_t port = basePort * (i + 1);\n\n        PacketSinkHelper dlPacketSinkHelper(\"ns3::UdpSocketFactory\",\n                                            InetSocketAddress(Ipv4Address::GetAny(), port));\n        ueApps.Add(dlPacketSinkHelper.Install(ueNodes.Get(i)));\n        // Enable the tracing of RX packets\n        ueApps.Get(i)->TraceConnectWithoutContext(\"RxWithAddresses\", MakeCallback(&RxTrace));\n\n        Ptr<OnOffApplication> streamingServer = CreateObject<OnOffApplication>();\n        remoteApps.Add(streamingServer);\n        // Attributes\n        streamingServer->SetAttribute(\n            \"Remote\",\n            AddressValue(InetSocketAddress(ueIpIface.GetAddress(i), port)));\n        streamingServer->SetAttribute(\"DataRate\", DataRateValue(DataRate(\"3000000bps\")));\n        streamingServer->SetAttribute(\"PacketSize\", UintegerValue(1500));\n        streamingServer->SetAttribute(\"OnTime\", PointerValue(onTimeRv));\n        streamingServer->SetAttribute(\"OffTime\", PointerValue(offTimeRv));\n\n        remoteHost->AddApplication(streamingServer);\n        streamingServer->TraceConnectWithoutContext(\"TxWithAddresses\", MakeCallback(&TxTrace));\n    }\n\n    // Inidcate when to start streaming\n    remoteApps.Start(Seconds(2));\n    // Indicate when to stop streaming\n    remoteApps.Stop(simTime + Seconds(10));\n\n    // UE applications start listening\n    ueApps.Start(Seconds(1));\n    // UE applications stop listening\n    ueApps.Stop(simTime + Seconds(15));\n\n    // ORAN BEGIN\n    if (useOran == true)\n    {\n        if (!dbFileName.empty())\n        {\n            std::remove(dbFileName.c_str());\n        }\n\n        TypeId defaultLmTid = TypeId::LookupByName(\"ns3::OranLmNoop\");\n\n        Ptr<OranLm> defaultLm = nullptr;\n        Ptr<OranDataRepository> dataRepository = CreateObject<OranDataRepositorySqlite>();\n        Ptr<OranCmm> cmm = CreateObject<OranCmmHandover>();\n        Ptr<OranNearRtRic> nearRtRic = CreateObject<OranNearRtRic>();\n        Ptr<OranNearRtRicE2Terminator> nearRtRicE2Terminator =\n            CreateObject<OranNearRtRicE2Terminator>();\n\n        if (useOnnx == true)\n        {\n            NS_ABORT_MSG_IF(\n                !TypeId::LookupByNameFailSafe(\"ns3::OranLmLte2LteOnnxHandover\", &defaultLmTid),\n                \"ONNX LM not found. Were the ONNX headers and libraries found during the config \"\n                \"operation?\");\n        }\n        else if (useTorch == true)\n        {\n            NS_ABORT_MSG_IF(\n                !TypeId::LookupByNameFailSafe(\"ns3::OranLmLte2LteTorchHandover\", &defaultLmTid),\n                \"Torch LM not found. Were the Torch headers and libraries found during the config \"\n                \"operation?\");\n        }\n        else if (useDistance == true)\n        {\n            defaultLmTid = TypeId::LookupByName(\"ns3::OranLmLte2LteDistanceHandover\");\n        }\n\n        ObjectFactory defaultLmFactory;\n        defaultLmFactory.SetTypeId(defaultLmTid);\n        defaultLm = defaultLmFactory.Create<OranLm>();\n\n        dataRepository->SetAttribute(\"DatabaseFile\", StringValue(dbFileName));\n        defaultLm->SetAttribute(\"Verbose\", BooleanValue(verbose));\n        defaultLm->SetAttribute(\"NearRtRic\", PointerValue(nearRtRic));\n\n        cmm->SetAttribute(\"NearRtRic\", PointerValue(nearRtRic));\n\n        nearRtRicE2Terminator->SetAttribute(\"NearRtRic\", PointerValue(nearRtRic));\n        nearRtRicE2Terminator->SetAttribute(\"DataRepository\", PointerValue(dataRepository));\n        nearRtRicE2Terminator->SetAttribute(\n            \"TransmissionDelayRv\",\n            StringValue(\"ns3::ConstantRandomVariable[Constant=\" + std::to_string(txDelay) + \"]\"));\n\n        nearRtRic->SetAttribute(\"DefaultLogicModule\", PointerValue(defaultLm));\n        nearRtRic->SetAttribute(\"E2Terminator\", PointerValue(nearRtRicE2Terminator));\n        nearRtRic->SetAttribute(\"DataRepository\", PointerValue(dataRepository));\n        nearRtRic->SetAttribute(\"LmQueryInterval\", TimeValue(Seconds(lmQueryInterval)));\n        nearRtRic->SetAttribute(\"ConflictMitigationModule\", PointerValue(cmm));\n\n        Simulator::Schedule(Seconds(1), &OranNearRtRic::Start, nearRtRic);\n\n        for (uint32_t idx = 0; idx < ueNodes.GetN(); idx++)\n        {\n            Ptr<OranReporterLocation> locationReporter = CreateObject<OranReporterLocation>();\n            Ptr<OranReporterLteUeCellInfo> lteUeCellInfoReporter =\n                CreateObject<OranReporterLteUeCellInfo>();\n            Ptr<OranReporterAppLoss> appLossReporter = CreateObject<OranReporterAppLoss>();\n            Ptr<OranE2NodeTerminatorLteUe> lteUeTerminator =\n                CreateObject<OranE2NodeTerminatorLteUe>();\n\n            locationReporter->SetAttribute(\"Terminator\", PointerValue(lteUeTerminator));\n\n            lteUeCellInfoReporter->SetAttribute(\"Terminator\", PointerValue(lteUeTerminator));\n\n            appLossReporter->SetAttribute(\"Terminator\", PointerValue(lteUeTerminator));\n            remoteApps.Get(idx)->TraceConnectWithoutContext(\n                \"Tx\",\n                MakeCallback(&ns3::OranReporterAppLoss::AddTx, appLossReporter));\n            ueApps.Get(idx)->TraceConnectWithoutContext(\n                \"Rx\",\n                MakeCallback(&ns3::OranReporterAppLoss::AddRx, appLossReporter));\n\n            lteUeTerminator->SetAttribute(\"NearRtRic\", PointerValue(nearRtRic));\n            lteUeTerminator->SetAttribute(\"RegistrationIntervalRv\",\n                                          StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n            lteUeTerminator->SetAttribute(\"SendIntervalRv\",\n                                          StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n\n            lteUeTerminator->AddReporter(locationReporter);\n            lteUeTerminator->AddReporter(lteUeCellInfoReporter);\n            lteUeTerminator->AddReporter(appLossReporter);\n            lteUeTerminator->SetAttribute(\"TransmissionDelayRv\",\n                                          StringValue(\"ns3::ConstantRandomVariable[Constant=\" +\n                                                      std::to_string(txDelay) + \"]\"));\n\n            lteUeTerminator->Attach(ueNodes.Get(idx));\n\n            Simulator::Schedule(Seconds(1), &OranE2NodeTerminatorLteUe::Activate, lteUeTerminator);\n        }\n\n        for (uint32_t idx = 0; idx < enbNodes.GetN(); idx++)\n        {\n            Ptr<OranReporterLocation> locationReporter = CreateObject<OranReporterLocation>();\n            Ptr<OranE2NodeTerminatorLteEnb> lteEnbTerminator =\n                CreateObject<OranE2NodeTerminatorLteEnb>();\n\n            locationReporter->SetAttribute(\"Terminator\", PointerValue(lteEnbTerminator));\n\n            lteEnbTerminator->SetAttribute(\"NearRtRic\", PointerValue(nearRtRic));\n            lteEnbTerminator->SetAttribute(\"RegistrationIntervalRv\",\n                                           StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n            lteEnbTerminator->SetAttribute(\"SendIntervalRv\",\n                                           StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n\n            lteEnbTerminator->AddReporter(locationReporter);\n            lteEnbTerminator->Attach(enbNodes.Get(idx));\n            lteEnbTerminator->SetAttribute(\"TransmissionDelayRv\",\n                                           StringValue(\"ns3::ConstantRandomVariable[Constant=\" +\n                                                       std::to_string(txDelay) + \"]\"));\n            Simulator::Schedule(Seconds(1),\n                                &OranE2NodeTerminatorLteEnb::Activate,\n                                lteEnbTerminator);\n        }\n    }\n    // ORAN END\n\n    // Erase the trace files if they exist\n    std::ofstream trafficOutFile(s_trafficTraceFile, std::ios_base::trunc);\n    trafficOutFile.close();\n    std::ofstream posOutFile(s_positionTraceFile, std::ios_base::trunc);\n    posOutFile.close();\n    std::ofstream hoOutFile(s_handoverTraceFile, std::ios_base::trunc);\n    hoOutFile.close();\n\n    // Start tracing node locations\n    Simulator::Schedule(Seconds(1), &TracePositions, ueNodes);\n\n    // Connect to handover trace so we know when a handover is successfully performed\n    Config::Connect(\"/NodeList/*/DeviceList/*/LteEnbRrc/HandoverEndOk\",\n                    MakeCallback(&NotifyHandoverEndOkEnb));\n\n    // Tell the simulator how long to run\n    Simulator::Stop(simTime + Seconds(20));\n    // Run the simulation\n    Simulator::Run();\n    // Clean up used resources\n    Simulator::Destroy();\n\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/oran-lte-2-lte-rsrp-handover-lm-example.cc",
      "code": "/**\n * NIST-developed software is provided by NIST as a public service. You may\n * use, copy and distribute copies of the software in any medium, provided that\n * you keep intact this entire notice. You may improve, modify and create\n * derivative works of the software or any portion of the software, and you may\n * copy and distribute such modifications or works. Modified works should carry\n * a notice stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the National\n * Institute of Standards and Technology as the source of the software.\n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES NO\n * WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF\n * LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT AND DATA ACCURACY. NIST\n * NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE\n * UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST\n * DOES NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE\n * SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE\n * CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n *\n * You are solely responsible for determining the appropriateness of using and\n * distributing the software and you assume all risks associated with its use,\n * including but not limited to the risks and costs of program errors,\n * compliance with applicable laws, damage to or loss of data, programs or\n * equipment, and the unavailability or interruption of operation. This\n * software is not intended to be used in any situation where a failure could\n * cause risk of injury or damage to property. The software developed by NIST\n * employees is not subject to copyright protection within the United States.\n */\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/oran-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OranLte2LteRsrpHandoverExample\");\n\n/**\n * Example of the ORAN models.\n *\n * The scenario consists of an LTE UE moving back and forth\n * between 2 LTE eNBs. The LTE UE reports its location to the RIC\n * and current Cell ID. In the RIC, an LM will periodically check\n * the RSRP and RSRQ of UE, and if needed, issue a handover command.\n *\n * This example demonstrates how to configure processing delays for the LMs.\n */\n\n// Tracing rsrp, rsrq, and sinr\nvoid\nTraceRsrpRsrqSinr(Ptr<OutputStreamWrapper> stream,\n                  uint16_t rnti,\n                  uint16_t cellId,\n                  double rsrp,\n                  double rsrq,\n                  uint8_t sinr)\n{\n    *stream->GetStream() << Simulator::Now().GetSeconds() << \" \" << rnti << \" \" << cellId << \" \"\n                         << rsrp << \" \" << rsrq << \" \" << +sinr << \" \" << std::endl;\n}\n\n// Trace RX'd packets\nvoid\nRxTrace(Ptr<OutputStreamWrapper> stream,\n        Ptr<const Packet> p,\n        const Address& from,\n        const Address& to)\n{\n    uint16_t ueId = (InetSocketAddress::ConvertFrom(to).GetPort() / 1000);\n\n    *stream->GetStream() << Simulator::Now().GetSeconds() << \" \" << ueId << \" RX \" << p->GetSize()\n                         << std::endl;\n}\n\n// Trace TX'd packets\nvoid\nTxTrace(Ptr<OutputStreamWrapper> stream,\n        Ptr<const Packet> p,\n        const Address& from,\n        const Address& to)\n{\n    uint16_t ueId = (InetSocketAddress::ConvertFrom(to).GetPort() / 1000);\n\n    *stream->GetStream() << Simulator::Now().GetSeconds() << \" \" << ueId << \" TX \" << p->GetSize()\n                         << std::endl;\n}\n\n// Trace each node's location\nvoid\nPositionTrace(Ptr<OutputStreamWrapper> stream, NodeContainer nodes)\n{\n    for (uint32_t i = 0; i < nodes.GetN(); i++)\n    {\n        Vector pos = nodes.Get(i)->GetObject<MobilityModel>()->GetPosition();\n        *stream->GetStream() << Simulator::Now().GetSeconds() << \" \" << nodes.Get(i)->GetId() << \" \"\n                             << pos.x << \" \" << pos.y << std::endl;\n    }\n\n    Simulator::Schedule(Seconds(1), &PositionTrace, stream, nodes);\n}\n\n// Trace handover events\nvoid\nHandoverTrace(Ptr<OutputStreamWrapper> stream, uint64_t imsi, uint16_t cellid, uint16_t rnti)\n{\n    *stream->GetStream() << Simulator::Now().GetSeconds() << \" \" << imsi << \" \" << cellid << \" \"\n                         << rnti << std::endl;\n}\n\n// Output DB queries\nvoid\nQueryRcSink(std::string query, std::string args, int rc)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" Query \"\n              << ((rc == SQLITE_OK || rc == SQLITE_DONE) ? \"OK\" : \"ERROR\") << \"(\" << rc << \"): \\\"\"\n              << query << \"\\\"\";\n\n    if (!args.empty())\n    {\n        std::cout << \" (\" << args << \")\";\n    }\n\n    std::cout << std::endl;\n}\n\n// Function to change node velocities\nvoid\nReverseVelocity(NodeContainer nodes, Time interval)\n{\n    for (uint32_t idx = 0; idx < nodes.GetN(); idx++)\n    {\n        Ptr<ConstantVelocityMobilityModel> mobility =\n            nodes.Get(idx)->GetObject<ConstantVelocityMobilityModel>();\n        mobility->SetVelocity(Vector(mobility->GetVelocity().x * -1, 0, 0));\n    }\n\n    Simulator::Schedule(interval, &ReverseVelocity, nodes, interval);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint16_t numberOfUes = 1;\n    uint16_t numberOfEnbs = 2;\n    Time simTime = Seconds(30);\n    Time maxWaitTime = Seconds(0.010);\n    std::string processingDelayRv = \"ns3::NormalRandomVariable[Mean=0.005|Variance=0.000031]\";\n    double distance = 50; // distance between eNBs\n    Time interval = Seconds(15);\n    double speed = 2; // speed of the ue\n    bool dbLog = false;\n    Time lmQueryInterval = Seconds(5);\n    std::string dbFileName = \"oran-repository.db\";\n    std::string lateCommandPolicy = \"DROP\";\n\n    // Command line arguments\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"db-log\", \"Enable printing SQL queries results\", dbLog);\n    cmd.AddValue(\"max-wait-time\", \"The maximum amount of time an LM has to run\", maxWaitTime);\n    cmd.AddValue(\"processing-delay-rv\",\n                 \"The random variable that represents the LMs processing delay\",\n                 processingDelayRv);\n    cmd.AddValue(\"lm-query-interval\",\n                 \"The interval at which to query the LM for commands\",\n                 lmQueryInterval);\n    cmd.AddValue(\"late-command-policy\",\n                 \"The policy to use for handling commands received after the maximum wait time \"\n                 \"(\\\"DROP\\\" or \\\"SAVE\\\")\",\n                 lateCommandPolicy);\n    cmd.AddValue(\"sim-time\", \"The amount of time to simulate\", simTime);\n    cmd.Parse(argc, argv);\n\n    LogComponentEnable(\"OranNearRtRic\", (LogLevel)(LOG_PREFIX_TIME | LOG_WARN));\n\n    // Increase the buffer size to accomodate the application demand\n    Config::SetDefault(\"ns3::LteRlcUm::MaxTxBufferSize\", UintegerValue(1000 * 1024));\n    // Disabled to prevent the automatic cell reselection when signal quality is bad.\n    Config::SetDefault(\"ns3::LteUePhy::EnableRlfDetection\", BooleanValue(false));\n\n    // Configure the LTE parameters (pathloss, bandwidth, scheduler)\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    lteHelper->SetAttribute(\"PathlossModel\", StringValue(\"ns3::Cost231PropagationLossModel\"));\n    lteHelper->SetEnbDeviceAttribute(\"DlBandwidth\", UintegerValue(50));\n    lteHelper->SetEnbDeviceAttribute(\"UlBandwidth\", UintegerValue(50));\n    lteHelper->SetSchedulerType(\"ns3::RrFfMacScheduler\");\n    lteHelper->SetSchedulerAttribute(\"HarqEnabled\", BooleanValue(true));\n    lteHelper->SetHandoverAlgorithmType(\"ns3::NoOpHandoverAlgorithm\");\n\n    // Deploy the EPC\n    Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n\n    // Create a single remote host\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // IP configuration\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(65000));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(0)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n\n    // Create nodes and node containers\n    NodeContainer ueNodes;\n    NodeContainer enbNodes;\n    enbNodes.Create(numberOfEnbs);\n    ueNodes.Create(numberOfUes);\n\n    // Install Mobility Model\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    for (uint16_t i = 0; i < numberOfEnbs; i++)\n    {\n        positionAlloc->Add(Vector(distance * i, 0, 20));\n    }\n\n    for (uint16_t i = 0; i < numberOfUes; i++)\n    {\n        // Coordinates of the middle point between the eNBs, minus the distance covered\n        // in half of the interval for switching directions\n        positionAlloc->Add(Vector((distance / 2) - (speed * (interval.GetSeconds() / 2)), 0, 1.5));\n    }\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(enbNodes);\n\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(ueNodes);\n\n    for (uint32_t idx = 0; idx < ueNodes.GetN(); idx++)\n    {\n        Ptr<ConstantVelocityMobilityModel> mobility =\n            ueNodes.Get(idx)->GetObject<ConstantVelocityMobilityModel>();\n        mobility->SetVelocity(Vector(speed, 0, 0));\n    }\n\n    // Schedule the first direction switch\n    Simulator::Schedule(interval, &ReverseVelocity, ueNodes, interval);\n\n    // Install LTE Devices in eNB and UEs\n    NetDeviceContainer enbLteDevs = lteHelper->InstallEnbDevice(enbNodes);\n    NetDeviceContainer ueLteDevs = lteHelper->InstallUeDevice(ueNodes);\n\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueLteDevs));\n    // Assign IP address to UEs, and install applications\n    for (uint32_t u = 0; u < ueNodes.GetN(); ++u)\n    {\n        Ptr<Node> ueNode = ueNodes.Get(u);\n        // Set the default gateway for the UE\n        Ptr<Ipv4StaticRouting> ueStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(ueNode->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // Attach all UEs to the first eNodeB\n    for (uint16_t i = 0; i < numberOfUes; i++)\n    {\n        lteHelper->Attach(ueLteDevs.Get(i), enbLteDevs.Get(0));\n    }\n\n    // Add X2 interface\n    lteHelper->AddX2Interface(enbNodes);\n\n    // Install and start applications on UEs and remote host\n    uint16_t basePort = 1000;\n    ApplicationContainer remoteApps;\n    ApplicationContainer ueApps;\n\n    Ptr<RandomVariableStream> onTimeRv = CreateObject<UniformRandomVariable>();\n    onTimeRv->SetAttribute(\"Min\", DoubleValue(1.0));\n    onTimeRv->SetAttribute(\"Max\", DoubleValue(5.0));\n    Ptr<RandomVariableStream> offTimeRv = CreateObject<UniformRandomVariable>();\n    offTimeRv->SetAttribute(\"Min\", DoubleValue(1.0));\n    offTimeRv->SetAttribute(\"Max\", DoubleValue(5.0));\n\n    Ptr<OutputStreamWrapper> packetTraceStream =\n        Create<OutputStreamWrapper>(\"packet.tr\", std::ios::out);\n\n    for (uint16_t i = 0; i < ueNodes.GetN(); i++)\n    {\n        uint16_t port = basePort * (i + 1);\n\n        PacketSinkHelper dlPacketSinkHelper(\"ns3::UdpSocketFactory\",\n                                            InetSocketAddress(Ipv4Address::GetAny(), port));\n        ueApps.Add(dlPacketSinkHelper.Install(ueNodes.Get(i)));\n        // Enable the tracing of RX packets\n        ueApps.Get(i)->TraceConnectWithoutContext(\"RxWithAddresses\",\n                                                  MakeBoundCallback(&RxTrace, packetTraceStream));\n\n        Ptr<OnOffApplication> streamingServer = CreateObject<OnOffApplication>();\n        remoteApps.Add(streamingServer);\n        // Attributes\n        streamingServer->SetAttribute(\n            \"Remote\",\n            AddressValue(InetSocketAddress(ueIpIface.GetAddress(i), port)));\n        streamingServer->SetAttribute(\"DataRate\", DataRateValue(DataRate(\"3000000bps\")));\n        streamingServer->SetAttribute(\"PacketSize\", UintegerValue(1500));\n        streamingServer->SetAttribute(\"OnTime\", PointerValue(onTimeRv));\n        streamingServer->SetAttribute(\"OffTime\", PointerValue(offTimeRv));\n\n        remoteHost->AddApplication(streamingServer);\n        streamingServer->TraceConnectWithoutContext(\"TxWithAddresses\",\n                                                    MakeBoundCallback(&TxTrace, packetTraceStream));\n    }\n\n    // Inidcate when to start streaming\n    remoteApps.Start(Seconds(2));\n    // Indicate when to stop streaming\n    remoteApps.Stop(simTime + Seconds(10));\n\n    // UE applications start listening\n    ueApps.Start(Seconds(1));\n    // UE applications stop listening\n    ueApps.Stop(simTime + Seconds(15));\n\n    // ORAN Models -- BEGIN\n    Ptr<OranNearRtRic> nearRtRic = nullptr;\n    OranE2NodeTerminatorContainer e2NodeTerminatorsEnbs;\n    OranE2NodeTerminatorContainer e2NodeTerminatorsUes;\n    Ptr<OranHelper> oranHelper = CreateObject<OranHelper>();\n\n    oranHelper->SetAttribute(\"Verbose\", BooleanValue(true));\n    oranHelper->SetAttribute(\"LmQueryInterval\", TimeValue(lmQueryInterval));\n    oranHelper->SetAttribute(\"E2NodeInactivityThreshold\", TimeValue(Seconds(2)));\n    oranHelper->SetAttribute(\"E2NodeInactivityIntervalRv\",\n                             StringValue(\"ns3::ConstantRandomVariable[Constant=2]\"));\n    oranHelper->SetAttribute(\"LmQueryMaxWaitTime\",\n                             TimeValue(maxWaitTime)); // 0 means wait for all LMs to finish\n    oranHelper->SetAttribute(\"LmQueryLateCommandPolicy\", StringValue(lateCommandPolicy));\n\n    // RIC setup\n    if (!dbFileName.empty())\n    {\n        std::remove(dbFileName.c_str());\n    }\n\n    oranHelper->SetDataRepository(\"ns3::OranDataRepositorySqlite\",\n                                  \"DatabaseFile\",\n                                  StringValue(dbFileName));\n    oranHelper->SetDefaultLogicModule(\"ns3::OranLmLte2LteRsrpHandover\",\n                                      \"ProcessingDelayRv\",\n                                      StringValue(processingDelayRv));\n    oranHelper->SetConflictMitigationModule(\"ns3::OranCmmNoop\");\n\n    nearRtRic = oranHelper->CreateNearRtRic();\n\n    // UE Nodes setup\n    for (uint32_t idx = 0; idx < ueNodes.GetN(); idx++)\n    {\n        Ptr<OranReporterLocation> locationReporter = CreateObject<OranReporterLocation>();\n        Ptr<OranReporterLteUeCellInfo> lteUeCellInfoReporter =\n            CreateObject<OranReporterLteUeCellInfo>();\n        Ptr<OranReporterLteUeRsrpRsrq> rsrpRsrqReporter = CreateObject<OranReporterLteUeRsrpRsrq>();\n        Ptr<OranE2NodeTerminatorLteUe> lteUeTerminator = CreateObject<OranE2NodeTerminatorLteUe>();\n\n        locationReporter->SetAttribute(\"Terminator\", PointerValue(lteUeTerminator));\n\n        lteUeCellInfoReporter->SetAttribute(\"Terminator\", PointerValue(lteUeTerminator));\n\n        rsrpRsrqReporter->SetAttribute(\"Terminator\", PointerValue(lteUeTerminator));\n\n        for (uint32_t netDevIdx = 0; netDevIdx < ueNodes.Get(idx)->GetNDevices(); netDevIdx++)\n        {\n            Ptr<LteUeNetDevice> lteUeDevice =\n                ueNodes.Get(idx)->GetDevice(netDevIdx)->GetObject<LteUeNetDevice>();\n            if (lteUeDevice)\n            {\n                Ptr<LteUePhy> uePhy = lteUeDevice->GetPhy();\n                uePhy->TraceConnectWithoutContext(\n                    \"ReportUeMeasurements\",\n                    MakeCallback(&ns3::OranReporterLteUeRsrpRsrq::ReportRsrpRsrq,\n                                 rsrpRsrqReporter));\n            }\n        }\n\n        lteUeTerminator->SetAttribute(\"NearRtRic\", PointerValue(nearRtRic));\n        lteUeTerminator->SetAttribute(\"RegistrationIntervalRv\",\n                                      StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n        lteUeTerminator->SetAttribute(\"SendIntervalRv\",\n                                      StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n\n        lteUeTerminator->AddReporter(locationReporter);\n        lteUeTerminator->AddReporter(lteUeCellInfoReporter);\n        lteUeTerminator->AddReporter(rsrpRsrqReporter);\n\n        lteUeTerminator->Attach(ueNodes.Get(idx));\n\n        Simulator::Schedule(Seconds(1), &OranE2NodeTerminatorLteUe::Activate, lteUeTerminator);\n    }\n\n    // ENb Nodes setup\n    oranHelper->SetE2NodeTerminator(\"ns3::OranE2NodeTerminatorLteEnb\",\n                                    \"RegistrationIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"),\n                                    \"SendIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n\n    oranHelper->AddReporter(\"ns3::OranReporterLocation\",\n                            \"Trigger\",\n                            StringValue(\"ns3::OranReportTriggerPeriodic\"));\n\n    e2NodeTerminatorsEnbs.Add(oranHelper->DeployTerminators(nearRtRic, enbNodes));\n\n    // DB logging to the terminal\n    if (dbLog)\n    {\n        nearRtRic->Data()->TraceConnectWithoutContext(\"QueryRc\", MakeCallback(&QueryRcSink));\n    }\n\n    // Activate and the components\n    Simulator::Schedule(Seconds(1), &OranHelper::ActivateAndStartNearRtRic, oranHelper, nearRtRic);\n    Simulator::Schedule(Seconds(1.5),\n                        &OranHelper::ActivateE2NodeTerminators,\n                        oranHelper,\n                        e2NodeTerminatorsEnbs);\n    Simulator::Schedule(Seconds(2),\n                        &OranHelper::ActivateE2NodeTerminators,\n                        oranHelper,\n                        e2NodeTerminatorsUes);\n    // ORAN Models -- END\n\n    // Trace successful handovers\n    Ptr<OutputStreamWrapper> handoverTraceStream =\n        Create<OutputStreamWrapper>(\"handover.tr\", std::ios::out);\n    Config::ConnectWithoutContext(\"/NodeList/*/DeviceList/*/LteEnbRrc/HandoverEndOk\",\n                                  MakeBoundCallback(&HandoverTrace, handoverTraceStream));\n\n    // Periodically trace node positions\n    Ptr<OutputStreamWrapper> positionTraceStream =\n        Create<OutputStreamWrapper>(\"positions.tr\", std::ios::out);\n    Simulator::Schedule(Seconds(1), &PositionTrace, positionTraceStream, ueNodes);\n\n    // Trace rsrp, rsrq, and sinr\n    Ptr<OutputStreamWrapper> rsrpRsrqSinrTraceStream =\n        Create<OutputStreamWrapper>(\"rsrp-rsrq-sinr.tr\", std::ios::out);\n    for (NetDeviceContainer::Iterator it = ueLteDevs.Begin(); it != ueLteDevs.End(); ++it)\n    {\n        Ptr<NetDevice> device = *it;\n        Ptr<LteUeNetDevice> lteUeDevice = device->GetObject<LteUeNetDevice>();\n        if (lteUeDevice)\n        {\n            Ptr<LteUePhy> uePhy = lteUeDevice->GetPhy();\n            uePhy->TraceConnectWithoutContext(\n                \"ReportCurrentCellRsrpSinr\",\n                MakeBoundCallback(&TraceRsrpRsrqSinr, rsrpRsrqSinrTraceStream));\n        }\n    }\n\n    /* Enabling Tracing for the simulation scenario */\n    lteHelper->EnablePhyTraces();\n    lteHelper->EnableMacTraces();\n    lteHelper->EnableRlcTraces();\n    lteHelper->EnablePdcpTraces();\n\n    Simulator::Stop(simTime);\n    Simulator::Run();\n\n    Simulator::Destroy();\n\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/oran-multiple-net-devices-example.cc",
      "code": "/**\n * NIST-developed software is provided by NIST as a public service. You may\n * use, copy and distribute copies of the software in any medium, provided that\n * you keep intact this entire notice. You may improve, modify and create\n * derivative works of the software or any portion of the software, and you may\n * copy and distribute such modifications or works. Modified works should carry\n * a notice stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the National\n * Institute of Standards and Technology as the source of the software.\n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES NO\n * WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF\n * LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT AND DATA ACCURACY. NIST\n * NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE\n * UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST\n * DOES NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE\n * SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE\n * CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n *\n * You are solely responsible for determining the appropriateness of using and\n * distributing the software and you assume all risks associated with its use,\n * including but not limited to the risks and costs of program errors,\n * compliance with applicable laws, damage to or loss of data, programs or\n * equipment, and the unavailability or interruption of operation. This\n * software is not intended to be used in any situation where a failure could\n * cause risk of injury or damage to property. The software developed by NIST\n * employees is not subject to copyright protection within the United States.\n */\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/oran-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <stdio.h>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OranLte2LteDistanceHandoverHelperExample\");\n\n/**\n * Usage example of the ORAN models, configured with the ORAN Helper.\n *\n * The scenario consists of an LTE UE moving back and forth\n * between 2 LTE eNBs. The LTE UE reports to the RIC its location\n * and current Cell ID. In the RIC, an LM will periodically check\n * the position, and if needed, issue a handover command.\n */\n\nvoid\nTraceEnbRx(std::string context, uint16_t rnti, uint8_t lcid, uint32_t bytes, uint64_t delay)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" s: \" << context << \" recieved \" << bytes\n              << \" bytes from RNTI \" << (uint32_t)rnti << std::endl;\n}\n\nvoid\nNotifyHandoverEndOkEnb(std::string context, uint64_t imsi, uint16_t cellid, uint16_t rnti)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" s:\" << context << \" eNB CellId \" << cellid\n              << \": completed handover of UE with IMSI \" << imsi << \" RNTI \" << rnti << std::endl;\n\n    Config::Disconnect(\"NodeList/*/DeviceList/*/$ns3::LteNetDevice/$ns3::LteEnbNetDevice/LteEnbRrc/\"\n                       \"UeMap/*/DataRadioBearerMap/*/LteRlc/RxPDU\",\n                       MakeCallback(&TraceEnbRx));\n\n    Config::Connect(\"NodeList/*/DeviceList/*/$ns3::LteNetDevice/$ns3::LteEnbNetDevice/LteEnbRrc/\"\n                    \"UeMap/*/DataRadioBearerMap/*/LteRlc/RxPDU\",\n                    MakeCallback(&TraceEnbRx));\n}\n\nvoid\nRxTrace(std::string context, Ptr<const Packet> packet, const Address& address)\n{\n    InetSocketAddress isa = InetSocketAddress::ConvertFrom(address);\n\n    std::cout << Simulator::Now().GetSeconds() << \" s: \" << context << \" recieved \"\n              << packet->GetSize() << \" bytes from \" << isa.GetIpv4() << \" on port \"\n              << (uint32_t)isa.GetPort() << std::endl;\n}\n\nvoid\nQueryRcSink(std::string query, std::string args, int rc)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" Query \"\n              << ((rc == SQLITE_OK || rc == SQLITE_DONE) ? \"OK\" : \"ERROR\") << \"(\" << rc << \"): \\\"\"\n              << query << \"\\\"\";\n\n    if (!args.empty())\n    {\n        std::cout << \" (\" << args << \")\";\n    }\n    std::cout << std::endl;\n}\n\nvoid\nReverseVelocity(NodeContainer nodes, Time interval)\n{\n    for (uint32_t idx = 0; idx < nodes.GetN(); idx++)\n    {\n        Ptr<ConstantVelocityMobilityModel> mobility =\n            nodes.Get(idx)->GetObject<ConstantVelocityMobilityModel>();\n        mobility->SetVelocity(Vector(mobility->GetVelocity().x * -1, 0, 0));\n    }\n\n    Simulator::Schedule(interval, &ReverseVelocity, nodes, interval);\n}\n\n/**\n * ORAN handover example. Based on the LTE module's \"lena-x2-handover.cc\".\n */\nint\nmain(int argc, char* argv[])\n{\n    uint16_t numberOfUes = 1;\n    uint16_t numberOfEnbs = 2;\n    uint32_t numberOfNetDevs = 2;\n    Time simTime = Seconds(50);\n    double distance = 50;\n    Time interval = Seconds(15);\n    double speed = 1.5;\n    bool verbose = false;\n    bool applicationOutput = false;\n    bool enbOutput = true;\n\n    std::string dbFileName = \"oran-repository.db\";\n\n    // Command line arguments\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"Enable printing SQL queries results\", verbose);\n    cmd.AddValue(\"application-output\",\n                 \"Enable printing application traffic information\",\n                 applicationOutput);\n    cmd.AddValue(\"enb-output\", \"Enable eNodeB traffic information\", enbOutput);\n    cmd.Parse(argc, argv);\n\n    Config::SetDefault(\"ns3::LteHelper::UseIdealRrc\", BooleanValue(false));\n\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n    lteHelper->SetSchedulerType(\"ns3::RrFfMacScheduler\");\n    lteHelper->SetHandoverAlgorithmType(\"ns3::NoOpHandoverAlgorithm\"); // disable automatic handover\n\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n\n    // Create remote hosts\n    NodeContainer remoteHostsContainer;\n    remoteHostsContainer.Create(numberOfNetDevs);\n    InternetStackHelper internet;\n    internet.Install(remoteHostsContainer);\n\n    // Create the Internet\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n\n    for (uint16_t i = 0; i < remoteHostsContainer.GetN(); i++)\n    {\n        // Create the P2P links between P-GW and servers\n        PointToPointHelper p2ph;\n        p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n        p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(1500));\n        p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.010)));\n\n        NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHostsContainer.Get(i));\n        // Assign IPv6 addresses\n        Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n        // Define route from server to UEs\n        Ptr<Node> remoteHost = remoteHostsContainer.Get(i);\n        Ipv4Address remoteHostAddr = remoteHost->GetObject<Ipv4>()->GetAddress(1, 0).GetLocal();\n        Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n        // interface 0 is localhost, 1 is the p2p device\n        remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"),\n                                                   Ipv4Mask(\"255.0.0.0\"),\n                                                   1);\n        // Define route from P-GW to the server\n        Ptr<Ipv4StaticRouting> pgwStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(pgw->GetObject<Ipv4>());\n        pgwStaticRouting->AddHostRouteTo(remoteHostAddr, internetDevices.Get(0)->GetIfIndex());\n    }\n\n    NodeContainer ueNodes;\n    NodeContainer enbNodes;\n    enbNodes.Create(numberOfEnbs);\n    ueNodes.Create(numberOfUes);\n\n    // Install Mobility Model\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    for (uint16_t i = 0; i < numberOfEnbs; i++)\n    {\n        positionAlloc->Add(Vector(distance * i, 0.0, 20.0));\n    }\n\n    for (uint16_t i = 0; i < numberOfUes; i++)\n    {\n        // Coordinates of the middle point between the eNBs, minus the distance covered\n        // in half of the interval for switching directions\n        positionAlloc->Add(Vector((distance / 2) - (speed * (interval.GetSeconds() / 2)), 0, 1.5));\n    }\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(enbNodes);\n\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(ueNodes);\n\n    for (uint32_t idx = 0; idx < ueNodes.GetN(); idx++)\n    {\n        Ptr<ConstantVelocityMobilityModel> mobility =\n            ueNodes.Get(idx)->GetObject<ConstantVelocityMobilityModel>();\n        mobility->SetVelocity(Vector(speed, 0, 0));\n    }\n\n    // Schedule the first direction switch\n    Simulator::Schedule(interval, &ReverseVelocity, ueNodes, interval);\n\n    // Install LTE Devices in eNB and UEs\n    NetDeviceContainer enbLteDevs = lteHelper->InstallEnbDevice(enbNodes);\n\n    NetDeviceContainer ueLteDevs;\n    for (uint32_t i = 0; i < ueNodes.GetN(); i++)\n    {\n        for (uint32_t j = 0; j < numberOfNetDevs; j++)\n        {\n            ueLteDevs.Add(lteHelper->InstallUeDevice(ueNodes.Get(i)));\n        }\n    }\n    // Install the IP stack on the UEs\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpIfaces;\n    ueIpIfaces = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueLteDevs));\n\n    // Attach all UEs to the first eNodeB\n    for (uint16_t i = 0; i < ueLteDevs.GetN(); i++)\n    {\n        lteHelper->Attach(ueLteDevs.Get(i), enbLteDevs.Get(0));\n    }\n\n    // Install and start applications on UEs and remote host\n    uint16_t dlPort = 10000;\n    uint16_t ulPort = 20000;\n\n    // randomize a bit start times to avoid simulation artifacts\n    // (e.g., buffer overflows due to packet transmissions happening\n    // exactly at the same time)\n    Ptr<UniformRandomVariable> startTimeSeconds = CreateObject<UniformRandomVariable>();\n    startTimeSeconds->SetAttribute(\"Min\", DoubleValue(0.05));\n    startTimeSeconds->SetAttribute(\"Max\", DoubleValue(0.06));\n\n    ApplicationContainer clientApps;\n    ApplicationContainer serverApps;\n\n    for (uint32_t u = 0; u < ueNodes.GetN(); ++u)\n    {\n        Ptr<Node> ue = ueNodes.Get(u);\n        Ptr<Ipv4StaticRouting> ueStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(ue->GetObject<Ipv4>());\n\n        for (uint32_t netDevIdx = 1; netDevIdx < ue->GetNDevices(); netDevIdx++)\n        {\n            Ptr<Node> remoteHost = remoteHostsContainer.Get(netDevIdx - 1);\n            Ipv4Address remoteHostAddr = remoteHost->GetObject<Ipv4>()->GetAddress(1, 0).GetLocal();\n            Ipv4Address ueAddress = ue->GetObject<Ipv4>()->GetAddress(netDevIdx, 0).GetLocal();\n\n            ueStaticRouting->AddHostRouteTo(remoteHostAddr,\n                                            epcHelper->GetUeDefaultGatewayAddress(),\n                                            netDevIdx);\n\n            dlPort++;\n\n            OnOffHelper dlClientHelper(\"ns3::UdpSocketFactory\",\n                                       InetSocketAddress(ueAddress, dlPort));\n            dlClientHelper.SetAttribute(\"Local\",\n                                        AddressValue(InetSocketAddress(remoteHostAddr, dlPort)));\n            clientApps.Add(dlClientHelper.Install(remoteHost));\n\n            PacketSinkHelper dlPacketSinkHelper(\"ns3::UdpSocketFactory\",\n                                                InetSocketAddress(Ipv4Address::GetAny(), dlPort));\n            serverApps.Add(dlPacketSinkHelper.Install(ue));\n\n            ulPort++;\n\n            OnOffHelper ulClientHelper(\"ns3::UdpSocketFactory\",\n                                       InetSocketAddress(remoteHostAddr, ulPort));\n            ulClientHelper.SetAttribute(\"Local\",\n                                        AddressValue(InetSocketAddress(ueAddress, ulPort)));\n            clientApps.Add(ulClientHelper.Install(ue));\n\n            PacketSinkHelper ulPacketSinkHelper(\"ns3::UdpSocketFactory\",\n                                                InetSocketAddress(Ipv4Address::GetAny(), ulPort));\n            serverApps.Add(ulPacketSinkHelper.Install(remoteHost));\n        }\n    }\n\n    Time startTime = Seconds(startTimeSeconds->GetValue());\n    serverApps.Start(startTime);\n    clientApps.Start(startTime);\n    clientApps.Stop(simTime);\n\n    // Add X2 interface\n    lteHelper->AddX2Interface(enbNodes);\n\n    // ORAN Models -- BEGIN\n    Ptr<OranNearRtRic> nearRtRic = nullptr;\n    OranE2NodeTerminatorContainer e2NodeTerminatorsEnbs;\n    OranE2NodeTerminatorContainer e2NodeTerminatorsUes;\n    Ptr<OranHelper> oranHelper = CreateObject<OranHelper>();\n\n    oranHelper->SetAttribute(\"Verbose\", BooleanValue(true));\n    oranHelper->SetAttribute(\"LmQueryInterval\", TimeValue(Seconds(5)));\n    oranHelper->SetAttribute(\"E2NodeInactivityThreshold\", TimeValue(Seconds(2)));\n    oranHelper->SetAttribute(\"E2NodeInactivityIntervalRv\",\n                             StringValue(\"ns3::ConstantRandomVariable[Constant=2]\"));\n    oranHelper->SetAttribute(\"LmQueryMaxWaitTime\",\n                             TimeValue(Seconds(0))); // 0 means wait for all LMs to finish\n    oranHelper->SetAttribute(\"LmQueryLateCommandPolicy\", EnumValue(OranNearRtRic::DROP));\n    oranHelper->SetAttribute(\"RicTransmissionDelayRv\",\n                             StringValue(\"ns3::ConstantRandomVariable[Constant=0.001]\"));\n\n    // RIC setup\n    if (!dbFileName.empty())\n    {\n        std::remove(dbFileName.c_str());\n    }\n\n    oranHelper->SetDataRepository(\"ns3::OranDataRepositorySqlite\",\n                                  \"DatabaseFile\",\n                                  StringValue(dbFileName));\n    oranHelper->SetDefaultLogicModule(\"ns3::OranLmLte2LteDistanceHandover\",\n                                      \"ProcessingDelayRv\",\n                                      StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    oranHelper->SetConflictMitigationModule(\"ns3::OranCmmNoop\");\n\n    nearRtRic = oranHelper->CreateNearRtRic();\n\n    // UE Nodes setup\n    for (uint32_t netDevIdx = 0; netDevIdx < numberOfNetDevs; netDevIdx++)\n    {\n        oranHelper->SetE2NodeTerminator(\"ns3::OranE2NodeTerminatorLteUe\",\n                                        \"RegistrationIntervalRv\",\n                                        StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"),\n                                        \"SendIntervalRv\",\n                                        StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"),\n                                        \"TransmissionDelayRv\",\n                                        StringValue(\"ns3::ConstantRandomVariable[Constant=0.001]\"));\n\n        if (netDevIdx == 0)\n        {\n            oranHelper->AddReporter(\"ns3::OranReporterLocation\",\n                                    \"Trigger\",\n                                    StringValue(\"ns3::OranReportTriggerPeriodic\"));\n        }\n\n        oranHelper->AddReporter(\n            \"ns3::OranReporterLteUeCellInfo\",\n            \"Trigger\",\n            StringValue(\"ns3::OranReportTriggerLteUeHandover[InitialReport=true]\"));\n\n        e2NodeTerminatorsUes.Add(oranHelper->DeployTerminators(nearRtRic, ueNodes, netDevIdx));\n    }\n\n    // ENb Nodes setup\n    oranHelper->SetE2NodeTerminator(\"ns3::OranE2NodeTerminatorLteEnb\",\n                                    \"RegistrationIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"),\n                                    \"SendIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"),\n                                    \"TransmissionDelayRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=0.001]\"));\n\n    oranHelper->AddReporter(\"ns3::OranReporterLocation\",\n                            \"Trigger\",\n                            StringValue(\"ns3::OranReportTriggerPeriodic\"));\n\n    e2NodeTerminatorsEnbs.Add(oranHelper->DeployTerminators(nearRtRic, enbNodes));\n\n    // DB logging to the terminal\n    if (verbose)\n    {\n        nearRtRic->Data()->TraceConnectWithoutContext(\"QueryRc\", MakeCallback(&QueryRcSink));\n    }\n\n    // Activate and the components\n    Simulator::Schedule(Seconds(1), &OranHelper::ActivateAndStartNearRtRic, oranHelper, nearRtRic);\n    Simulator::Schedule(Seconds(1.5),\n                        &OranHelper::ActivateE2NodeTerminators,\n                        oranHelper,\n                        e2NodeTerminatorsEnbs);\n    Simulator::Schedule(Seconds(2),\n                        &OranHelper::ActivateE2NodeTerminators,\n                        oranHelper,\n                        e2NodeTerminatorsUes);\n    // ORAN Models -- END\n\n    if (applicationOutput)\n    {\n        // Trace the reception of packets at the application layer\n        Config::Connect(\"/NodeList/*/ApplicationList/*/$ns3::PacketSink/Rx\",\n                        MakeCallback(&RxTrace));\n    }\n\n    if (enbOutput)\n    {\n        // Trace the end of handovers\n        Config::Connect(\"/NodeList/*/DeviceList/*/LteEnbRrc/HandoverEndOk\",\n                        MakeCallback(&NotifyHandoverEndOkEnb));\n\n        // Trace the receiption of PDUs at the eNB\n        Simulator::Schedule(Seconds(0.5),\n                            &Config::Connect,\n                            \"NodeList/*/DeviceList/*/$ns3::LteNetDevice/$ns3::LteEnbNetDevice/\"\n                            \"LteEnbRrc/UeMap/*/DataRadioBearerMap/*/LteRlc/RxPDU\",\n                            MakeCallback(&TraceEnbRx));\n    }\n\n    Simulator::Stop(simTime);\n    Simulator::Run();\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/oran-random-walk-example.cc",
      "code": "/**\n * NIST-developed software is provided by NIST as a public service. You may\n * use, copy and distribute copies of the software in any medium, provided that\n * you keep intact this entire notice. You may improve, modify and create\n * derivative works of the software or any portion of the software, and you may\n * copy and distribute such modifications or works. Modified works should carry\n * a notice stating that you changed the software and should note the date and\n * nature of any such change. Please explicitly acknowledge the National\n * Institute of Standards and Technology as the source of the software.\n *\n * NIST-developed software is expressly provided \"AS IS.\" NIST MAKES NO\n * WARRANTY OF ANY KIND, EXPRESS, IMPLIED, IN FACT OR ARISING BY OPERATION OF\n * LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT AND DATA ACCURACY. NIST\n * NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE\n * UNINTERRUPTED OR ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST\n * DOES NOT WARRANT OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF THE\n * SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE\n * CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.\n *\n * You are solely responsible for determining the appropriateness of using and\n * distributing the software and you assume all risks associated with its use,\n * including but not limited to the risks and costs of program errors,\n * compliance with applicable laws, damage to or loss of data, programs or\n * equipment, and the unavailability or interruption of operation. This\n * software is not intended to be used in any situation where a failure could\n * cause risk of injury or damage to property. The software developed by NIST\n * employees is not subject to copyright protection within the United States.\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/oran-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OranRandomWalkExample\");\n\n/**\n * Usage example of the ORAN models.\n *\n * A simple topology of a node moving randomly\n * and reporting its location is used.\n */\n\nvoid\nCourseChange(Ptr<const MobilityModel> mobility)\n{\n    Vector pos = mobility->GetPosition();\n    Vector vel = mobility->GetVelocity();\n    std::cout << Simulator::Now() << \", model=\" << mobility << \", POS: x=\" << pos.x\n              << \", y=\" << pos.y << \", z=\" << pos.z << \"; VEL:\" << vel.x << \", y=\" << vel.y\n              << \", z=\" << vel.z << std::endl;\n}\n\nvoid\nQueryRcSink(std::string query, std::string args, int rc)\n{\n    std::cout << Simulator::Now().GetSeconds() << \" Query \"\n              << ((rc == SQLITE_OK || rc == SQLITE_DONE) ? \"OK\" : \"ERROR\") << \"(\" << rc << \"): \\\"\"\n              << query << \"\\\"\";\n\n    if (!args.empty())\n    {\n        std::cout << \" (\" << args << \")\";\n    }\n    std::cout << std::endl;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint16_t numberOfNodes = 1;\n    Time simTime = Seconds(50);\n    bool verbose = false;\n    std::string dbFileName = \"oran-repository.db\";\n\n    // Command line arguments\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"duration\", \"The length of the simulation.\", simTime);\n    cmd.AddValue(\"nodes\", \"The number of nodes to consider.\", numberOfNodes);\n    cmd.AddValue(\"verbose\", \"Enable printing node location.\", verbose);\n    cmd.Parse(argc, argv);\n\n    // Create nodes.\n    NodeContainer nodes;\n    nodes.Create(numberOfNodes);\n\n    // Setup mobility model.\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomDiscPositionAllocator\",\n                                  \"X\",\n                                  StringValue(\"100.0\"),\n                                  \"Y\",\n                                  StringValue(\"100.0\"),\n                                  \"Rho\",\n                                  StringValue(\"ns3::UniformRandomVariable[Min=0|Max=30]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Mode\",\n                              StringValue(\"Time\"),\n                              \"Time\",\n                              StringValue(\"2s\"),\n                              \"Speed\",\n                              StringValue(\"ns3::ConstantRandomVariable[Constant=1.0]\"),\n                              \"Bounds\",\n                              StringValue(\"0|100|0|100\"));\n\n    // Deploy mobility model.\n    mobility.Install(nodes);\n\n    // Deploy ORAN\n    Ptr<OranNearRtRic> nearRtRic = nullptr;\n    OranE2NodeTerminatorContainer e2NodeTerminators;\n    Ptr<OranHelper> oranHelper = CreateObject<OranHelper>();\n    oranHelper->SetAttribute(\"Verbose\", BooleanValue(true));\n\n    // RIC setup\n    if (!dbFileName.empty())\n    {\n        std::remove(dbFileName.c_str());\n    }\n\n    oranHelper->SetDataRepository(\"ns3::OranDataRepositorySqlite\",\n                                  \"DatabaseFile\",\n                                  StringValue(dbFileName));\n    oranHelper->SetDefaultLogicModule(\"ns3::OranLmNoop\");\n    oranHelper->SetConflictMitigationModule(\"ns3::OranCmmNoop\");\n\n    nearRtRic = oranHelper->CreateNearRtRic();\n\n    // Terminator nodes setup\n    oranHelper->SetE2NodeTerminator(\"ns3::OranE2NodeTerminatorWired\",\n                                    \"RegistrationIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"),\n                                    \"SendIntervalRv\",\n                                    StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n\n    oranHelper->AddReporter(\"ns3::OranReporterLocation\",\n                            \"Trigger\",\n                            StringValue(\"ns3::OranReportTriggerPeriodic\"));\n\n    e2NodeTerminators.Add(oranHelper->DeployTerminators(nearRtRic, nodes));\n\n    // DB logging to the terminal\n    if (verbose)\n    {\n        nearRtRic->Data()->TraceConnectWithoutContext(\"QueryRc\", MakeCallback(&QueryRcSink));\n    }\n\n    // Activate and the components\n    Simulator::Schedule(Seconds(1), &OranHelper::ActivateAndStartNearRtRic, oranHelper, nearRtRic);\n    Simulator::Schedule(Seconds(2),\n                        &OranHelper::ActivateE2NodeTerminators,\n                        oranHelper,\n                        e2NodeTerminators);\n\n    // Link output callback to mobility model.\n    if (verbose)\n    {\n        Config::ConnectWithoutContext(\"/NodeList/*/$ns3::MobilityModel/CourseChange\",\n                                      MakeCallback(&CourseChange));\n    }\n\n    // Run the simulation.\n    Simulator::Stop(simTime);\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}\n"
    }
  ]
}