{
  "repo_name": "SoonyangZhang/webrtc-gcc-ns3",
  "github_url": "https://github.com/SoonyangZhang/webrtc-gcc-ns3",
  "readme": "# webrtc-gcc-ns3\ntest google congestion control algorithm on ns3.31\nThe ex-webrtc module depends on libwebrtc.a  \n## Preparation \nThere are three ways to get libwebtc.a  \n### The first approach  \nDownload offcial webrtc. This approch is not suggested. ex-webrtc is referred the code under /webrtc/test/scenario. It is small discrete event simulator and only suports to build two nodes topology (webrtc/test/scenario/network_node.cc). I copy some source files in test and api under ex-webrtc. Once these files are changed by webrtc, building error will encountered.    \n1 download webrtc.  \n```\nmkdir webrtc-checkout  \ncd webrtc-checkout  \nfetch --nohooks webrtc  \ngclient sync  \ncd src   \ngit checkout -b m84 refs/remotes/branch-heads/4147   \ngclient sync  \n```\n2 Add a flag in basic_types.h (third_party/libyuv/include/libyuv):\n```\n#define LIBYUV_LEGACY_TYPES  \n```\n3 Add two files to rtc_base library(BUILD.gn):  \n```\nrtc_library(\"rtc_base\") {\n  sources = [\n    ...\n    \"memory_stream.cc\",\n    \"memory_stream.h\",\n    \"memory_usage.cc\",\n    \"memory_usage.h\",\n    ....\n    ]\n}\n```\nRemove them out of the original library(rtc_library(\"rtc_base_tests_utils\")).  \nThe build flag rtc_include_tests is diabled, or else there will be errors when compiling.  \n4 Delete code in webrtc:  \n```\n//third_party/webrtc/modules/rtp_rtcp/source/rtp_rtcp_impl.cc   \nbool ModuleRtpRtcpImpl::TrySendPacket(RtpPacketToSend* packet,  \n                                      const PacedPacketInfo& pacing_info) {  \n  RTC_DCHECK(rtp_sender_);  \n  //if (!rtp_sender_->packet_generator.SendingMedia()) {   \n //   return false;  \n // }  \n  rtp_sender_->packet_sender.SendPacket(packet, pacing_info);  \n  return true;  \n}\n```\n5 Add code in webrtc(to get send bandwidth):  \n```\n//third_party/webrtc/call/call.h  \nclass Call {  \n    virtual uint32_t last_bandwidth_bps(){return 0;}  \n};  \n//third_party/webrtc/call/call.cc  \nnamespace internal {  \nclass Call{\n    uint32_t last_bandwidth_bps() override {return last_bandwidth_bps_;}  \n}\n}  \n```\n6  Built webrtc  with clang. [Get clang installed first](https://www.jianshu.com/p/3c7eae5c0c68).   \n- first step:    \n\n```\ncd webrtc/src  \ngn gen out/m84 --args='is_debug=false is_component_build=false is_clang=true rtc_include_tests=false rtc_use_h264=true rtc_enable_protobuf=false use_rtti=true use_custom_libcxx=false treat_warnings_as_errors=false use_ozone=true'   \n```\n- second step:  \n\n```\ncd webrtc/src  \nninja -C out/m84  \n```\n### The second approach  \nDownload the webrtc I upload. This approach to build libwertc.a is suggested for these intending to make some change in webrtc source code.    \nurl: https://pan.baidu.com/s/18F26BAmZhj_CAQzKNUeDSA  \nauth code: j4ts  \nAfter download the code, decompress it:  \n```\ncat webrtc.tar.gz* |tar zx  \n```\nBuilt webrtc  with clang (refer to step 6 above).  \n### The third approach\nI upload webrtc header and libwebrtc.a on github for fast prototype.  \nNo bother is needed to build webrtc.  \ndownload it here: https://github.com/SoonyangZhang/webrtc-header-lib  \n## Build ns3.31\n1 Add environment variable   \n```\nsudo gedit source /etc/profile   \nexport WEBRTC_SRC_DIR=/xx/xx/xx/webrtc/src   \n```\nWEBRTC_SRC_DIR is the path where you put webrtc source code.  \nThe reason for this can be found in ex-webrtc/wscript.. \n```\nwebrtc_code_path = os.environ['WEBRTC_SRC_DIR']  \nwebrtc_lib_path = os.path.join(webrtc_code_path, 'out', 'm84', 'obj')  \nwebrtc_absl_path = os.path.join(webrtc_code_path, 'third_party', 'abseil-cpp')  \n```\n2 Change the warning flags in ns3 (ns-allinone-3.31/ns-3.31/waf-tools/cflags.h).  \n```\nself.warnings_flags = [['-Wall'], ['-Wno-unused-parameter'], ['-Wextra']]\n```\nThe origin content can be seen [here](https://github.com/nsnam/ns-3-dev-git/blob/ns-3.31/waf-tools/cflags.py#L22).  \n4 Put the folder ex-webrtc under ns-allinone-3.31/ns-3.31/src.  \n5 Build ns3 with clang++  \n```\ncd ns-allinone-3.31/ns-3.31  \nsource /etc/profile  \nCXX=\"clang++\"  \nCXXFLAGS=\"-std=c++14\" \n./waf configure  \n./waf build  \n```\n## Run example:\n1 Put the file webrtc-static.cc under ns-allinone-3.31/ns-3.31/scratch/.  \n2 Rebuild ns3  \n```\ncd ns-allinone-3.31/ns-3.31  \nsource /etc/profile  \nCXX=\"clang++\"  \n./waf configure  \n./waf build  \n\n```\n3 Create a folder named traces under ns-allinone-3.31/ns-3.31/. The traced data can be found there.  \n4 Run the example in simulation mode (ns3 event time):\n```\n./waf --run \"scratch/webrtc-static --m=simu --it=1\"  \n```\n5 Run the example in emulation mode (real clock):   \n```\n ./waf --run \"scratch/webrtc-static --m=emu --it=1\"  \n```\nThe code here is used by [gym](https://github.com/OpenNetLab/gym) to build reinforce learning based congestion controller.  \n## Results:  \nIn simulation mode:  \n![avatar](https://github.com/SoonyangZhang/webrtc-gcc-ns3/blob/main/results/gcc-simu-bw.png)  \nIn Emulation mode:  \n![avatar](https://github.com/SoonyangZhang/webrtc-gcc-ns3/blob/main/results/gcc-emu-bw.png)  \nThe difference is clear.  \n## Reference:  \n[1] [build webrtc with gcc](https://mediasoup.org/documentation/v3/libmediasoupclient/installation/)   \n[2] [the blog in chinese to configure this code on ns3](https://blog.csdn.net/u010643777/article/details/107237315)   \n[3] [gym-Build reinforce learning congestion control controller for webrtc](https://github.com/OpenNetLab/gym)\n",
  "examples": [
    {
      "file_path": "ex-webrtc/model/webrtc-clock.cc",
      "code": "#include <utility>\r\n#include \"ns3/simulator.h\"\r\n#include \"ns3/nstime.h\"\r\n#include \"webrtc-clock.h\"\r\nnamespace ns3{\r\nclass ExternalClock:public rtc::ClockInterface{\r\npublic:\r\n    ExternalClock(){}\r\n    ~ExternalClock() override{}\r\n    int64_t TimeNanos() const override{\r\n        return Simulator::Now().GetNanoSeconds();\r\n    }\r\n};\r\n\r\nstatic  bool webrtc_clock_init=false;\r\nstatic ExternalClock external_clock;\r\n\r\n\r\nvoid webrtc_register_clock(){\r\n    if(!webrtc_clock_init){\r\n        rtc::SetClockForTesting(&external_clock);\r\n        webrtc_clock_init=true;\r\n    }\r\n    \r\n}\r\nuint32_t webrtc_time32(){\r\n    return rtc::Time32();\r\n}\r\nint64_t webrtc_time_millis(){\r\n    return rtc::TimeMillis();\r\n}\r\nint64_t webrtc_time_micros(){\r\n    return rtc::TimeMicros();\r\n}\r\nint64_t webrtc_time_nanos(){\r\n    return rtc::TimeNanos();\r\n}\r\n}\r\n\r\nnamespace webrtc{\r\nTimestamp WebrtcSimulationClock::CurrentTime() {\r\n  return Timestamp::Micros(rtc::TimeMicros());\r\n}\r\n\r\nNtpTime WebrtcSimulationClock::CurrentNtpTime() {\r\n  int64_t now_ms =rtc::TimeMillis();\r\n  uint32_t seconds = (now_ms / 1000) + kNtpJan1970;\r\n  uint32_t fractions =\r\n      static_cast<uint32_t>((now_ms % 1000) * kMagicNtpFractionalUnit / 1000);\r\n  return NtpTime(seconds, fractions);\r\n}\r\n\r\nint64_t WebrtcSimulationClock::CurrentNtpInMilliseconds() {\r\n  return TimeInMilliseconds() + 1000 * static_cast<int64_t>(kNtpJan1970);\r\n}\r\n}\r\n"
    },
    {
      "file_path": "ex-webrtc/model/webrtc-receiver.cc",
      "code": "#include \"webrtc-receiver.h\"\r\n#include \"ns3/log.h\"\r\n#include \"rtc_base/net_helper.h\"\r\n#include \"api/test/network_emulation/network_emulation_interfaces.h\"\r\n#include \"webrtc-tag.h\"\r\n#include \"webrtc-trace.h\"\r\nnamespace ns3{\r\nNS_LOG_COMPONENT_DEFINE(\"WebrtcReceiver\");\r\nnamespace{\r\n    const uint32_t kIpv4HeaderSize=20;\r\n    constexpr char kDummyTransportName[] = \"dummy\";\r\n}\r\nWebrtcReceiver::WebrtcReceiver(WebrtcSessionManager *manager){\r\n    m_manager=manager;\r\n    m_clock=manager->time_controller_->GetClock();\r\n    m_manager->RegisterReceiverTransport(this,false);\r\n    m_client=m_manager->receiver_client_;\r\n    m_call=m_client->GetCall();\r\n    \r\n}\r\nWebrtcReceiver::~WebrtcReceiver(){}\r\nInetSocketAddress WebrtcReceiver::GetLocalAddress(){\r\n    Ptr<Node> node=GetNode();\r\n    Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();\r\n    Ipv4Address local_ip = ipv4->GetAddress (1, 0).GetLocal ();\r\n    return InetSocketAddress{local_ip,m_bindPort};    \r\n}\r\nvoid WebrtcReceiver::ConfigurePeer(Ipv4Address addr,uint16_t port){\r\n    m_peerIp=addr;\r\n    m_peerPort=port;    \r\n}\r\nvoid WebrtcReceiver::Bind(uint16_t port){\r\n    m_bindPort=port;\r\n    if (m_socket== NULL) {\r\n        m_socket = Socket::CreateSocket (GetNode (),UdpSocketFactory::GetTypeId ());\r\n        auto local = InetSocketAddress{Ipv4Address::GetAny (), port};\r\n        auto res = m_socket->Bind (local);\r\n        NS_ASSERT (res == 0);\r\n    }\r\n    m_socket->SetRecvCallback (MakeCallback(&WebrtcReceiver::RecvPacket,this));\r\n    m_context = GetNode()->GetId ();\r\n    NotifyRouteChange();    \r\n}\r\nbool WebrtcReceiver::SendRtp(const uint8_t* packet,\r\n               size_t length,\r\n               const webrtc::PacketOptions& options){\r\n    NS_ASSERT(length<1500&&length>0);\r\n    int64_t send_time_ms = m_clock->TimeInMilliseconds();\r\n    rtc::SentPacket sent_packet;\r\n    sent_packet.packet_id = options.packet_id;\r\n    sent_packet.info.included_in_feedback = options.included_in_feedback;\r\n    sent_packet.info.included_in_allocation = options.included_in_allocation;\r\n    sent_packet.send_time_ms = send_time_ms;\r\n    sent_packet.info.packet_size_bytes = length;\r\n    sent_packet.info.packet_type = rtc::PacketType::kData;\r\n    m_call->OnSentPacket(sent_packet);\r\n    {\r\n        rtc::CopyOnWriteBuffer buffer(packet,length);\r\n        LockScope ls(&m_rtpLock);\r\n        m_rtpQ.push_back(buffer);\r\n    }\r\n    if(m_running)\r\n    Simulator::ScheduleWithContext(m_context, Time (0),MakeEvent(&WebrtcReceiver::DeliveryPacket, this));         \r\n    return true;               \r\n}\r\nbool WebrtcReceiver::SendRtcp(const uint8_t* packet, size_t length){\r\n    {\r\n        NS_ASSERT(length<1500&&length>0);\r\n        rtc::CopyOnWriteBuffer buffer(packet,length);\r\n        LockScope ls(&m_rtcpLock);\r\n        m_rtcpQ.push_back(buffer);        \r\n    }\r\n    if(m_running)\r\n    Simulator::ScheduleWithContext(m_context, Time (0),MakeEvent(&WebrtcReceiver::DeliveryPacket, this)); \r\n    return true;\r\n}\r\nvoid WebrtcReceiver::StartApplication(){\r\n    m_running=true;\r\n}\r\nvoid WebrtcReceiver::StopApplication(){\r\n    m_running=false;\r\n}\r\nvoid WebrtcReceiver::NotifyRouteChange(){\r\n  rtc::NetworkRoute route;\r\n  route.connected = true;\r\n  // We assume that the address will be unique in the lower bytes.\r\n  route.local = rtc::RouteEndpoint::CreateWithNetworkId(static_cast<uint16_t>(1234));\r\n  route.remote = rtc::RouteEndpoint::CreateWithNetworkId(static_cast<uint16_t>(4321));\r\n  m_packetOverhead=webrtc::test::PacketOverhead::kDefault +\r\n                           kIpv4HeaderSize+cricket::kUdpHeaderSize;\r\n  route.packet_overhead =m_packetOverhead;                         \r\n  m_call->GetTransportControllerSend()->OnNetworkRouteChanged(\r\n      kDummyTransportName, route);     \r\n}\r\nvoid WebrtcReceiver::DeliveryPacket(){\r\n    std::deque<Ptr<Packet>> sendQ;\r\n    {\r\n        LockScope ls(&m_rtpLock);\r\n        while(!m_rtpQ.empty()){\r\n            rtc::CopyOnWriteBuffer buffer=m_rtpQ.front();\r\n            Ptr<Packet> packet=Create<Packet>(buffer.data(),buffer.size());\r\n            sendQ.push_back(packet);\r\n            m_rtpQ.pop_front();\r\n        }\r\n    }\r\n    {\r\n        LockScope ls(&m_rtcpLock);\r\n        while(!m_rtcpQ.empty()){\r\n            rtc::CopyOnWriteBuffer buffer=m_rtcpQ.front();\r\n            Ptr<Packet> packet=Create<Packet>(buffer.data(),buffer.size());\r\n            sendQ.push_back(packet);\r\n            m_rtcpQ.pop_front();\r\n\t    \r\n        }        \r\n    }\r\n    while(!sendQ.empty()){\r\n        Ptr<Packet> packet=sendQ.front();\r\n        sendQ.pop_front();\r\n        SendToNetwork(packet);\r\n    }\r\n}\r\nvoid WebrtcReceiver::SendToNetwork(Ptr<Packet> p){\r\n    NS_ASSERT(p->GetSize()>0);\r\n    m_socket->SendTo(p,0,InetSocketAddress{m_peerIp,m_peerPort});\r\n}\r\nvoid WebrtcReceiver::RecvPacket(Ptr<Socket> socket){\r\n    Address remoteAddr;\r\n    auto packet = socket->RecvFrom (remoteAddr);\r\n    uint32_t recv=packet->GetSize();\r\n    uint32_t now=Simulator::Now().GetMilliSeconds();\r\n    WebrtcTag tag;\r\n    packet->RemovePacketTag (tag);\r\n    uint32_t sequence=tag.GetSequence();\r\n    uint32_t owd=now-tag.GetTime();\r\n    if (!m_traceReceiptPkt.IsNull()) {\r\n        m_traceReceiptPkt(now,sequence,owd);\r\n    }\r\n    if(!m_knowPeer){\r\n        m_peerIp= InetSocketAddress::ConvertFrom (remoteAddr).GetIpv4 ();\r\n        uint16_t port=m_peerPort;\r\n        m_peerPort= InetSocketAddress::ConvertFrom (remoteAddr).GetPort ();\r\n        m_knowPeer=true;\r\n        NS_ASSERT(port==m_peerPort);\r\n    }\r\n    if (!m_running) {return;}\r\n    UtilCalculator::Instance()->OnPacketInfo(now,recv);\r\n    NS_ASSERT(recv<=1500);\r\n    uint8_t buf[1500]={'\\0'};\r\n    packet->CopyData(buf,recv);\r\n  if (!webrtc::RtpHeaderParser::IsRtcp(buf, recv)) {\r\n    auto ssrc = webrtc::RtpHeaderParser::GetSsrc(buf, recv);\r\n    //RTC_CHECK(ssrc.has_value());\r\n    if(!ssrc.has_value()){\r\n        return;\r\n    }\r\n  }    \r\n    rtc::CopyOnWriteBuffer packet_data(buf,recv);\r\n    webrtc::EmulatedIpPacket emu_packet(rtc::SocketAddress(), rtc::SocketAddress(), std::move(packet_data),\r\n                          m_clock->CurrentTime(), m_packetOverhead);\r\n    m_client->OnPacketReceived(std::move(emu_packet));     \r\n}\r\n}\r\n"
    },
    {
      "file_path": "ex-webrtc/model/webrtc-sender.cc",
      "code": "#include \"webrtc-sender.h\"\r\n#include \"ns3/log.h\"\r\n#include \"rtc_base/net_helper.h\"\r\n#include \"rtc_base/network/sent_packet.h\"\r\n#include \"api/test/network_emulation/network_emulation_interfaces.h\"\r\n#include \"webrtc-tag.h\"\r\nnamespace ns3{\r\nNS_LOG_COMPONENT_DEFINE(\"WebrtcSender\");\r\nnamespace{\r\n    const uint32_t kIpv4HeaderSize=20;\r\n    const int32_t kTraceInterval=25;\r\n    constexpr char kDummyTransportName[] = \"dummy\";\r\n}\r\nWebrtcSender::WebrtcSender(WebrtcSessionManager *manager){\r\n    m_manager=manager;\r\n    m_clock=manager->time_controller_->GetClock();\r\n    m_manager->RegisterSenderTransport(this,false);\r\n    m_client=m_manager->sender_client_;\r\n    m_call=m_client->GetCall();\r\n    m_initial_time=Simulator::Now().GetMilliSeconds();\r\n}\r\nWebrtcSender::~WebrtcSender(){}\r\nInetSocketAddress WebrtcSender::GetLocalAddress(){\r\n    Ptr<Node> node=GetNode();\r\n    Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();\r\n    Ipv4Address local_ip = ipv4->GetAddress (1, 0).GetLocal ();\r\n    return InetSocketAddress{local_ip,m_bindPort};     \r\n}\r\nvoid WebrtcSender::Bind(uint16_t port){\r\n    m_bindPort=port;\r\n    if (m_socket== NULL) {\r\n        m_socket = Socket::CreateSocket (GetNode (),UdpSocketFactory::GetTypeId ());\r\n        auto local = InetSocketAddress{Ipv4Address::GetAny (), port};\r\n        auto res = m_socket->Bind (local);\r\n        NS_ASSERT (res == 0);\r\n    }\r\n    m_socket->SetRecvCallback (MakeCallback(&WebrtcSender::RecvPacket,this));    \r\n    m_context = GetNode()->GetId ();\r\n    NotifyRouteChange();    \r\n}\r\nvoid WebrtcSender::ConfigurePeer(Ipv4Address addr,uint16_t port){\r\n    m_peerIp=addr;\r\n    m_peerPort=port;\r\n}\r\nvoid WebrtcSender::SetBwTraceFuc(TraceBandwidth cb){\r\n    m_traceBw=cb;\r\n}\r\nbool WebrtcSender::SendRtp(const uint8_t* packet,\r\n               size_t length,\r\n               const webrtc::PacketOptions& options){\r\n    //NS_LOG_INFO(\"send rtp packet\");\r\n    if(length==0){\r\n      NS_LOG_INFO(\"0 packet\");\r\n\t  return true;\r\n    }\r\n    NS_ASSERT(length<1500&&length>0);\r\n    int64_t send_time_ms = m_clock->TimeInMilliseconds();\r\n    rtc::SentPacket sent_packet;\r\n    sent_packet.packet_id = options.packet_id;\r\n    sent_packet.info.included_in_feedback = options.included_in_feedback;\r\n    sent_packet.info.included_in_allocation = options.included_in_allocation;\r\n    sent_packet.send_time_ms = send_time_ms;\r\n    sent_packet.info.packet_size_bytes = length;\r\n    sent_packet.info.packet_type = rtc::PacketType::kData;\r\n    m_call->OnSentPacket(sent_packet);\r\n    {\r\n        rtc::CopyOnWriteBuffer buffer(packet,length);\r\n        LockScope ls(&m_rtpLock);\r\n        m_rtpQ.push_back(buffer);\r\n\t    //auto ssrc = webrtc::RtpHeaderParser::GetSsrc(packet, length);\r\n    }\r\n    bool output=false;\r\n    uint32_t now=Simulator::Now().GetMilliSeconds();\r\n    if(m_lastTraceTime==0){\r\n        m_lastTraceTime=now;\r\n        output=true;\r\n    }\r\n    if(now>=m_lastTraceTime+kTraceInterval){\r\n        m_lastTraceTime=now;\r\n        output=true;\r\n    }\r\n    if(output&&!m_traceBw.IsNull()){\r\n        uint32_t bw=m_call->last_bandwidth_bps();\r\n        m_traceBw(now,bw);\r\n    }\r\n    if(m_running)\r\n    Simulator::ScheduleWithContext(m_context, Time (0),MakeEvent(&WebrtcSender::DeliveryPacket, this));     \r\n    return true;               \r\n}\r\nbool WebrtcSender::SendRtcp(const uint8_t* packet, size_t length){\r\n    {\r\n        NS_ASSERT(length<1500&&length>0);\r\n        rtc::CopyOnWriteBuffer buffer(packet,length);\r\n        LockScope ls(&m_rtcpLock);\r\n        m_rtcpQ.push_back(buffer);        \r\n    }\r\n    if(m_running)\r\n    Simulator::ScheduleWithContext(m_context, Time (0),MakeEvent(&WebrtcSender::DeliveryPacket, this)); \r\n    return true;\r\n}\r\nvoid WebrtcSender::StartApplication(){\r\n    m_running=true;\r\n    m_manager->CreateStreamPair();\r\n    m_manager->Start();\r\n}\r\nvoid WebrtcSender::StopApplication(){\r\n    m_running=false;\r\n    m_manager->Stop();\r\n}\r\nvoid WebrtcSender::NotifyRouteChange(){\r\n  rtc::NetworkRoute route;\r\n  route.connected = true;\r\n  // We assume that the address will be unique in the lower bytes.\r\n  route.local = rtc::RouteEndpoint::CreateWithNetworkId(static_cast<uint16_t>(1234));\r\n  route.remote = rtc::RouteEndpoint::CreateWithNetworkId(static_cast<uint16_t>(4321));\r\n  m_packetOverhead=webrtc::test::PacketOverhead::kDefault +\r\n                           kIpv4HeaderSize+cricket::kUdpHeaderSize;\r\n  route.packet_overhead =m_packetOverhead;                        \r\n  m_call->GetTransportControllerSend()->OnNetworkRouteChanged(\r\n      kDummyTransportName, route);                         \r\n                            \r\n}\r\nvoid WebrtcSender::DeliveryPacket(){\r\n    std::deque<Ptr<Packet>> sendQ;\r\n    {\r\n        LockScope ls(&m_rtpLock);\r\n        while(!m_rtpQ.empty()){\r\n            rtc::CopyOnWriteBuffer buffer=m_rtpQ.front();\r\n            Ptr<Packet> packet=Create<Packet>(buffer.data(),buffer.size());\r\n            sendQ.push_back(packet);\r\n            m_rtpQ.pop_front();\r\n        }\r\n    }\r\n    {\r\n        LockScope ls(&m_rtcpLock);\r\n        while(!m_rtcpQ.empty()){\r\n            rtc::CopyOnWriteBuffer buffer=m_rtcpQ.front();\r\n            Ptr<Packet> packet=Create<Packet>(buffer.data(),buffer.size());\r\n            sendQ.push_back(packet);\r\n            m_rtcpQ.pop_front();\r\n\t    \r\n        }        \r\n    }\r\n    while(!sendQ.empty()){\r\n        Ptr<Packet> packet=sendQ.front();\r\n        sendQ.pop_front();\r\n        SendToNetwork(packet);\r\n    }\r\n}\r\nvoid WebrtcSender::SendToNetwork(Ptr<Packet> p){\r\n    NS_ASSERT(p->GetSize()>0);\r\n    uint64_t send_time=Simulator::Now().GetMilliSeconds();\r\n    WebrtcTag tag(m_seq,send_time);\r\n    m_seq++;\r\n    p->AddPacketTag(tag); \r\n    m_socket->SendTo(p,0,InetSocketAddress{m_peerIp,m_peerPort});\r\n}\r\nvoid WebrtcSender::RecvPacket(Ptr<Socket> socket){\r\n    if(!m_running){return;}\r\n    Address remoteAddr;\r\n    auto packet = socket->RecvFrom (remoteAddr);\r\n    uint32_t recv=packet->GetSize ();\r\n    NS_ASSERT(recv<=1500);\r\n    uint8_t buf[1500]={'\\0'};\r\n    packet->CopyData(buf,recv);\r\n    rtc::CopyOnWriteBuffer packet_data(buf,recv);\r\n  if (!webrtc::RtpHeaderParser::IsRtcp(buf, recv)) {\r\n    auto ssrc = webrtc::RtpHeaderParser::GetSsrc(buf, recv);\r\n    if(!ssrc.has_value()){\r\n\tNS_LOG_INFO(\"sender no ssrc\");\r\n\treturn;\r\n    }\r\n  } \r\n    webrtc::EmulatedIpPacket emu_packet(rtc::SocketAddress(), rtc::SocketAddress(), std::move(packet_data),\r\n                          m_clock->CurrentTime(), m_packetOverhead);\r\n    m_client->OnPacketReceived(std::move(emu_packet));                      \r\n} \r\n}\r\n"
    },
    {
      "file_path": "ex-webrtc/model/webrtc-tag.cc",
      "code": "#include <iostream>\r\n#include \"ns3/webrtc-tag.h\"\r\n#include \"ns3/log.h\"\r\n#include \"ns3/core-module.h\"\r\nnamespace ns3{\r\nsize_t varint_length(uint64_t number){\r\n    int64_t next=number;\r\n    size_t key=0;\r\n    if(next){\r\n        do{\r\n            next=next/128;\r\n            key++;\r\n        }while(next>0);\r\n    }\r\n    return key;\r\n}\r\nTypeId WebrtcTag::GetTypeId (void){\r\n   static TypeId tid = TypeId (\"ns3::WebrtcTag\")\r\n     .SetParent<Tag> ()\r\n     .AddConstructor<WebrtcTag> ()\r\n     .AddAttribute (\"Time\",\r\n                    \"time stamp\",\r\n                    EmptyAttributeValue (),\r\n                    MakeUintegerAccessor (&WebrtcTag::GetTime),\r\n                    MakeUintegerChecker<uint64_t> ())\r\n     .AddAttribute (\"Number\",\r\n                    \"sequence number\",\r\n                    EmptyAttributeValue (),\r\n                    MakeUintegerAccessor (&WebrtcTag::GetSequence),\r\n                    MakeUintegerChecker<uint64_t> ())                    \r\n   ;\r\n   return tid;    \r\n}\r\nTypeId WebrtcTag::GetInstanceTypeId (void) const{\r\n    return GetTypeId ();\r\n} \r\nuint32_t WebrtcTag::GetSerializedSize (void) const {\r\n    return varint_length(seq_)+varint_length(time_);\r\n}\r\nvoid WebrtcTag::Serialize (TagBuffer i) const{\r\n    VarintEncode(i,seq_);\r\n    VarintEncode(i,time_);\r\n}\r\nvoid WebrtcTag::Deserialize (TagBuffer i){\r\n    VarientDecode(i,&seq_);\r\n    VarientDecode(i,&time_);\r\n}\r\nvoid WebrtcTag::VarintEncode(TagBuffer &i,uint64_t value) const{\r\n    char first=0;\r\n    uint64_t next=value;\r\n    if(next){\r\n        do{\r\n            uint8_t byte=0;\r\n            first=next%128;\r\n            next=next/128;\r\n            byte=first;\r\n            if(next>0){\r\n                byte|=128;\r\n            }\r\n            i.WriteU8(byte);\r\n        }while(next>0);\r\n    }    \r\n}\r\nvoid WebrtcTag::VarientDecode(TagBuffer &i,uint64_t *value){\r\n    uint64_t remain=0;\r\n    uint64_t remain_multi=1;\r\n    uint8_t byte=0;\r\n    do{\r\n        byte=i.ReadU8();\r\n        remain+=(byte&127)*remain_multi;\r\n        remain_multi*=128;\r\n    }while(byte&128);\r\n    *value=remain;\r\n}\r\n}\r\n"
    },
    {
      "file_path": "scratch/webrtc-static.cc",
      "code": "#include <iostream>\r\n#include <string>\r\n#include <unistd.h>\r\n#include <vector>\r\n#include <utility>\r\n#include <algorithm>\r\n#include \"ns3/webrtc-defines.h\"\r\n#include \"ns3/core-module.h\"\r\n#include \"ns3/applications-module.h\"\r\n#include \"ns3/internet-module.h\"\r\n#include \"ns3/network-module.h\"\r\n#include \"ns3/point-to-point-module.h\"\r\n#include \"ns3/ipv4-global-routing-helper.h\"\r\n#include \"ns3/traffic-control-module.h\"\r\n#include \"ns3/log.h\"\r\n#include \"ns3/ex-webrtc-module.h\"\r\n\r\n\r\n#include <time.h>\r\n#include <sys/time.h>\r\n\r\nusing namespace ns3;\r\nusing namespace std;\r\nNS_LOG_COMPONENT_DEFINE (\"webrtc-static\");\r\n\r\nconst uint32_t DEFAULT_PACKET_SIZE = 1500;\r\nconst uint32_t kBwUnit=1000000;\r\n\r\nuint64_t get_os_millis()\r\n{\r\n    struct timeval tv;\r\n    gettimeofday(&tv, NULL);\r\n    return (uint64_t)(tv.tv_sec * 1000 + tv.tv_usec / 1000);\r\n}\r\n\r\nclass TriggerRandomLoss{\r\npublic:\r\n    TriggerRandomLoss(){}\r\n    ~TriggerRandomLoss(){\r\n        if(m_timer.IsRunning()){\r\n            m_timer.Cancel();\r\n        }\r\n    }\r\n    void RegisterDevice(Ptr<NetDevice> dev){\r\n        m_dev=dev;\r\n    }\r\n    void Start(){\r\n        Time next=Seconds(2);\r\n        m_timer=Simulator::Schedule(next,&TriggerRandomLoss::ConfigureRandomLoss,this);\r\n    }\r\n    void ConfigureRandomLoss(){\r\n        if(m_timer.IsExpired()){\r\n            std::string errorModelType = \"ns3::RateErrorModel\";\r\n            ObjectFactory factory;\r\n            factory.SetTypeId (errorModelType);\r\n            Ptr<ErrorModel> em = factory.Create<ErrorModel> ();\r\n            m_dev->SetAttribute (\"ReceiveErrorModel\", PointerValue (em));            \r\n            m_timer.Cancel();\r\n        }\r\n    }\r\nprivate:\r\n    Ptr<NetDevice> m_dev;\r\n    EventId m_timer;\r\n};\r\nstruct CompareV\r\n{\r\n    bool operator() (const std::pair<Time,int64_t> &a,const std::pair<Time,int64_t> &b)\r\n    {\r\n        return a.first<b.first;\r\n    }\r\n};\r\nclass BandwidthChanger\r\n{\r\npublic:\r\n    BandwidthChanger(){}\r\n    ~BandwidthChanger(){\r\n        if (m_timer.IsRunning()) {\r\n            m_timer.Cancel();\r\n        }\r\n    }\r\n    \r\n    void RegisterDevice(Ptr<NetDevice> dev) {\r\n        m_dev=dev;\r\n    }\r\n    \r\n    void Config(int64_t initial_bps,std::vector<std::pair<Time,int64_t> >& info) {\r\n        m_initialRate=initial_bps;\r\n        m_info.swap(info);\r\n    }\r\n    \r\n    void TotalThroughput(Time stop,int64_t &channel_bit){\r\n        int index=lower_bound_index(stop);\r\n        if (0 == index){\r\n            channel_bit=0;\r\n        }else{\r\n            int64_t bit=0;\r\n            for(int i=0;i<index;i++){\r\n                if(0 == i){\r\n                    bit+=m_initialRate*(m_info.at(i).first.GetMilliSeconds()/1000);\r\n                }else{\r\n                    bit+=m_info.at(i-1).second*((m_info.at(i).first-m_info.at(i-1).first).GetMilliSeconds()/1000);\r\n                }\r\n            }\r\n            if (stop > m_info.back().first) {\r\n                bit+=m_info.back().second*((stop-m_info.back().first).GetMilliSeconds()/1000);\r\n            }\r\n            channel_bit=bit;\r\n        }\r\n    }\r\n    void Start()\r\n    {\r\n        if (m_info.size()>0) {\r\n            Time next=m_info[m_index].first;\r\n            m_timer=Simulator::Schedule(next,&BandwidthChanger::ResetBandwidth,this);\r\n        }\r\n    }\r\n    void ResetBandwidth()\r\n    {\r\n        if (m_timer.IsExpired() && m_dev) {\r\n            PointToPointNetDevice *device=static_cast<PointToPointNetDevice*>(PeekPointer(m_dev));\r\n            device->SetDataRate(DataRate(m_info[m_index].second));\r\n            NS_LOG_INFO(Simulator::Now().GetSeconds()<<\" \"<<m_info[m_index].second);\r\n            m_index++;\r\n            if (m_index < m_info.size()){\r\n                NS_ASSERT(m_info[m_index].first>m_info[m_index-1].first);\r\n                Time next=m_info[m_index].first-m_info[m_index-1].first;\r\n                m_timer=Simulator::Schedule(next,&BandwidthChanger::ResetBandwidth,this);\r\n            }\r\n        }\r\n    }\r\n\r\n    int lower_bound_index(Time point){\r\n        auto ele=std::make_pair(point,0);\r\n        auto iter=std::lower_bound(m_info.begin(), m_info.end(),ele,CompareV());\r\n        return iter-m_info.begin();\r\n    }\r\nprivate:\r\n    int64_t m_initialRate=0;\r\n    std::vector<std::pair<Time,int64_t> > m_info;\r\n    uint32_t m_index{0};\r\n    Ptr<NetDevice> m_dev;\r\n    EventId m_timer;\r\n};\r\n\r\nstruct LinkProperty{\r\n    uint16_t nodes[2];\r\n    uint32_t bandwidth;\r\n    uint32_t propagation_ms;\r\n};\r\nuint32_t CalMaxRttInDumbbell(LinkProperty *topoinfo,int links){\r\n    uint32_t rtt1=2*(topoinfo[0].propagation_ms+topoinfo[1].propagation_ms+topoinfo[2].propagation_ms);\r\n    uint32_t rtt2=2*(topoinfo[1].propagation_ms+topoinfo[3].propagation_ms+topoinfo[4].propagation_ms);\r\n    return std::max<uint32_t>(rtt1,rtt2);\r\n}\r\n\r\n/** Network topology\r\n *       n0            n1\r\n *        |            | \r\n *        | l0         | l2\r\n *        |            | \r\n *        n2---l1------n3\r\n *        |            | \r\n *        |  l3        | l4\r\n *        |            | \r\n *        n4           n5\r\n */\r\n\r\nint ip=1;\r\nstatic NodeContainer BuildDumbbellTopo(LinkProperty *topoinfo,int links,int bottleneck_i,\r\n                                    uint32_t buffer_ms,TriggerRandomLoss *trigger=nullptr)\r\n{\r\n    int hosts=links+1;\r\n    NodeContainer topo;\r\n    topo.Create (hosts);\r\n    InternetStackHelper stack;\r\n    stack.Install (topo);\r\n    for (int i=0;i<links;i++){\r\n        uint16_t src=topoinfo[i].nodes[0];\r\n        uint16_t dst=topoinfo[i].nodes[1];\r\n        uint32_t bps=topoinfo[i].bandwidth;\r\n        uint32_t owd=topoinfo[i].propagation_ms;\r\n        NodeContainer nodes=NodeContainer (topo.Get (src), topo.Get (dst));\r\n        auto bufSize = std::max<uint32_t> (DEFAULT_PACKET_SIZE, bps * buffer_ms / 8000);\r\n        int packets=bufSize/DEFAULT_PACKET_SIZE;\r\n        std::cout<<bps<<std::endl;\r\n        PointToPointHelper pointToPoint;\r\n        pointToPoint.SetDeviceAttribute (\"DataRate\", DataRateValue  (DataRate (bps)));\r\n        pointToPoint.SetChannelAttribute (\"Delay\", TimeValue (MilliSeconds (owd)));\r\n        if(bottleneck_i==i){\r\n            pointToPoint.SetQueue (\"ns3::DropTailQueue\",\"MaxSize\", StringValue (std::to_string(20)+\"p\"));\r\n        }else{\r\n            pointToPoint.SetQueue (\"ns3::DropTailQueue\",\"MaxSize\", StringValue (std::to_string(packets)+\"p\"));   \r\n        }\r\n        NetDeviceContainer devices = pointToPoint.Install (nodes);\r\n        if(bottleneck_i==i){\r\n            TrafficControlHelper pfifoHelper;\r\n            uint16_t handle = pfifoHelper.SetRootQueueDisc (\"ns3::FifoQueueDisc\", \"MaxSize\", StringValue (std::to_string(packets)+\"p\"));\r\n            pfifoHelper.AddInternalQueues (handle, 1, \"ns3::DropTailQueue\", \"MaxSize\",StringValue (std::to_string(packets)+\"p\"));\r\n            pfifoHelper.Install(devices);  \r\n        }\r\n        Ipv4AddressHelper address;\r\n        std::string nodeip=\"10.1.\"+std::to_string(ip)+\".0\";\r\n        ip++;\r\n        address.SetBase (nodeip.c_str(), \"255.255.255.0\");\r\n        address.Assign (devices);\r\n        if(bottleneck_i==i&&trigger){\r\n            trigger->RegisterDevice(devices.Get(1));\r\n        }\r\n    }\r\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables ();\r\n    return topo;\r\n}\r\nstatic NodeContainer BuildP2PTopo(TriggerRandomLoss *trigger,\r\n                                  BandwidthChanger *changer,\r\n                                  uint64_t bps,\r\n                                  uint32_t msDelay,\r\n                                  uint32_t msQdelay)\r\n{\r\n    NodeContainer nodes;\r\n    nodes.Create (2);\r\n\r\n    PointToPointHelper pointToPoint;\r\n    pointToPoint.SetDeviceAttribute (\"DataRate\", DataRateValue  (DataRate (bps)));\r\n    pointToPoint.SetChannelAttribute (\"Delay\", TimeValue (MilliSeconds (msDelay)));\r\n    auto bufSize = std::max<uint32_t> (DEFAULT_PACKET_SIZE, bps * msQdelay / 8000);\r\n    \r\n    int packets=bufSize/DEFAULT_PACKET_SIZE;\r\n    pointToPoint.SetQueue (\"ns3::DropTailQueue\",\r\n                           \"MaxSize\", StringValue (std::to_string(5)+\"p\"));\r\n    NetDeviceContainer devices = pointToPoint.Install (nodes);\r\n\r\n    InternetStackHelper stack;\r\n    stack.Install (nodes);\r\n\r\n    TrafficControlHelper pfifoHelper;\r\n    uint16_t handle = pfifoHelper.SetRootQueueDisc (\"ns3::FifoQueueDisc\", \"MaxSize\", StringValue (std::to_string(packets)+\"p\"));\r\n    pfifoHelper.AddInternalQueues (handle, 1, \"ns3::DropTailQueue\", \"MaxSize\",StringValue (std::to_string(packets)+\"p\"));\r\n    pfifoHelper.Install(devices);\r\n\r\n\r\n    Ipv4AddressHelper address;\r\n    std::string nodeip=\"10.1.1.0\";\r\n    address.SetBase (nodeip.c_str(), \"255.255.255.0\");\r\n    address.Assign (devices);\r\n    if(trigger){\r\n        trigger->RegisterDevice(devices.Get(1));\r\n    }\r\n    if(changer){\r\n        changer->RegisterDevice(devices.Get(0));\r\n    }\r\n    return nodes;\r\n}\r\nstatic void InstallWebrtcApplication( Ptr<Node> sender,\r\n                        Ptr<Node> receiver,\r\n                        uint16_t send_port,\r\n                        uint16_t recv_port,\r\n                        Time start_app,\r\n                        Time stop_app,\r\n                        WebrtcSessionManager *manager,\r\n                        WebrtcTrace *trace=nullptr)\r\n{\r\n    Ptr<WebrtcSender> sendApp = CreateObject<WebrtcSender> (manager);\r\n    Ptr<WebrtcReceiver> recvApp = CreateObject<WebrtcReceiver>(manager);\r\n    sender->AddApplication (sendApp);\r\n    receiver->AddApplication (recvApp);\r\n    sendApp->Bind(send_port);\r\n    recvApp->Bind(recv_port);\r\n    Ptr<Ipv4> ipv4 = receiver->GetObject<Ipv4> ();\r\n    Ipv4Address addr = ipv4->GetAddress (1, 0).GetLocal ();\r\n    sendApp->ConfigurePeer(addr,recv_port);\r\n    ipv4=sender->GetObject<Ipv4> ();\r\n    addr=ipv4->GetAddress (1, 0).GetLocal ();\r\n    recvApp->ConfigurePeer(addr,send_port);\r\n    if(trace){\r\n        if (trace->LogFlag()&WebrtcTrace::E_WEBRTC_BW) {\r\n            sendApp->SetBwTraceFuc(MakeCallback(&WebrtcTrace::OnBW,trace));\r\n        }\r\n        if (trace->LogFlag()&WebrtcTrace::E_WEBRTC_OWD || trace->LogFlag()&WebrtcTrace::E_WEBRTC_LOSS) {\r\n            recvApp->SetTraceReceiptPktInfo(MakeCallback(&WebrtcTrace::OnReceiptPktInfo,trace));\r\n        }\r\n    }\r\n    sendApp->SetStartTime(start_app);\r\n    sendApp->SetStopTime(stop_app);\r\n    recvApp->SetStartTime(start_app);\r\n    recvApp->SetStopTime(stop_app+Seconds(1));\r\n}\r\nuint64_t kMillisPerSecond=1000;\r\nuint64_t kMicroPerMillis=1000;\r\nstd::unique_ptr<WebrtcSessionManager> CreateWebrtcSessionManager(webrtc::TimeController *controller,\r\nuint32_t max_rate=1000,uint32_t min_rate=300,uint32_t start_rate=500,uint32_t h=720,uint32_t w=1280){\r\n    std::unique_ptr<WebrtcSessionManager> webrtc_manager(new WebrtcSessionManager(controller,min_rate,start_rate,max_rate,h,w));\r\n    webrtc_manager->CreateClients();\r\n    return webrtc_manager;\r\n}\r\ntypedef struct {\r\n    float start;\r\n    float stop;\r\n}client_config_t;\r\nvoid test_app_on_p2p(std::string &instance,TimeConollerType controller_type,\r\n                    float app_start,float app_stop,\r\n                    client_config_t *config,int num,\r\n                    TriggerRandomLoss *trigger_loss,BandwidthChanger *changer){\r\n    uint64_t bps=6*kBwUnit;\r\n    uint32_t link_delay=30;//milliseconds;\r\n    uint32_t buffer_delay=30;//ms\r\n    if (0 == instance.compare(\"2\")) {\r\n        link_delay=30;\r\n        buffer_delay=60;\r\n    }else if (0 == instance.compare(\"3\")) {\r\n        link_delay=30;\r\n        buffer_delay=90;\r\n    }else if (0 == instance.compare(\"4\")) {\r\n        link_delay=50;\r\n        buffer_delay=50;\r\n    }else if (0 == instance.compare(\"5\")) {\r\n        link_delay=50;\r\n        buffer_delay=100;\r\n    }else if (0 == instance.compare(\"6\")) {\r\n        link_delay=50;\r\n        buffer_delay=150;\r\n    }else if (0 == instance.compare(\"7\")) {\r\n        bps=10*kBwUnit;\r\n        link_delay=50;\r\n        buffer_delay=50;\r\n    }else if (0 == instance.compare(\"8\")) {\r\n        bps=10*kBwUnit;\r\n        link_delay=50;\r\n        buffer_delay=100;\r\n    }else if (0 == instance.compare(\"9\")) {\r\n        bps=10*kBwUnit;\r\n        link_delay=50;\r\n        buffer_delay=150;\r\n    }else if (0 == instance.compare(\"10\")) {\r\n        bps=10*kBwUnit;\r\n        link_delay=50;\r\n        buffer_delay=100;\r\n        for(int i=0;i<num;i++){\r\n            config[i].start=app_start;\r\n        }\r\n    }else if (0 == instance.compare(\"11\")){\r\n        bps=5*kBwUnit;\r\n        link_delay=50;\r\n        buffer_delay=100;\r\n        if(changer){\r\n            std::vector<std::pair<Time,int64_t> > bw_info;\r\n            bw_info.push_back(std::make_pair(Seconds(20),4*kBwUnit));\r\n            bw_info.push_back(std::make_pair(Seconds(40),3*kBwUnit));\r\n            bw_info.push_back(std::make_pair(Seconds(60),2*kBwUnit));\r\n            bw_info.push_back(std::make_pair(Seconds(80),1*kBwUnit));\r\n            bw_info.push_back(std::make_pair(Seconds(100),2*kBwUnit));\r\n            bw_info.push_back(std::make_pair(Seconds(120),3*kBwUnit));\r\n            bw_info.push_back(std::make_pair(Seconds(140),4*kBwUnit));\r\n            bw_info.push_back(std::make_pair(Seconds(180),5*kBwUnit));\r\n            changer->Config(bps,bw_info);\r\n            changer->Start();\r\n        }\r\n    }\r\n\r\n    NodeContainer nodes = BuildP2PTopo(trigger_loss,changer,bps,link_delay,buffer_delay);\r\n    std::string webrtc_log_com(\"_gcc_\");\r\n    int64_t webrtc_start_us=1;\r\n    int64_t webrtc_stop_us=app_stop*kMillisPerSecond*kMicroPerMillis;\r\n    webrtc::TimeController* time_controller=CreateTimeController(controller_type,webrtc_start_us,webrtc_stop_us);\r\n    uint32_t max_rate=bps/1000;\r\n    \r\n    std::vector<std::unique_ptr<WebrtcSessionManager>> sesssion_manager;\r\n    for (int i=0;i<num;i++) {\r\n        std::unique_ptr<WebrtcSessionManager> m(CreateWebrtcSessionManager(time_controller,max_rate));\r\n        sesssion_manager.push_back(std::move(m)); \r\n    }\r\n    UtilCalculator *calculator=UtilCalculator::Instance();\r\n    calculator->Enable();\r\n    \r\n    uint16_t sendPort=5432;\r\n    uint16_t recvPort=5000;\r\n    \r\n    std::string prefix=instance+webrtc_log_com;\r\n    std::vector<WebrtcTrace*> trace_vec;\r\n    for (int i=0;i<num;i++) {\r\n        \r\n        std::string log=prefix+std::to_string(i+1);\r\n        WebrtcTrace *trace=new WebrtcTrace();\r\n        trace_vec.push_back(trace);\r\n        trace->Log(log,WebrtcTrace::E_WEBRTC_ALL);\r\n        InstallWebrtcApplication(nodes.Get(0),nodes.Get(1),sendPort,recvPort,\r\n                                Seconds(config[i].start),Seconds(config[i].stop),\r\n                               sesssion_manager.at(i).get(),trace);\r\n        sendPort++;\r\n        recvPort++;\r\n    }\r\n\r\n\r\n    Simulator::Stop (Seconds(app_stop+10));\r\n    uint64_t last=get_os_millis();\r\n    Simulator::Run ();\r\n    Simulator::Destroy();\r\n    if(time_controller){\r\n        delete time_controller;\r\n    }\r\n    {\r\n        int64_t last_stamp=calculator->GetLastReceiptMillis();\r\n        int64_t channnel_bit=0;\r\n        if (changer){\r\n            changer->TotalThroughput(MilliSeconds(last_stamp),channnel_bit);\r\n        }else{\r\n            if(last_stamp>app_start*1000){\r\n                int64_t duration=last_stamp-app_start*1000;\r\n                channnel_bit=bps*(duration/1000);\r\n            }\r\n        }\r\n        NS_LOG_INFO(\"channel byte \"<<(uint32_t)channnel_bit/8);\r\n        calculator->CalculateUtil(prefix,channnel_bit);\r\n    }\r\n    for(auto it=trace_vec.begin();it!=trace_vec.end();it++){\r\n        WebrtcTrace *trace=(*it);\r\n        delete trace;\r\n    }\r\n    trace_vec.clear();\r\n    uint32_t elapse=(get_os_millis()-last);\r\n    std::cout<<\"run time millis: \"<<elapse<<std::endl;\r\n    exit(0);\r\n    return ;\r\n}\r\n\r\nstatic const float startTime=0.001;\r\nstatic const float simDuration=200.0;\r\n\r\n/*\r\n ./waf --run \"scratch/webrtc-static --m=simu --it=1\"\r\n ./waf --run \"scratch/webrtc-static --m=simu --topo=change --it=11 --folder=change\"\r\n ./waf --run \"scratch/webrtc-static --m=simu --topo=random --it=1  --folder=losszero\"\r\n ./waf --run \"scratch/webrtc-static --m=simu --topo=random --it=1 --lo=50 --folder=loss5\"\r\n*/\r\nint main(int argc, char *argv[]){\r\n    LogComponentEnable(\"webrtc-static\",LOG_LEVEL_ALL);\r\n    LogComponentEnable(\"WebrtcSender\",LOG_LEVEL_ALL);\r\n    LogComponentEnable(\"WebrtcReceiver\",LOG_LEVEL_ALL);\r\n    std::string mode(\"simu\");\r\n    std::string topo(\"p2p\");\r\n    std::string instance=std::string(\"1\");\r\n    std::string loss_str(\"0\");\r\n    std::string data_folder(\"no-one\");\r\n    CommandLine cmd;\r\n    cmd.AddValue(\"m\",\"mode\",mode);\r\n    cmd.AddValue (\"topo\", \"topology\", topo);\r\n    cmd.AddValue (\"it\", \"instacne\", instance);\r\n    cmd.AddValue (\"lo\", \"loss\",loss_str);\r\n    cmd.AddValue (\"folder\", \"folder name to collect data\", data_folder);\r\n    cmd.Parse (argc, argv);\r\n    TimeConollerType controller_type=TimeConollerType::SIMU_CONTROLLER;\r\n    if (0==mode.compare(\"simu\")){\r\n        webrtc_register_clock();\r\n    }else if(0==mode.compare(\"emu\")){\r\n        controller_type=TimeConollerType::EMU_CONTROLLER;\r\n        GlobalValue::Bind (\"SimulatorImplementationType\", StringValue (\"ns3::RealtimeSimulatorImpl\")); \r\n    }else{\r\n        return -1;\r\n    }\r\n    {\r\n        char buffer[128] = {0};\r\n        if (getcwd(buffer,sizeof(buffer)) != buffer) {\r\n            NS_LOG_ERROR(\"path error\");\r\n            return -1;\r\n        }\r\n        std::string ns3_path(buffer,::strlen(buffer));\r\n        if ('/'!=ns3_path.back()){\r\n            ns3_path.push_back('/');\r\n        }\r\n        std::string pathname=ns3_path+\"traces/\"+data_folder;\r\n        set_webrtc_trace_folder(pathname);\r\n    }\r\n    int loss_integer=std::stoi(loss_str);\r\n    std::unique_ptr<TriggerRandomLoss> triggerloss=nullptr;\r\n    std::unique_ptr<BandwidthChanger> changer=nullptr; \r\n    if (loss_integer>0) {\r\n        double random_loss=loss_integer*1.0/1000;\r\n        Config::SetDefault (\"ns3::RateErrorModel::ErrorRate\", DoubleValue (random_loss));\r\n        Config::SetDefault (\"ns3::RateErrorModel::ErrorUnit\", StringValue (\"ERROR_UNIT_PACKET\"));\r\n        Config::SetDefault (\"ns3::BurstErrorModel::ErrorRate\", DoubleValue (random_loss));\r\n        Config::SetDefault (\"ns3::BurstErrorModel::BurstSize\", StringValue (\"ns3::UniformRandomVariable[Min=1|Max=3]\"));\r\n        triggerloss.reset(new TriggerRandomLoss());\r\n        triggerloss->Start();\r\n    }\r\n    if (0 == topo.compare(\"dumbbell\")) {\r\n        \r\n    }else if (0 == topo.compare(\"change\")) {\r\n        client_config_t config[1]={\r\n            [0]={.start=startTime,.stop=simDuration},\r\n        };\r\n        changer.reset(new BandwidthChanger());\r\n        test_app_on_p2p(instance,controller_type,startTime,simDuration,config,1,\r\n                        triggerloss.get(),changer.get());\r\n    }else if (0 == topo.compare(\"random\")) {\r\n        client_config_t config[3]={\r\n            [0]={.start=startTime,.stop=simDuration},\r\n            [1]={.start=startTime,.stop=simDuration},\r\n            [2]={.start=startTime,.stop=simDuration},\r\n        };\r\n        test_app_on_p2p(instance,controller_type,startTime,simDuration,config,3,\r\n                        triggerloss.get(),changer.get());\r\n    }else {\r\n        client_config_t config[3]={\r\n            [0]={.start=startTime,.stop=simDuration},\r\n            [1]={.start=startTime+35,.stop=simDuration},\r\n            [2]={.start=startTime+80,.stop=simDuration},\r\n        };\r\n        test_app_on_p2p(instance,controller_type,startTime,simDuration,config,3,\r\n                        triggerloss.get(),changer.get());\r\n    }\r\n    return 0;\r\n}\r\n"
    }
  ]
}