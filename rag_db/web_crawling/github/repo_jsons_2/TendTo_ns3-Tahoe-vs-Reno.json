{
  "repo_name": "TendTo/ns3-Tahoe-vs-Reno",
  "github_url": "https://github.com/TendTo/ns3-Tahoe-vs-Reno",
  "readme": "# TCP comparison\n\nThis is a comparison between two old TCP variants: TCP Tahoe and TCP Reno, using the ns-3 simulator.\n\n## TCP variants\n\nOver the years, many TCP variants have been developed, each trying to improve the performance of the predecessor, given the right conditions.\nMost of them have become highly sophisticated.\nStill, it can be interesting to look at two of the first TCP variants: TCP Tahoe and TCP Reno and see the basic components of any TCP variant.\n\n### TCP Tahoe\n\nTCP Tahoe is the first TCP variant to consider the issue of congestion.\nIt's mechanism is very simple and can be easily understood.\nThis makes it a good starting point to understand how TCP works.\nIt uses\n\n- **slow start**: it doubles the congestion window every RTT.\n- **congestion avoidance**: it increases the congestion window by 1 every RTT.\n- **fast retransmit**: it detects packet loss by checking if the next packet is received.\n\n### TCP Reno\n\nTCP Reno is the first TCP variant to be standardized. It is a newer TCP variant than TCP Tahoe and uses a more complex mechanism to handle congestion.\nApart from the slow start and congestion avoidance mechanisms, it uses:\n\n- **fast recovery**: it recovers from packet loss by halving the congestion window instead of going straight in the slow start phase.\n\n## Installation\n\n### Requirements\n\n- [ns-3 simulator v3.37](https://www.nsnam.org/).\n- [c++ compiler](https://gcc.gnu.org/).\n- [cmake](https://cmake.org/).\n- [python3](https://www.python.org/).\n\nThe simulation uses the [ns-3 simulator](https://www.nsnam.org/), and has been developed and tested with the version 3.37.\n\n### Build\n\nFirst, make sure you have already completed all the step required for the installation of the simulator shown [here](https://www.nsnam.org/docs/release/3.37/tutorial/html/index.html).  \nThe directory structure should look something like this:\n\n```bash\n.\n\u2514\u2500\u2500 ns-allinone-3.37/\n    \u2514\u2500\u2500 ns-3.37/\n        \u251c\u2500\u2500 ns3\n        \u251c\u2500\u2500 examples/\n        \u251c\u2500\u2500 src/\n        \u251c\u2500\u2500 scratch/\n        \u2514\u2500\u2500 ...\n```\n\nMove to the `scratch` folder and clone the repository:\n\n```bash\ncd ns-allinone-3.37/ns-3.37/scratch\ngit clone git@github.com:TendTo/ns3-Tahoe-vs-Reno.git\n```\n\nLastly, move back to the `ns-3.37` folder and build the simulation:\n\n```bash\ncd ..\n./ns3 run \"p2p-project --PrintHelp\"\n```\n\n## Usage\n\nThe simulation is highly configurable. The following options are available:\n\n```bash\nUsage: ./ns3 run \"p2p-project [options]\"\n\nProgram Options:\n    --n_tcp_tahoe:         Number of Tcp Tahoe nodes [1]\n    --n_tcp_reno:          Number of Tcp Reno nodes [1]\n    --s_buf_size:          Sender buffer size (bytes) [131072]\n    --r_buf_size:          Receiver buffer size (bytes) [131072]\n    --cwnd:                Initial congestion window (segments) [1]\n    --ssthresh:            Initial slow start threshold (segments) [65535]\n    --mtu:                 Size of IP packets to send (bytes) [1500]\n    --sack:                Enable SACK [true]\n    --nagle:               Enable Nagle algorithm [false]\n    --error_p:             Packet error rate [0]\n    --s_bandwidth:         Sender link bandwidth [10Mbps]\n    --s_delay:             Sender link delay [40ms]\n    --r_bandwidth:         Receiver link bandwidth [10Mbps]\n    --r_delay:             Receiver link delay [40ms]\n    --tcp_queue_size:      TCP queue size (packets) [25]\n    --run:                 Run id [0]\n    --duration:            Duration of the simulation (s) [3]\n    --max_mbytes_to_send:  Maximum number of megabytes to send (MB) [0]\n    --prefix_file_name:    Prefix file name [P2P-project]\n    --graph_output:        The type of image to output: png, svg [png]\n    --ascii_tracing:       Enable ASCII tracing [false]\n    --pcap_tracing:        Enable Pcap tracing [false]\n\nGeneral Arguments:\n    --PrintGlobals:              Print the list of globals.\n    --PrintGroups:               Print the list of groups.\n    --PrintGroup=[group]:        Print all TypeIds of group.\n    --PrintTypeIds:              Print all TypeIds.\n    --PrintAttributes=[typeid]:  Print all attributes of typeid.\n    --PrintVersion:              Print the ns-3 version.\n    --PrintHelp:                 Print this help message.\n```\n\n## Example usages\n\nThe following are some example usages of the simulation with the output graphs.\n\n### Scenario 1\n\n```bash\n./ns3 run \"p2p-project --n_tcp_tahoe=1 --n_tcp_reno=0 --error_p=0.001 --run=0 --duration=10\"\n```\n\n```mermaid\nflowchart LR\nr{{router}}\nn0[Node 0\\nTCP Tahoe]\ni((Receiver))\n\n    r <--Random loss--> i\n    n0 <----> r\n```\n\n![Graph 1](./docs/img/graph-1.png)\n\n### Scenario 2\n\n```bash\n./ns3 run \"p2p-project --n_tcp_tahoe=0 --n_tcp_reno=1 --error_p=0.001 --run=0 --duration=10\"\n```\n\n```mermaid\nflowchart LR\nr{{router}}\nn0[Node 0\\nTCP Reno]\ni((Receiver))\n\n    r <--Random loss--> i\n    n0 <----> r\n```\n\n![Graph 2](./docs/img/graph-2.png)\n\n### Scenario 3\n\n```bash\n./ns3 run \"p2p-project --n_tcp_tahoe=1 --n_tcp_reno=1 --error_p=0.002 --run=1 --duration=10\"\n```\n\n```mermaid\nflowchart LR\nr{{router}}\nn0[Node 0\\nTCP Tahoe]\nn1[Node 1\\nTCP Reno]\ni((Receiver))\n\n    r <--Random loss--> i\n    n0 <----> r\n    n1 <----> r\n```\n\n![Graph 3](./docs/img/graph-3.png)\n\n### Scenario 4\n\n```bash\n./ns3 run \"p2p-project --n_tcp_tahoe=2 --n_tcp_reno=2 --run=0 --duration=10\"\n```\n\n```mermaid\nflowchart LR\nr{{router}}\nn0[Node 0\\nTCP Tahoe]\nn1[Node 1\\nTCP Tahoe]\nn2[Node 2\\nTCP Reno]\nn3[Node 3\\nTCP Reno]\ni((Receiver))\n\n    r <----> i\n    n0 <----> r\n    n1 <----> r\n    n2 <----> r\n    n3 <----> r\n```\n\n![Graph 4](./docs/img/graph-4.png)\n\n## Conclusion\n\nTCP Tahoe and TCP Reno are very similar. The main difference is that TCP Reno uses a fast retransmit mechanism to detect packet loss and a fast recovery mechanism to recover from packet loss and follows up with a fast recovery phase.  \nThis means that, in most cases, TCP Reno outperforms TCP Tahoe.\n\n## References\n\n- [ns-3](https://www.nsnam.org/)\n- [TCP congestion control](https://datatracker.ietf.org/doc/html/rfc5681)\n- [A Comparative Analysis of TCP Tahoe, Reno, New-Reno, SACK and Vegas](https://inst.eecs.berkeley.edu/~ee122/fa05/projects/Project2/SACKRENEVEGAS.pdf)\n",
  "examples": [
    {
      "file_path": "p2p-project.cc",
      "code": "#include \"simulation/configuration.h\"\n#include \"simulation/simulator-helper.h\"\n#include \"simulation/tracer.h\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/point-to-point-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"P2P-Project\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Read the configuration from the command line and use it to initialize the default values\n    Configuration conf;\n    ParseConsoleArgs(conf, argc, argv);\n    InitializeDefaultConfiguration(conf);\n\n    // Set up tracing\n    Tracer tracer(conf, GraphDataUpdateType::All);\n\n    SimulatorHelper simHelper(conf, tracer);\n    simHelper.Setup();\n\n    NS_LOG_INFO(\"Run Simulation\");\n    simHelper.Run();\n    NS_LOG_INFO(\"The simulation has ended\");\n\n    return 0;\n}\n"
    },
    {
      "file_path": "simulation/simulator-helper.cc",
      "code": "#include \"simulator-helper.h\"\n\nNS_LOG_COMPONENT_DEFINE(\"SimulatorHelper\");\n\nSimulatorHelper::SimulatorHelper(const Configuration& conf, Tracer& tracer)\n    : m_port(9),\n      m_conf(conf),\n      m_isInitialized(false),\n      m_tracer(tracer)\n{\n    m_ipv4Helper.SetBase(\"10.0.1.0\", \"255.255.255.0\");\n}\n\nvoid\nSimulatorHelper::Setup()\n{\n    SetupNodes();\n    SetupSenderChannel();\n    SetupReceiverChannel();\n\n    NS_LOG_INFO(\"Initialize Global Routing.\");\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    SetupSenderApplications();\n    SetupReceiverApplications();\n    SetupTracing();\n\n    m_isInitialized = true;\n}\n\nvoid\nSimulatorHelper::Run()\n{\n    NS_LOG_FUNCTION(this);\n\n    if (!m_isInitialized)\n    {\n        NS_LOG_WARN(\"SimulatorHelper is not initialized\");\n        return;\n    }\n\n    NS_LOG_INFO(\"Running simulation\");\n    Simulator::Stop(Seconds(m_conf.duration));\n    Simulator::Run();\n    Simulator::Destroy();\n}\n\nvoid\nSimulatorHelper::SetupNodes()\n{\n    NS_LOG_FUNCTION(this);\n\n    NS_LOG_INFO(\"Create nodes\");\n    m_senders.Create(m_conf.n_tcp_tahoe + m_conf.n_tcp_reno);\n    m_receivers.Create(1);\n    m_gateway.Create(1);\n\n    InternetStackHelper internet;\n    internet.InstallAll();\n}\n\nvoid\nSimulatorHelper::SetupSenderChannel()\n{\n    NS_LOG_FUNCTION(this);\n\n    NS_LOG_INFO(\"Create sender channel\");\n    m_s_pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(m_conf.s_bandwidth));\n    m_s_pointToPoint.SetChannelAttribute(\"Delay\", StringValue(m_conf.s_delay));\n    for (uint32_t i = 0; i < m_senders.GetN(); i++)\n    {\n        NetDeviceContainer devices = m_s_pointToPoint.Install(m_senders.Get(i), m_gateway.Get(0));\n        m_ipv4Helper.NewNetwork();\n        m_ipv4Helper.Assign(devices);\n    }\n\n    for (uint32_t i = 0; i < m_conf.n_tcp_tahoe; i++)\n    {\n        Config::Set(\"/NodeList/\" + std::to_string(i) + \"/$ns3::TcpL4Protocol/SocketType\",\n                    TypeIdValue(TcpTahoe::GetTypeId()));\n        Config::Set(\"/NodeList/\" + std::to_string(i) + \"/$ns3::TcpL4Protocol/RecoveryType\",\n                    TypeIdValue(TcpTahoeLossRecovery::GetTypeId()));\n    }\n    for (uint32_t i = m_conf.n_tcp_tahoe; i < m_conf.n_tcp_tahoe + m_conf.n_tcp_reno; i++)\n    {\n        Config::Set(\"/NodeList/\" + std::to_string(i) + \"/$ns3::TcpL4Protocol/SocketType\",\n                    TypeIdValue(TypeId::LookupByName(\"ns3::TcpLinuxReno\")));\n        Config::Set(\"/NodeList/\" + std::to_string(i) + \"/$ns3::TcpL4Protocol/RecoveryType\",\n                    TypeIdValue(TypeId::LookupByName(\"ns3::TcpClassicRecovery\")));\n    }\n}\n\nvoid\nSimulatorHelper::SetupReceiverChannel()\n{\n    NS_LOG_FUNCTION(this);\n\n    NS_LOG_LOGIC(\"Create error model\");\n    Ptr<UniformRandomVariable> uv = CreateObject<UniformRandomVariable>();\n    Ptr<RateErrorModel> error_model = CreateObject<RateErrorModel>();\n    error_model->SetRandomVariable(uv);\n    error_model->SetUnit(RateErrorModel::ERROR_UNIT_PACKET);\n    error_model->SetRate(m_conf.error_p);\n\n    NS_LOG_INFO(\"Create receiver channel\");\n    m_r_pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(m_conf.r_bandwidth));\n    m_r_pointToPoint.SetChannelAttribute(\"Delay\", StringValue(m_conf.r_delay));\n    m_r_pointToPoint.SetDeviceAttribute(\"ReceiveErrorModel\", PointerValue(error_model));\n\n    NetDeviceContainer devices = m_r_pointToPoint.Install(m_gateway.Get(0), m_receivers.Get(0));\n    m_ipv4Helper.NewNetwork();\n    m_ipv4Helper.Assign(devices);\n\n    TrafficControlHelper tch;\n    tch.SetRootQueueDisc(\"ns3::RedQueueDisc\");\n    tch.Uninstall(devices);\n    QueueDiscContainer qDiscs = tch.Install(devices);\n    qDiscs.Get(0)->TraceConnectWithoutContext(\"PacketsInQueue\",\n                                              MakeCallback(&Tracer::TcpQueueTracer, &m_tracer));\n}\n\nvoid\nSimulatorHelper::SetupSenderApplications()\n{\n    NS_LOG_FUNCTION(this);\n\n    NS_LOG_INFO(\"Create sender applications\");\n    Ipv4Address remoteAddress = m_receivers.Get(0)->GetObject<Ipv4>()->GetAddress(1, 0).GetLocal();\n    BulkSendHelper source(\"ns3::TcpSocketFactory\", InetSocketAddress(remoteAddress, m_port));\n    source.SetAttribute(\"SendSize\", UintegerValue(m_conf.adu_bytes));\n    source.SetAttribute(\"MaxBytes\", UintegerValue(m_conf.max_mbytes_to_send * 1000000));\n    source.SetAttribute(\"StartTime\", TimeValue(Seconds(0)));\n    source.SetAttribute(\"StopTime\", TimeValue(Seconds(m_conf.duration)));\n\n    ApplicationContainer sourceApps = source.Install(m_senders);\n}\n\nvoid\nSimulatorHelper::SetupReceiverApplications()\n{\n    NS_LOG_FUNCTION(this);\n\n    NS_LOG_INFO(\"Create receiver applications\");\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\",\n                          InetSocketAddress(Ipv4Address::GetAny(), m_port));\n    sink.SetAttribute(\"StartTime\", TimeValue(Seconds(0)));\n    sink.SetAttribute(\"StopTime\", TimeValue(Seconds(m_conf.duration)));\n    ApplicationContainer sinkApps = sink.Install(m_receivers);\n}\n\nvoid\nSimulatorHelper::SetupTracing()\n{\n    Simulator::Schedule(NanoSeconds(1), MakeCallback(&Tracer::ScheduleTracing, &m_tracer));\n    Simulator::ScheduleDestroy(MakeCallback(&Tracer::PrintGraphDataToFile, &m_tracer));\n\n    // Set up tracing if enabled\n    if (m_conf.ascii_tracing)\n    {\n        AsciiTraceHelper ascii;\n        m_s_pointToPoint.EnableAsciiAll(ascii.CreateFileStream(m_conf.prefix_file_name + \".tr\"));\n        m_r_pointToPoint.EnableAsciiAll(ascii.CreateFileStream(m_conf.prefix_file_name + \".tr\"));\n    }\n    if (m_conf.pcap_tracing)\n    {\n        m_s_pointToPoint.EnablePcapAll(m_conf.prefix_file_name, false);\n        m_r_pointToPoint.EnablePcapAll(m_conf.prefix_file_name, false);\n    }\n}\n"
    },
    {
      "file_path": "simulation/tcp-tahoe.cc",
      "code": "#include \"tcp-tahoe.h\"\n\n#include \"ns3/log.h\"\n#include \"ns3/simulator.h\"\n\nNS_LOG_COMPONENT_DEFINE(\"TcpTahoe\");\nNS_OBJECT_ENSURE_REGISTERED(TcpTahoe);\n\nTcpTahoe::TcpTahoe()\n    : TcpCongestionOps()\n{\n}\n\nTcpTahoe::TcpTahoe(const TcpTahoe& socket)\n    : TcpCongestionOps(socket)\n{\n}\n\nns3::TypeId\nTcpTahoe::GetTypeId()\n{\n    static TypeId tid = TypeId(\"ns3::TcpTahoe\")\n                            .SetParent<TcpCongestionOps>()\n                            .SetGroupName(\"Internet\")\n                            .AddConstructor<TcpTahoe>();\n    return tid;\n}\n\nstd::string\nTcpTahoe::GetName() const\n{\n    return \"TcpTahoe\";\n}\n\nvoid\nTcpTahoe::IncreaseWindow(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked)\n{\n    NS_LOG_FUNCTION(this << tcb << segmentsAcked);\n\n    if (tcb->m_cWnd < tcb->m_ssThresh) // The cwnd is less than the ssThresh => slow start\n    {\n        NS_LOG_DEBUG(\"In slow start, m_cWnd \" << tcb->m_cWnd << \" m_ssThresh \" << tcb->m_ssThresh);\n        SlowStart(tcb, segmentsAcked);\n    }\n    else // The cwnd is greater than or equal to the ssThresh => congestion avoidance\n    {\n        NS_LOG_DEBUG(\"In cong. avoidance, m_cWnd \" << tcb->m_cWnd << \" m_ssThresh \"\n                                                   << tcb->m_ssThresh);\n        CongestionAvoidance(tcb, segmentsAcked);\n    }\n}\n\nuint32_t\nTcpTahoe::GetSsThresh(Ptr<const TcpSocketState> tcb, uint32_t bytesInFlight)\n{\n    NS_LOG_FUNCTION(this << tcb << bytesInFlight);\n\n    return std::max<uint32_t>(2 * tcb->m_segmentSize, tcb->m_cWnd / 2);\n}\n\nns3::Ptr<TcpCongestionOps>\nTcpTahoe::Fork()\n{\n    return CopyObject<TcpTahoe>(this);\n}\n\nvoid\nTcpTahoe::SlowStart(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked)\n{\n    NS_LOG_FUNCTION(this << tcb << segmentsAcked);\n\n    if (segmentsAcked >= 1)\n    {\n        uint32_t sndCwnd = tcb->m_cWnd;\n        // Set the cwnd to the minimum of the following:\n        // 1. The current cwnd + the number of segments acked * segment size\n        // 2. The ssThresh\n        uint32_t realSegmentsAcked = std::min(segmentsAcked, tcb->m_bytesInFlight.Get() / tcb->m_segmentSize + 1);\n        tcb->m_cWnd =\n            std::min((sndCwnd + (realSegmentsAcked * tcb->m_segmentSize)), (uint32_t)tcb->m_ssThresh);\n        NS_LOG_INFO(\"In SlowStart, updated to cwnd \" << tcb->m_cWnd << \" ssthresh \"\n                                                     << tcb->m_ssThresh);\n    }\n}\n\nvoid\nTcpTahoe::CongestionAvoidance(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked)\n{\n    NS_LOG_FUNCTION(this << tcb << segmentsAcked);\n\n    // Number of packets in the cwnd\n    uint32_t w = tcb->m_cWnd / tcb->m_segmentSize;\n\n    // Floor w to 1 if w == 0\n    if (w == 0)\n        w = 1;\n\n    NS_LOG_DEBUG(\"w in segments \" << w << \" m_cWndCnt \" << m_cWndCnt << \" segments acked \"\n                                  << segmentsAcked);\n    // Increase m_cWndCnt by the number of segments acked\n    m_cWndCnt += segmentsAcked;\n\n    if (m_cWndCnt >= w)\n    {\n        // Floor value of (segments_acked / segments in cwnd)\n        uint32_t delta = m_cWndCnt / w;\n        // Increase the cwnd by the (segments acked * segment size / segments in cwnd)\n        tcb->m_cWnd += delta * tcb->m_segmentSize;\n        // Remove the number of segments used to increase cwnd from m_cWndCnt\n        m_cWndCnt -= delta * w;\n        NS_LOG_DEBUG(\"Subtracting delta * w from m_cWndCnt \" << delta * w);\n    }\n    NS_LOG_DEBUG(\"At end of CongestionAvoidance(), m_cWnd: \" << tcb->m_cWnd\n                                                             << \" m_cWndCnt: \" << m_cWndCnt);\n}\n"
    }
  ]
}