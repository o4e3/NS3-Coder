{
  "repo_name": "cisco/ns3-rmcat",
  "github_url": "https://github.com/cisco/ns3-rmcat",
  "readme": ".. contents::\n\nns3-rmcat Documentation\n----------------------------\n\n.. heading hierarchy:\n   ------------- Chapter\n   ************* Section (#.#)\n   ============= Subsection (#.#.#)\n   ############# Paragraph (no number)\n\nns3-rmcat is an `ns3 <https://www.nsnam.org/release/ns-allinone-3.26.tar.bz2>`_ module (Currently ns-3.26 is supported) used for `IETF RMCAT <https://datatracker.ietf.org/wg/rmcat/charter/>`_ candidate algorithm testing.\n\nIt can be used in one of these ways:\n\n1. As complementary tests for the unit test and integration test in emulator environment.\n\n2. Algorithm tuning. It's easier to support different topologies using ns3, as ns3 provides sophisticated LTE and WiFi models, which make it easier to peek the internals than a real world system and emulator testbed.\n\n3. Algorithm comparison. Simulation testbed is more reproducible than real world test and emulator testbed. The different candidate algorithms can be easily switched, thus making side-by-side comparison of different algorithms an easy and fair task.\n\n\nModel\n*****************\n\nThe model for real-time media congestion is documented at `\"Framework for Real-time Media Congestion Avoidance Techniques\" <https://tools.ietf.org/html/draft-zhu-rmcat-framework-00>`_, and ns3-rmcat is a simplified implementation focussing on evaluation of real-time media congestion control algorithms in a simulation environment.\n\nns3-rmcat defines ns3 applications (see `model/apps <model/apps>`_) running on different network topologies. These ns3 applications send fake video codec data (`model/syncodecs <model/syncodecs>`_, more on `syncodecs <https://github.com/cisco/syncodecs>`_), according to the congestion control algorithm under test.\n\nThe sender application, ``RmcatSender``, sends fake video codec data in media packets to the receiver application, ``RmcatReceiver``. ``RmcatReceiver`` gets the sequence of packets and takes reception timestamp information, and sends it back to ``RmcatSender`` in feedback packets. The (sender-based) congestion control algorithm running on ``RmcatSender`` processes the feedback information (see `model/congestion-control <model/congestion-control>`_), to get bandwidth estimation. The sender application then uses this bandwidth estimation to control the fake video encoder by adjusting its target video bitrate.\n\nDifferent topologies (see `model/topo <model/topo>`_) are currently supported, currently only point-to-point wired topology and WIFI topologies are used. We will add LTE support later.\n\nTestcases\n*****************\n\nThe test cases are in `test/rmcat-wired-test-suite <test/rmcat-wired-test-suite.cc>`_ and `test/rmcat-wifi-test-suite <test/rmcat-wifi-test-suite.cc>`_; and currently organized in three test suites:\n\n  - `rmcat-wifi <https://datatracker.ietf.org/doc/draft-ietf-rmcat-eval-test/?include_text=1>`_\n\n  - `rmcat-wired <https://datatracker.ietf.org/doc/draft-fu-rmcat-wifi-test-case/?include_text=1>`_\n\n  - rmcat-wired-vparam, which is based on some of the wired test cases, but varying other parameters such as bottleneck bandwidth, propagation delay, etc.\n\n`LTE <https://datatracker.ietf.org/doc/draft-ietf-rmcat-wireless-tests/?include_text=1>`_ test case are not implemented yet.\n\nExamples\n*****************\n\n`examples <examples>`_ is provided as an application template for experimenting new test cases and algorithm changes.\n\nWrite your own congestion control algorithm\n***************************************************\n\nYou can create your own congestion control algorithm by inheriting from  `SenderBasedController <model/congestion-control/sender-based-controller.h#L85>`_, `DummyController <model/congestion-control/dummy-controller.h#L39>`_ is an example which just prints the packet loss, queuing delay and receive rate without doing any congestion control: the bandwidth estimation is hard-coded.\n\nTo reuse the plotting tool, the following logs are expected to be written (see `NadaController <model/congestion-control/nada-controller.cc>`_, `process_test_logs.py <tools/process_test_logs.py>`_):\n\n::\n\n    # rmcat flow 0, this is the flow id, SenderBasedController::m_id\n    # ts, current timestamp when receving the rmcat feedback in millionseconds\n    # loglen, packet history size, SenderBasedController::m_packetHistory.size()\n    # qdel, queuing delay, SenderBasedController::getCurrentQdelay()\n    # rtt, round trip time, SenderBasedController::getCurrentRTT()\n    # ploss, packet loss count in last 500 ms, SenderBasedController::getPktLossInfo()\n    # plr, packet loss ratio, SenderBasedController::getPktLossInfo()\n    # xcurr, aggregated congestion signal that accounts for queuing delay, ECN\n    # rrate, current receive rate in bps, SenderBasedController::getCurrentRecvRate()\n    # srate, current estimated available bandwidth in bps\n    # avgint, average inter-loss interval in packets, SenderBasedController::getLossIntervalInfo()\n    # curint, most recent (currently growing) inter-loss interval in packets, SenderBasedController::getLossIntervalInfo()\n\n    rmcat_0 ts: 158114 loglen: 60 qdel: 286 rtt: 386 ploss: 0 plr: 0.00 xcurr: 4.72 rrate: 863655.56 srate: 916165.81 avgint: 437.10 curint: 997\n\n\nUsage\n*****************\n\n1. Download ns3 (ns-3.26 is currently supported, other version may also work but are untested).\n\n2. Git clone ns3-rmcat into ``ns-3.xx/src``. Initialize syncodecs submodule (``git submodule update --init --recursive``)\n\n3. configure the workspace, ``CXXFLAGS=\"-std=c++11 -Wall -Werror -Wno-potentially-evaluated-expression -Wno-unused-local-typedefs\" ./waf configure --enable-examples --enable-tests``.\n\n4. build, ``./waf build``\n\n5. run tests, ``./test.py -s rmcat-wired -w rmcat.html -r``, where ``rmcat.html`` is the test report.\n\n7. [optional] run examples, ``./waf --run \"rmcat-example --log\"``, ``--log`` will turn on RmcatSender/RmcatReceiver logs for debugging.\n\n8. draw the plots (need to install the python module `matplotlib <https://matplotlib.org/>`_), ``python src/ns3-rmcat/tools/process_test_logs.py testpy-output/2017-08-11-18-52-15-CUT; python src/ns3-rmcat/tools/plot_tests.py testpy-output/2017-08-11-18-52-15-CUT``\n\nYou can also use `test.csh <tools/test.csh>`_ to run the testcases and the plot scripts in one shot. If you do so, logs with testcase names will be located in the \"testpy-output/[CURRENT UTC TIME]\" directory, if none specified.\n\n::\n\n    # run from ns3 root directory: ns-3.xx/\n    #\n    # Example:\n    # ./src/ns3-rmcat/tools/test.csh wired 2017-07-21-rmcat-wired\n    # ./src/ns3-rmcat/tools/test.csh vparam 2017-07-21-rmcat-wired-vparam\n    # ./src/ns3-rmcat/tools/test.csh wifi 2017-07-21-rmcat-wifi\n    #\n    # The second parameter, output directory, is optional. If not specified,\n    # the script will use a folder with a name based on current GMT time\n\n\nNote that in ns-3.26, the testing script (test.py) only works with python2. So one may want to point the python alias to python to ensure that the `test.csh` script runs out of box:\n\n::\n    alias python=python2.7.3\n::\n\nAlternatively, you can use `test_v2.csh <tools/test_v2.csh>`_ to explicitly invoke python2 for running the testing script and python3 for running the processing and plotting scripts.  The latter works with both python2 and python3.\n\n\nTroubleshooting\n*****************\n\nTo build ns-3.26 on newer compilers: see tips `here <https://www.nsnam.org/wiki/HOWTO_build_old_versions_of_ns-3_on_newer_compilers>`_. To disable warnings from breaking your build, do the following:\n::\n\n      CXXFLAGS=\"-Wall\" ./waf configure\n      ./waf -vv\n::\n\n\n\nTo debug \"rmcat-wired\" test suite:\n\n::\n\n    ./waf --command-template=\"gdb %s\" --run \"test-runner\"\n    r --assert-on-failure --suite=rmcat-wired\n\nTo debug rmcat example, enter ns3 source directory:\n\n::\n\n    ./waf --command-template=\"gdb %s\" --run src/ns3-rmcat/examples/rmcat-example\n\nFuture work\n**********************************\n\nAdding LTE topology and test cases\n\nAdd support for ECN marking\n\nEncapsulate Sender's rate shaping buffer in a C++ interface or class\n\nWired test cases: implement time-varying bottleneck capacity by changing the physical link properties\n",
  "examples": [
    {
      "file_path": "examples/rmcat-example.cc",
      "code": "/******************************************************************************\n * Copyright 2016-2017 cisco Systems, Inc.                                    *\n *                                                                            *\n * Licensed under the Apache License, Version 2.0 (the \"License\");            *\n * you may not use this file except in compliance with the License.           *\n * You may obtain a copy of the License at                                    *\n *                                                                            *\n *     http://www.apache.org/licenses/LICENSE-2.0                             *\n *                                                                            *\n * Unless required by applicable law or agreed to in writing, software        *\n * distributed under the License is distributed on an \"AS IS\" BASIS,          *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *\n * See the License for the specific language governing permissions and        *\n * limitations under the License.                                             *\n ******************************************************************************/\n\n/**\n * @file\n * Simple example demonstrating the usage of the rmcat ns3 module, using:\n *  - NADA as controller for rmcat flows\n *  - Statistics-based traffic source as codec\n *  - [Optionally] TCP flows\n *  - [Optionally] UDP flows\n *\n * @version 0.1.1\n * @author Jiantao Fu\n * @author Sergio Mena\n * @author Xiaoqing Zhu\n */\n\n#include \"ns3/nada-controller.h\"\n#include \"ns3/rmcat-sender.h\"\n#include \"ns3/rmcat-receiver.h\"\n#include \"ns3/rmcat-constants.h\"\n#include \"ns3/point-to-point-helper.h\"\n#include \"ns3/data-rate.h\"\n#include \"ns3/bulk-send-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/traffic-control-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/core-module.h\"\n\nconst uint32_t RMCAT_DEFAULT_RMIN  =  150000;  // in bps: 150Kbps\nconst uint32_t RMCAT_DEFAULT_RMAX  = 1500000;  // in bps: 1.5Mbps\nconst uint32_t RMCAT_DEFAULT_RINIT =  150000;  // in bps: 150Kbps\n\nconst uint32_t TOPO_DEFAULT_BW     = 1000000;    // in bps: 1Mbps\nconst uint32_t TOPO_DEFAULT_PDELAY =      50;    // in ms:   50ms\nconst uint32_t TOPO_DEFAULT_QDELAY =     300;    // in ms:  300ms\n\nusing namespace ns3;\n\nstatic NodeContainer BuildExampleTopo (uint64_t bps,\n                                       uint32_t msDelay,\n                                       uint32_t msQdelay)\n{\n    NodeContainer nodes;\n    nodes.Create (2);\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute (\"DataRate\", DataRateValue  (DataRate (bps)));\n    pointToPoint.SetChannelAttribute (\"Delay\", TimeValue (MilliSeconds (msDelay)));\n    auto bufSize = std::max<uint32_t> (DEFAULT_PACKET_SIZE, bps * msQdelay / 8000);\n    pointToPoint.SetQueue (\"ns3::DropTailQueue\",\n                           \"Mode\", StringValue (\"QUEUE_MODE_BYTES\"),\n                           \"MaxBytes\", UintegerValue (bufSize));\n    NetDeviceContainer devices = pointToPoint.Install (nodes);\n\n    InternetStackHelper stack;\n    stack.Install (nodes);\n    Ipv4AddressHelper address;\n    address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n    address.Assign (devices);\n\n    // Uncomment to capture simulated traffic\n    // pointToPoint.EnablePcapAll (\"rmcat-example\");\n\n    // disable tc for now, some bug in ns3 causes extra delay\n    TrafficControlHelper tch;\n    tch.Uninstall (devices);\n\n    return nodes;\n}\n\nstatic void InstallTCP (Ptr<Node> sender,\n                        Ptr<Node> receiver,\n                        uint16_t port,\n                        float startTime,\n                        float stopTime)\n{\n    // configure TCP source/sender/client\n    auto serverAddr = receiver->GetObject<Ipv4> ()->GetAddress (1,0).GetLocal ();\n    BulkSendHelper source{\"ns3::TcpSocketFactory\",\n                           InetSocketAddress{serverAddr, port}};\n    // Set the amount of data to send in bytes. Zero is unlimited.\n    source.SetAttribute (\"MaxBytes\", UintegerValue (0));\n    source.SetAttribute (\"SendSize\", UintegerValue (DEFAULT_PACKET_SIZE));\n\n    auto clientApps = source.Install (sender);\n    clientApps.Start (Seconds (startTime));\n    clientApps.Stop (Seconds (stopTime));\n\n    // configure TCP sink/receiver/server\n    PacketSinkHelper sink{\"ns3::TcpSocketFactory\",\n                           InetSocketAddress{Ipv4Address::GetAny (), port}};\n    auto serverApps = sink.Install (receiver);\n    serverApps.Start (Seconds (startTime));\n    serverApps.Stop (Seconds (stopTime));\n\n}\n\nstatic Time GetIntervalFromBitrate (uint64_t bitrate, uint32_t packetSize)\n{\n    if (bitrate == 0u) {\n        return Time::Max ();\n    }\n    const auto secs = static_cast<double> (packetSize + IPV4_UDP_OVERHEAD) /\n                            (static_cast<double> (bitrate) / 8. );\n    return Seconds (secs);\n}\n\nstatic void InstallUDP (Ptr<Node> sender,\n                        Ptr<Node> receiver,\n                        uint16_t serverPort,\n                        uint64_t bitrate,\n                        uint32_t packetSize,\n                        uint32_t startTime,\n                        uint32_t stopTime)\n{\n    // configure UDP source/sender/client\n    auto serverAddr = receiver->GetObject<Ipv4> ()->GetAddress (1,0).GetLocal ();\n    const auto interPacketInterval = GetIntervalFromBitrate (bitrate, packetSize);\n    uint32_t maxPacketCount = 0XFFFFFFFF;\n    UdpClientHelper client{serverAddr, serverPort};\n    client.SetAttribute (\"MaxPackets\", UintegerValue (maxPacketCount));\n    client.SetAttribute (\"Interval\", TimeValue (interPacketInterval));\n    client.SetAttribute (\"PacketSize\", UintegerValue (packetSize));\n\n    auto clientApps = client.Install (sender);\n    clientApps.Start (Seconds (startTime));\n    clientApps.Stop (Seconds (stopTime));\n\n    // configure TCP sink/receiver/server\n    UdpServerHelper server{serverPort};\n    auto serverApps = server.Install (receiver);\n    serverApps.Start (Seconds (startTime));\n    serverApps.Stop (Seconds (stopTime));\n}\n\nstatic void InstallApps (bool nada,\n                         Ptr<Node> sender,\n                         Ptr<Node> receiver,\n                         uint16_t port,\n                         float initBw,\n                         float minBw,\n                         float maxBw,\n                         float startTime,\n                         float stopTime)\n{\n    Ptr<RmcatSender> sendApp = CreateObject<RmcatSender> ();\n    Ptr<RmcatReceiver> recvApp = CreateObject<RmcatReceiver> ();\n    sender->AddApplication (sendApp);\n    receiver->AddApplication (recvApp);\n\n    if (nada) {\n        sendApp->SetController (std::make_shared<rmcat::NadaController> ());\n    }\n    Ptr<Ipv4> ipv4 = receiver->GetObject<Ipv4> ();\n    Ipv4Address receiverIp = ipv4->GetAddress (1, 0).GetLocal ();\n    sendApp->Setup (receiverIp, port); // initBw, minBw, maxBw);\n\n    const auto fps = 25.;\n    auto innerCodec = new syncodecs::StatisticsCodec{fps};\n    auto codec = new syncodecs::ShapedPacketizer{innerCodec, DEFAULT_PACKET_SIZE};\n    sendApp->SetCodec (std::shared_ptr<syncodecs::Codec>{codec});\n\n    recvApp->Setup (port);\n\n    sendApp->SetStartTime (Seconds (startTime));\n    sendApp->SetStopTime (Seconds (stopTime));\n\n    recvApp->SetStartTime (Seconds (startTime));\n    recvApp->SetStopTime (Seconds (stopTime));\n}\n\nint main (int argc, char *argv[])\n{\n    int nRmcat = 1;\n    int nTcp = 0;\n    int nUdp = 0;\n    bool log = false;\n    bool nada = true;\n    std::string strArg  = \"strArg default\";\n\n    CommandLine cmd;\n    cmd.AddValue (\"rmcat\", \"Number of RMCAT (NADA) flows\", nRmcat);\n    cmd.AddValue (\"tcp\", \"Number of TCP flows\", nTcp);\n    cmd.AddValue (\"udp\", \"Number of UDP flows\", nUdp);\n    cmd.AddValue (\"log\", \"Turn on logs\", log);\n    cmd.AddValue (\"nada\", \"true: use NADA, false: use dummy\", nada);\n    cmd.Parse (argc, argv);\n\n    if (log) {\n        LogComponentEnable (\"RmcatSender\", LOG_INFO);\n        LogComponentEnable (\"RmcatReceiver\", LOG_INFO);\n        LogComponentEnable (\"Packet\", LOG_FUNCTION);\n    }\n\n    // configure default TCP parameters\n    Config::SetDefault (\"ns3::TcpSocket::DelAckCount\", UintegerValue (0));\n    Config::SetDefault (\"ns3::TcpL4Protocol::SocketType\", StringValue (\"ns3::TcpNewReno\"));\n    Config::SetDefault (\"ns3::TcpSocket::SegmentSize\", UintegerValue (1000));\n\n    const uint64_t linkBw   = TOPO_DEFAULT_BW;\n    const uint32_t msDelay  = TOPO_DEFAULT_PDELAY;\n    const uint32_t msQDelay = TOPO_DEFAULT_QDELAY;\n\n    const float minBw =  RMCAT_DEFAULT_RMIN;\n    const float maxBw =  RMCAT_DEFAULT_RMAX;\n    const float initBw = RMCAT_DEFAULT_RINIT;\n\n    const float endTime = 300.;\n\n    NodeContainer nodes = BuildExampleTopo (linkBw, msDelay, msQDelay);\n\n    int port = 8000;\n    nRmcat = std::max<int> (0, nRmcat); // No negative RMCAT flows\n    for (size_t i = 0; i < (unsigned int) nRmcat; ++i) {\n        auto start = 10. * i;\n        auto end = std::max (start + 1., endTime - start);\n        InstallApps (nada, nodes.Get (0), nodes.Get (1), port++,\n                     initBw, minBw, maxBw, start, end);\n    }\n\n    nTcp = std::max<int> (0, nTcp); // No negative TCP flows\n    for (size_t i = 0; i < (unsigned int) nTcp; ++i) {\n        auto start = 17. * i;\n        auto end = std::max (start + 1., endTime - start);\n        InstallTCP (nodes.Get (0), nodes.Get (1), port++, start, end);\n    }\n\n    // UDP parameters\n    const uint64_t bandwidth = RMCAT_DEFAULT_RMAX / 4;\n    const uint32_t pktSize = DEFAULT_PACKET_SIZE;\n\n    nUdp = std::max<int> (0, nUdp); // No negative UDP flows\n    for (size_t i = 0; i < (unsigned int) nUdp; ++i) {\n        auto start = 23. * i;\n        auto end = std::max (start + 1., endTime - start);\n        InstallUDP (nodes.Get (0), nodes.Get (1), port++,\n                    bandwidth, pktSize, start, end);\n    }\n\n    std::cout << \"Running Simulation...\" << std::endl;\n    Simulator::Stop (Seconds (endTime));\n    Simulator::Run ();\n    Simulator::Destroy ();\n    std::cout << \"Done\" << std::endl;\n\n    return 0;\n}\n"
    },
    {
      "file_path": "model/apps/rmcat-receiver.cc",
      "code": "/******************************************************************************\n * Copyright 2016-2017 Cisco Systems, Inc.                                    *\n *                                                                            *\n * Licensed under the Apache License, Version 2.0 (the \"License\");            *\n * you may not use this file except in compliance with the License.           *\n *                                                                            *\n * You may obtain a copy of the License at                                    *\n *                                                                            *\n *     http://www.apache.org/licenses/LICENSE-2.0                             *\n *                                                                            *\n * Unless required by applicable law or agreed to in writing, software        *\n * distributed under the License is distributed on an \"AS IS\" BASIS,          *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *\n * See the License for the specific language governing permissions and        *\n * limitations under the License.                                             *\n ******************************************************************************/\n\n/**\n * @file\n * Receiver application implementation for rmcat ns3 module.\n *\n * @version 0.1.1\n * @author Jiantao Fu\n * @author Sergio Mena\n * @author Xiaoqing Zhu\n */\n\n#include \"rmcat-receiver.h\"\n#include \"rmcat-constants.h\"\n#include \"ns3/udp-socket-factory.h\"\n#include \"ns3/packet.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/log.h\"\n\nNS_LOG_COMPONENT_DEFINE (\"RmcatReceiver\");\n\nnamespace ns3 {\nRmcatReceiver::RmcatReceiver ()\n: m_running{false}\n, m_waiting{false}\n, m_ssrc{0}\n, m_remoteSsrc{0}\n, m_srcIp{}\n, m_srcPort{}\n, m_socket{NULL}\n, m_header{}\n, m_sendEvent{}\n, m_periodUs{RMCAT_FEEDBACK_PERIOD_US}\n{}\n\nRmcatReceiver::~RmcatReceiver () {}\n\nvoid RmcatReceiver::Setup (uint16_t port)\n{\n    m_socket = Socket::CreateSocket (GetNode (), UdpSocketFactory::GetTypeId ());\n    auto local = InetSocketAddress{Ipv4Address::GetAny (), port};\n    auto ret = m_socket->Bind (local);\n    NS_ASSERT (ret == 0);\n    m_socket->SetRecvCallback (MakeCallback (&RmcatReceiver::RecvPacket, this));\n\n    m_running = false;\n    m_waiting = true;\n}\n\nvoid RmcatReceiver::StartApplication ()\n{\n    m_running = true;\n    m_ssrc = rand ();\n    m_header.SetSendSsrc (m_ssrc);\n    Time tFirst {MicroSeconds (m_periodUs)};\n    m_sendEvent = Simulator::Schedule (tFirst, &RmcatReceiver::SendFeedback, this, true);\n}\n\nvoid RmcatReceiver::StopApplication ()\n{\n    m_running = false;\n    m_waiting = true;\n    m_header.Clear ();\n    Simulator::Cancel (m_sendEvent);\n}\n\nvoid RmcatReceiver::RecvPacket (Ptr<Socket> socket)\n{\n    if (!m_running) {\n        return;\n    }\n\n    Address remoteAddr{};\n    auto packet = m_socket->RecvFrom (remoteAddr);\n    NS_ASSERT (packet);\n    RtpHeader header{};\n    NS_LOG_INFO (\"RmcatReceiver::RecvPacket, \" << packet->ToString ());\n    packet->RemoveHeader (header);\n    auto srcIp = InetSocketAddress::ConvertFrom (remoteAddr).GetIpv4 ();\n    const auto srcPort = InetSocketAddress::ConvertFrom (remoteAddr).GetPort ();\n    if (m_waiting) {\n        m_waiting = false;\n        m_remoteSsrc = header.GetSsrc ();\n        m_srcIp = srcIp;\n        m_srcPort = srcPort;\n    } else {\n        // Only one flow supported\n        NS_ASSERT (m_remoteSsrc == header.GetSsrc ());\n        NS_ASSERT (m_srcIp == srcIp);\n        NS_ASSERT (m_srcPort == srcPort);\n    }\n\n    uint64_t recvTimestampUs = Simulator::Now ().GetMicroSeconds ();\n    AddFeedback (header.GetSequence (), recvTimestampUs);\n}\n\nvoid RmcatReceiver::AddFeedback (uint16_t sequence,\n                                 uint64_t recvTimestampUs)\n{\n    auto res = m_header.AddFeedback (m_remoteSsrc, sequence, recvTimestampUs);\n    if (res == CCFeedbackHeader::CCFB_TOO_LONG) {\n        SendFeedback (false);\n        res = m_header.AddFeedback (m_remoteSsrc, sequence, recvTimestampUs);\n    }\n    NS_ASSERT (res == CCFeedbackHeader::CCFB_NONE);\n}\n\nvoid RmcatReceiver::SendFeedback (bool reschedule)\n{\n    if (m_running && !m_header.Empty ()) {\n        //TODO (authors): If packet empty, easiest is to send it as is. Propose to authors\n        auto packet = Create<Packet> ();\n        packet->AddHeader (m_header);\n        NS_LOG_INFO (\"RmcatReceiver::SendFeedback, \" << packet->ToString ());\n        m_socket->SendTo (packet, 0, InetSocketAddress{m_srcIp, m_srcPort});\n\n        m_header.Clear ();\n        m_header.SetSendSsrc (m_ssrc);\n    }\n\n    if (reschedule) {\n        Time tNext {MicroSeconds (m_periodUs)};\n        m_sendEvent = Simulator::Schedule (tNext, &RmcatReceiver::SendFeedback, this, true);\n    }\n}\n\n}\n\n"
    },
    {
      "file_path": "model/apps/rmcat-sender.cc",
      "code": "/******************************************************************************\n * Copyright 2016-2017 Cisco Systems, Inc.                                    *\n *                                                                            *\n * Licensed under the Apache License, Version 2.0 (the \"License\");            *\n * you may not use this file except in compliance with the License.           *\n *                                                                            *\n * You may obtain a copy of the License at                                    *\n *                                                                            *\n *     http://www.apache.org/licenses/LICENSE-2.0                             *\n *                                                                            *\n * Unless required by applicable law or agreed to in writing, software        *\n * distributed under the License is distributed on an \"AS IS\" BASIS,          *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *\n * See the License for the specific language governing permissions and        *\n * limitations under the License.                                             *\n ******************************************************************************/\n\n/**\n * @file\n * Sender application implementation for rmcat ns3 module.\n *\n * @version 0.1.1\n * @author Jiantao Fu\n * @author Sergio Mena\n * @author Xiaoqing Zhu\n */\n\n#include \"rmcat-sender.h\"\n#include \"rtp-header.h\"\n#include \"ns3/dummy-controller.h\"\n#include \"ns3/nada-controller.h\"\n#include \"ns3/udp-socket-factory.h\"\n#include \"ns3/packet.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/log.h\"\n\n#include <sys/stat.h>\n\nNS_LOG_COMPONENT_DEFINE (\"RmcatSender\");\n\nnamespace ns3 {\n\nRmcatSender::RmcatSender ()\n: m_destIP{}\n, m_destPort{0}\n, m_initBw{0}\n, m_minBw{0}\n, m_maxBw{0}\n, m_paused{false}\n, m_ssrc{0}\n, m_sequence{0}\n, m_rtpTsOffset{0}\n, m_socket{NULL}\n, m_enqueueEvent{}\n, m_sendEvent{}\n, m_sendOversleepEvent{}\n, m_fps{30.}\n, m_rVin{0.}\n, m_rSend{0.}\n, m_rateShapingBytes{0}\n, m_nextSendTstmpUs{0}\n{}\n\nRmcatSender::~RmcatSender () {}\n\nvoid RmcatSender::PauseResume (bool pause)\n{\n    NS_ASSERT (pause != m_paused);\n    if (pause) {\n        Simulator::Cancel (m_enqueueEvent);\n        Simulator::Cancel (m_sendEvent);\n        Simulator::Cancel (m_sendOversleepEvent);\n        m_rateShapingBuf.clear ();\n        m_rateShapingBytes = 0;\n    } else {\n        m_rVin = m_initBw;\n        m_rSend = m_initBw;\n        m_enqueueEvent = Simulator::ScheduleNow (&RmcatSender::EnqueuePacket, this);\n        m_nextSendTstmpUs = 0;\n    }\n    m_paused = pause;\n}\n\nvoid RmcatSender::SetCodec (std::shared_ptr<syncodecs::Codec> codec)\n{\n    m_codec = codec;\n}\n\n// TODO (deferred): allow flexible input of video traffic trace path via config file, etc.\nvoid RmcatSender::SetCodecType (SyncodecType codecType)\n{\n    syncodecs::Codec* codec = NULL;\n    switch (codecType) {\n        case SYNCODEC_TYPE_PERFECT:\n        {\n            codec = new syncodecs::PerfectCodec{DEFAULT_PACKET_SIZE};\n            break;\n        }\n        case SYNCODEC_TYPE_FIXFPS:\n        {\n            m_fps = SYNCODEC_DEFAULT_FPS;\n            auto innerCodec = new syncodecs::SimpleFpsBasedCodec{m_fps};\n            codec = new syncodecs::ShapedPacketizer{innerCodec, DEFAULT_PACKET_SIZE};\n            break;\n        }\n        case SYNCODEC_TYPE_STATS:\n        {\n            m_fps = SYNCODEC_DEFAULT_FPS;\n            auto innerStCodec = new syncodecs::StatisticsCodec{m_fps};\n            codec = new syncodecs::ShapedPacketizer{innerStCodec, DEFAULT_PACKET_SIZE};\n            break;\n        }\n        case SYNCODEC_TYPE_TRACE:\n        case SYNCODEC_TYPE_HYBRID:\n        {\n            const std::vector<std::string> candidatePaths = {\n                \".\",      // If run from top directory (e.g., with gdb), from ns-3.26/\n                \"../\",    // If run from with test_new.py with designated directory, from ns-3.26/2017-xyz/\n                \"../..\",  // If run with test.py, from ns-3.26/testpy-output/201...\n            };\n\n            const std::string traceSubDir{\"src/ns3-rmcat/model/syncodecs/video_traces/chat_firefox_h264\"};\n            std::string traceDir{};\n\n            for (auto c : candidatePaths) {\n                std::ostringstream currPathOss;\n                currPathOss << c << \"/\" << traceSubDir;\n                struct stat buffer;\n                if (::stat (currPathOss.str ().c_str (), &buffer) == 0) {\n                    //filename exists\n                    traceDir = currPathOss.str ();\n                    break;\n                }\n            }\n\n            NS_ASSERT_MSG (!traceDir.empty (), \"Traces file not found in candidate paths\");\n\n            auto filePrefix = \"chat\";\n            auto innerCodec = (codecType == SYNCODEC_TYPE_TRACE) ?\n                                 new syncodecs::TraceBasedCodecWithScaling{\n                                    traceDir,        // path to traces directory\n                                    filePrefix,      // video filename\n                                    SYNCODEC_DEFAULT_FPS,             // Default FPS: 30fps\n                                    true} :          // fixed mode: image resolution doesn't change\n                                 new syncodecs::HybridCodec{\n                                    traceDir,        // path to traces directory\n                                    filePrefix,      // video filename\n                                    SYNCODEC_DEFAULT_FPS,             // Default FPS: 30fps\n                                    true};           // fixed mode: image resolution doesn't change\n\t    m_fps = SYNCODEC_DEFAULT_FPS;\n            codec = new syncodecs::ShapedPacketizer{innerCodec, DEFAULT_PACKET_SIZE};\n            break;\n        }\n        case SYNCODEC_TYPE_SHARING:\n        {\n            auto innerShCodec = new syncodecs::SimpleContentSharingCodec{};\n            codec = new syncodecs::ShapedPacketizer{innerShCodec, DEFAULT_PACKET_SIZE};\n            break;\n        }\n        default:  // defaults to perfect codec\n            codec = new syncodecs::PerfectCodec{DEFAULT_PACKET_SIZE};\n    }\n\n    // update member variable\n    m_codec = std::shared_ptr<syncodecs::Codec>{codec};\n}\n\nvoid RmcatSender::SetController (std::shared_ptr<rmcat::SenderBasedController> controller)\n{\n    m_controller = controller;\n}\n\nvoid RmcatSender::Setup (Ipv4Address destIP,\n                         uint16_t destPort)\n{\n    if (!m_codec) {\n        m_codec = std::make_shared<syncodecs::PerfectCodec> (DEFAULT_PACKET_SIZE);\n    }\n\n    if (!m_controller) {\n        m_controller = std::make_shared<rmcat::DummyController> ();\n    } else {\n        m_controller->reset ();\n    }\n\n    m_destIP = destIP;\n    m_destPort = destPort;\n}\n\nvoid RmcatSender::SetRinit (float r)\n{\n    m_initBw = r;\n    if (m_controller) m_controller->setInitBw (m_initBw);\n}\n\nvoid RmcatSender::SetRmin (float r)\n{\n    m_minBw = r;\n    if (m_controller) m_controller->setMinBw (m_minBw);\n}\n\nvoid RmcatSender::SetRmax (float r)\n{\n    m_maxBw = r;\n    if (m_controller) m_controller->setMaxBw (m_maxBw);\n}\n\nvoid RmcatSender::StartApplication ()\n{\n    m_ssrc = rand ();\n    // RTP initial values for sequence number and timestamp SHOULD be random (RFC 3550)\n    m_sequence = rand ();\n    m_rtpTsOffset = rand ();\n\n    NS_ASSERT (m_minBw <= m_initBw);\n    NS_ASSERT (m_initBw <= m_maxBw);\n\n    m_rVin = m_initBw;\n    m_rSend = m_initBw;\n\n    if (m_socket == NULL) {\n        m_socket = Socket::CreateSocket (GetNode (), UdpSocketFactory::GetTypeId ());\n        auto res = m_socket->Bind ();\n        NS_ASSERT (res == 0);\n    }\n    m_socket->SetRecvCallback (MakeCallback (&RmcatSender::RecvPacket, this));\n\n    m_enqueueEvent = Simulator::Schedule (Seconds (0.0), &RmcatSender::EnqueuePacket, this);\n    m_nextSendTstmpUs = 0;\n}\n\nvoid RmcatSender::StopApplication ()\n{\n    Simulator::Cancel (m_enqueueEvent);\n    Simulator::Cancel (m_sendEvent);\n    Simulator::Cancel (m_sendOversleepEvent);\n    m_rateShapingBuf.clear ();\n    m_rateShapingBytes = 0;\n}\n\nvoid RmcatSender::EnqueuePacket ()\n{\n    syncodecs::Codec& codec = *m_codec;\n    codec.setTargetRate (m_rVin);\n    ++codec; // Advance codec/packetizer to next frame/packet\n    const auto bytesToSend = codec->first.size ();\n    NS_ASSERT (bytesToSend > 0);\n    NS_ASSERT (bytesToSend <= DEFAULT_PACKET_SIZE);\n\n    m_rateShapingBuf.push_back (bytesToSend);\n    m_rateShapingBytes += bytesToSend;\n\n    NS_LOG_INFO (\"RmcatSender::EnqueuePacket, packet enqueued, packet length: \" << bytesToSend\n                 << \", buffer size: \" << m_rateShapingBuf.size ()\n                 << \", buffer bytes: \" << m_rateShapingBytes);\n\n    double secsToNextEnqPacket = codec->second;\n    Time tNext{Seconds (secsToNextEnqPacket)};\n    m_enqueueEvent = Simulator::Schedule (tNext, &RmcatSender::EnqueuePacket, this);\n\n    if (!USE_BUFFER) {\n        m_sendEvent = Simulator::ScheduleNow (&RmcatSender::SendPacket, this,\n                                              secsToNextEnqPacket * 1000. * 1000.);\n        return;\n    }\n\n    if (m_rateShapingBuf.size () == 1) {\n        // Buffer was empty\n        const uint64_t nowUs = Simulator::Now ().GetMicroSeconds ();\n        const uint64_t usToNextSentPacket = nowUs < m_nextSendTstmpUs ?\n                                                    m_nextSendTstmpUs - nowUs : 0;\n        NS_LOG_INFO (\"(Re-)starting the send timer: nowUs \" << nowUs\n                     << \", bytesToSend \" << bytesToSend\n                     << \", usToNextSentPacket \" << usToNextSentPacket\n                     << \", m_rSend \" << m_rSend\n                     << \", m_rVin \" << m_rVin\n                     << \", secsToNextEnqPacket \" << secsToNextEnqPacket);\n\n        Time tNext{MicroSeconds (usToNextSentPacket)};\n        m_sendEvent = Simulator::Schedule (tNext, &RmcatSender::SendPacket, this, usToNextSentPacket);\n    }\n}\n\nvoid RmcatSender::SendPacket (uint64_t usSlept)\n{\n    NS_ASSERT (m_rateShapingBuf.size () > 0);\n    NS_ASSERT (m_rateShapingBytes < MAX_QUEUE_SIZE_SANITY);\n\n    const auto bytesToSend = m_rateShapingBuf.front ();\n    NS_ASSERT (bytesToSend > 0);\n    NS_ASSERT (bytesToSend <= DEFAULT_PACKET_SIZE);\n    m_rateShapingBuf.pop_front ();\n    NS_ASSERT (m_rateShapingBytes >= bytesToSend);\n    m_rateShapingBytes -= bytesToSend;\n\n    NS_LOG_INFO (\"RmcatSender::SendPacket, packet dequeued, packet length: \" << bytesToSend\n                 << \", buffer size: \" << m_rateShapingBuf.size ()\n                 << \", buffer bytes: \" << m_rateShapingBytes);\n\n    // Synthetic oversleep: random uniform [0% .. 1%]\n    uint64_t oversleepUs = usSlept * (rand () % 100) / 10000;\n    Time tOver{MicroSeconds (oversleepUs)};\n    m_sendOversleepEvent = Simulator::Schedule (tOver, &RmcatSender::SendOverSleep,\n                                                this, bytesToSend);\n\n    // schedule next sendData\n    const double usToNextSentPacketD = double (bytesToSend) * 8. * 1000. * 1000. / m_rSend;\n    const uint64_t usToNextSentPacket = uint64_t (usToNextSentPacketD);\n\n    if (!USE_BUFFER || m_rateShapingBuf.size () == 0) {\n        // Buffer became empty\n        const auto nowUs = Simulator::Now ().GetMicroSeconds ();\n        m_nextSendTstmpUs = nowUs + usToNextSentPacket;\n        return;\n    }\n\n    Time tNext{MicroSeconds (usToNextSentPacket)};\n    m_sendEvent = Simulator::Schedule (tNext, &RmcatSender::SendPacket, this, usToNextSentPacket);\n}\n\nvoid RmcatSender::SendOverSleep (uint32_t bytesToSend) {\n    const auto nowUs = Simulator::Now ().GetMicroSeconds ();\n\n    m_controller->processSendPacket (nowUs, m_sequence, bytesToSend);\n\n    ns3::RtpHeader header{96}; // 96: dynamic payload type, according to RFC 3551\n    header.SetSequence (m_sequence++);\n    NS_ASSERT (nowUs >= 0);\n    // Most video payload types in RFC 3551, Table 5, use a 90 KHz clock\n    // Therefore, assuming 90 KHz clock for RTP timestamps\n    header.SetTimestamp (m_rtpTsOffset + uint32_t (nowUs * 90 / 1000));;\n    header.SetSsrc (m_ssrc);\n\n    auto packet = Create<Packet> (bytesToSend);\n    packet->AddHeader (header);\n\n    NS_LOG_INFO (\"RmcatSender::SendOverSleep, \" << packet->ToString ());\n    m_socket->SendTo (packet, 0, InetSocketAddress{m_destIP, m_destPort});\n}\n\nvoid RmcatSender::RecvPacket (Ptr<Socket> socket)\n{\n    Address remoteAddr;\n    auto Packet = m_socket->RecvFrom (remoteAddr);\n    NS_ASSERT (Packet);\n\n    auto rIPAddress = InetSocketAddress::ConvertFrom (remoteAddr).GetIpv4 ();\n    auto rport = InetSocketAddress::ConvertFrom (remoteAddr).GetPort ();\n    NS_ASSERT (rIPAddress == m_destIP);\n    NS_ASSERT (rport == m_destPort);\n\n    // get the feedback header\n    const uint64_t nowUs = Simulator::Now ().GetMicroSeconds ();\n    CCFeedbackHeader header{};\n    NS_LOG_INFO (\"RmcatSender::RecvPacket, \" << Packet->ToString ());\n    Packet->RemoveHeader (header);\n    std::set<uint32_t> ssrcList{};\n    header.GetSsrcList (ssrcList);\n    if (ssrcList.count (m_ssrc) == 0) {\n        NS_LOG_INFO (\"RmcatSender::Received Feedback packet with no data for SSRC \" << m_ssrc);\n        CalcBufferParams (nowUs);\n        return;\n    }\n    std::vector<std::pair<uint16_t,\n                          CCFeedbackHeader::MetricBlock> > feedback{};\n    const bool res = header.GetMetricList (m_ssrc, feedback);\n    NS_ASSERT (res);\n    std::vector<rmcat::SenderBasedController::FeedbackItem> fbBatch{};\n    for (auto& item : feedback) {\n        const rmcat::SenderBasedController::FeedbackItem fbItem{\n            .sequence = item.first,\n            .rxTimestampUs = item.second.m_timestampUs,\n            .ecn = item.second.m_ecn\n        };\n        fbBatch.push_back (fbItem);\n    }\n    m_controller->processFeedbackBatch (nowUs, fbBatch);\n    CalcBufferParams (nowUs);\n}\n\nvoid RmcatSender::CalcBufferParams (uint64_t nowUs)\n{\n    //Calculate rate shaping buffer parameters\n    const auto r_ref = m_controller->getBandwidth (nowUs); // bandwidth in bps\n    float bufferLen;\n    //Purpose: smooth out timing issues between send and receive\n    // feedback for the common case: buffer oscillating between 0 and 1 packets\n    if (m_rateShapingBuf.size () > 1) {\n        bufferLen = static_cast<float> (m_rateShapingBytes);\n    } else {\n        bufferLen = 0;\n    }\n\n    syncodecs::Codec& codec = *m_codec;\n\n    // TODO (deferred): encapsulate rate shaping buffer in a separate class\n    if (USE_BUFFER && static_cast<bool> (codec)) {\n        float r_diff = 8. * bufferLen * m_fps;\n        float r_diff_v = std::min<float>(BETA_V*r_diff, r_ref*0.05);  // limit change to 5% of reference rate\n        float r_diff_s = std::min<float>(BETA_S*r_diff, r_ref*0.05);  // limit change to 5% of reference rate\n        m_rVin = std::max<float> (m_minBw, r_ref - r_diff_v);\n        m_rSend = std::min<float>(m_maxBw, r_ref + r_diff_s);\n        NS_LOG_INFO (\"New rate shaping buffer parameters: r_ref \" << r_ref/1000. // in Kbps\n                     << \", m_rVin \" << m_rVin/1000.\n                     << \", m_rSend \" << m_rSend/1000.\n                     << \", fps \" << m_fps\n                     << \", buffer length \" << bufferLen);  // in Bytes\n    } else {\n        m_rVin = r_ref;\n        m_rSend = r_ref;\n    }\n}\n\n}\n"
    },
    {
      "file_path": "model/topo/topo.cc",
      "code": "/******************************************************************************\n * Copyright 2016-2017 Cisco Systems, Inc.                                    *\n *                                                                            *\n * Licensed under the Apache License, Version 2.0 (the \"License\");            *\n * you may not use this file except in compliance with the License.           *\n *                                                                            *\n * You may obtain a copy of the License at                                    *\n *                                                                            *\n *     http://www.apache.org/licenses/LICENSE-2.0                             *\n *                                                                            *\n * Unless required by applicable law or agreed to in writing, software        *\n * distributed under the License is distributed on an \"AS IS\" BASIS,          *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *\n * See the License for the specific language governing permissions and        *\n * limitations under the License.                                             *\n ******************************************************************************/\n\n/**\n * @file\n * Common network topology setup implementation for rmcat ns3 module.\n *\n * @version 0.1.1\n * @author Jiantao Fu\n * @author Sergio Mena\n * @author Xiaoqing Zhu\n */\n\n#include \"topo.h\"\n#include \"ns3/rmcat-sender.h\"\n#include \"ns3/rmcat-receiver.h\"\n#include \"ns3/nada-controller.h\"\n#include <memory>\n#include <limits>\n#include <sys/stat.h>\n\nNS_LOG_COMPONENT_DEFINE (\"Topo\");\n\nnamespace ns3 {\n\n/* Implementations of utility functions */\n\nstatic Ipv4Address GetIpv4AddressOfNode (Ptr<Node> node,\n                                         uint32_t interface,\n                                         uint32_t addressIndex)\n{\n    // interface index 0 is the loopback\n    auto ipv4 = node->GetObject<Ipv4> ();\n    auto iaddr = ipv4->GetAddress (interface, addressIndex);\n    return iaddr.GetLocal ();\n}\n\n\nstatic std::string GetPrefix (Ptr<Node> node,\n                              const std::string& logName,\n                              const std::string& flowId,\n                              uint16_t port=0)\n{\n    std::ostringstream os;\n    os << \"[\";\n    GetIpv4AddressOfNode (node, 1, 0).Print (os);\n    os << \":\" << port << \"] \" << logName << \": \" << flowId;\n    return os.str ();\n}\n\nstatic Time GetIntervalFromBitrate (uint64_t bitrate, uint32_t packetSize)\n{\n    if (bitrate == 0u) {\n        return Time::Max ();\n    }\n    const auto secs = static_cast<double> (packetSize + IPV4_UDP_OVERHEAD) /\n                            (static_cast<double> (bitrate) / 8. );\n    return Seconds (secs);\n}\n\nstatic void PacketSinkLogging (const std::string& nameAndId,\n                               Ptr<Application> app,\n                               double interval,\n                               uint32_t oldRecv)\n{\n    TimeValue startT, stopT;\n    app->GetAttribute (\"StartTime\", startT);\n    app->GetAttribute (\"StopTime\", stopT);\n    const auto now = Simulator::Now ().GetMilliSeconds ();\n    const auto start = startT.Get ().GetMilliSeconds ();\n    const auto stop = stopT.Get ().GetMilliSeconds ();\n    auto recv = oldRecv;\n    if (start <= now &&  now <= stop) {\n        Ptr<PacketSink> sink = DynamicCast<PacketSink> (app);\n        recv = sink->GetTotalRx ();\n        std::ostringstream os;\n        os << std::fixed;\n        os.precision (4);\n        os << nameAndId << \" ts: \" << now\n           << \" recv: \" << recv // Number of bytes received so far for this flow\n           << \" rrate: \" << static_cast<double> (recv - oldRecv) / interval * 8.;\n                                                // Subtraction will wrap properly\n        NS_LOG_INFO (os.str ());\n    }\n    Time tNext{Seconds (interval)};\n    Simulator::Schedule (tNext, &PacketSinkLogging, nameAndId, app, interval, recv);\n}\n\n\n/*\n * Implementations of:\n * -- InstallTCP\n * -- InstallCBR\n * -- InstallRMCAT\n */\n\nApplicationContainer Topo::InstallTCP (const std::string& flowId,\n                                       Ptr<Node> sender,\n                                       Ptr<Node> receiver,\n                                       uint16_t serverPort)\n{\n    BulkSendHelper source (\"ns3::TcpSocketFactory\",\n                           InetSocketAddress{GetIpv4AddressOfNode (receiver, 1, 0), serverPort});\n\n    // Set the amount of data to send in bytes. Zero denotes unlimited.\n    source.SetAttribute (\"MaxBytes\", UintegerValue (0));\n    source.SetAttribute (\"SendSize\", UintegerValue (DEFAULT_PACKET_SIZE));\n\n    auto clientApps = source.Install (sender);\n    clientApps.Start (Seconds (0));\n    clientApps.Stop (Seconds (T_MAX_S));\n\n    PacketSinkHelper sink (\"ns3::TcpSocketFactory\",\n                           InetSocketAddress{Ipv4Address::GetAny (), serverPort});\n    auto serverApps = sink.Install (receiver);\n    serverApps.Start (Seconds (0));\n    serverApps.Stop (Seconds (T_MAX_S));\n\n    const auto interval = T_TCP_LOG;\n    Simulator::Schedule (Seconds (interval),\n                         &PacketSinkLogging,\n                         GetPrefix (sender, \"tcp_log\", flowId, serverPort),\n                         serverApps.Get (0),\n                         interval,\n                         0);\n\n    ApplicationContainer apps;\n    apps.Add (clientApps);\n    apps.Add (serverApps);\n    return apps;\n}\n\n\nApplicationContainer Topo::InstallCBR (Ptr<Node> sender,\n                                       Ptr<Node> receiver,\n                                       uint16_t serverPort,\n                                       uint64_t bitrate,\n                                       uint32_t packetSize)\n{\n    UdpServerHelper server (serverPort);\n    ApplicationContainer serverApps = server.Install (receiver);\n    serverApps.Start (Seconds (0));\n    serverApps.Stop (Seconds (T_MAX_S));\n\n    const auto interPacketInterval = GetIntervalFromBitrate (bitrate, packetSize);\n    const auto maxPacketCount = std::numeric_limits<uint32_t>::max ();\n    UdpClientHelper client (GetIpv4AddressOfNode (receiver, 1, 0), serverPort);\n    client.SetAttribute (\"MaxPackets\", UintegerValue (maxPacketCount));\n    client.SetAttribute (\"Interval\", TimeValue (interPacketInterval));\n    client.SetAttribute (\"PacketSize\", UintegerValue (packetSize));\n    ApplicationContainer clientApps = client.Install (sender);\n    clientApps.Start (Seconds (0));\n    clientApps.Stop (Seconds (T_MAX_S));\n\n    ApplicationContainer apps;\n    apps.Add (clientApps);\n    apps.Add (serverApps);\n    return apps;\n}\n\nApplicationContainer Topo::InstallRMCAT (const std::string& flowId,\n                                         Ptr<Node> sender,\n                                         Ptr<Node> receiver,\n                                         uint16_t serverPort)\n{\n\n    auto rmcatAppSend = CreateObject<RmcatSender> ();\n    auto rmcatAppRecv = CreateObject<RmcatReceiver> ();\n    sender->AddApplication (rmcatAppSend);\n    receiver->AddApplication (rmcatAppRecv);\n\n    Ipv4Address serverIP = GetIpv4AddressOfNode (receiver, 1, 0);\n    rmcatAppSend->Setup (serverIP, serverPort);\n\n    /* configure congestion controller */\n    auto controller = std::make_shared<rmcat::NadaController> ();\n    controller->setLogCallback (logFromController);\n    controller->setId (flowId);\n    rmcatAppSend->SetController (controller);\n\n    rmcatAppSend->SetStartTime (Seconds (0));\n    rmcatAppSend->SetStopTime (Seconds (T_MAX_S));\n\n    rmcatAppRecv->Setup (serverPort);\n    rmcatAppRecv->SetStartTime (Seconds (0));\n    rmcatAppRecv->SetStopTime (Seconds (T_MAX_S));\n\n    ApplicationContainer apps;\n    apps.Add (rmcatAppSend);\n    apps.Add (rmcatAppRecv);\n    return apps;\n}\n\nvoid Topo::logFromController (const std::string& msg) {\n    NS_LOG_INFO (\"controller_log: \" << msg);\n}\n\n}\n"
    },
    {
      "file_path": "model/topo/wifi-topo.cc",
      "code": "/******************************************************************************\n * Copyright 2016-2017 Cisco Systems, Inc.                                    *\n *                                                                            *\n * Licensed under the Apache License, Version 2.0 (the \"License\");            *\n * you may not use this file except in compliance with the License.           *\n *                                                                            *\n * You may obtain a copy of the License at                                    *\n *                                                                            *\n *     http://www.apache.org/licenses/LICENSE-2.0                             *\n *                                                                            *\n * Unless required by applicable law or agreed to in writing, software        *\n * distributed under the License is distributed on an \"AS IS\" BASIS,          *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *\n * See the License for the specific language governing permissions and        *\n * limitations under the License.                                             *\n ******************************************************************************/\n\n/**\n * @file\n * Wifi network topology setup for rmcat ns3 module.\n *\n * @version 0.1.1\n * @author Jiantao Fu\n * @author Sergio Mena\n * @author Xiaoqing Zhu\n */\n\n#include \"wifi-topo.h\"\n#include <utility>\n\nnamespace ns3 {\n\nWifiTopo::~WifiTopo () {}\n\nvoid WifiTopo::Build (uint64_t bandwidthBps,\n                      uint32_t msDelay,\n                      uint32_t msQDelay,\n                      uint32_t nWifi,\n                      WifiPhyStandard standard,\n                      WifiMode rateMode)\n{\n    // Set up wired link\n    m_wiredNodes.Create (2);\n    PointToPointHelper wiredLinkHlpr;\n    wiredLinkHlpr.SetDeviceAttribute (\"DataRate\", DataRateValue (DataRate (bandwidthBps)));\n    wiredLinkHlpr.SetChannelAttribute (\"Delay\", TimeValue (MilliSeconds (msDelay)));\n\n    uint32_t bufSize = bandwidthBps * msQDelay / 8 / 1000;\n    // At least one full packet with default size must fit\n    NS_ASSERT (bufSize >= DEFAULT_PACKET_SIZE + IPV4_UDP_OVERHEAD);\n    wiredLinkHlpr.SetQueue (\"ns3::DropTailQueue\",\n                            \"Mode\", StringValue (\"QUEUE_MODE_BYTES\"),\n                            \"MaxBytes\", UintegerValue (bufSize));\n\n    m_wiredDevices = wiredLinkHlpr.Install (m_wiredNodes);\n\n    //Uncomment the line below to ease troubleshooting\n    //wiredLinkHlpr.EnablePcapAll (\"WifiTopo-wired\");\n\n    // Config global settings for wifi mac queue\n    Config::SetDefault (\"ns3::WifiMacQueue::MaxPacketNumber\", UintegerValue (WIFI_TOPO_MACQUEUE_MAXNPKTS));\n    Config::SetDefault (\"ns3::WifiMacQueue::MaxDelay\", TimeValue (MilliSeconds (msQDelay)));\n\n    // Workaround for the arp bug, https://groups.google.com/forum/#!topic/ns-3-users/TiY9IUFnrZ4\n    // http://mailman.isi.edu/pipermail/ns-developers/2007-November/003549.html\n    // https://www.nsnam.org/bugzilla/show_bug.cgi?id=2057\n    Config::SetDefault (\"ns3::ArpCache::AliveTimeout\", TimeValue (Seconds (WIFI_TOPO_ARPCACHE_ALIVE_TIMEOUT)));\n\n    m_wifiStaNodes.Create (nWifi);\n    m_wifiApNode = m_wiredNodes.Get (0);\n\n    // Create channel\n    YansWifiPhyHelper wifiPhyHelper = YansWifiPhyHelper::Default ();\n    wifiPhyHelper.Set (\"ChannelNumber\",UintegerValue (6));\n    YansWifiChannelHelper wifiChannelHelper = YansWifiChannelHelper::Default ();\n    wifiChannelHelper.SetPropagationDelay (\"ns3::ConstantSpeedPropagationDelayModel\");\n\n    // reference loss must be changed when operating at 2.4GHz\n    if (standard == WIFI_PHY_STANDARD_80211n_2_4GHZ) {\n        wifiChannelHelper.AddPropagationLoss (\"ns3::LogDistancePropagationLossModel\",\n                                              \"Exponent\", DoubleValue (WIFI_TOPO_2_4GHZ_PATHLOSS_EXPONENT),\n                                              \"ReferenceLoss\", DoubleValue (WIFI_TOPO_2_4GHZ_PATHLOSS_REFLOSS));\n    }\n    wifiPhyHelper.SetChannel (wifiChannelHelper.Create ());\n\n    bool qos = false;\n    bool ht = false;\n    uint32_t channelWidth = WIFI_TOPO_CHANNEL_WIDTH;\n    // Set guard interval, qos and ht for 802.11 and ac\n    if ( standard == WIFI_PHY_STANDARD_80211n_5GHZ \\\n        || standard == WIFI_PHY_STANDARD_80211n_2_4GHZ \\\n        || standard == WIFI_PHY_STANDARD_80211ac\n       ) {\n        wifiPhyHelper.Set (\"ShortGuardEnabled\", BooleanValue (false));\n        // Set MIMO capabilities for high rate, see YansWifiPhy::ConfigureHtDeviceMcsSet\n        wifiPhyHelper.Set (\"TxAntennas\", UintegerValue (8));\n        wifiPhyHelper.Set (\"RxAntennas\", UintegerValue (8));\n\n        qos = ht = true;\n    }\n\n    wifiPhyHelper.SetPcapDataLinkType (YansWifiPhyHelper::DLT_IEEE802_11_RADIO);\n\n    //Uncomment the line below to ease troubleshooting\n    //wifiPhyHelper.EnablePcapAll (\"WifiTopo-wifi\");\n\n    // Create wireless channel, see wifi-phy-standard.h\n    m_wifi.SetStandard (standard);\n\n    // See wifi-phy.h\n    if (rateMode.GetUid () == 0) {\n        m_wifi.SetRemoteStationManager (\"ns3::MinstrelHtWifiManager\");\n    } else {\n        m_wifi.SetRemoteStationManager (\"ns3::ConstantRateWifiManager\",\n                                        \"DataMode\", StringValue (rateMode.GetUniqueName ()),\n                                        \"ControlMode\", StringValue (rateMode.GetUniqueName ()));\n    }\n\n    // Uncomment the line below for debugging purposes\n    // EnableWifiLogComponents ();\n\n    Packet::EnablePrinting ();\n\n    // Install phy and mac\n    Ssid ssid = Ssid (\"ns-3-ssid\");\n\n    WifiMacHelper wifiMacHelper;\n\n    // Set up station\n    wifiMacHelper.SetType (\"ns3::StaWifiMac\",\n                           \"Ssid\", SsidValue (ssid),\n                           \"ActiveProbing\", BooleanValue (false),\n                           \"QosSupported\", BooleanValue (qos),\n                           \"HtSupported\", BooleanValue (ht));\n    m_staDevices = m_wifi.Install (wifiPhyHelper, wifiMacHelper, m_wifiStaNodes);\n\n    // Set up AP\n    wifiMacHelper.SetType (\"ns3::ApWifiMac\",\n                           \"Ssid\", SsidValue (ssid),\n                           \"QosSupported\", BooleanValue (qos),\n                           \"HtSupported\", BooleanValue (ht));\n    m_apDevices = m_wifi.Install (wifiPhyHelper, wifiMacHelper, m_wifiApNode);\n\n    // Set channel width\n    Config::Set (\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/ChannelWidth\",\n                 UintegerValue (channelWidth));\n\n    // Configure mobility\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();\n    for (uint32_t i = 0; i < nWifi; ++i) {\n        positionAlloc->Add (Vector (1.0, 0.0, 0.0));\n    }\n    positionAlloc->Add (Vector (0.0, 0.0, 0.0));\n    mobility.SetPositionAllocator (positionAlloc);\n    mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install (m_wifiStaNodes);\n    mobility.Install (m_wifiApNode);\n\n    // install protocol stack\n    InternetStackHelper stack;\n    stack.Install (m_wifiStaNodes);\n    stack.Install (m_wiredNodes);\n\n    Ipv4AddressHelper address;\n\n    address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n    address.Assign (m_wiredDevices);\n\n    address.SetBase (\"10.1.2.0\", \"255.255.255.0\");\n    address.Assign (m_staDevices);\n    address.Assign (m_apDevices);\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables ();\n\n    // Disable tc now, some bug in ns3 cause extra delay\n    TrafficControlHelper tch;\n    tch.Uninstall (m_wiredDevices);\n    tch.Uninstall (m_staDevices);\n    tch.Uninstall (m_apDevices);\n}\n\nApplicationContainer WifiTopo::InstallTCP (const std::string& flowId,\n                                           uint32_t nodeId,\n                                           uint16_t serverPort,\n                                           bool downstream)\n{\n    NS_ASSERT (nodeId <  m_wifiStaNodes.GetN ());\n\n    auto sender = m_wifiStaNodes.Get (nodeId);\n    auto receiver = m_wiredNodes.Get (1);\n\n    if (downstream) {\n        std::swap (sender, receiver);\n    }\n\n    return Topo::InstallTCP (flowId,\n                             sender,\n                             receiver,\n                             serverPort);\n}\n\nApplicationContainer WifiTopo::InstallCBR (uint32_t nodeId,\n                                           uint16_t serverPort,\n                                           uint64_t bitrate,\n                                           uint32_t packetSize,\n                                           bool downstream)\n{\n    NS_ASSERT (nodeId <  m_wifiStaNodes.GetN ());\n\n    auto sender = m_wifiStaNodes.Get (nodeId);\n    auto receiver = m_wiredNodes.Get (1);\n    if (downstream) {\n        std::swap (sender, receiver);\n    }\n\n    return Topo::InstallCBR (sender,\n                             receiver,\n                             serverPort,\n                             bitrate,\n                             packetSize);\n}\n\n\nApplicationContainer WifiTopo::InstallRMCAT (const std::string& flowId,\n                                             uint32_t nodeId,\n                                             uint16_t serverPort,\n                                             bool downstream)\n{\n    NS_ASSERT (nodeId <  m_wifiStaNodes.GetN ());\n\n    auto sender = m_wifiStaNodes.Get (nodeId);\n    auto receiver = m_wiredNodes.Get (1);\n    if (downstream) {\n        std::swap (sender, receiver);\n    }\n\n    return Topo::InstallRMCAT (flowId,\n                               sender,\n                               receiver,\n                               serverPort);\n}\n\nVector WifiTopo::GetPosition (uint32_t idx) const\n{\n    auto node = m_wifiStaNodes.Get (idx);\n    auto mobility = node->GetObject<MobilityModel> ();\n    return mobility->GetPosition ();\n}\n\nvoid WifiTopo::SetPosition (uint32_t idx, const Vector& position)\n{\n    auto node = m_wifiStaNodes.Get (idx);\n    auto mobility = node->GetObject<MobilityModel> ();\n    mobility->SetPosition (position);\n}\n\nvoid WifiTopo::EnableWifiLogComponents ()\n{\n    LogLevel l = (LogLevel)(LOG_LEVEL_ALL|LOG_PREFIX_TIME|LOG_PREFIX_NODE);\n\n    const char* components[] = {\n            // For debugging packet loss\n            \"UdpSocketImpl\",\n            \"Ipv4L3Protocol\",\n            \"Ipv4Interface\",\n            \"ArpL3Protocol\",\n            \"ArpCache\",\n            // Wifi-related\n            \"WifiNetDevice\",\n            \"Aarfcd\",\n            \"AdhocWifiMac\",\n            \"AmrrWifiRemoteStation\",\n            \"ApWifiMac\",\n            \"ArfWifiManager\",\n            \"Cara\",\n            \"DcaTxop\",\n            \"DcfManager\",\n            \"DsssErrorRateModel\",\n            \"EdcaTxopN\",\n            \"InterferenceHelper\",\n            \"Jakes\",\n            \"MacLow\",\n            \"MacRxMiddle\",\n            \"MsduAggregator\",\n            \"MsduStandardAggregator\",\n            \"NistErrorRateModel\",\n            \"OnoeWifiRemoteStation\",\n            \"PropagationLossModel\",\n            \"RegularWifiMac\",\n            \"RraaWifiManager\",\n            \"StaWifiMac\",\n            \"SupportedRates\",\n            \"WifiChannel\",\n            \"WifiPhyStateHelper\",\n            \"WifiPhy\",\n            \"WifiRemoteStationManager\",\n            \"YansErrorRateModel\",\n            \"YansWifiChannel\",\n            \"YansWifiPhy\",\n        };\n\n    for (size_t i = 0; i < sizeof (components) / sizeof (components[0]); i++) {\n        LogComponentEnable (components[i], l);\n    }\n}\n\n}\n"
    },
    {
      "file_path": "model/topo/wired-topo.cc",
      "code": "/******************************************************************************\n * Copyright 2016-2017 Cisco Systems, Inc.                                    *\n *                                                                            *\n * Licensed under the Apache License, Version 2.0 (the \"License\");            *\n * you may not use this file except in compliance with the License.           *\n *                                                                            *\n * You may obtain a copy of the License at                                    *\n *                                                                            *\n *     http://www.apache.org/licenses/LICENSE-2.0                             *\n *                                                                            *\n * Unless required by applicable law or agreed to in writing, software        *\n * distributed under the License is distributed on an \"AS IS\" BASIS,          *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *\n * See the License for the specific language governing permissions and        *\n * limitations under the License.                                             *\n ******************************************************************************/\n\n/**\n * @file\n * Wired network topology setup implementation for rmcat ns3 module.\n *\n * @version 0.1.1\n * @author Jiantao Fu\n * @author Sergio Mena\n * @author Xiaoqing Zhu\n */\n\n#include \"wired-topo.h\"\n\nnamespace ns3 {\n\nWiredTopo::WiredTopo ()\n: m_numApps{0},\n  m_bufSize{0}\n{}\n\nWiredTopo::~WiredTopo ()\n{}\n\nvoid WiredTopo::Build (uint64_t bandwidthBps, uint32_t msDelay, uint32_t msQDelay)\n{\n    // Set up bottleneck link\n    m_bottleneckNodes.Create (2);\n    PointToPointHelper bottleneckLinkHlpr;\n    bottleneckLinkHlpr.SetDeviceAttribute (\"DataRate\", DataRateValue (DataRate (bandwidthBps)));\n\n    // We set the the bottleneck link's propagation delay to 90% of the total delay\n    bottleneckLinkHlpr.SetChannelAttribute (\"Delay\", TimeValue (MicroSeconds (msDelay * 1000 * 9 / 10)));\n    m_bufSize = bandwidthBps * msQDelay / 8 / 1000;\n    // At least one full packet with default size must fit\n    NS_ASSERT (m_bufSize >= DEFAULT_PACKET_SIZE + IPV4_UDP_OVERHEAD);\n\n    bottleneckLinkHlpr.SetQueue (\"ns3::DropTailQueue\",\n                                 \"Mode\", StringValue (\"QUEUE_MODE_BYTES\"),\n                                 \"MaxBytes\", UintegerValue (m_bufSize));\n\n    m_bottleneckDevices = bottleneckLinkHlpr.Install (m_bottleneckNodes);\n\n    //Uncomment the line below to ease troubleshooting\n    //bottleneckLinkHlpr.EnablePcapAll (\"rmcat-wired-capture\", true);\n\n    m_inetStackHlpr.Install (m_bottleneckNodes);\n    Ipv4AddressHelper address;\n    address.SetBase (\"12.0.1.0\", \"255.255.255.0\");\n    address.Assign (m_bottleneckDevices);\n\n    // Set up helpers for applications\n    NS_ASSERT (m_numApps == 0);\n    m_appLinkHlpr.SetDeviceAttribute (\"DataRate\", DataRateValue (DataRate (1u << 30))); // 1 Gbps\n\n    // We set the application link's propagation delay (one on each side of the bottleneck)\n    // to 5% of the total delay\n    m_appLinkHlpr.SetChannelAttribute (\"Delay\", TimeValue (MicroSeconds (msDelay * 1000 * 5 / 100)));\n\n    // Set queue to drop-tail, but don't care much about buffer size\n    m_appLinkHlpr.SetQueue (\"ns3::DropTailQueue\",\n                            \"Mode\", StringValue (\"QUEUE_MODE_BYTES\"),\n                            \"MaxBytes\", UintegerValue (m_bufSize));\n\n    // Disable tc now, some bug in ns3 causes extra delay\n    TrafficControlHelper tch;\n    tch.Uninstall (m_bottleneckDevices);\n\n    Packet::EnablePrinting ();\n}\n\nApplicationContainer WiredTopo::InstallTCP (const std::string& flowId,\n                                            uint16_t serverPort,\n                                            bool newNode)\n{\n    auto appNodes = SetupAppNodes (0, newNode);\n    auto sender = appNodes.Get (0);\n    auto receiver = appNodes.Get (1);\n\n    return Topo::InstallTCP (flowId, sender, receiver, serverPort);\n}\n\nApplicationContainer WiredTopo::InstallCBR (uint16_t serverPort,\n                                            uint32_t bitrate,\n                                            uint32_t packetSize,\n                                            bool forward)\n{\n    // At least one packet must fit in the bottleneck link's queue\n    NS_ASSERT (m_bufSize >= packetSize + IPV4_UDP_OVERHEAD);\n\n    auto appNodes = SetupAppNodes (0, true);\n    auto sender = appNodes.Get (1);\n    auto receiver = appNodes.Get (0);\n    if (forward) {\n        std::swap (sender, receiver);\n    }\n\n    return Topo::InstallCBR (sender,\n                             receiver,\n                             serverPort,\n                             bitrate,\n                             packetSize);\n}\n\nApplicationContainer WiredTopo::InstallRMCAT (const std::string& flowId,\n                                              uint16_t serverPort,\n                                              uint32_t pDelayMs,\n                                              bool forward)\n{\n    auto appNodes = SetupAppNodes (pDelayMs, true);\n\n    auto sender = appNodes.Get (1);\n    auto receiver = appNodes.Get (0);\n    if (forward) {\n        std::swap (sender, receiver);\n    }\n\n    return Topo::InstallRMCAT (flowId,\n                               sender,\n                               receiver,\n                               serverPort);\n}\n\nvoid WiredTopo::SetupAppNode (Ptr<Node> node, int bottleneckIdx, uint32_t pDelayMs)\n{\n    NodeContainer nodes (node, m_bottleneckNodes.Get (bottleneckIdx));\n    auto devices = m_appLinkHlpr.Install (nodes);\n    if (pDelayMs > 0) {\n        Ptr<PointToPointChannel> channel = DynamicCast<PointToPointChannel> (devices.Get (0)->GetChannel ());\n        TimeValue delay;\n        channel->GetAttribute (\"Delay\", delay);\n        const uint64_t us = delay.Get ().GetMicroSeconds ();\n        // variable us is 5% of the total base delay\n        const uint64_t total = us * 100 / 5;\n        NS_ASSERT (us <= total);\n        NS_ASSERT (total - us <= pDelayMs * 1000);\n        delay.Set (MicroSeconds (pDelayMs * 1000 - (total - us)));\n        channel->SetAttribute (\"Delay\", delay);\n    }\n    Ipv4AddressHelper address;\n    std::ostringstream stringStream;\n    const unsigned x = (m_numApps + 1) / 256;\n    const unsigned y = (m_numApps + 1) % 256;\n    stringStream << (10 + bottleneckIdx) << \".\" << x << \".\" << y << \".0\";\n    address.SetBase (stringStream.str ().c_str (), \"255.255.255.0\");\n    address.Assign (devices);\n\n    TrafficControlHelper tch;\n    tch.Uninstall (devices);\n\n    //Uncomment the lines below to ease troubleshooting\n    //if (bottleneckIdx == 0) {\n    //    std::ostringstream stringStream0;\n    //    stringStream0 << \"rmcat-wired-app-capture\" << m_numApps;\n    //    m_appLinkHlpr.EnablePcap (stringStream0.str (), devices, true);\n    //}\n}\n\nNodeContainer WiredTopo::SetupAppNodes (uint32_t pDelayMs, bool newNode)\n{\n    if (newNode) {\n        NodeContainer appNodes;\n        appNodes.Create (2);\n        m_inetStackHlpr.Install (appNodes);\n        SetupAppNode (appNodes.Get (0), 0, pDelayMs);\n        SetupAppNode (appNodes.Get (1), 1, 0);\n        ++m_numApps;\n        m_appNodes = appNodes;\n    }\n    // The first time we set up a flow, newNode must be true\n    NS_ASSERT (m_numApps > 0);\n    return m_appNodes;\n}\n\n}\n"
    },
    {
      "file_path": "test/rmcat-common-test.cc",
      "code": "/******************************************************************************\n * Copyright 2016-2017 Cisco Systems, Inc.                                    *\n *                                                                            *\n * Licensed under the Apache License, Version 2.0 (the \"License\");            *\n * you may not use this file except in compliance with the License.           *\n *                                                                            *\n * You may obtain a copy of the License at                                    *\n *                                                                            *\n *     http://www.apache.org/licenses/LICENSE-2.0                             *\n *                                                                            *\n * Unless required by applicable law or agreed to in writing, software        *\n * distributed under the License is distributed on an \"AS IS\" BASIS,          *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *\n * See the License for the specific language governing permissions and        *\n * limitations under the License.                                             *\n ******************************************************************************/\n\n/**\n * @file\n * Base class implementation for testing rmcat ns3 module.\n *\n * @version 0.1.1\n * @author Jiantao Fu\n * @author Sergio Mena\n * @author Xiaoqing Zhu\n */\n\n#include \"rmcat-common-test.h\"\n#include \"ns3/log.h\"\n\nusing namespace ns3;\n\n/* Base class of RMCAT test cases: constructor */\nRmcatTestCase::RmcatTestCase (uint64_t capacity,\n                              uint32_t delay,\n                              uint32_t qdelay,\n                              std::string desc)\n: TestCase{desc}\n, m_debug{false}\n, m_sb{NULL}\n, m_capacity{capacity}   // bottleneck capacity\n, m_delay{delay}         // one-way propagation delay\n, m_qdelay{qdelay}       // bottleneck queue depth\n{\n\n    // name of log file same as test case descriptions\n    std::stringstream ss;\n    ss << desc << \".log\";\n    m_logfile = ss.str ();\n}\n\nvoid RmcatTestCase::DoSetup ()\n{\n    // configure logging level\n    LogLevel l = (LogLevel)(LOG_LEVEL_INFO |\n                            LOG_PREFIX_TIME |\n                            LOG_PREFIX_NODE);\n    LogComponentEnable (\"Topo\", l);\n\n    if (m_debug) {\n        LogComponentEnable (\"OnOffApplication\", l);\n        LogComponentEnable (\"UdpClient\", l);\n        LogComponentEnable (\"BulkSendApplication\", l);\n        LogComponentEnable (\"V4Ping\", l);\n        LogComponentEnable (\"RmcatSender\", l);\n        LogComponentEnable (\"RmcatReceiver\", l);\n    }\n\n    // open output file stream and corresponding streaming buffer\n    // for logging\n    m_ofs.open (m_logfile.c_str (), std::ios_base::out);\n    m_sb = std::clog.rdbuf (m_ofs.rdbuf ());\n}\n\nvoid RmcatTestCase::DoTeardown ()\n{\n    // close up output file stream\n    std::clog.rdbuf (m_sb);\n    m_ofs.close ();\n}\n"
    },
    {
      "file_path": "test/rmcat-wifi-test-case.cc",
      "code": "/******************************************************************************\n * Copyright 2016-2017 Cisco Systems, Inc.                                    *\n *                                                                            *\n * Licensed under the Apache License, Version 2.0 (the \"License\");            *\n * you may not use this file except in compliance with the License.           *\n *                                                                            *\n * You may obtain a copy of the License at                                    *\n *                                                                            *\n *     http://www.apache.org/licenses/LICENSE-2.0                             *\n *                                                                            *\n * Unless required by applicable law or agreed to in writing, software        *\n * distributed under the License is distributed on an \"AS IS\" BASIS,          *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *\n * See the License for the specific language governing permissions and        *\n * limitations under the License.                                             *\n ******************************************************************************/\n\n/**\n * @file\n * Common template for rmcat wifi test cases.\n *\n * This file contains implementation of the\n * RmcatWifiTestCase class. It defines the\n * common template for individual rmcat-wifi\n * test cases as specified in Section 4 of the\n * following IETF draft:\n *\n * Evaluation Test Cases for Interactive Real-Time\n * Media over Wireless Networks\n * https://tools.ietf.org/html/draft-ietf-rmcat-wireless-tests-04\n *\n * @version 0.1.1\n * @author Jiantao Fu\n * @author Sergio Mena\n * @author Xiaoqing Zhu\n */\n\n#include \"rmcat-wifi-test-case.h\"\n\nNS_LOG_COMPONENT_DEFINE (\"RmcatSimTestWifi\");\n\n/*\n * Implement common procedures in setting up a\n * rmcat-wifi test case:\n * -- configuration of network topology, including\n *    number of wired and wireless nodes;\n * -- configuration of capacity and propagation\n *    delay of the wired connection\n * -- configuration of PHY- and MAC-layer parameters\n *    for the wireless connections\n * -- configuration of traversing traffic flows\n *    in terms of traffic type (i.e., RMCAT/TCP/UDP),\n *    arrival and departure patterns\n */\n\n/* Constructor */\nRmcatWifiTestCase::RmcatWifiTestCase (uint64_t capacity, // wired link capacity (in bps)\n                                      uint32_t pdelay,   // wired link forward propagation delay (in ms)\n                                      uint32_t qdelay,   // wired link queue depth (in ms)\n                                      std::string desc)  // test case name/description\n: RmcatTestCase{capacity, pdelay, qdelay, desc}\n, m_nWifi{2}  // default: a pair of bi-directional RMCAT flows\n, m_nDnRMCAT{1}\n, m_nUpRMCAT{1}\n, m_nDnTCP{0}\n, m_nUpTCP{0}\n, m_nDnCBR{0}\n, m_nUpCBR{0}\n, m_rCBR{0}\n, m_simTime{RMCAT_TC_SIMTIME}\n, m_codecType{SYNCODEC_TYPE_FIXFPS}\n, m_phyMode{WifiMode (\"HtMcs11\")}\n{}\n\n\n/**\n * Configure RMCAT flows in terms of:\n * -- direction (downlink/uplink)\n * -- arrival/departure times\n */\nvoid RmcatWifiTestCase::SetRMCATFlows (size_t numFlows,\n                                       const std::vector<uint32_t>& startTimes,\n                                       const std::vector<uint32_t>& endTimes,\n                                       bool fwd)\n{\n    if (fwd) {\n        // configure downlink flows\n        m_nDnRMCAT   = numFlows;\n        m_startTDnRMCAT = startTimes;\n        m_finisTDnRMCAT = endTimes;\n    } else {\n        // configure uplink flows\n        m_nUpRMCAT = numFlows;\n        m_startTUpRMCAT  = startTimes;\n        m_finisTUpRMCAT = endTimes;\n    }\n}\n\n/**\n * Configure long lived TCP background flows\n * in terms of:\n * -- direction (downlink/uplink)\n * -- arrival/departure times\n */\nvoid RmcatWifiTestCase::SetTCPFlows (size_t numFlows,\n                                     const std::vector<uint32_t>& startTimes,\n                                     const std::vector<uint32_t>& endTimes,\n                                     bool fwd)\n{\n    if (fwd) {\n        // configure downlink flows\n        m_nDnTCP   = numFlows;\n        m_startTDnTCP = startTimes;\n        m_finisTDnTCP = endTimes;\n    } else {\n        // configure uplink flows\n        m_nUpTCP = numFlows;\n        m_startTUpTCP = startTimes;\n        m_finisTUpTCP = endTimes;\n    }\n}\n\n/*\n * Configure CBR-over-UDP background flows\n * in terms of:\n * -- direction (downlink/uplink)\n * -- arrival/departure times\n */\nvoid RmcatWifiTestCase::SetUDPFlows (size_t numFlows,\n                                     const std::vector<uint32_t>& startTimes,\n                                     const std::vector<uint32_t>& endTimes,\n                                     bool fwd)\n{\n    if (fwd) {\n        // configure downlink flows\n        m_nDnCBR   = numFlows;\n        m_startTDnCBR = startTimes;\n        m_finisTDnCBR = endTimes;\n    } else {\n        // configure uplink flows\n        m_nUpCBR = numFlows;\n        m_startTUpCBR = startTimes;\n        m_finisTUpCBR = endTimes;\n    }\n}\n\n\n/**\n * Instantiate RMCAT flows\n */\nvoid RmcatWifiTestCase::SetUpRMCAT (std::vector<Ptr<RmcatSender> >& send,\n                                    bool fwd)\n{\n    size_t numFlows = fwd ? m_nDnRMCAT : m_nUpRMCAT;\n    const uint32_t basePort = RMCAT_TC_RMCAT_PORT + (fwd ? 0: 1000);\n    const auto nRmcatBase = (fwd ? 0 : m_nDnRMCAT);\n    std::stringstream ss0;\n    if (fwd) {\n        ss0 << \"rmcatDn_\";\n    } else {\n        ss0 << \"rmcatUp_\";\n    }\n\n    for (uint32_t i = 0; i < numFlows; i++) {\n        std::stringstream ss;\n        ss << ss0.str () << i;\n\n        ApplicationContainer rmcatApps = m_topo.InstallRMCAT (ss.str (),        // flowID\n                                                              nRmcatBase + i,   // nodeID\n                                                              basePort + i * 2, // port # ,\n                                                              fwd);             // direction\n\n        send[i] = DynamicCast<RmcatSender> (rmcatApps.Get (0));\n        send[i]->SetCodecType (m_codecType);\n        send[i]->SetRinit (RMCAT_TC_RINIT);\n        send[i]->SetRmin (RMCAT_TC_RMIN);\n        send[i]->SetRmax (RMCAT_TC_RMAX);\n        send[i]->SetStartTime (Seconds (0));\n        send[i]->SetStopTime (Seconds (m_simTime-1));\n    }\n\n    // configure start/end times for downlink flows\n    if (fwd && m_startTDnRMCAT.size () > 0) {\n        NS_ASSERT (m_startTDnRMCAT.size () == numFlows);\n        NS_ASSERT (m_finisTDnRMCAT.size () == numFlows);\n        for (uint32_t i = 0; i < numFlows; i++) {\n            send[i]->SetStartTime (Seconds (m_startTDnRMCAT[i]));\n            send[i]->SetStopTime (Seconds (m_finisTDnRMCAT[i]));\n        }\n    }\n\n    // configure start/end times for uplink flows\n    if (!fwd && m_startTUpRMCAT.size () > 0) {\n        NS_ASSERT (m_startTUpRMCAT.size () == numFlows);\n        NS_ASSERT (m_finisTUpRMCAT.size () == numFlows);\n        for (uint32_t i = 0; i < numFlows; i++) {\n            send[i]->SetStartTime (Seconds (m_startTUpRMCAT[i]));\n            send[i]->SetStopTime (Seconds (m_finisTUpRMCAT[i]));\n        }\n    }\n}\n\n/** Instantiate long lived TCP background flows */\nvoid RmcatWifiTestCase::SetUpTCP (std::vector<Ptr<BulkSendApplication> >& tcpSend,\n                                  bool fwd)\n{\n    size_t numFlows = fwd ? m_nDnTCP : m_nUpTCP;\n    const uint32_t basePort = RMCAT_TC_LONG_TCP_PORT + (fwd ? 0: 1000);\n    const auto nTcpBase = m_nDnRMCAT+m_nUpRMCAT+ (fwd? 0:m_nDnTCP);\n\n    std::stringstream ss0;\n    if (fwd) {\n        ss0 << \"tcpDn_\";\n    } else {\n        ss0 << \"tcpUp_\";\n    }\n\n    std::vector<Ptr<Application> > tcpRecv (numFlows);\n\n    for (uint32_t i = 0; i < numFlows; i++) {\n        std::stringstream ss;\n        ss << ss0.str () << i;\n\n        auto tcpApps = m_topo.InstallTCP (ss.str (),        // flow description\n                                          nTcpBase+i,       // node ID for server/client\n                                          basePort + 2 * i, // server port\n                                          fwd);\n\n        tcpSend[i] = DynamicCast<BulkSendApplication> (tcpApps.Get (0));\n        tcpSend[i]->SetStartTime (Seconds (RMCAT_TC_BG_TSTART));\n        tcpSend[i]->SetStopTime (Seconds (RMCAT_TC_BG_TFINIS));\n        tcpRecv[i] = DynamicCast<Application> (tcpApps.Get (1));\n        tcpRecv[i]->SetStartTime (Seconds (RMCAT_TC_BG_TSTART));\n        tcpRecv[i]->SetStopTime (Seconds (RMCAT_TC_BG_TFINIS));\n    }\n\n    // configure start/end times for downlink flows\n    if (fwd && m_startTDnTCP.size () > 0) {\n        NS_ASSERT (m_startTDnTCP.size () == numFlows);\n        NS_ASSERT (m_finisTDnTCP.size () == numFlows);\n        for (uint32_t i = 0; i < numFlows; i++) {\n            tcpSend[i]->SetStartTime (Seconds (m_startTDnTCP[i]));\n            tcpSend[i]->SetStopTime (Seconds (m_finisTDnTCP[i]));\n            tcpRecv[i]->SetStartTime (Seconds (m_startTDnTCP[i]));\n            tcpRecv[i]->SetStopTime (Seconds (m_finisTDnTCP[i]));\n        }\n    }\n\n    // configure start/end times for uplink flows\n    if (!fwd && m_startTUpTCP.size () > 0) {\n        NS_ASSERT (m_startTUpTCP.size () == numFlows);\n        NS_ASSERT (m_finisTUpTCP.size () == numFlows);\n        for (uint32_t i = 0; i < numFlows; i++) {\n            tcpSend[i]->SetStartTime (Seconds (m_startTUpTCP[i]));\n            tcpSend[i]->SetStopTime (Seconds (m_finisTUpTCP[i]));\n            tcpRecv[i]->SetStartTime (Seconds (m_startTUpTCP[i]));\n            tcpRecv[i]->SetStopTime (Seconds (m_finisTUpTCP[i]));\n        }\n    }\n}\n\n/** Instantiate CBR-over-UDP background flows */\nvoid RmcatWifiTestCase::SetUpCBR (std::vector<Ptr<Application> >& cbrSend,\n                                  bool fwd)\n{\n\n    size_t numFlows = fwd ? m_nDnCBR : m_nUpCBR;\n    const uint32_t basePort = RMCAT_TC_CBR_UDP_PORT + (fwd ? 0: 1000);\n    const uint32_t nCbrBase = m_nDnRMCAT+m_nUpRMCAT+m_nDnTCP+m_nUpTCP + (fwd? 0:m_nDnCBR);\n    for (uint32_t i = 0; i < numFlows; i++) {\n        ApplicationContainer cbrApps = m_topo.InstallCBR (nCbrBase+i,   // node ID\n                                                          basePort+i,   // port #,\n                                                          m_rCBR,       // rate of CBR\n                                                          RMCAT_TC_UDP_PKTSIZE,\n                                                          //   RMCAT_TC_BG_TSTART,\n                                                          //   RMCAT_TC_BG_TFINIS,\n                                                          fwd);\n\n        cbrSend[i] = cbrApps.Get (0);\n        cbrSend[i]->SetStartTime (Seconds (RMCAT_TC_BG_TSTART));\n        cbrSend[i]->SetStopTime (Seconds (RMCAT_TC_BG_TFINIS));\n    }\n\n    // configure start/end times for downlink flows\n    if (fwd && m_startTDnCBR.size () > 0) {\n        NS_ASSERT (m_startTDnCBR.size () == numFlows);\n        NS_ASSERT (m_finisTDnCBR.size () == numFlows);\n        for (uint32_t i = 0; i < numFlows; i++) {\n            cbrSend[i]->SetStartTime (Seconds (m_startTDnCBR[i]));\n            cbrSend[i]->SetStopTime (Seconds (m_finisTDnCBR[i]));\n        }\n    }\n\n    // configure start/end times for uplink flows\n    if (!fwd && m_startTUpCBR.size () > 0) {\n        NS_ASSERT (m_startTUpCBR.size () == numFlows);\n        NS_ASSERT (m_finisTUpCBR.size () == numFlows);\n        for (uint32_t i = 0; i < numFlows; i++) {\n            cbrSend[i]->SetStartTime (Seconds (m_startTUpCBR[i]));\n            cbrSend[i]->SetStopTime (Seconds (m_finisTUpCBR[i]));\n        }\n    }\n}\n\n/**\n * Inherited DoSetup function:\n * -- Build network topology\n * -- Enable additional logging\n */\nvoid RmcatWifiTestCase::DoSetup ()\n{\n    RmcatTestCase::DoSetup ();\n    m_nWifi  = m_nDnRMCAT + m_nUpRMCAT;\n    m_nWifi += m_nDnTCP + m_nUpTCP;\n    m_nWifi += m_nDnCBR + m_nUpCBR;\n\n    m_topo.Build (m_capacity,\n                  m_delay,\n                  m_qdelay,\n                  m_nWifi,\n                  WIFI_PHY_STANDARD_80211n_5GHZ,\n                  m_phyMode);\n\n    ns3::LogComponentEnable (\"RmcatSimTestWifi\", LOG_LEVEL_INFO);\n}\n\n/**\n * Inherited DoRun () function:\n * -- Instantiate RMCAT/TCP/UDP flows\n * -- Populate routing table\n * -- Kickoff simulation\n */\nvoid RmcatWifiTestCase::DoRun ()\n{\n    /* Configure downlink/uplink flows */\n    std::vector< Ptr<RmcatSender> > sendDnRMCAT (m_nDnRMCAT);\n    std::vector< Ptr<RmcatSender> > sendUpRMCAT (m_nUpRMCAT);\n    std::vector< Ptr<BulkSendApplication> > sendDnTCP (m_nDnTCP);\n    std::vector< Ptr<BulkSendApplication> > sendUpTCP (m_nUpTCP);\n    std::vector< Ptr<Application> > sendDnCBR (m_nDnCBR);\n    std::vector< Ptr<Application> > sendUpCBR (m_nUpCBR);\n\n    SetUpRMCAT (sendDnRMCAT, true);\n    SetUpRMCAT (sendUpRMCAT, false);\n\n    SetUpTCP (sendDnTCP, true);\n    SetUpTCP (sendUpTCP, false);\n\n    SetUpCBR (sendDnCBR, true);\n    SetUpCBR (sendUpCBR, false);\n\n    /* Kick off simulation */\n    NS_LOG_INFO (\"Run Simulation.\");\n    Simulator::Stop (Seconds (m_simTime));\n    Simulator::Run ();\n    Simulator::Destroy ();\n    NS_LOG_INFO (\"Done.\");\n}\n"
    },
    {
      "file_path": "test/rmcat-wired-test-case.cc",
      "code": "/******************************************************************************\n * Copyright 2016-2017 Cisco Systems, Inc.                                    *\n *                                                                            *\n * Licensed under the Apache License, Version 2.0 (the \"License\");            *\n * you may not use this file except in compliance with the License.           *\n *                                                                            *\n * You may obtain a copy of the License at                                    *\n *                                                                            *\n *     http://www.apache.org/licenses/LICENSE-2.0                             *\n *                                                                            *\n * Unless required by applicable law or agreed to in writing, software        *\n * distributed under the License is distributed on an \"AS IS\" BASIS,          *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *\n * See the License for the specific language governing permissions and        *\n * limitations under the License.                                             *\n ******************************************************************************/\n\n/**\n * @file\n * Test suite for rmcat wired test cases.\n *\n * @version 0.1.1\n * @author Jiantao Fu\n * @author Sergio Mena\n * @author Xiaoqing Zhu\n */\n\n#include \"rmcat-wired-test-case.h\"\n\nNS_LOG_COMPONENT_DEFINE (\"RmcatSimTestWired\");\n\n/*\n * Implementation of the RmcatWiredTestCase\n * class. It defines the template for individual\n * rmcat-wired test cases as specified in\n * the following IETF draft (rmcat-eval-test):\n *\n * Test Cases for Evaluating RMCAT Proposals\n * https://tools.ietf.org/html/draft-ietf-rmcat-eval-test-05\n *\n * The RmcatTestSuite class simply instantiates\n * the collection of specific test cases as\n * defined in the rmcat-eval-test draft.\n */\n\n// TODO (deferred):  Jitter model\n// TODO (deferred):  Audio + Video combined\n// TODO (deferred):  align topology implementation with wifi case\n\nstatic void SenderPauseResume (Ptr<RmcatSender> send, bool pause)\n{\n    send->PauseResume (pause);\n}\n\n/* Constructor */\nRmcatWiredTestCase::RmcatWiredTestCase (uint64_t capacity, // bottleneck capacity (in bps)\n                                        uint32_t delay,    // one-way propagation delay (in ms)\n                                        uint32_t qdelay,   // bottleneck queue depth (in ms)\n                                        std::string desc)  // test case name/description\n: RmcatTestCase{capacity, delay, qdelay, desc},\n  m_numFlowsFw{1},  // default: a single forward RMCAT flow\n  m_numFlowsBw{0},\n  m_numTcpFlows{0},\n  m_numShortTcpFlows{0},\n  m_numInitOnFlows{0},\n  m_simTime{RMCAT_TC_SIMTIME},\n  m_pauseFid{0},\n  m_codecType{SYNCODEC_TYPE_FIXFPS}\n{}\n\n\n/*\n * Configure time-varying available bandwidth\n */\nvoid RmcatWiredTestCase::SetBW (const std::vector<uint32_t>& times,\n                                const std::vector<uint64_t>& capacities,\n                                bool fwd)\n{\n    if (capacities.size () > 0) {\n        NS_ASSERT (capacities.size () == times.size ());\n        NS_ASSERT (m_capacity >= *std::max_element (capacities.begin (), capacities.end ()));\n        NS_ASSERT (times[0] == 0);\n\n        if (fwd) {\n            m_timesFw = times;\n            m_capacitiesFw = capacities;\n        } else {\n            m_timesBw = times;\n            m_capacitiesBw = capacities;\n        }\n    }\n}\n\n/*\n * Configure media pause/resume times for RMCAT flows\n *\n *  Only the forward direction is supported for now.\n */\nvoid RmcatWiredTestCase::SetPauseResumeTimes (size_t fid,\n                                              const std::vector<uint32_t> & ptimes,\n                                              const std::vector<uint32_t> & rtimes,\n                                              bool fwd)\n{\n    NS_ASSERT (fwd); // Only fwd direction supported for now\n    NS_ASSERT (fid < m_numFlowsFw);\n    NS_ASSERT (ptimes.size () == rtimes.size ());\n\n    m_pauseFid = fid;\n    m_pauseTimes = ptimes;\n    m_resumeTimes = rtimes;\n}\n\n/*\n *  Configure RMCAT flows in terms of:\n *  -- direction (forward/backward)\n *  -- arrival/departure times\n*/\nvoid RmcatWiredTestCase::SetRMCATFlows (size_t numFlows,\n                                        const std::vector<uint32_t>& startTimes,\n                                        const std::vector<uint32_t>& endTimes,\n                                        bool fwd)\n{\n    if (fwd) {\n        // configure forward-direction flows\n        m_numFlowsFw   = numFlows;\n        m_startTimesFw = startTimes;\n        m_endTimesFw = endTimes;\n    } else {\n        // configure backward-direction flows\n        m_numFlowsBw = numFlows;\n        m_startTimesBw = startTimes;\n        m_endTimesBw = endTimes;\n    }\n}\n\n\n/*\n *  Configure long lived TCP background flows\n *  in terms of arrival/departure times.\n *\n *  @note Only the forward direction is supported for now.\n */\nvoid RmcatWiredTestCase::SetTCPLongFlows (size_t numFlows,\n                                          const std::vector<uint32_t>& startTimes,\n                                          const std::vector<uint32_t>& endTimes,\n                                          bool fwd)\n{\n    NS_ASSERT (fwd);\n    m_numTcpFlows   = numFlows;\n    m_startTimesTcp = startTimes;\n    m_endTimesTcp   = endTimes;\n}\n\n/**\n *  Configure a collection of short-lived TCP background flows.\n *\n *  Arrival/departure patterns of the short-lived flows are specified in\n *  in function #SetUpTCPShort as random processes\n *\n *  @note Only the forward direction is supported for now.\n */\nvoid RmcatWiredTestCase::SetTCPShortFlows (size_t numFlows,\n                                           size_t numInitOnFlows,\n                                           bool fwd)\n{\n    NS_ASSERT (fwd);\n    m_numShortTcpFlows = numFlows;\n    m_numInitOnFlows = numInitOnFlows;\n\n}\n\n/*\n * Inherited DoSetup function:\n * -- Build network topology\n * -- Enable additional logging\n */\nvoid RmcatWiredTestCase::DoSetup ()\n{\n    RmcatTestCase::DoSetup ();\n    m_topo.Build (m_capacity, m_delay, m_qdelay);\n    ns3::LogComponentEnable (\"RmcatSimTestWired\", LOG_LEVEL_INFO);\n}\n\n/*\n * Inherited DoRun () function:\n * -- Instantiate RMCAT and TCP background flows\n * -- Populate routing table\n * -- Kickoff simulation\n */\nvoid RmcatWiredTestCase::DoRun ()\n{\n\n    NS_ASSERT (m_startTimesFw.size () == m_endTimesFw.size ());\n    NS_ASSERT (m_startTimesFw.size () == 0 || m_startTimesFw.size () == m_numFlowsFw);\n    NS_ASSERT (m_pDelays.size () == 0 || m_pDelays.size () == m_numFlowsFw);\n\n    NS_ASSERT (m_pauseTimes.size () == m_resumeTimes.size ()); // always pause-resume pairs\n    NS_ASSERT (m_startTimesTcp.size () == m_endTimesTcp.size ());\n    NS_ASSERT (m_startTimesTcp.size () == 0 || m_startTimesTcp.size () == m_numTcpFlows);\n\n    /*\n     * Configure forward direction path and traffic\n    */\n    std::vector<Ptr<RmcatSender> > sendFw (m_numFlowsFw);\n    std::vector<std::shared_ptr<Timer> > ptimersFw;\n    std::vector<std::shared_ptr<Timer> > rtimersFw;\n    std::vector<Ptr<BulkSendApplication> > tcpLongSend (m_numTcpFlows);\n    std::vector<Ptr<BulkSendApplication> > tcpShortSend;\n\n    SetUpPath (m_timesFw, m_capacitiesFw, true);     // time-varying available BW\n    SetUpRMCAT (sendFw, ptimersFw, rtimersFw, true); // instantiate forward RMCAT flows\n    SetUpTCPLong (m_numTcpFlows, tcpLongSend);       // instantiate background long lived TCP flows\n    SetUpTCPShort (m_numShortTcpFlows,\n                   m_numInitOnFlows,\n                   tcpShortSend);  // instantiate background short TCP flows\n\n    /*\n     * Configure backward direction path and traffic\n     */\n    std::vector<Ptr<RmcatSender> > sendBw (m_numFlowsBw);\n    std::vector<std::shared_ptr<Timer> > ptimersBw;\n    std::vector<std::shared_ptr<Timer> > rtimersBw;\n\n    SetUpPath (m_timesBw, m_capacitiesBw, false);\n    SetUpRMCAT (sendBw, ptimersBw, rtimersBw, false);\n\n    /* Populate routing table */\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables ();\n\n    /* Kick off simulation */\n    NS_LOG_INFO (\"Run Simulation.\");\n    Simulator::Stop (Seconds (m_simTime));\n    Simulator::Run ();\n    Simulator::Destroy ();\n    NS_LOG_INFO (\"Done.\");\n}\n\n\n/*\n * Realize time-varying available bandwidth by\n * introducing background time-varying UDP background\n * traffic, as specified in Section 5.1 of the\n * rmcat-eval-test draft:\n *\n *     When using background non-adaptive UDP traffic to induce\n *     time-varying bottleneck , the physical path capacity\n *     remains at 4Mbps and the UDP traffic source rate changes\n *     over time as (4-x)Mbps, where x is the bottleneck capacity\n *     specified in Table 1.\n */\nvoid RmcatWiredTestCase::SetUpPath (const std::vector<uint32_t>& times,\n                                    const std::vector<uint64_t>& capacities,\n                                    bool fwd)\n{\n    const uint16_t basePort = RMCAT_TC_CBR_UDP_PORT + (fwd ? 0:1000);\n\n    if (capacities.size () > 0) {\n        NS_ASSERT (capacities.size () == times.size ());\n        NS_ASSERT (m_capacity >= *std::max_element (capacities.begin (), capacities.end ()));\n        NS_ASSERT (times[0] == 0);\n\n        uint32_t pktsize = RMCAT_TC_UDP_PKTSIZE;\n        for (size_t i = 0; i < times.size (); ++i) {\n            const uint32_t current_rate = m_capacity - capacities[i];\n\n            if (current_rate > 0) {\n                const uint32_t startTime = times[i];\n                const uint32_t endTime = (i < times.size () - 1) ? times[i + 1] : m_simTime;\n\n                // install a new CBR-over-UDP flow at current_rate\n                ApplicationContainer cbrApps = m_topo.InstallCBR (basePort + i, // port number\n                                                                  current_rate, // rate\n                                                                  pktsize,      // packet size\n                                                                  fwd);         // direction indicator\n                cbrApps.Get (0)->SetStartTime (Seconds (startTime));\n                cbrApps.Get (0)->SetStopTime (Seconds (endTime));\n            }\n        }\n    }\n}\n\n/*\n *  Instantiate RMCAT flows\n */\nvoid RmcatWiredTestCase::SetUpRMCAT (std::vector<Ptr<RmcatSender> >& send,\n                                     std::vector<std::shared_ptr<Timer> >& ptimers,\n                                     std::vector<std::shared_ptr<Timer> >& rtimers,\n                                     bool fwd)\n{\n    const uint32_t basePort = RMCAT_TC_RMCAT_PORT + (fwd ? 0: 1000);\n    size_t numFlows = fwd ? m_numFlowsFw : m_numFlowsBw;\n    uint32_t pDelayMs = 0;\n\n    // configure flowID as string\n    std::stringstream ss0;\n    ss0 << \"rmcat_\";\n    switch (m_codecType) {\n        case SYNCODEC_TYPE_PERFECT:\n            ss0 << \"cbr_\";\n            break;\n        case SYNCODEC_TYPE_FIXFPS:\n            ss0 << \"fixfps_\";\n            break;\n        case SYNCODEC_TYPE_STATS:\n            ss0 << \"stats_\";\n            break;\n        case SYNCODEC_TYPE_TRACE:\n            ss0 << \"tr_\";\n            break;\n        case SYNCODEC_TYPE_SHARING:\n            ss0 << \"cs_\";\n            break;\n        case SYNCODEC_TYPE_HYBRID:\n            ss0 << \"hybrid_\";\n            break;\n        default:\n            ss0 << \"other_\";\n    }\n\n    if (fwd) {\n        ss0 << \"fwd_\";\n    } else {\n        ss0 << \"bwd_\";\n    }\n\n    for (size_t i = 0; i < numFlows; ++i) {\n        // configure per-flow RTT\n        if (fwd && m_pDelays.size () > 0) {\n            pDelayMs = m_pDelays[i];\n        }\n\n        std::stringstream ss;\n        ss << ss0.str () << i;\n\n        ApplicationContainer rmcatApps = m_topo.InstallRMCAT (ss.str (),          // Flow ID\n                                                              basePort + (i * 2), // port number\n                                                              pDelayMs,           // path RTT\n                                                              fwd);               // direction indicator\n\n        send[i] = DynamicCast<RmcatSender> (rmcatApps.Get (0));\n        send[i]->SetCodecType (m_codecType);\n        send[i]->SetRinit (RMCAT_TC_RINIT);\n        send[i]->SetRmin (RMCAT_TC_RMIN);\n        send[i]->SetRmax (RMCAT_TC_RMAX);\n        send[i]->SetStartTime (Seconds (0));\n        send[i]->SetStopTime (Seconds (m_simTime-1));\n    }\n\n    /* configure start/end times for forward flows */\n    if (fwd && m_startTimesFw.size () > 0) {\n        NS_ASSERT (m_startTimesFw.size () == numFlows);\n        NS_ASSERT (m_startTimesFw.size () == numFlows);\n        for (uint32_t i = 0; i < numFlows; i++) {\n            send[i]->SetStartTime (Seconds (m_startTimesFw[i]));\n            send[i]->SetStopTime (Seconds (m_endTimesFw[i]));\n        }\n    }\n\n    /* configure start/end times for backward flows */\n    if (!fwd && m_startTimesBw.size () > 0) {\n        NS_ASSERT (m_startTimesBw.size () == numFlows);\n        NS_ASSERT (m_startTimesBw.size () == numFlows);\n        for (uint32_t i = 0; i < numFlows; i++) {\n            send[i]->SetStartTime (Seconds (m_startTimesBw[i]));\n            send[i]->SetStopTime (Seconds (m_endTimesBw[i]));\n        }\n    }\n\n    /* configure media pause/resume times for given flow */\n    if (fwd && m_pauseTimes.size () > 0\n            && m_resumeTimes.size () > 0) {\n\n        size_t fid = m_pauseFid;\n        NS_ASSERT (fid < m_numFlowsFw);\n        size_t ntimes = m_pauseTimes.size ();\n        ptimers.resize (ntimes);\n        rtimers.resize (ntimes);\n        // configure pause times\n        for (size_t i = 0; i < ntimes; ++i) {\n            Timer *ptimer = new Timer{Timer::CANCEL_ON_DESTROY};\n            Timer *rtimer = new Timer{Timer::CANCEL_ON_DESTROY};\n\n            ptimer->SetFunction (&SenderPauseResume);\n            rtimer->SetFunction (&SenderPauseResume);\n\n            ptimer->SetArguments (send[fid], true);  // pause\n            rtimer->SetArguments (send[fid], false);  // resume\n\n            ptimer->SetDelay (Seconds (m_pauseTimes[i]));\n            rtimer->SetDelay (Seconds (m_resumeTimes[i]));\n\n            ptimer->Schedule ();\n            rtimer->Schedule ();\n\n            ptimers[i] = std::shared_ptr<Timer>{ptimer};\n            rtimers[i] = std::shared_ptr<Timer>{rtimer};\n        }\n    }\n}\n\n/*\n * Instantiate long lived background TCP flows\n * (only forward direction is supported for now)\n */\nvoid RmcatWiredTestCase::SetUpTCPLong (size_t numFlows,\n                                       std::vector<Ptr<BulkSendApplication> >& tcpSend)\n{\n    const uint16_t basePort = RMCAT_TC_LONG_TCP_PORT;\n    for (size_t i = 0; i < numFlows; ++i) {\n        std::stringstream ss;\n        ss << \"tcp_\" << i;\n\n        ApplicationContainer tcpApps = m_topo.InstallTCP (ss.str (),          // flow description\n                                                          basePort + (i * 2), // port number\n                                                          true);              // create a new node for this flow\n\n        tcpSend[i] = DynamicCast<BulkSendApplication> (tcpApps.Get (0));\n        tcpSend[i]->SetStartTime (Seconds (RMCAT_TC_BG_TSTART));\n        tcpSend[i]->SetStopTime (Seconds (RMCAT_TC_BG_TFINIS));\n    }\n\n    // configure start/end time\n    if (m_startTimesTcp.size () > 0) {\n        for (size_t i = 0; i < numFlows; ++i) {\n            tcpSend[i]->SetStartTime (Seconds (m_startTimesTcp[i]));\n        }\n    }\n\n    if (m_endTimesTcp.size () > 0) {\n        for (size_t i = 0; i < numFlows; ++i) {\n            tcpSend[i]->SetStopTime (Seconds (m_endTimesTcp[i]));\n        }\n    }\n}\n\n/*\n * Instantiate short-lived background TCP flows\n *\n * The expected behavior of short TCP flows are specified\n * in Section 6.1 of the following IETF draft (rmcat-eval-criteria):\n *\n * Evaluating Congestion Control for Interactive Real-time Media\n * https://tools.ietf.org/html/draft-ietf-rmcat-eval-criteria-06\n *\n *     Each short TCP flow is modeled as a sequence of file downloads\n *     interleaved with idle periods.  Not all short TCPs start at the\n *     same time, i.e., some start in the ON state while others start\n *     in the OFF state.\n *\n *     The short TCP flows can be modeled as follows: 30 connections\n *     start simultaneously fetching small (30-50 KB) amounts of data.\n *     This covers the case where the short TCP flows are not fetching\n *     a video file.\n *\n *     The idle period between bursts of starting a group of TCP flows\n *     is typically derived from an exponential distribution with the\n *     mean value of 10 seconds.\n *\n *     [These values were picked based on the data available at\n *      http://httparchive.org/interesting.php as of October 2015].\n *\n * The timeline of the short TCP flows are specified in\n * Section 5.6 of the rmcat-eval-test draft\n *\n *     +  Traffic timeline: each short TCP flow is modeled as a\n *        sequence of file downloads interleaved with idle periods.\n *        Not all short TCP flows start at the same time, 2 of them\n *        start in the ON state while rest of the 8 flows start in an\n *        OFF stats.\n *\n * Currently only forward direction is supported\n *\n * @param [in] numFlows:  number of short TCP background flows\n * @param [in] numInitOnFlows: number of short TCP flows that are initially in ON\n *                             state at start time\n * @param [in, out] tcpSend:   pointers to the instantiated TCP senders\n*/\nvoid RmcatWiredTestCase::SetUpTCPShort (size_t numFlows,\n                                        size_t numInitOnFlows,\n                                        std::vector<Ptr<BulkSendApplication> >& tcpSend)\n{\n    uint16_t port = RMCAT_TC_SHORT_TCP_PORT;\n    int startTime = RMCAT_TC_SHORT_TCP_TGAP;\n    int endTime = m_simTime - RMCAT_TC_SHORT_TCP_TGAP;\n\n    /*\n     * Default values of the following parameters follow\n     *  Section 6.1 of the rmcat-eval-criteria draft\n     */\n    uint32_t meanOffDuration = RMCAT_TC_SHORT_TCP_MEAN_OFF_TIME;\n    uint32_t minFileSize = RMCAT_TC_SHORT_TCP_MIN_FILE_SIZE;\n    uint32_t maxFileSize = RMCAT_TC_SHORT_TCP_MAX_FILE_SIZE;\n\n    // Draw random values of ON/OFF duration\n    Ptr<ExponentialRandomVariable> offDurationRnd = CreateObject<ExponentialRandomVariable> ();\n    offDurationRnd->SetAttribute (\"Mean\", DoubleValue (meanOffDuration));\n\n    // Draw random values of transfer file sizes\n    // uniformly distributed between minFileSize and maxFileSize\n    Ptr<UniformRandomVariable> transferSizeRnd = CreateObject<UniformRandomVariable> ();\n    transferSizeRnd->SetAttribute (\"Min\", DoubleValue (minFileSize));\n    transferSizeRnd->SetAttribute (\"Max\", DoubleValue (maxFileSize));\n\n    for (size_t i = 0; i < numFlows; ++i) {\n        bool first = true;   // create a new node for the first file transfer session\n\n        double initTime = ((numInitOnFlows < i) ? startTime : startTime + offDurationRnd->GetValue ());\n        for (double lastTime = initTime;\n                    lastTime < endTime;\n                    lastTime += offDurationRnd->GetValue ()) {\n\n            std::stringstream ss;\n            ss << \"tcp_\" << i;\n            ApplicationContainer tcpApps = m_topo.InstallTCP (ss.str (), // flow description\n                                                              port++,    // port number\n                                                              first);    // whether to create a new node\n\n            Ptr<BulkSendApplication> app = DynamicCast<BulkSendApplication> (tcpApps.Get (0));\n            app->SetStartTime (Seconds (lastTime));\n            app->SetStopTime  (Seconds (m_simTime - 1));\n            app->SetAttribute (\"MaxBytes\", UintegerValue (transferSizeRnd->GetInteger ()));\n            app->SetAttribute (\"SendSize\", UintegerValue (RMCAT_TC_TCP_PKTSIZE));\n\n            tcpSend.push_back (app);\n            first = false;\n        }\n    }\n}\n\n"
    }
  ]
}