{
  "repo_name": "guoxiliu/VideoStream-NS3",
  "github_url": "https://github.com/guoxiliu/VideoStream-NS3",
  "readme": "# VideoStream-NS3\nThe project is designed to provide a simulation of adaptive video streaming over  wireless home networks using ns-3.\n\n## Introduction\n\n### Video Streaming\n*Streaming* is a technology used to deliver content from the server to clients over the internet without having to download it. Multimedia streaming is one of the most popular and successful streaming services since it allows the user to watch the video or listen to music almost immediately without having to wait for the file to be completely downloaded. Unlike the file transfer which keeps the file on the device until the user manually deletes it, the streaming data is automatically removed after the user uses it.\n\n### Adaptive Streaming\n\nTraditional progressive video streaming is simply one single video file being streamed over the internet, and the video can be stretched or shrunk to fit different screen resolutions. Regardless of the device playing it, the video file will always be the same. *Adaptive streaming* (also known as Adaptive Bitrate Streaming), instead, is a technique designed to deliver the multimedia contents to the user in the most efficient way and in the highest possible quality for each user. \n\n## Installation\n\n### Prerequisites\nns-3 (version 3.30), Python (`python 2.7+` or `python 3.5+`), C++ compiler (`clang++` or `g++`)\n\n### How to install\n\n1. Download and build `ns-3` following the official document [here](https://www.nsnam.org/docs/release/3.30/tutorial/singlehtml/index.html#getting-started).\n2. Copy the files **exactly** into the folders of the `ns-3`. (Be aware of the `wscript` in `src->applications`, otherwise the video streaming application will not be installed!)\n3. Run `./waf` or `./waf build` to build the new application.\n4. Run `./waf --run videoStreamer` for the testing program (you can change `CASE` in `videoStreamTest.cc` for different network environments).\n\n### Detailed explanation\n\n[Frank](https://github.com/Frankytx) and I made a YouTube video for explaning what we did for the project. [Check out here!](https://youtu.be/PEvXoRmz3tk) (Sorry for the microphone issue...)\n\n## Results\n\n### Network configurations\n\n![Different test cases](./attachments/cases.png)\n\n- (a) P2P network with 1 server and 1 client\n- (b) P2P network with 1 server and 2 clients\n- (c) Wireless network with 1 server and 3 mobile clients\n- (d) Wireless network with 3 servers and 3 mobile clients\n\n### Case of requesting lower video quality\n\nSet a low bandwidth in `videoStreamTest.cc`, e.g., `2 Mbps`, and you are expected to see the drop of video quality level.\n\n```\n(......)\nAt time 3.5 s: Not enough frames in the buffer, rebuffering!\nAt time 3.61909s client received frame 15 and 56408 bytes from 10.1.1.1 port 5000\nAt time 3.85341s client received frame 16 and 57350 bytes from 10.1.1.1 port 5000\nAt time 4.08793s client received frame 17 and 57400 bytes from 10.1.1.1 port 5000\nAt time 4.33389s client received frame 18 and 60200 bytes from 10.1.1.1 port 5000\nAt time 4.5 s: Not enough frames in the buffer, rebuffering!\nAt time 4.58276s client received frame 19 and 60898 bytes from 10.1.1.1 port 5000\nAt time 4.7944s client received frame 20 and 51800 bytes from 10.1.1.1 port 5000\nAt time 5.05752s client received frame 21 and 64400 bytes from 10.1.1.1 port 5000\nAt time 5.27239s client received frame 22 and 52577 bytes from 10.1.1.1 port 5000\nAt time 5.5 s: Not enough frames in the buffer, rebuffering!\nAt time 5.50119s: Lower the video quality level!\n(......)\n```\n\n### Case of requesting higher video quality\n\nSet a high bandwidth in `videoStreamTest.cc`, e.g., `100 Mbps`, and make sure the video length is longer than 5 seconds, then you are expected to see the increase of video quality level.\n\n```\n(......)\nAt time 2.5349s client received frame 120 and 277397 bytes from 10.1.1.1 port 5000\nAt time 2.55769s client received frame 121 and 278819 bytes from 10.1.1.1 port 5000\nAt time 2.58043s client received frame 122 and 278288 bytes from 10.1.1.1 port 5000\nAt time 2.60336s client received frame 123 and 280667 bytes from 10.1.1.1 port 5000\nAt time 2.61411s client received frame 124 and 131446 bytes from 10.1.1.1 port 5000\nAt time 2.61411s: Increase the video quality level to 4\n(......)\n```\n\n## Issues\n\n- We noticed that the mobile devices will lose connection to the server when it moves out of the range of wireless signals. However, we did not observe the transmission rate dropping when the mobile devices are away from the sever, which requires further investigation on how different modes work in the ns-3 wireless simulator. \n- Due to the time limitation, we did not use the real video files for the transmission. It is also a good feature to add some decoders of video file formats to the application.\n\n## Resources\n\n- [Project report](https://arxiv.org/abs/2302.14196)\n\n## References \n\n1. The ns-3 development team, \u201cns-3 network simulator.\u201d https://www.nsnam.org/docs/release/3.32/tutorial/html/ introduction.html. Accessed: 2020-11-28. \n2. X. Zhu and B. Girod, \u201cVideo streaming over wireless networks,\u201d in 2007 15th European Signal Processing Conference, pp. 1462\u20131466, IEEE, 2007. \n3. A. Fouda, A. N. Ragab, A. Esswie, M. Marzban, A. Naser, M. Rehan, and A. S. Ibrahim, \u201cReal-time video streaming over ns3-based emulated lte networks,\u201d Int. J. Electr. Commun. Comput. Technol.(IJECCT), vol. 4, no. 3, 2014. \n4. T.-Y. Huang, R. Johari, N. McKeown, M. Trunnell, and M. Watson, \u201cA buffer-based approach to rate adaptation: evidence from a large video streaming service,\u201d in Proceedings of the 2014 ACM conference on SIGCOMM, SIGCOMM \u201914, pp. 187\u2013198, Association for Computing Machinery, 2014. \n5. L. Liu, H. Hu, Y. Luo, and Y. Wen, \u201cWhen Wireless Video Streaming Meets AI: A Deep Learning Approach,\u201d IEEE Wireless Communications, vol. 27, pp. 127\u2013133, Apr. 2020.\n",
  "examples": [
    {
      "file_path": "scratch/videoStreamer/videoStreamTest.cc",
      "code": "/*****************************************************\n*\n* File:  videoStreamTest.cc\n*\n* Explanation:  This script modifies the tutorial first.cc\n*               to test the video stream application.\n*\n*****************************************************/\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\n//#define NS3_LOG_ENABLE\n\n/**\n * @brief The test cases include:\n * 1. P2P network with 1 server and 1 client\n * 2. P2P network with 1 server and 2 clients\n * 3. Wireless network with 1 server and 3 mobile clients\n * 4. Wireless network with 3 servers and 3 mobile clients\n */\n#define CASE 1\n\nNS_LOG_COMPONENT_DEFINE (\"VideoStreamTest\");\n\nint\nmain (int argc, char *argv[])\n{\n  CommandLine cmd;\n  cmd.Parse (argc, argv);\n  \n  Time::SetResolution (Time::NS);\n  LogComponentEnable (\"VideoStreamClientApplication\", LOG_LEVEL_INFO);\n  LogComponentEnable (\"VideoStreamServerApplication\", LOG_LEVEL_INFO);\n\n  if (CASE == 1)\n  {\n    NodeContainer nodes;\n    nodes.Create (2);\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute (\"DataRate\", StringValue (\"100Mbps\"));\n    pointToPoint.SetChannelAttribute (\"Delay\", StringValue (\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install (nodes);\n\n    InternetStackHelper stack;\n    stack.Install (nodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n    VideoStreamClientHelper videoClient (interfaces.GetAddress (0), 5000);\n    ApplicationContainer clientApp = videoClient.Install (nodes.Get (1));\n    clientApp.Start (Seconds (0.5));\n    clientApp.Stop (Seconds (100.0));\n\n    VideoStreamServerHelper videoServer (5000);\n    videoServer.SetAttribute (\"MaxPacketSize\", UintegerValue (1400));\n    videoServer.SetAttribute (\"FrameFile\", StringValue (\"./scratch/videoStreamer/frameList.txt\"));\n    // videoServer.SetAttribute (\"FrameSize\", UintegerValue (4096));\n\n    ApplicationContainer serverApp = videoServer.Install (nodes.Get (0));\n    serverApp.Start (Seconds (0.0));\n    serverApp.Stop (Seconds (100.0));\n\n    pointToPoint.EnablePcap (\"videoStream\", devices.Get (1), false);\n    Simulator::Run ();\n    Simulator::Destroy ();\n  }\n\n  else if (CASE == 2)\n  {\n    NodeContainer nodes;\n    nodes.Create (3);\n    NodeContainer n0n1= NodeContainer (nodes.Get(0), nodes.Get(1));\n    NodeContainer n0n2= NodeContainer (nodes.Get(0), nodes.Get(2));\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute (\"DataRate\", StringValue (\"2Mbps\"));\n    pointToPoint.SetChannelAttribute (\"Delay\", StringValue (\"2ms\"));\n\n    NetDeviceContainer d0d1= pointToPoint.Install (n0n1);\n    NetDeviceContainer d0d2= pointToPoint.Install (n0n2);\n\n    InternetStackHelper stack;\n    stack.Install (nodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n    address.Assign (d0d1);\n\n    address.SetBase (\"10.1.2.0\", \"255.255.255.0\");\n    address.Assign (d0d2);\n\n    //Ipv4InterfaceContainer interfaces = address.Assign (devices);\n    Ipv4InterfaceContainer i0i1 = address.Assign (d0d1);\n    Ipv4InterfaceContainer i0i2 = address.Assign (d0d2);\n\n    VideoStreamClientHelper videoClient1 (i0i1.GetAddress (0), 5000);\n    ApplicationContainer clientApp1 = videoClient1.Install (nodes.Get (1));\n    clientApp1.Start (Seconds (1.0));\n    clientApp1.Stop (Seconds (100.0));\n\n    VideoStreamClientHelper videoClient2 (i0i2.GetAddress (0), 5000);\n    ApplicationContainer clientApp2 = videoClient2.Install (nodes.Get (2));\n    clientApp2.Start (Seconds (0.5));\n    clientApp2.Stop (Seconds (100.0));\n\n    VideoStreamServerHelper videoServer (5000);\n    videoServer.SetAttribute (\"MaxPacketSize\", UintegerValue (1400));\n    videoServer.SetAttribute (\"FrameFile\", StringValue (\"./scratch/videoStreamer/small.txt\"));\n    // videoServer.SetAttribute (\"FrameSize\", UintegerValue (4096));\n\n    ApplicationContainer serverApp = videoServer.Install (nodes.Get (0));\n    serverApp.Start (Seconds (0.0));\n    serverApp.Stop (Seconds (100.0));\n\n    pointToPoint.EnablePcap (\"videoStream\", d0d1.Get (1), false);\n    pointToPoint.EnablePcap (\"videoStream\", d0d2.Get (1), false);\n    Simulator::Run ();\n    Simulator::Destroy ();\n  }\n  else if (CASE == 3)\n  {\n    const uint32_t nWifi = 3, nAp = 1;\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create (nWifi);  \n    NodeContainer wifiApNode;\n    wifiApNode.Create(nAp);   \n    \n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();   \n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();  \n    phy.SetChannel (channel.Create ());  \n  \n    WifiHelper wifi;\n    wifi.SetRemoteStationManager (\"ns3::AarfWifiManager\");  \n  \n  \n    WifiMacHelper mac; \n    Ssid ssid = Ssid (\"ns-3-aqiao\");  \n    mac.SetType (\"ns3::StaWifiMac\",    \n                \"Ssid\", SsidValue (ssid),   \n                \"ActiveProbing\", BooleanValue (false));  \n  \n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install (phy, mac, wifiStaNodes);  \n  \n    mac.SetType (\"ns3::ApWifiMac\",   \n                \"Ssid\", SsidValue (ssid));   \n  \n    NetDeviceContainer apDevices;\n    apDevices = wifi.Install (phy, mac, wifiApNode);   \n\n    MobilityHelper mobility; \n    mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0),\n                                 \"MinY\", DoubleValue (0.0),\n                                 \"DeltaX\", DoubleValue (30.0),\n                                 \"DeltaY\", DoubleValue (30.0),\n                                 \"GridWidth\", UintegerValue (2),\n                                 \"LayoutType\", StringValue (\"RowFirst\"));\n \n    \n    mobility.SetMobilityModel (\"ns3::RandomWalk2dMobilityModel\", \"Bounds\", RectangleValue (Rectangle (-50, 50, -50, 50)));   \n    mobility.Install (wifiStaNodes);\n   \n    mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");  \n    mobility.Install (wifiApNode);\n  \n    InternetStackHelper stack;\n    stack.Install (wifiApNode);\n    stack.Install (wifiStaNodes);   \n  \n    Ipv4AddressHelper address;\n  \n    address.SetBase (\"10.1.3.0\", \"255.255.255.0\");\n    \n    Ipv4InterfaceContainer apInterfaces;\n    apInterfaces = address.Assign (apDevices); \n    Ipv4InterfaceContainer wifiInterfaces;\n    wifiInterfaces=address.Assign (staDevices);\n                  \n    //UdpEchoServerHelper echoServer (9);\n    VideoStreamServerHelper videoServer (5000);\n    videoServer.SetAttribute (\"MaxPacketSize\", UintegerValue (1400));\n    videoServer.SetAttribute (\"FrameFile\", StringValue (\"./scratch/videoStreamer/small.txt\"));\n    for(uint m=0; m<nAp; m++)\n    {\n      ApplicationContainer serverApps = videoServer.Install (wifiApNode.Get (m));\n      serverApps.Start (Seconds (0.0));\n      serverApps.Stop (Seconds (100.0));\n    }\n  \n    for(uint k=0; k<nWifi; k++)\n    {\n      VideoStreamClientHelper videoClient (apInterfaces.GetAddress (0), 5000);\n      ApplicationContainer clientApps =\n      videoClient.Install (wifiStaNodes.Get (k));\n      clientApps.Start (Seconds (0.5));\n      clientApps.Stop (Seconds (100.0));\n    }\n  \n    Ipv4GlobalRoutingHelper::PopulateRoutingTables ();\n  \n    Simulator::Stop (Seconds (10.0));\n  \n    phy.EnablePcap (\"wifi-videoStream\", apDevices.Get (0));\n    AnimationInterface anim(\"wifi-1-3.xml\");\n    Simulator::Run ();\n    Simulator::Destroy ();\n  }\n  else if (CASE == 4)\n  {\n    const uint32_t nWifi = 3, nAp = 3;\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create (nWifi);  \n    NodeContainer wifiApNode;\n    wifiApNode.Create(nAp);   \n    \n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();   \n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();  \n    phy.SetChannel (channel.Create ());  \n  \n    WifiHelper wifi;\n    wifi.SetRemoteStationManager (\"ns3::AarfWifiManager\");  \n  \n  \n    WifiMacHelper mac; \n    Ssid ssid = Ssid (\"ns-3-aqiao\");  \n    mac.SetType (\"ns3::StaWifiMac\",    \n                \"Ssid\", SsidValue (ssid),   \n                \"ActiveProbing\", BooleanValue (false));  \n  \n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install (phy, mac, wifiStaNodes);  \n  \n    mac.SetType (\"ns3::ApWifiMac\",   \n                \"Ssid\", SsidValue (ssid));   \n  \n    NetDeviceContainer apDevices;\n    apDevices = wifi.Install (phy, mac, wifiApNode);   \n    MobilityHelper mobility; \n    mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue (0.0),\n                                  \"MinY\", DoubleValue (0.0),\n                                  \"DeltaX\", DoubleValue (50.0),\n                                  \"DeltaY\", DoubleValue (30.0),\n                                  \"GridWidth\", UintegerValue (3),\n                                  \"LayoutType\", StringValue (\"RowFirst\"));\n  \n    mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");  \n    mobility.Install (wifiApNode);\n      \n    //mobility.SetMobilityModel (\"ns3::RandomWalk2dMobilityModel\",   \n    //                           \"Bounds\", RectangleValue (Rectangle (-50, 50, -50, 50)));   \n    //mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");  \n    mobility.Install (wifiStaNodes);\n  \n    InternetStackHelper stack;\n    stack.Install (wifiApNode);\n    stack.Install (wifiStaNodes);   \n  \n    Ipv4AddressHelper address;\n  \n    address.SetBase (\"10.1.3.0\", \"255.255.255.0\");\n    \n    Ipv4InterfaceContainer apInterfaces;\n    apInterfaces = address.Assign (apDevices); \n    Ipv4InterfaceContainer wifiInterfaces;\n    wifiInterfaces=address.Assign (staDevices);\n                  \n    //UdpEchoServerHelper echoServer (9);\n    VideoStreamServerHelper videoServer (5000);\n    videoServer.SetAttribute (\"MaxPacketSize\", UintegerValue (1400));\n    videoServer.SetAttribute (\"FrameFile\", StringValue (\"./scratch/videoStreamer/small.txt\"));\n    for(uint m=0; m<nAp; m++)\n    {\n      ApplicationContainer serverApps = videoServer.Install (wifiApNode.Get (m));\n      serverApps.Start (Seconds (0.0));\n      serverApps.Stop (Seconds (100.0));\n    }\n  \n    for(uint k=0; k<nWifi; k++)\n    {\n      VideoStreamClientHelper videoClient (apInterfaces.GetAddress (k), 5000);\n      ApplicationContainer clientApps =\n      videoClient.Install (wifiStaNodes.Get (k));\n      clientApps.Start (Seconds (0.5));\n      clientApps.Stop (Seconds (100.0));\n    }\n  \n    Ipv4GlobalRoutingHelper::PopulateRoutingTables ();\n  \n    Simulator::Stop (Seconds (10.0));\n  \n    phy.EnablePcap (\"wifi-videoStream\", apDevices.Get (0));\n    AnimationInterface anim(\"wifi-1-3.xml\");\n    Simulator::Run ();\n    Simulator::Destroy ();\n  }\n\n  return 0;\n}\n"
    },
    {
      "file_path": "src/applications/helper/video-stream-helper.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n\n#include \"video-stream-helper.h\"\n#include \"ns3/video-stream-server.h\"\n#include \"ns3/video-stream-client.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/names.h\"\n\nnamespace ns3{\n\nVideoStreamServerHelper::VideoStreamServerHelper(uint16_t port)\n{\n  m_factory.SetTypeId (VideoStreamServer::GetTypeId ());\n  SetAttribute (\"Port\", UintegerValue (port));\n}\n\nvoid\nVideoStreamServerHelper::SetAttribute(std::string name, const AttributeValue &value)\n{\n  m_factory.Set (name, value);\n}\n\nApplicationContainer \nVideoStreamServerHelper::Install (Ptr<Node> node) const\n{\n  return ApplicationContainer (InstallPriv (node));\n}\n\nApplicationContainer \nVideoStreamServerHelper::Install (std::string nodeName) const\n{\n  Ptr<Node> node = Names::Find<Node> (nodeName);\n  return ApplicationContainer (InstallPriv (node));\n}\n\nApplicationContainer \nVideoStreamServerHelper::Install (NodeContainer c) const\n{\n  ApplicationContainer apps;\n  for (NodeContainer::Iterator i = c.Begin(); i != c.End(); i++)\n  {\n    apps.Add (InstallPriv (*i));\n  }\n  \n  return apps;\n}\n\nPtr<Application>\nVideoStreamServerHelper::InstallPriv (Ptr<Node> node) const\n{\n  Ptr<Application> app = m_factory.Create<VideoStreamServer> ();\n  node->AddApplication (app);\n\n  return app;\n}\n\nVideoStreamClientHelper::VideoStreamClientHelper(Address ip, uint16_t port)\n{\n  m_factory.SetTypeId (VideoStreamClient::GetTypeId ());\n  SetAttribute (\"RemoteAddress\", AddressValue (ip));\n  SetAttribute (\"RemotePort\", UintegerValue (port));\n}\n\n\nVideoStreamClientHelper::VideoStreamClientHelper(Address addr)\n{\n  m_factory.SetTypeId (VideoStreamClient::GetTypeId ());\n  SetAttribute (\"RemoteAddress\", AddressValue (addr));\n}\n\nvoid\nVideoStreamClientHelper::SetAttribute(std::string name, const AttributeValue &value)\n{\n  m_factory.Set (name, value);\n}\n\nApplicationContainer \nVideoStreamClientHelper::Install (Ptr<Node> node) const\n{\n  return ApplicationContainer (InstallPriv (node));\n}\n\nApplicationContainer \nVideoStreamClientHelper::Install (std::string nodeName) const\n{\n  Ptr<Node> node = Names::Find<Node> (nodeName);\n  return ApplicationContainer (InstallPriv (node));\n}\n\nApplicationContainer \nVideoStreamClientHelper::Install (NodeContainer c) const\n{\n  ApplicationContainer apps;\n  for (NodeContainer::Iterator i = c.Begin(); i != c.End(); i++)\n  {\n    apps.Add (InstallPriv (*i));\n  }\n  \n  return apps;\n}\n\nPtr<Application>\nVideoStreamClientHelper::InstallPriv (Ptr<Node> node) const\n{\n  Ptr<Application> app = m_factory.Create<VideoStreamClient> ();\n  node->AddApplication (app);\n\n  return app;\n}\n\n} // namespace ns3"
    },
    {
      "file_path": "src/applications/model/video-stream-client.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n\n#include \"ns3/log.h\"\n#include \"ns3/ipv4-address.h\"\n#include \"ns3/ipv6-address.h\"\n#include \"ns3/nstime.h\"\n#include \"ns3/inet-socket-address.h\"\n#include \"ns3/inet6-socket-address.h\"\n#include \"ns3/socket.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/socket-factory.h\"\n#include \"ns3/packet.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/trace-source-accessor.h\"\n#include \"video-stream-client.h\"\n\nnamespace ns3 {\n\nNS_LOG_COMPONENT_DEFINE (\"VideoStreamClientApplication\");\n\nNS_OBJECT_ENSURE_REGISTERED (VideoStreamClient);\n\nTypeId\nVideoStreamClient::GetTypeId (void)\n{\n  static TypeId tid = TypeId (\"ns3::VideoStreamClient\")\n    .SetParent<Application> ()\n    .SetGroupName (\"Applications\")\n    .AddConstructor<VideoStreamClient> ()\n    .AddAttribute (\"RemoteAddress\", \"The destination address of the outbound packets\",\n                    AddressValue (),\n                    MakeAddressAccessor (&VideoStreamClient::m_peerAddress),\n                    MakeAddressChecker ())\n    .AddAttribute (\"RemotePort\", \"The destination port of the outbound packets\",\n                    UintegerValue (5000),\n                    MakeUintegerAccessor (&VideoStreamClient::m_peerPort),\n                    MakeUintegerChecker<uint16_t> ())\n    \n  ;\n  return tid;\n}\n\nVideoStreamClient::VideoStreamClient ()\n{\n  NS_LOG_FUNCTION (this);\n  m_initialDelay = 3;\n  m_lastBufferSize = 0;\n  m_currentBufferSize = 0;\n  m_frameSize = 0;\n  m_frameRate = 25;\n  m_videoLevel = 3;\n  m_stopCounter = 0;\n  m_lastRecvFrame = 1e6;\n  m_rebufferCounter = 0;\n  m_bufferEvent = EventId();\n  m_sendEvent = EventId();\n}\n\nVideoStreamClient::~VideoStreamClient ()\n{\n  NS_LOG_FUNCTION (this);\n  m_socket = 0;\n}\n\nvoid\nVideoStreamClient::SetRemote (Address ip, uint16_t port)\n{\n  NS_LOG_FUNCTION (this << ip << port);\n  m_peerAddress = ip;\n  m_peerPort = port;\n}\n\nvoid \nVideoStreamClient::SetRemote (Address addr)\n{\n  NS_LOG_FUNCTION (this << addr);\n  m_peerAddress = addr;\n}\n\nvoid\nVideoStreamClient::DoDispose (void)\n{\n  NS_LOG_FUNCTION (this);\n  Application::DoDispose ();\n}\n\nvoid \nVideoStreamClient::StartApplication (void)\n{\n  NS_LOG_FUNCTION (this);\n\n  if (m_socket == 0)\n  {\n    TypeId tid = TypeId::LookupByName (\"ns3::UdpSocketFactory\");\n    m_socket = Socket::CreateSocket (GetNode (), tid);\n    if (Ipv4Address::IsMatchingType (m_peerAddress) == true)\n    {\n      if (m_socket->Bind () == -1)\n      {\n        NS_FATAL_ERROR (\"Failed to bind socket\");\n      }\n      m_socket->Connect (InetSocketAddress(Ipv4Address::ConvertFrom (m_peerAddress), m_peerPort));\n    }\n    else if (Ipv6Address::IsMatchingType (m_peerAddress) == true)\n    {\n      if (m_socket->Bind6 () == -1)\n      {\n        NS_FATAL_ERROR (\"Failed to bind socket\");\n      }\n      m_socket->Connect (m_peerAddress);\n    }\n    else if (InetSocketAddress::IsMatchingType (m_peerAddress) == true)\n    {\n      if (m_socket->Bind () == -1)\n      {\n        NS_FATAL_ERROR (\"Failed to bind socket\");\n      }\n      m_socket->Connect (m_peerAddress);\n    }\n    else if (Inet6SocketAddress::IsMatchingType (m_peerAddress) == true)\n    {\n      if (m_socket->Bind6 () == -1)\n      {\n        NS_FATAL_ERROR (\"Failed to bind socket\");\n      }\n      m_socket->Connect (m_peerAddress);\n    }\n    else\n    {\n      NS_ASSERT_MSG (false, \"Incompatible address type: \" << m_peerAddress);\n    }\n  }\n\n  m_socket->SetRecvCallback (MakeCallback (&VideoStreamClient::HandleRead, this));\n  m_sendEvent = Simulator::Schedule (MilliSeconds (1.0), &VideoStreamClient::Send, this);\n  m_bufferEvent = Simulator::Schedule (Seconds (m_initialDelay), &VideoStreamClient::ReadFromBuffer, this);\n}\n\nvoid\nVideoStreamClient::StopApplication ()\n{\n  NS_LOG_FUNCTION (this);\n\n  if (m_socket != 0)\n  {\n    m_socket->Close ();\n    m_socket->SetRecvCallback (MakeNullCallback<void, Ptr<Socket>> ());\n    m_socket = 0;\n  }\n\n  Simulator::Cancel (m_bufferEvent);\n}\n\nvoid\nVideoStreamClient::Send (void)\n{\n  NS_LOG_FUNCTION (this);\n  NS_ASSERT (m_sendEvent.IsExpired ());\n\n  uint8_t dataBuffer[10];\n  sprintf((char *) dataBuffer, \"%hu\", 0);\n  Ptr<Packet> firstPacket = Create<Packet> (dataBuffer, 10);\n  m_socket->Send (firstPacket);\n\n  if (Ipv4Address::IsMatchingType (m_peerAddress))\n  {\n    NS_LOG_INFO (\"At time \" << Simulator::Now ().GetSeconds () << \"s client sent 10 bytes to \" <<\n                  Ipv4Address::ConvertFrom (m_peerAddress) << \" port \" << m_peerPort);\n  }\n  else if (Ipv6Address::IsMatchingType (m_peerAddress))\n  {\n    NS_LOG_INFO (\"At time \" << Simulator::Now ().GetSeconds () << \"s client sent 10 bytes to \" <<\n                  Ipv6Address::ConvertFrom (m_peerAddress) << \" port \" << m_peerPort);\n  }\n  else if (InetSocketAddress::IsMatchingType (m_peerAddress))\n  {\n    NS_LOG_INFO (\"At time \" << Simulator::Now ().GetSeconds () << \"s client sent 10 bytes to \" <<\n                  InetSocketAddress::ConvertFrom (m_peerAddress).GetIpv4 () << \" port \" << InetSocketAddress::ConvertFrom (m_peerAddress).GetPort ());\n  }\n  else if (Inet6SocketAddress::IsMatchingType (m_peerAddress))\n  {\n    NS_LOG_INFO (\"At time \" << Simulator::Now ().GetSeconds () << \"s client sent 10 bytes to \" <<\n                  Inet6SocketAddress::ConvertFrom (m_peerAddress).GetIpv6 () << \" port \" << Inet6SocketAddress::ConvertFrom (m_peerAddress).GetPort ());\n  }\n}\n\nuint32_t \nVideoStreamClient::ReadFromBuffer (void)\n{\n  // NS_LOG_INFO (\"At time \" << Simulator::Now ().GetSeconds () << \" s, last buffer size: \" << m_lastBufferSize << \", current buffer size: \" << m_currentBufferSize);\n  if (m_currentBufferSize < m_frameRate) \n  {\n\n    if (m_lastBufferSize == m_currentBufferSize)\n    {\n      m_stopCounter++;\n      // If the counter reaches 3, which means the client has been waiting for 3 sec, and no packets arrived.\n      // In this case, we think the video streaming has finished, and there is no need to schedule the event.\n      if (m_stopCounter < 3)\n      {\n        m_bufferEvent = Simulator::Schedule (Seconds (1.0), &VideoStreamClient::ReadFromBuffer, this);\n      }\n    }\n    else\n    {\n      NS_LOG_INFO (\"At time \" << Simulator::Now ().GetSeconds () << \" s: Not enough frames in the buffer, rebuffering!\");\n      m_stopCounter = 0;  // reset the stopCounter\n      m_rebufferCounter++;\n      m_bufferEvent = Simulator::Schedule (Seconds (1.0), &VideoStreamClient::ReadFromBuffer, this);\n    }\n\n    m_lastBufferSize = m_currentBufferSize;\n    return (-1);\n  }\n  else\n  {\n    NS_LOG_INFO (\"At time \" << Simulator::Now ().GetSeconds () << \" s: Play video frames from the buffer\");\n    if (m_stopCounter > 0) m_stopCounter = 0;    // reset the stopCounter\n    if (m_rebufferCounter > 0) m_rebufferCounter = 0;   // reset the rebufferCounter\n    m_currentBufferSize -= m_frameRate;\n\n    m_bufferEvent = Simulator::Schedule (Seconds (1.0), &VideoStreamClient::ReadFromBuffer, this);\n    m_lastBufferSize = m_currentBufferSize;\n    return (m_currentBufferSize);\n  }\n}\n\nvoid \nVideoStreamClient::HandleRead (Ptr<Socket> socket)\n{\n  NS_LOG_FUNCTION (this << socket);\n\n  Ptr<Packet> packet;\n  Address from;\n  Address localAddress;\n  while ((packet = socket->RecvFrom (from)))\n  {\n    socket->GetSockName (localAddress);\n    if (InetSocketAddress::IsMatchingType (from))\n    {\n      uint8_t recvData[packet->GetSize()];\n      packet->CopyData (recvData, packet->GetSize ());\n      uint32_t frameNum;\n      sscanf ((char *) recvData, \"%u\", &frameNum);\n\n      if (frameNum == m_lastRecvFrame)\n      {\n        m_frameSize += packet->GetSize ();\n      }\n      else\n      {\n        if (frameNum > 0)\n        {\n          NS_LOG_INFO (\"At time \" << Simulator::Now ().GetSeconds () << \"s client received frame \" << frameNum-1 << \" and \" << m_frameSize << \" bytes from \" <<  InetSocketAddress::ConvertFrom (from).GetIpv4 () << \" port \" << InetSocketAddress::ConvertFrom (from).GetPort ());\n        }\n\n        m_currentBufferSize++;\n        m_lastRecvFrame = frameNum;\n        m_frameSize = packet->GetSize ();\n      }\n\n      // The rebuffering event has happend 3+ times, which suggest the client to lower the video quality.\n      if (m_rebufferCounter >= 3)\n      {\n        if (m_videoLevel > 1)\n        {\n          NS_LOG_INFO (\"At time \" << Simulator::Now ().GetSeconds () << \"s: Lower the video quality level!\");\n          m_videoLevel--;\n          // reflect the change to the server\n          uint8_t dataBuffer[10];\n          sprintf((char *) dataBuffer, \"%hu\", m_videoLevel);\n          Ptr<Packet> levelPacket = Create<Packet> (dataBuffer, 10);\n          socket->SendTo (levelPacket, 0, from);\n          m_rebufferCounter = 0;\n        }\n      }\n      \n      // If the current buffer size supports 5+ seconds video, we can try to increase the video quality level.\n      if (m_currentBufferSize > 5 * m_frameRate)\n      {\n        if (m_videoLevel < MAX_VIDEO_LEVEL)\n        {\n          m_videoLevel++;\n          // reflect the change to the server\n          uint8_t dataBuffer[10];\n          sprintf((char *) dataBuffer, \"%hu\", m_videoLevel);\n          Ptr<Packet> levelPacket = Create<Packet> (dataBuffer, 10);\n          socket->SendTo (levelPacket, 0, from);\n          m_currentBufferSize = m_frameRate;\n          NS_LOG_INFO (\"At time \" << Simulator::Now ().GetSeconds() << \"s: Increase the video quality level to \" << m_videoLevel);\n        }\n      }\n    }\n  }\n}\n\n} // namespace ns3"
    },
    {
      "file_path": "src/applications/model/video-stream-server.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n\n#include \"ns3/log.h\"\n#include \"ns3/ipv4-address.h\"\n#include \"ns3/ipv6-address.h\"\n#include \"ns3/address-utils.h\"\n#include \"ns3/nstime.h\"\n#include \"ns3/inet-socket-address.h\"\n#include \"ns3/inet6-socket-address.h\"\n#include \"ns3/socket.h\"\n#include \"ns3/udp-socket.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/socket-factory.h\"\n#include \"ns3/packet.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/video-stream-server.h\"\n\nnamespace ns3 {\n\nNS_LOG_COMPONENT_DEFINE (\"VideoStreamServerApplication\");\n\nNS_OBJECT_ENSURE_REGISTERED (VideoStreamServer);\n\nTypeId\nVideoStreamServer::GetTypeId (void)\n{\n  static TypeId tid = TypeId (\"ns3::VideoStreamServer\")\n    .SetParent<Application> ()\n    .SetGroupName(\"Applications\")\n    .AddConstructor<VideoStreamServer> ()\n    .AddAttribute (\"Interval\", \"The time to wait between packets\",\n                    TimeValue (Seconds (0.01)),\n                    MakeTimeAccessor (&VideoStreamServer::m_interval),\n                    MakeTimeChecker ())\n    .AddAttribute (\"Port\", \"Port on which we listen for incoming packets.\",\n                    UintegerValue (5000),\n                    MakeUintegerAccessor (&VideoStreamServer::m_port),\n                    MakeUintegerChecker<uint16_t> ())\n    .AddAttribute (\"MaxPacketSize\", \"The maximum size of a packet\",\n                    UintegerValue (1400),\n                    MakeUintegerAccessor (&VideoStreamServer::m_maxPacketSize),\n                    MakeUintegerChecker<uint16_t> ())\n    .AddAttribute (\"FrameFile\", \"The file that contains the video frame sizes\",\n                    StringValue (\"\"),\n                    MakeStringAccessor (&VideoStreamServer::SetFrameFile, &VideoStreamServer::GetFrameFile),\n                    MakeStringChecker ())\n    .AddAttribute (\"VideoLength\", \"The length of the video in seconds\",\n                    UintegerValue (60),\n                    MakeUintegerAccessor (&VideoStreamServer::m_videoLength),\n                    MakeUintegerChecker<uint32_t> ())\n    ;\n    return tid;\n}\n\nVideoStreamServer::VideoStreamServer ()\n{\n  NS_LOG_FUNCTION (this);\n  m_socket = 0;\n  m_frameRate = 25;\n  m_frameSizeList = std::vector<uint32_t>();\n}\n\nVideoStreamServer::~VideoStreamServer ()\n{\n  NS_LOG_FUNCTION (this);\n  m_socket = 0;\n}\n\nvoid \nVideoStreamServer::DoDispose (void)\n{\n  NS_LOG_FUNCTION (this);\n  Application::DoDispose ();\n}\n\nvoid\nVideoStreamServer::StartApplication (void)\n{\n  NS_LOG_FUNCTION (this);\n\n  if (m_socket == 0)\n  {\n    TypeId tid = TypeId::LookupByName (\"ns3::UdpSocketFactory\");\n    m_socket = Socket::CreateSocket (GetNode (), tid);\n    InetSocketAddress local = InetSocketAddress (Ipv4Address::GetAny (), m_port);\n    if (m_socket->Bind (local) == -1)\n    {\n      NS_FATAL_ERROR (\"Failed to bind socket\");\n    }\n    if (addressUtils::IsMulticast (m_local))\n    {\n      Ptr<UdpSocket> udpSocket = DynamicCast<UdpSocket> (m_socket);\n      if (udpSocket)\n      {\n        udpSocket->MulticastJoinGroup (0, m_local);\n      }\n      else\n      {\n        NS_FATAL_ERROR (\"Error: Failed to join multicast group\");\n      }\n    }\n  }\n\n  m_socket->SetAllowBroadcast (true);\n  m_socket->SetRecvCallback (MakeCallback (&VideoStreamServer::HandleRead, this));\n}\n\nvoid\nVideoStreamServer::StopApplication ()\n{\n  NS_LOG_FUNCTION (this);\n\n\n  if (m_socket != 0)\n  {\n    m_socket->Close();\n    m_socket->SetRecvCallback (MakeNullCallback<void, Ptr<Socket>> ());\n    m_socket = 0;\n  }\n\n  for (auto iter = m_clients.begin (); iter != m_clients.end (); iter++)\n  {\n    Simulator::Cancel (iter->second->m_sendEvent);\n  }\n  \n}\n\nvoid \nVideoStreamServer::SetFrameFile (std::string frameFile)\n{\n  NS_LOG_FUNCTION (this << frameFile);\n  m_frameFile = frameFile;\n  if (frameFile != \"\")\n  {\n    std::string line;\n    std::ifstream fileStream(frameFile);\n    while (std::getline (fileStream, line))\n    {\n      int result = std::stoi(line);\n      m_frameSizeList.push_back (result);\n    }\n  }\n  NS_LOG_INFO (\"Frame list size: \" << m_frameSizeList.size());\n}\n\nstd::string\nVideoStreamServer::GetFrameFile (void) const\n{\n  NS_LOG_FUNCTION (this);\n  return m_frameFile;\n}\n\nvoid\nVideoStreamServer::SetMaxPacketSize (uint32_t maxPacketSize)\n{\n  m_maxPacketSize = maxPacketSize;\n}\n\nuint32_t\nVideoStreamServer::GetMaxPacketSize (void) const\n{\n  return m_maxPacketSize;\n}\n\nvoid \nVideoStreamServer::Send (uint32_t ipAddress)\n{\n  NS_LOG_FUNCTION (this);\n\n  uint32_t frameSize, totalFrames;\n  ClientInfo *clientInfo = m_clients.at (ipAddress);\n\n  NS_ASSERT (clientInfo->m_sendEvent.IsExpired ());\n  // If the frame sizes are not from the text file, and the list is empty\n  if (m_frameSizeList.empty ())\n  {\n    frameSize = m_frameSizes[clientInfo->m_videoLevel];\n    totalFrames = m_videoLength * m_frameRate;\n  }\n  else\n  {\n    frameSize = m_frameSizeList[clientInfo->m_sent] * clientInfo->m_videoLevel;\n    totalFrames = m_frameSizeList.size ();\n  }\n\n  // the frame might require several packets to send\n  for (uint i = 0; i < frameSize / m_maxPacketSize; i++)\n  {\n    SendPacket (clientInfo, m_maxPacketSize);\n  }\n  uint32_t remainder = frameSize % m_maxPacketSize;\n  SendPacket (clientInfo, remainder);\n\n  NS_LOG_INFO (\"At time \" << Simulator::Now ().GetSeconds () << \"s server sent frame \" << clientInfo->m_sent << \" and \" << frameSize << \" bytes to \" << InetSocketAddress::ConvertFrom (clientInfo->m_address).GetIpv4 () << \" port \" << InetSocketAddress::ConvertFrom (clientInfo->m_address).GetPort ());\n\n  clientInfo->m_sent += 1;\n  if (clientInfo->m_sent < totalFrames)\n  {\n    clientInfo->m_sendEvent = Simulator::Schedule (m_interval, &VideoStreamServer::Send, this, ipAddress);\n  }\n}\n\nvoid \nVideoStreamServer::SendPacket (ClientInfo *client, uint32_t packetSize)\n{\n  uint8_t dataBuffer[packetSize];\n  sprintf ((char *) dataBuffer, \"%u\", client->m_sent);\n  Ptr<Packet> p = Create<Packet> (dataBuffer, packetSize);\n  if (m_socket->SendTo (p, 0, client->m_address) < 0)\n  {\n    NS_LOG_INFO (\"Error while sending \" << packetSize << \"bytes to \" << InetSocketAddress::ConvertFrom (client->m_address).GetIpv4 () << \" port \" << InetSocketAddress::ConvertFrom (client->m_address).GetPort ());\n  }\n}\n\nvoid \nVideoStreamServer::HandleRead (Ptr<Socket> socket)\n{\n  NS_LOG_FUNCTION (this << socket);\n\n  Ptr<Packet> packet;\n  Address from;\n  Address localAddress;\n  while ((packet = socket->RecvFrom (from)))\n  {\n    socket->GetSockName (localAddress);\n    if (InetSocketAddress::IsMatchingType (from))\n    {\n      NS_LOG_INFO (\"At time \" << Simulator::Now ().GetSeconds () << \"s server received \" << packet->GetSize () << \" bytes from \" << InetSocketAddress::ConvertFrom (from).GetIpv4 () << \" port \" << InetSocketAddress::ConvertFrom (from).GetPort ());\n\n      uint32_t ipAddr = InetSocketAddress::ConvertFrom (from).GetIpv4 ().Get ();\n\n      // the first time we received the message from the client\n      if (m_clients.find (ipAddr) == m_clients.end ())\n      {\n        ClientInfo *newClient = new ClientInfo();\n        newClient->m_sent = 0;\n        newClient->m_videoLevel = 3;\n        newClient->m_address = from;\n        // newClient->m_sendEvent = EventId ();\n        m_clients[ipAddr] = newClient;\n        newClient->m_sendEvent = Simulator::Schedule (Seconds (0.0), &VideoStreamServer::Send, this, ipAddr);\n      }\n      else\n      {\n        uint8_t dataBuffer[10];\n        packet->CopyData (dataBuffer, 10);\n\n        uint16_t videoLevel;\n        sscanf((char *) dataBuffer, \"%hu\", &videoLevel);\n        NS_LOG_INFO (\"At time \" << Simulator::Now ().GetSeconds () << \"s server received video level \" << videoLevel);\n        m_clients.at (ipAddr)->m_videoLevel = videoLevel;\n      }\n    }\n  }\n}\n\n} // namespace ns3"
    }
  ]
}