{
  "repo_name": "hust-diangroup/ns3-ai",
  "github_url": "https://github.com/hust-diangroup/ns3-ai",
  "readme": "# ns3-ai\n\n## Introduction\n\n[ns\u20133](https://www.nsnam.org/) is widely recognized as an excellent open-source networking simulation\ntool utilized in network research and education. In recent times, there has been a growing interest in\nintegrating AI algorithms into network research, with many researchers opting for open-source frameworks\nsuch as [TensorFlow](https://www.tensorflow.org/) and [PyTorch](https://pytorch.org/). Integrating the\nML frameworks with simulation tools in source code level has proven to be a challenging task due to their\nindependent development. As a result, it is more practical and convenient to establish a connection\nbetween the two through interprocess data transmission.\n\n<p align=\"center\">\n    <img src=\"./docs/architecture.png\" alt=\"arch\" width=\"500\"/>\n</p>\n\nOur model offers an efficient solution to facilitate the data exchange between ns-3 and Python-based\nAI frameworks. It does not implement any specific AI algorithms. Instead, it focuses on enabling\ninterconnectivity between Python and C++. Therefore, it is necessary to separately install the desired AI\nframework. Then, by cloning or downloading our work and importing the relevant Python modules, you can\nseamlessly exchange data between ns-3 and your AI algorithms.\n\nThe approach for enabling this data exchange is inspired by [ns3-gym](https://github.com/tkn-tub/ns3-gym),\nbut it utilizes a shared-memory-based approach, which not only ensures faster execution but also provides\ngreater flexibility.\n\n### Features\n\n- High-performance data interaction module in both C++ and Python side.\n- A high-level [Gym interface](model/gym-interface) for using Gymnasium APIs, and a low-level\n  [message interface](model/msg-interface) for customizing the shared data.\n- Useful skeleton code to easily integrate with AI frameworks on Python side.\n\n## Installation\n\nCheck out [install.md](./docs/install.md) for how to install and setup ns3-ai.\n\n## Quickstart on ns3-ai\n\n### Demo\n\nTo get started on ns3-ai, check out the [A-Plus-B](examples/a-plus-b) example. This example shows how\nC++ passes two numbers to Python and their sum is passed back to C++, with the implementation using\nall available interfaces: Gym interface, message interface (struct-based) and message\ninterface (vector-based).\n\n### Documentation\n\nReady to deploy ns3-ai in your own research? Before you code, please go over the tutorials on\n[Gym interface](model/gym-interface) and [message interface](model/msg-interface). They provide\nstep-by-step guidance on writing C++-Python interfaces, with some useful code snippets.\n\nWe also created some **pure C++** examples, which uses C++-based ML frameworks to train\nmodels. They don't rely on interprocess communication, so there is no overhead in serialization\nand interprocess communication. See [using-pure-cpp](docs/using-pure-cpp.md) for details.\n\n## Examples\n\nPlease refer to the README.md in corresponding directories for more information.\n\n### [A-Plus-B](examples/a-plus-b)\n\nThis example show how you can use ns3-ai by a very simple case that you transfer `a` and `b` from ns-3 (C++) to Python\nand calculate `a + b` in Python to put back the results.\n\n### [Multi-BSS](examples/multi-bss)\n\nThis example simulates a VR gaming scenario. We change the CCA threshold using DQN\nto meet VR delay and throughput requirements. Model optimization is in progress.\n\n### [RL-TCP](examples/rl-tcp/)\n\nThis example is inspired by [ns3-gym example](https://github.com/tkn-tub/ns3-gym#rl-tcp). We build this example for the\n[benchmarking](./docs/benchmarking) and to compare with their module.\n\n### [Rate-Control](examples/rate-control)\n\nThis is an example that shows how to develop a new rate control algorithm for the ns-3 Wi-Fi module using ns3-ai.\nAvailable examples are Constant Rate and Thompson Sampling.\n\n### [LTE-CQI](examples/lte-cqi/)\n\nThis original work is done based on [5G NR](https://5g-lena.cttc.es/) branch in ns-3. We made some changes to make it\nalso run in LTE codebase in ns-3 mainline. We didn't reproduce all the experiments on LTE, and the results in our paper\nare based on NR work.\n\n## Other materials\n\n### Google Summer of Code 2023\n\n'ns3-ai improvements' has been chosen as one of the [project ideas](https://www.nsnam.org/wiki/GSOC2023Projects)\nfor the ns-3 projects in [GSoC 2023](https://summerofcode.withgoogle.com/programs/2023). The project\ndeveloped the message interface (struct-based & vector-based) and Gym interface, provided more examples\nand enhanced stability and usability.\n\n- Project wiki page: [GSOC2023ns3-ai](https://www.nsnam.org/wiki/GSOC2023ns3-ai)\n\n### Online tutorial\n\nNote: this tutorial explains the original design, which is not up to date with the newer interface.\n\nJoin us in this [online recording](https://vimeo.com/566296651) to get better knowledge about ns3-ai.\nThe slides introducing the ns3-ai model could also be found [here](https://www.nsnam.org/wp-content/uploads/2021/tutorials/ns3-ai-tutorial-June-2021.pdf).\n\n## Cite Our Work\n\nPlease use the following bibtex:\n\n```\n@inproceedings{10.1145/3389400.3389404,\nauthor = {Yin, Hao and Liu, Pengyu and Liu, Keshu and Cao, Liu and Zhang, Lytianyang and Gao, Yayu and Hei, Xiaojun},\ntitle = {Ns3-Ai: Fostering Artificial Intelligence Algorithms for Networking Research},\nyear = {2020},\nisbn = {9781450375375},\npublisher = {Association for Computing Machinery},\naddress = {New York, NY, USA},\nurl = {https://doi.org/10.1145/3389400.3389404},\ndoi = {10.1145/3389400.3389404},\nbooktitle = {Proceedings of the 2020 Workshop on Ns-3},\npages = {57\u201364},\nnumpages = {8},\nkeywords = {AI, network simulation, ns-3},\nlocation = {Gaithersburg, MD, USA},\nseries = {WNS3 2020}\n}\n\n```",
  "examples": [
    {
      "file_path": "examples/a-plus-b/use-gym/apb.cc",
      "code": "/*\n * Copyright (c) 2023 Huazhong University of Science and Technology\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author:  Muyuan Shen <muyuan_shen@hust.edu.cn>\n */\n\n#include <ns3/ai-module.h>\n#include <ns3/core-module.h>\n\n#include <chrono>\n#include <iostream>\n#include <random>\n\n#define NUM_ENV 10000\n\nnamespace ns3\n{\n\nclass ApbEnv : public OpenGymEnv\n{\n  public:\n    ApbEnv();\n    ~ApbEnv() override;\n    static TypeId GetTypeId();\n    void DoDispose() override;\n\n    uint32_t GetAPlusB();\n\n    // OpenGym interfaces:\n    Ptr<OpenGymSpace> GetActionSpace() override;\n    Ptr<OpenGymSpace> GetObservationSpace() override;\n    bool GetGameOver() override;\n    Ptr<OpenGymDataContainer> GetObservation() override;\n    float GetReward() override;\n    std::string GetExtraInfo() override;\n    bool ExecuteActions(Ptr<OpenGymDataContainer> action) override;\n\n    uint32_t m_a;\n    uint32_t m_b;\n\n  private:\n    uint32_t m_sum;\n};\n\nApbEnv::ApbEnv()\n{\n    SetOpenGymInterface(OpenGymInterface::Get());\n}\n\nApbEnv::~ApbEnv()\n{\n}\n\nTypeId\nApbEnv::GetTypeId()\n{\n    static TypeId tid = TypeId(\"ns3::ApbEnv\").SetParent<OpenGymEnv>().SetGroupName(\"OpenGym\");\n    return tid;\n}\n\nvoid\nApbEnv::DoDispose()\n{\n}\n\nuint32_t\nApbEnv::GetAPlusB()\n{\n    Notify();\n    return m_sum;\n}\n\nPtr<OpenGymSpace>\nApbEnv::GetActionSpace()\n{\n    std::vector<uint32_t> shape = {1};\n    std::string dtype = TypeNameGet<uint32_t>();\n    Ptr<OpenGymBoxSpace> box = CreateObject<OpenGymBoxSpace>(0, 20, shape, dtype);\n    return box;\n}\n\nPtr<OpenGymSpace>\nApbEnv::GetObservationSpace()\n{\n    std::vector<uint32_t> shape = {2};\n    std::string dtype = TypeNameGet<uint32_t>();\n    Ptr<OpenGymBoxSpace> box = CreateObject<OpenGymBoxSpace>(0, 10, shape, dtype);\n    return box;\n}\n\nbool\nApbEnv::GetGameOver()\n{\n    return false;\n}\n\nPtr<OpenGymDataContainer>\nApbEnv::GetObservation()\n{\n    std::vector<uint32_t> shape = {2};\n    Ptr<OpenGymBoxContainer<uint32_t>> box = CreateObject<OpenGymBoxContainer<uint32_t>>(shape);\n\n    box->AddValue(m_a);\n    box->AddValue(m_b);\n\n    return box;\n}\n\nfloat\nApbEnv::GetReward()\n{\n    return 0.0;\n}\n\nstd::string\nApbEnv::GetExtraInfo()\n{\n    return \"\";\n}\n\nbool\nApbEnv::ExecuteActions(Ptr<OpenGymDataContainer> action)\n{\n    Ptr<OpenGymBoxContainer<uint32_t>> box = DynamicCast<OpenGymBoxContainer<uint32_t>>(action);\n    m_sum = box->GetValue(0);\n    return true;\n}\n\n} // namespace ns3\n\nint\nmain(int argc, char* argv[])\n{\n    using namespace ns3;\n\n    Ptr<ApbEnv> apb = CreateObject<ApbEnv>();\n\n    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\n    std::mt19937 gen(seed);\n    std::uniform_int_distribution<int> distrib(1, 10);\n\n    uint32_t sum;\n\n    for (int i = 0; i < NUM_ENV; ++i)\n    {\n        apb->m_a = distrib(gen);\n        apb->m_b = distrib(gen);\n        std::cout << \"set: \" << apb->m_a << \",\" << apb->m_b << \";\";\n        std::cout << \"\\n\";\n\n        sum = apb->GetAPlusB();\n\n        std::cout << \"get: \" << sum << \";\";\n        std::cout << \"\\n\";\n    }\n\n    apb->NotifySimulationEnd();\n\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/a-plus-b/use-msg-stru/apb.cc",
      "code": "/*\n * Copyright (c) 2020-2023 Huazhong University of Science and Technology\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Authors: Pengyu Liu <eic_lpy@hust.edu.cn>\n *          Hao Yin <haoyin@uw.edu>\n *          Muyuan Shen <muyuan_shen@hust.edu.cn>\n */\n\n#include \"apb.h\"\n\n#include <ns3/ai-module.h>\n\n#include <chrono>\n#include <iostream>\n#include <random>\n\n#define NUM_ENV 10000\n\nusing namespace ns3;\n\nint\nmain()\n{\n    auto interface = Ns3AiMsgInterface::Get();\n    interface->SetIsMemoryCreator(false);\n    interface->SetUseVector(false);\n    interface->SetHandleFinish(true);\n    Ns3AiMsgInterfaceImpl<EnvStruct, ActStruct>* msgInterface =\n        interface->GetInterface<EnvStruct, ActStruct>();\n\n    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\n    std::mt19937 gen(seed);\n    std::uniform_int_distribution<int> distrib(1, 10);\n\n    for (int i = 0; i < NUM_ENV; ++i)\n    {\n        msgInterface->CppSendBegin();\n        std::cout << \"set: \";\n        uint32_t temp_a = distrib(gen);\n        uint32_t temp_b = distrib(gen);\n        std::cout << temp_a << \",\" << temp_b << \";\";\n        msgInterface->GetCpp2PyStruct()->env_a = temp_a;\n        msgInterface->GetCpp2PyStruct()->env_b = temp_b;\n        std::cout << \"\\n\";\n        msgInterface->CppSendEnd();\n\n        msgInterface->CppRecvBegin();\n        std::cout << \"get: \";\n        std::cout << msgInterface->GetPy2CppStruct()->act_c;\n        std::cout << \"\\n\";\n        msgInterface->CppRecvEnd();\n    }\n}\n"
    },
    {
      "file_path": "examples/a-plus-b/use-msg-vec/apb.cc",
      "code": "/*\n * Copyright (c) 2023 Huazhong University of Science and Technology\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Muyuan Shen <muyuan_shen@hust.edu.cn>\n */\n\n#include \"apb.h\"\n\n#include <ns3/ai-module.h>\n\n#include <chrono>\n#include <iostream>\n#include <random>\n\n#define NUM_ENV 10000\n#define APB_SIZE 3\n\nusing namespace ns3;\n\nint\nmain()\n{\n    auto interface = Ns3AiMsgInterface::Get();\n    interface->SetIsMemoryCreator(false);\n    interface->SetUseVector(true);\n    interface->SetHandleFinish(true);\n    Ns3AiMsgInterfaceImpl<EnvStruct, ActStruct>* msgInterface =\n        interface->GetInterface<EnvStruct, ActStruct>();\n\n    // Should run after Python\n    assert(msgInterface->GetCpp2PyVector()->size() == APB_SIZE);\n\n    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\n    std::mt19937 gen(seed);\n    std::uniform_int_distribution<int> distrib(1, 10);\n\n    for (int i = 0; i < NUM_ENV; ++i)\n    {\n        msgInterface->CppSendBegin();\n        std::cout << \"set: \";\n        for (int j = 0; j < APB_SIZE; ++j)\n        {\n            uint32_t temp_a = distrib(gen);\n            uint32_t temp_b = distrib(gen);\n            std::cout << temp_a << \",\" << temp_b << \";\";\n            msgInterface->GetCpp2PyVector()->at(j).env_a = temp_a;\n            msgInterface->GetCpp2PyVector()->at(j).env_b = temp_b;\n        }\n        std::cout << \"\\n\";\n        msgInterface->CppSendEnd();\n\n        msgInterface->CppRecvBegin();\n        std::cout << \"get: \";\n        for (ActStruct j : *msgInterface->GetPy2CppVector())\n        {\n            std::cout << j.act_c << \";\";\n        }\n        std::cout << \"\\n\";\n        msgInterface->CppRecvEnd();\n    }\n}\n"
    },
    {
      "file_path": "examples/lte-cqi/use-msg/lte_cqi.cc",
      "code": "/*\n * Copyright (c) 2011-2018 Centre Tecnologic de Telecomunicacions de Catalunya (CTTC)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Authors: Jaume Nin <jaume.nin@cttc.cat>\n *          Manuel Requena <manuel.requena@cttc.es>\n * Modify:  Pengyu Liu <eic_lpy@hust.edu.cn>\n *          Hao Yin <haoyin@uw.edu>\n *          Muyuan Shen <muyuan_shen@hust.edu.cn>\n */\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\nusing namespace std;\n\nNS_LOG_COMPONENT_DEFINE(\"LenaSimpleEpc\");\n\nint\nmain(int argc, char* argv[])\n{\n    // LogComponentEnable (\"MyRrMacScheduler\", LOG_LEVEL_INFO);\n\n    uint16_t m_nUser = 5;\n    // although this speed is meaningless in reality, it has to be large to make CQI change\n    double speed = 10000;\n\n    string datarate = \"20Mbps\";\n    uint32_t packetSize = 1200;\n\n    // Set the simulation time\n    double simTime = 3.0;\n\n    // Command line arguments\n    CommandLine cmd;\n    cmd.AddValue(\"simTime\", \"Total duration of the simulation [s])\", simTime);\n    cmd.AddValue(\"datarate\", \"datarate\", datarate);\n    cmd.AddValue(\"packetSize\", \"packetSize\", packetSize);\n    cmd.AddValue(\"speed\", \"x-axis speed of moving UE\", speed);\n    cmd.Parse(argc, argv);\n\n    ConfigStore inputConfig;\n    inputConfig.ConfigureDefaults();\n\n    // parse again so you can override default values from the command line\n    cmd.Parse(argc, argv);\n\n    RngSeedManager::SetSeed(6);\n    RngSeedManager::SetRun(4);\n\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n    lteHelper->SetSchedulerType(\"ns3::MyRrMacScheduler\");\n    lteHelper->SetAttribute(\"PathlossModel\", StringValue(\"ns3::FriisSpectrumPropagationLossModel\"));\n\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n\n    // Create a single RemoteHost\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // Create the Internet\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetDeviceAttribute(\"Mtu\", UintegerValue(1500));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(10)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n    // interface 0 is localhost, 1 is the p2p device\n    // Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress (1);\n\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting =\n        ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n\n    NodeContainer ueNodes;\n    NodeContainer enbNodes;\n    enbNodes.Create(1);\n    ueNodes.Create(m_nUser);\n\n    // Install Mobility Model\n    Ptr<ListPositionAllocator> enbPositionAlloc = CreateObject<ListPositionAllocator>();\n    Ptr<ListPositionAllocator> uePositionAlloc = CreateObject<ListPositionAllocator>();\n    enbPositionAlloc->Add(Vector(0, 0, 25));\n    uePositionAlloc->Add(Vector(-15000, 8000, 1.5));   // the moving ue\n    uePositionAlloc->Add(Vector(10000, 10000, 1.5));   // stable ue #1\n    uePositionAlloc->Add(Vector(-10000, 10000, 1.5));  // stable ue #2\n    uePositionAlloc->Add(Vector(-10000, -10000, 1.5)); // stable ue #3\n    uePositionAlloc->Add(Vector(10000, -10000, 1.5));  // stable ue #4\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(enbPositionAlloc);\n    mobility.Install(enbNodes);\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.SetPositionAllocator(uePositionAlloc);\n    mobility.Install(ueNodes);\n\n    // set speed for the moving ue\n    Vector sp(speed, 0, 0);\n    ueNodes.Get(0)->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(sp);\n\n    // Install LTE Devices to the nodes\n    NetDeviceContainer enbLteDevs = lteHelper->InstallEnbDevice(enbNodes);\n    NetDeviceContainer ueLteDevs = lteHelper->InstallUeDevice(ueNodes);\n\n    Ptr<LteEnbNetDevice> lteEnbDev = enbLteDevs.Get(0)->GetObject<LteEnbNetDevice>();\n    Ptr<LteEnbPhy> enbPhy = lteEnbDev->GetPhy();\n    enbPhy->SetAttribute(\"TxPower\", DoubleValue(30.0));\n    enbPhy->SetAttribute(\"NoiseFigure\", DoubleValue(5.0));\n\n    // Install the IP stack on the UEs\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueLteDevs));\n    // Assign IP address to UEs, and install applications\n    for (uint32_t u = 0; u < ueNodes.GetN(); ++u)\n    {\n        Ptr<Node> ueNode = ueNodes.Get(u);\n        // Set the default gateway for the UE\n        Ptr<Ipv4StaticRouting> ueStaticRouting =\n            ipv4RoutingHelper.GetStaticRouting(ueNode->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    enum EpsBearer::Qci q = EpsBearer::GBR_CONV_VOICE;\n    EpsBearer bearer(q);\n\n    // Attach the UEs to the eNB\n    for (uint16_t i = 0; i < m_nUser; i++)\n    {\n        lteHelper->Attach(ueLteDevs.Get(i), enbLteDevs.Get(0));\n        // side effect: the default EPS bearer will be activated\n    }\n\n    Time udpInterval =\n        Time::FromDouble((packetSize * 8) / static_cast<double>(DataRate(datarate).GetBitRate()),\n                         Time::S);\n\n    // Install and start applications on UEs and remote host\n    uint16_t dlPort = 1234;\n    ApplicationContainer clientApps;\n    ApplicationContainer serverApps;\n    for (uint32_t u = 0; u < ueNodes.GetN(); ++u)\n    {\n        dlPort++;\n        PacketSinkHelper dlPacketSinkHelper(\"ns3::UdpSocketFactory\",\n                                            InetSocketAddress(Ipv4Address::GetAny(), dlPort));\n\n        serverApps.Add(dlPacketSinkHelper.Install(ueNodes.Get(u)));\n\n        UdpClientHelper dlClient(ueIpIface.GetAddress(u), dlPort);\n        dlClient.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n        dlClient.SetAttribute(\"Interval\", TimeValue(udpInterval));\n        dlClient.SetAttribute(\"MaxPackets\", UintegerValue(0xFFFFFFFF));\n\n        clientApps.Add(dlClient.Install(remoteHost));\n    }\n\n    serverApps.Start(MilliSeconds(10));\n    clientApps.Start(MilliSeconds(10));\n    lteHelper->EnableTraces();\n    // Uncomment to enable PCAP tracing\n    // p2ph.EnablePcapAll(\"lena-simple-epc\");\n\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n    // flowmon.Install (enbNodes.Get (0));\n\n    Ptr<RadioBearerStatsCalculator> rlcStats = lteHelper->GetRlcStats();\n    rlcStats->SetAttribute(\"EpochDuration\", TimeValue(Seconds(simTime)));\n\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n\n    /*GtkConfigStore config;\n    config.ConfigureAttributes();*/\n\n    cout << \"Begin Simulation Results\" << endl;\n\n    monitor->CheckForLostPackets();\n\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n\n    double Throughput = 0.0;\n\n    for (map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end();\n         ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n\n        cout << \"Flow ID: \" << i->first << \" Src Addr \" << t.sourceAddress << \" Dst Addr \"\n             << t.destinationAddress << endl;\n        cout << \"Tx Packets = \" << i->second.txPackets << endl;\n        cout << \"Rx Packets = \" << i->second.rxPackets << endl;\n        Throughput =\n            i->second.rxBytes * 8.0 /\n            (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) /\n            1024;\n        cout << \"Throughput: \" << Throughput << \" Kbps\" << endl;\n    }\n\n    NS_LOG_UNCOND(\"Done\");\n\n    cout << \"End Simulation Results\" << endl;\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/multi-bss/auto-mcs-wifi-manager.cc",
      "code": "/*\n * Copyright (c) 2006 INRIA\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Mathieu Lacage <mathieu.lacage@sophia.inria.fr>\n */\n\n#include \"auto-mcs-wifi-manager.h\"\n\n#include \"ns3/log.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/wifi-phy.h\"\n\n#include <algorithm>\n#include <absl/time/time.h>\n\nnamespace ns3\n{\n\n/**\n * \\brief hold per-remote-station state for Auto Mcs Wifi manager.\n *\n * This struct extends from WifiRemoteStation struct to hold additional\n * information required by the Auto Mcs Wifi manager\n */\nstruct AutoMcsWifiRemoteStation : public WifiRemoteStation\n{\n    double m_lastSnrObserved; //!< SNR of most recently reported packet sent to the remote station\n    uint16_t m_lastChannelWidthObserved; //!< Channel width (in MHz) of most recently reported\n                                         //!< packet sent to the remote station\n    uint16_t m_lastNssObserved; //!<  Number of spatial streams of most recently reported packet\n                                //!<  sent to the remote station\n    double m_lastSnrCached;     //!< SNR most recently used to select a rate\n    uint8_t m_lastNss;   //!< Number of spatial streams most recently used to the remote station\n    WifiMode m_lastMode; //!< Mode most recently used to the remote station\n    uint16_t\n        m_lastChannelWidth; //!< Channel width (in MHz) most recently used to the remote station\n};\n\n/// To avoid using the cache before a valid value has been cached\nstatic const double CACHE_INITIAL_VALUE = -100;\n\nNS_OBJECT_ENSURE_REGISTERED(AutoMcsWifiManager);\n\nNS_LOG_COMPONENT_DEFINE(\"AutoMcsWifiManager\");\n\nTypeId\nAutoMcsWifiManager::GetTypeId()\n{\n    static TypeId tid =\n        TypeId(\"ns3::AutoMcsWifiManager\")\n            .SetParent<WifiRemoteStationManager>()\n            .SetGroupName(\"Wifi\")\n            .AddConstructor<AutoMcsWifiManager>()\n            .AddAttribute(\"BerThreshold\",\n                          \"The maximum Bit Error Rate acceptable at any transmission mode\",\n                          DoubleValue(1e-7), // This default value was modified\n                          MakeDoubleAccessor(&AutoMcsWifiManager::m_ber),\n                          MakeDoubleChecker<double>())\n            .AddAttribute(\"autoMCS\",\n                          \"If enabled, select the best MCS for each STA-AP pair given the SNR.\",\n                          BooleanValue(false),\n                          MakeBooleanAccessor(&AutoMcsWifiManager::m_autoMCS),\n                          MakeBooleanChecker())\n            .AddTraceSource(\"Rate\",\n                            \"Traced value for rate changes (b/s)\",\n                            MakeTraceSourceAccessor(&AutoMcsWifiManager::m_currentRate),\n                            \"ns3::TracedValueCallback::Uint64\");\n    return tid;\n}\n\nAutoMcsWifiManager::AutoMcsWifiManager()\n    : m_currentRate(0)\n{\n    NS_LOG_FUNCTION(this);\n}\n\nAutoMcsWifiManager::~AutoMcsWifiManager()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nAutoMcsWifiManager::SetupPhy(const Ptr<WifiPhy> phy)\n{\n    NS_LOG_FUNCTION(this << phy);\n    WifiRemoteStationManager::SetupPhy(phy);\n}\n\nuint16_t\nAutoMcsWifiManager::GetChannelWidthForNonHtMode(WifiMode mode) const\n{\n    NS_ASSERT(mode.GetModulationClass() != WIFI_MOD_CLASS_HT &&\n              mode.GetModulationClass() != WIFI_MOD_CLASS_VHT &&\n              mode.GetModulationClass() != WIFI_MOD_CLASS_HE);\n    if (mode.GetModulationClass() == WIFI_MOD_CLASS_DSSS ||\n        mode.GetModulationClass() == WIFI_MOD_CLASS_HR_DSSS)\n    {\n        return 22;\n    }\n    else\n    {\n        return 20;\n    }\n}\n\nvoid\nAutoMcsWifiManager::DoInitialize()\n{\n    NS_LOG_FUNCTION(this);\n    BuildSnrThresholds();\n}\n\n// void\n// IdealWifiManager::PrintOutPer(double snr, WifiTxVector txVector)\n// {\n// }\n\nvoid\nAutoMcsWifiManager::BuildSnrThresholds()\n{\n    m_thresholds.clear();\n    WifiTxVector txVector;\n    uint8_t nss = 1;\n    for (const auto& mode : GetPhy()->GetModeList())\n    {\n        txVector.SetChannelWidth(GetChannelWidthForNonHtMode(mode));\n        txVector.SetNss(nss);\n        txVector.SetMode(mode);\n        NS_LOG_DEBUG(\"Adding mode = \" << mode.GetUniqueName());\n        AddSnrThreshold(txVector, GetPhy()->CalculateSnr(txVector, m_ber));\n    }\n    // Add all MCSes\n    if (GetHtSupported())\n    {\n        for (const auto& mode : GetPhy()->GetMcsList())\n        {\n            for (uint16_t j = 20; j <= GetPhy()->GetChannelWidth(); j *= 2)\n            {\n                txVector.SetChannelWidth(j);\n                if (mode.GetModulationClass() == WIFI_MOD_CLASS_HT)\n                {\n                    uint16_t guardInterval = GetShortGuardIntervalSupported() ? 400 : 800;\n                    txVector.SetGuardInterval(NanoSeconds(guardInterval));\n                    // derive NSS from the MCS index\n                    nss = (mode.GetMcsValue() / 8) + 1;\n                    NS_LOG_DEBUG(\"Adding mode = \" << mode.GetUniqueName() << \" channel width \" << j\n                                                  << \" nss \" << +nss << \" GI \" << guardInterval);\n                    txVector.SetNss(nss);\n                    txVector.SetMode(mode);\n                    AddSnrThreshold(txVector, GetPhy()->CalculateSnr(txVector, m_ber));\n                }\n                else // VHT or HE\n                {\n                    uint16_t guardInterval;\n                    if (mode.GetModulationClass() == WIFI_MOD_CLASS_VHT)\n                    {\n                        guardInterval = GetShortGuardIntervalSupported() ? 400 : 800;\n                    }\n                    else\n                    {\n                        guardInterval = GetGuardInterval().ToInteger(Time::NS);\n                    }\n                    txVector.SetGuardInterval(NanoSeconds(guardInterval));\n                    for (uint8_t k = 1; k <= GetPhy()->GetMaxSupportedTxSpatialStreams(); k++)\n                    {\n                        if (mode.IsAllowed(j, k))\n                        {\n                            NS_LOG_DEBUG(\"Adding mode = \" << mode.GetUniqueName()\n                                                          << \" channel width \" << j << \" nss \" << +k\n                                                          << \" GI \" << guardInterval);\n                            txVector.SetNss(k);\n                            txVector.SetMode(mode);\n                            AddSnrThreshold(txVector, GetPhy()->CalculateSnr(txVector, m_ber));\n                            std::vector<double> berThreshold{8.37e-7};\n                            // std::vector<double> berThreshold{1e-6, 1e-7, 1e-8};\n\n                            // std::vector<double> berThreshold{1.0 - std::pow((1.0 - 0.1),\n                            // 12000.0),\n                            //                                  1.0 - std::pow((1.0 - 0.01),\n                            //                                  12000.0), 1.0 -\n                            //                                      std::pow((1.0 - 0.001),\n                            //                                      12000.0)};\n                            // for (auto ber : berThreshold)\n                            // {\n                            //     std::cout << \"Mode \" << mode << \" Requires an SNR of  \"\n                            //               << RatioToDb(GetPhy()->CalculateSnr(txVector, ber))\n                            //               << \" for a ber \" << ber << std::endl;\n                            // }\n                        }\n                        else\n                        {\n                            NS_LOG_DEBUG(\"Mode = \" << mode.GetUniqueName() << \" disallowed\");\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\ndouble\nAutoMcsWifiManager::GetSnrThreshold(WifiTxVector txVector)\n{\n    NS_LOG_FUNCTION(this << txVector);\n    auto it = std::find_if(m_thresholds.begin(),\n                           m_thresholds.end(),\n                           [&txVector](const std::pair<double, WifiTxVector>& p) -> bool {\n                               return ((txVector.GetMode() == p.second.GetMode()) &&\n                                       (txVector.GetNss() == p.second.GetNss()) &&\n                                       (txVector.GetChannelWidth() == p.second.GetChannelWidth()));\n                           });\n    if (it == m_thresholds.end())\n    {\n        // This means capabilities have changed in runtime, hence rebuild SNR thresholds\n        BuildSnrThresholds();\n        it = std::find_if(m_thresholds.begin(),\n                          m_thresholds.end(),\n                          [&txVector](const std::pair<double, WifiTxVector>& p) -> bool {\n                              return ((txVector.GetMode() == p.second.GetMode()) &&\n                                      (txVector.GetNss() == p.second.GetNss()) &&\n                                      (txVector.GetChannelWidth() == p.second.GetChannelWidth()));\n                          });\n        NS_ASSERT_MSG(it != m_thresholds.end(), \"SNR threshold not found\");\n    }\n    return it->first;\n}\n\nvoid\nAutoMcsWifiManager::AddSnrThreshold(WifiTxVector txVector, double snr)\n{\n    NS_LOG_FUNCTION(this << txVector.GetMode().GetUniqueName() << txVector.GetChannelWidth()\n                         << snr);\n    m_thresholds.emplace_back(snr, txVector);\n}\n\nWifiRemoteStation*\nAutoMcsWifiManager::DoCreateStation() const\n{\n    NS_LOG_FUNCTION(this);\n    AutoMcsWifiRemoteStation* station = new AutoMcsWifiRemoteStation();\n    Reset(station);\n    return station;\n}\n\nvoid\nAutoMcsWifiManager::Reset(WifiRemoteStation* station) const\n{\n    NS_LOG_FUNCTION(this << station);\n    AutoMcsWifiRemoteStation* st = static_cast<AutoMcsWifiRemoteStation*>(station);\n    st->m_lastSnrObserved = 0.0;\n    st->m_lastChannelWidthObserved = 0;\n    st->m_lastNssObserved = 1;\n    st->m_lastSnrCached = CACHE_INITIAL_VALUE;\n    st->m_lastMode = GetDefaultMode();\n    st->m_lastChannelWidth = 0;\n    st->m_lastNss = 1;\n}\n\nvoid\nAutoMcsWifiManager::DoReportRxOk(WifiRemoteStation* station, double rxSnr, WifiMode txMode)\n{\n    NS_LOG_FUNCTION(this << station << rxSnr << txMode);\n    // choosenMCS.emplace_back(txMode.GetMcsValue());\n}\n\nvoid\nAutoMcsWifiManager::DoReportRtsFailed(WifiRemoteStation* station)\n{\n    NS_LOG_FUNCTION(this << station);\n}\n\nvoid\nAutoMcsWifiManager::DoReportDataFailed(WifiRemoteStation* station)\n{\n    NS_LOG_FUNCTION(this << station);\n}\n\nvoid\nAutoMcsWifiManager::DoReportRtsOk(WifiRemoteStation* st,\n                                  double ctsSnr,\n                                  WifiMode ctsMode,\n                                  double rtsSnr)\n{\n    NS_LOG_FUNCTION(this << st << ctsSnr << ctsMode.GetUniqueName() << rtsSnr);\n    AutoMcsWifiRemoteStation* station = static_cast<AutoMcsWifiRemoteStation*>(st);\n    station->m_lastSnrObserved = rtsSnr;\n    station->m_lastChannelWidthObserved =\n        GetPhy()->GetChannelWidth() >= 40 ? 20 : GetPhy()->GetChannelWidth();\n    station->m_lastNssObserved = 1;\n}\n\nvoid\nAutoMcsWifiManager::DoReportDataOk(WifiRemoteStation* st,\n                                   double ackSnr,\n                                   WifiMode ackMode,\n                                   double dataSnr,\n                                   MHz_u dataChannelWidth,\n                                   uint8_t dataNss)\n{\n    NS_LOG_FUNCTION(this << st << ackSnr << ackMode.GetUniqueName() << dataSnr << dataChannelWidth\n                         << +dataNss);\n    AutoMcsWifiRemoteStation* station = static_cast<AutoMcsWifiRemoteStation*>(st);\n    if (dataSnr == 0)\n    {\n        NS_LOG_WARN(\"DataSnr reported to be zero; not saving this report.\");\n        return;\n    }\n    station->m_lastSnrObserved = dataSnr;\n    station->m_lastChannelWidthObserved = dataChannelWidth;\n    station->m_lastNssObserved = dataNss;\n    // The default value of m_lastMode is non-HT, thus invalid for GetMcsValue\n    if (station->m_lastMode != GetDefaultMode())\n    {\n        choosenMCS.emplace_back(station->m_lastMode.GetMcsValue());\n    }\n}\n\nvoid\nAutoMcsWifiManager::DoReportAmpduTxStatus(WifiRemoteStation* st,\n                                          uint16_t nSuccessfulMpdus,\n                                          uint16_t nFailedMpdus,\n                                          double rxSnr,\n                                          double dataSnr,\n                                          MHz_u dataChannelWidth,\n                                          uint8_t dataNss)\n{\n    NS_LOG_FUNCTION(this << st << nSuccessfulMpdus << nFailedMpdus << rxSnr << dataSnr\n                         << dataChannelWidth << +dataNss);\n    AutoMcsWifiRemoteStation* station = static_cast<AutoMcsWifiRemoteStation*>(st);\n    if (dataSnr == 0)\n    {\n        NS_LOG_WARN(\"DataSnr reported to be zero; not saving this report.\");\n        return;\n    }\n    for (int i = 0; i < nSuccessfulMpdus; i++)\n    {\n        choosenMCS.emplace_back(station->m_lastMode.GetMcsValue());\n    }\n    station->m_lastSnrObserved = dataSnr;\n    station->m_lastChannelWidthObserved = dataChannelWidth;\n    station->m_lastNssObserved = dataNss;\n}\n\nvoid\nAutoMcsWifiManager::DoReportFinalRtsFailed(WifiRemoteStation* station)\n{\n    NS_LOG_FUNCTION(this << station);\n    Reset(station);\n}\n\nvoid\nAutoMcsWifiManager::DoReportFinalDataFailed(WifiRemoteStation* station)\n{\n    NS_LOG_FUNCTION(this << station);\n    Reset(station);\n}\n\nWifiTxVector\nAutoMcsWifiManager::DoGetDataTxVector(WifiRemoteStation* st, MHz_u allowedWidth)\n{\n    NS_LOG_FUNCTION(this << st << allowedWidth);\n    AutoMcsWifiRemoteStation* station = static_cast<AutoMcsWifiRemoteStation*>(st);\n    // We search within the Supported rate set the mode with the\n    // highest data rate for which the SNR threshold is smaller than m_lastSnr\n    // to ensure correct packet delivery.\n    WifiMode maxMode = GetDefaultModeForSta(st);\n    WifiTxVector txVector;\n    WifiMode mode;\n    uint64_t bestRate = 0;\n    uint8_t selectedNss = 1;\n    uint16_t guardInterval;\n    uint16_t channelWidth = std::min(GetChannelWidth(station), allowedWidth);\n    txVector.SetChannelWidth(channelWidth);\n\n    if ((Simulator::Now().GetSeconds() < 10))\n    {\n        if ((station->m_lastSnrCached != CACHE_INITIAL_VALUE) &&\n            (station->m_lastSnrObserved == station->m_lastSnrCached) &&\n            (channelWidth == station->m_lastChannelWidth))\n        {\n            // SNR has not changed, so skip the search and use the last mode selected\n            maxMode = station->m_lastMode;\n            selectedNss = station->m_lastNss;\n            NS_LOG_DEBUG(\"Using cached mode = \" << maxMode.GetUniqueName() << \" last snr observed \"\n                                                << station->m_lastSnrObserved << \" cached \"\n                                                << station->m_lastSnrCached << \" channel width \"\n                                                << station->m_lastChannelWidth << \" nss \"\n                                                << +selectedNss);\n        }\n\n        else\n        {\n            if (GetHtSupported() && GetHtSupported(st))\n            {\n                for (uint8_t i = 0; i < GetNMcsSupported(station); i++)\n                {\n                    mode = GetMcsSupported(station, i);\n                    txVector.SetMode(mode);\n                    if (mode.GetModulationClass() == WIFI_MOD_CLASS_HT)\n                    {\n                        guardInterval = static_cast<uint16_t>(\n                            std::max(GetShortGuardIntervalSupported(station) ? 400 : 800,\n                                     GetShortGuardIntervalSupported() ? 400 : 800));\n                        txVector.SetGuardInterval(NanoSeconds(guardInterval));\n                        // If the node and peer are both VHT capable, only search VHT modes\n                        if (GetVhtSupported() && GetVhtSupported(station))\n                        {\n                            continue;\n                        }\n                        // If the node and peer are both HE capable, only search HE modes\n                        if (GetHeSupported() && GetHeSupported(station))\n                        {\n                            continue;\n                        }\n                        // Derive NSS from the MCS index. There is a different mode for each\n                        // possible NSS value.\n                        uint8_t nss = (mode.GetMcsValue() / 8) + 1;\n                        txVector.SetNss(nss);\n                        if (!txVector.IsValid() || nss > std::min(GetMaxNumberOfTransmitStreams(),\n                                                                  GetNumberOfSupportedStreams(st)))\n                        {\n                            NS_LOG_DEBUG(\"Skipping mode \" << mode.GetUniqueName() << \" nss \" << +nss\n                                                          << \" width \"\n                                                          << txVector.GetChannelWidth());\n                            continue;\n                        }\n                        double threshold = GetSnrThreshold(txVector);\n                        uint64_t dataRate = mode.GetDataRate(txVector.GetChannelWidth(),\n                                                             txVector.GetGuardInterval(),\n                                                             nss);\n                        NS_LOG_DEBUG(\"Testing mode \" << mode.GetUniqueName() << \" data rate \"\n                                                     << dataRate << \" threshold \" << threshold\n                                                     << \" last snr observed \"\n                                                     << station->m_lastSnrObserved << \" cached \"\n                                                     << station->m_lastSnrCached);\n                        double snr = GetLastObservedSnr(station, channelWidth, nss);\n                        if (dataRate > bestRate && threshold < snr)\n                        {\n                            NS_LOG_DEBUG(\"Candidate mode = \"\n                                         << mode.GetUniqueName() << \" data rate \" << dataRate\n                                         << \" threshold \" << threshold << \" channel width \"\n                                         << channelWidth << \" snr \" << snr);\n                            bestRate = dataRate;\n                            maxMode = mode;\n                            selectedNss = nss;\n                        }\n                    }\n                    else if (mode.GetModulationClass() == WIFI_MOD_CLASS_VHT)\n                    {\n                        guardInterval = static_cast<uint16_t>(\n                            std::max(GetShortGuardIntervalSupported(station) ? 400 : 800,\n                                     GetShortGuardIntervalSupported() ? 400 : 800));\n                        txVector.SetGuardInterval(NanoSeconds(guardInterval));\n                        // If the node and peer are both HE capable, only search HE modes\n                        if (GetHeSupported() && GetHeSupported(station))\n                        {\n                            continue;\n                        }\n                        // If the node and peer are not both VHT capable, only search HT modes\n                        if (!GetVhtSupported() || !GetVhtSupported(station))\n                        {\n                            continue;\n                        }\n                        for (uint8_t nss = 1; nss <= std::min(GetMaxNumberOfTransmitStreams(),\n                                                              GetNumberOfSupportedStreams(station));\n                             nss++)\n                        {\n                            txVector.SetNss(nss);\n                            if (!txVector.IsValid())\n                            {\n                                NS_LOG_DEBUG(\"Skipping mode \" << mode.GetUniqueName() << \" nss \"\n                                                              << +nss << \" width \"\n                                                              << txVector.GetChannelWidth());\n                                continue;\n                            }\n                            double threshold = GetSnrThreshold(txVector);\n                            uint64_t dataRate = mode.GetDataRate(txVector.GetChannelWidth(),\n                                                                 txVector.GetGuardInterval(),\n                                                                 nss);\n                            NS_LOG_DEBUG(\"Testing mode = \"\n                                         << mode.GetUniqueName() << \" data rate \" << dataRate\n                                         << \" threshold \" << threshold << \" last snr observed \"\n                                         << station->m_lastSnrObserved << \" cached \"\n                                         << station->m_lastSnrCached);\n                            double snr = GetLastObservedSnr(station, channelWidth, nss);\n                            if (dataRate > bestRate && threshold < snr)\n                            {\n                                NS_LOG_DEBUG(\"Candidate mode = \" << mode.GetUniqueName()\n                                                                 << \" data rate \" << dataRate\n                                                                 << \" channel width \"\n                                                                 << channelWidth << \" snr \" << snr);\n                                bestRate = dataRate;\n                                maxMode = mode;\n                                selectedNss = nss;\n                            }\n                        }\n                    }\n                    else // HE\n                    {\n                        guardInterval = std::max(GetGuardInterval(station).ToInteger(Time::NS), GetGuardInterval().ToInteger(Time::NS));\n                        txVector.SetGuardInterval(NanoSeconds(guardInterval));\n                        // If the node and peer are not both HE capable, only search (V)HT modes\n                        if (!GetHeSupported() || !GetHeSupported(station))\n                        {\n                            continue;\n                        }\n                        for (uint8_t nss = 1; nss <= std::min(GetMaxNumberOfTransmitStreams(),\n                                                              GetNumberOfSupportedStreams(station));\n                             nss++)\n                        {\n                            txVector.SetNss(nss);\n                            if (!txVector.IsValid())\n                            {\n                                NS_LOG_DEBUG(\"Skipping mode \" << mode.GetUniqueName() << \" nss \"\n                                                              << +nss << \" width \"\n                                                              << +txVector.GetChannelWidth());\n                                continue;\n                            }\n                            double threshold = GetSnrThreshold(txVector);\n                            uint64_t dataRate = mode.GetDataRate(txVector.GetChannelWidth(),\n                                                                 txVector.GetGuardInterval(),\n                                                                 nss);\n                            NS_LOG_DEBUG(\"Testing mode = \"\n                                         << mode.GetUniqueName() << \" data rate \" << dataRate\n                                         << \" threshold \" << threshold << \" last snr observed \"\n                                         << station->m_lastSnrObserved << \" cached \"\n                                         << station->m_lastSnrCached);\n                            double snr = GetLastObservedSnr(station, channelWidth, nss);\n                            if (dataRate > bestRate && threshold < snr)\n                            {\n                                NS_LOG_DEBUG(\"Candidate mode = \"\n                                             << mode.GetUniqueName() << \" data rate \" << dataRate\n                                             << \" threshold \" << threshold << \" channel width \"\n                                             << channelWidth << \" snr \" << snr);\n                                bestRate = dataRate;\n                                maxMode = mode;\n                                selectedNss = nss;\n                            }\n                        }\n                    }\n                }\n            }\n            else\n            {\n                // Non-HT selection\n                selectedNss = 1;\n                for (uint8_t i = 0; i < GetNSupported(station); i++)\n                {\n                    mode = GetSupported(station, i);\n                    txVector.SetMode(mode);\n                    txVector.SetNss(selectedNss);\n                    uint16_t width = GetChannelWidthForNonHtMode(mode);\n                    txVector.SetChannelWidth(width);\n                    double threshold = GetSnrThreshold(txVector);\n                    uint64_t dataRate = mode.GetDataRate(txVector.GetChannelWidth(),\n                                                         txVector.GetGuardInterval(),\n                                                         txVector.GetNss());\n                    NS_LOG_DEBUG(\"mode = \" << mode.GetUniqueName() << \" threshold \" << threshold\n                                           << \" last snr observed \" << station->m_lastSnrObserved);\n                    double snr = GetLastObservedSnr(station, width, 1);\n                    if (dataRate > bestRate && threshold < snr)\n                    {\n                        NS_LOG_DEBUG(\"Candidate mode = \" << mode.GetUniqueName() << \" data rate \"\n                                                         << dataRate << \" threshold \" << threshold\n                                                         << \" snr \" << snr);\n                        bestRate = dataRate;\n                        maxMode = mode;\n                    }\n                }\n            }\n            NS_LOG_DEBUG(\"Updating cached values for station to \"\n                         << maxMode.GetUniqueName() << \" snr \" << station->m_lastSnrObserved);\n            station->m_lastSnrCached = station->m_lastSnrObserved;\n            station->m_lastMode = maxMode;\n            station->m_lastNss = selectedNss;\n        }\n    }\n    else\n    {\n        double average = 0;\n        for (auto it : choosenMCS)\n        {\n            average += it;\n        }\n        // std::cout << \" raw value \" << average / choosenMCS.size() << std::endl;\n        average = std::ceil(average / choosenMCS.size());\n        std::string mcs = \"HeMcs\" + std::to_string(int(average));\n        maxMode = WifiMode(mcs);\n    }\n    NS_LOG_DEBUG(\"Found maxMode: \" << maxMode << \" channelWidth: \" << channelWidth\n                                   << \" nss: \" << +selectedNss);\n    station->m_lastChannelWidth = channelWidth;\n    if (maxMode.GetModulationClass() == WIFI_MOD_CLASS_HE)\n    {\n        guardInterval = std::max(GetGuardInterval(station).ToInteger(Time::NS), GetGuardInterval().ToInteger(Time::NS));\n    }\n    else if ((maxMode.GetModulationClass() == WIFI_MOD_CLASS_HT) ||\n             (maxMode.GetModulationClass() == WIFI_MOD_CLASS_VHT))\n    {\n        guardInterval =\n            static_cast<uint16_t>(std::max(GetShortGuardIntervalSupported(station) ? 400 : 800,\n                                           GetShortGuardIntervalSupported() ? 400 : 800));\n    }\n    else\n    {\n        guardInterval = 800;\n    }\n    WifiTxVector bestTxVector{\n        maxMode,\n        GetDefaultTxPowerLevel(),\n        GetPreambleForTransmission(maxMode.GetModulationClass(), GetShortPreambleEnabled()),\n        NanoSeconds(guardInterval),\n        GetNumberOfAntennas(),\n        selectedNss,\n        0,\n        GetPhy()->GetTxBandwidth(maxMode, channelWidth),\n        GetAggregation(station)};\n\n    uint64_t maxDataRate = maxMode.GetDataRate(bestTxVector);\n\n    if (m_currentRate != maxDataRate)\n    {\n        // std::cout << \"New datarate: \" << maxMode << std::endl;\n\n        m_currentRate = maxDataRate;\n    }\n\n    return bestTxVector;\n}\n\nWifiTxVector\nAutoMcsWifiManager::DoGetRtsTxVector(WifiRemoteStation* st)\n{\n    NS_LOG_FUNCTION(this << st);\n    if (!m_autoMCS)\n    {\n        AutoMcsWifiRemoteStation* station = static_cast<AutoMcsWifiRemoteStation*>(st);\n        // We search within the Basic rate set the mode with the highest\n        // SNR threshold possible which is smaller than m_lastSnr to\n        // ensure correct packet delivery.\n        double maxThreshold = 0.0;\n        WifiTxVector txVector;\n        WifiMode mode;\n        uint8_t nss = 1;\n        WifiMode maxMode = GetDefaultMode();\n        // RTS is sent in a non-HT frame\n        for (uint8_t i = 0; i < GetNBasicModes(); i++)\n        {\n            mode = GetBasicMode(i);\n            txVector.SetMode(mode);\n            txVector.SetNss(nss);\n            txVector.SetChannelWidth(GetChannelWidthForNonHtMode(mode));\n            double threshold = GetSnrThreshold(txVector);\n            if (threshold > maxThreshold && threshold < station->m_lastSnrObserved)\n            {\n                maxThreshold = threshold;\n                maxMode = mode;\n            }\n        }\n        return WifiTxVector(\n            maxMode,\n            GetDefaultTxPowerLevel(),\n            GetPreambleForTransmission(maxMode.GetModulationClass(), GetShortPreambleEnabled()),\n            NanoSeconds(800),\n            GetNumberOfAntennas(),\n            nss,\n            0,\n            GetChannelWidthForNonHtMode(maxMode),\n            GetAggregation(station));\n    }\n    else\n    {\n        return WifiTxVector(\n            WifiMode(\"OfdmRate6Mbps\"),\n            GetDefaultTxPowerLevel(),\n            GetPreambleForTransmission(WifiMode(\"OfdmRate6Mbps\").GetModulationClass(),\n                                       GetShortPreambleEnabled()),\n            GetGuardInterval(st),\n            1,\n            1,\n            0,\n            GetPhy()->GetTxBandwidth(WifiMode(\"OfdmRate6Mbps\"), GetChannelWidth(st)),\n            GetAggregation(st));\n    }\n}\n\ndouble\nAutoMcsWifiManager::GetLastObservedSnr(AutoMcsWifiRemoteStation* station,\n                                       uint16_t channelWidth,\n                                       uint8_t nss) const\n{\n    double snr = station->m_lastSnrObserved;\n    if (channelWidth != station->m_lastChannelWidthObserved)\n    {\n        snr /= (static_cast<double>(channelWidth) / station->m_lastChannelWidthObserved);\n    }\n    if (nss != station->m_lastNssObserved)\n    {\n        snr /= (static_cast<double>(nss) / station->m_lastNssObserved);\n    }\n    NS_LOG_DEBUG(\"Last observed SNR is \" << station->m_lastSnrObserved << \" for channel width \"\n                                         << station->m_lastChannelWidthObserved << \" and nss \"\n                                         << +station->m_lastNssObserved << \"; computed SNR is \"\n                                         << snr << \" for channel width \" << channelWidth\n                                         << \" and nss \" << +nss);\n    return snr;\n}\n\n} // namespace ns3\n"
    },
    {
      "file_path": "examples/multi-bss/multi-bss.cc",
      "code": "/*\n * Copyright (c) 2022\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n\n#include \"multi-bss.h\"\n\n#include \"tgax-residential-propagation-loss-model.h\"\n\n#include \"ns3/ai-module.h\"\n#include \"ns3/ampdu-subframe-header.h\"\n#include \"ns3/ap-wifi-mac.h\"\n#include \"ns3/application-container.h\"\n#include \"ns3/boolean.h\"\n#include \"ns3/buildings-helper.h\"\n#include \"ns3/buildings-module.h\"\n#include \"ns3/burst-sink-helper.h\"\n#include \"ns3/bursty-helper.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/ctrl-headers.h\"\n#include \"ns3/double.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/frame-exchange-manager.h\"\n#include \"ns3/he-configuration.h\"\n#include \"ns3/he-phy.h\"\n#include \"ns3/ht-phy.h\"\n#include \"ns3/integer.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-flow-classifier.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/multi-model-spectrum-channel.h\"\n#include \"ns3/node-list.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/packet-socket-client.h\"\n#include \"ns3/packet-socket-helper.h\"\n#include \"ns3/packet-socket-server.h\"\n#include \"ns3/pointer.h\"\n#include \"ns3/qos-txop.h\"\n#include \"ns3/queue-item.h\"\n#include \"ns3/queue-size.h\"\n#include \"ns3/rng-seed-manager.h\"\n#include \"ns3/seq-ts-size-frag-header.h\"\n#include \"ns3/spectrum-wifi-helper.h\"\n#include \"ns3/spectrum-wifi-phy.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/sta-wifi-mac.h\"\n#include \"ns3/string.h\"\n#include \"ns3/threshold-preamble-detection-model.h\"\n#include \"ns3/trace-file-burst-generator.h\"\n#include \"ns3/traffic-control-helper.h\"\n#include \"ns3/traffic-control-layer.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/uinteger.h\"\n// #include \"ns3/v4ping-helper.h\"\n#include \"ns3/wifi-acknowledgment.h\"\n#include \"ns3/wifi-mac-queue.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/wifi-psdu.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <algorithm>\n#include <array>\n#include <cmath>\n#include <fstream>\n#include <map>\n#include <sstream>\n#include <unordered_map>\n#include <vector>\n\n/// Avoid std::numbers::pi because it's C++20\n#define PI 3.1415926535\n\n#define N_BSS 4\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"multi-bss\");\nPtr<UniformRandomVariable> randomX = CreateObject<UniformRandomVariable>();\nPtr<UniformRandomVariable> randomY = CreateObject<UniformRandomVariable>();\n\ndouble distance = 0.001; ///< The distance in meters between the AP and the STAs\nbool drlCca = false;\ndouble duration = 0;\nint totalDropsByOverlap = 0;\nuint8_t boxSize = 10;\nstd::map<int, std::string> configuration;\nuint32_t pktSize = 1500; ///< packet size used for the simulation (in bytes)\nuint8_t maxMpdus = 0;    ///< The maximum number of MPDUs in A-MPDUs (0 to disable MPDU aggregation)\nstd::string appType(\"constant\");\nstd::map<Mac48Address, Time>\n    timeFirstReceived; ///< Map that stores the time at which the first packet was received per AP\n///< (and the packet is addressed to that AP)\nstd::map<Mac48Address, Time>\n    timeLastReceived; ///< Map that stores the time at which the last packet was received per AP\n///< (and the packet is addressed to that AP)\nstd::map<Mac48Address, uint64_t> packetsReceived; ///< Map that stores the total packets received\n                                                  ///< per AP (and addressed to that AP)\nstd::map<Mac48Address, uint64_t>\n    bytesReceived; ///< Map that stores the total bytes received per AP (and addressed to that AP)\nstd::map<uint32_t, uint64_t> intervalBytesReceived;\nstd::map<uint32_t, std::vector<double>> intervalEdcaHolSample;\nstd::map<uint32_t, std::vector<double>> edcaHolSample;\nuint32_t networkSize;\nNetDeviceContainer apDevices;\nNetDeviceContainer staDevices;\nNetDeviceContainer devices;\nNodeContainer wifiNodes;\nNodeContainer apNodes;\nNodeContainer staNodes;\nint apNodeCount = 0;\ndouble txPower; ///< The transmit power of all the nodes in dBm\ndouble ccaSensitivity;\nstd::string propagationModel = \"\";\n\nstd::map<uint32_t, std::vector<double>> nodeCw;\nstd::map<uint32_t, std::vector<double>> nodeBackoff;\nstd::map<uint64_t, int> dataRateToMcs;\nstd::map<uint32_t, int> nodeMcs;\n\nstd::vector<std::string>\ncsv_split(std::string source, char delimeter)\n{\n    std::vector<std::string> ret;\n    std::string word = \"\";\n    //    int start = 0;\n\n    bool inQuote = false;\n    for (uint32_t i = 0; i < source.size(); ++i)\n    {\n        if (!inQuote && source[i] == '\"')\n        {\n            inQuote = true;\n            continue;\n        }\n        if (inQuote && source[i] == '\"')\n        {\n            if (source.size() > i && source[i + 1] == '\"')\n            {\n                ++i;\n            }\n            else\n            {\n                inQuote = false;\n                continue;\n            }\n        }\n\n        if (!inQuote && source[i] == delimeter)\n        {\n            ret.push_back(word);\n            word = \"\";\n        }\n        else\n        {\n            word += source[i];\n        }\n    }\n    ret.push_back(word);\n\n    return ret;\n}\n\n// Function object to compute the hash of a MAC address\nstruct MacAddressHash\n{\n    std::size_t operator()(const Mac48Address& address) const;\n};\n\nstd::size_t\nMacAddressHash::operator()(const Mac48Address& address) const\n{\n    uint8_t buffer[6];\n    address.CopyTo(buffer);\n    std::string s(buffer, buffer + 6);\n    return std::hash<std::string>{}(s);\n}\n\nstd::unordered_map<Mac48Address, uint32_t, MacAddressHash> m_staMacAddressToNodeId;\n\nconst std::map<AcIndex, std::string> m_aciToString = {\n    {AC_BE, \"BE\"},\n    {AC_BK, \"BK\"},\n    {AC_VI, \"VI\"},\n    {AC_VO, \"VO\"},\n};\n\nstruct InFlightPacketInfo\n{\n    Mac48Address m_srcAddress;\n    Mac48Address m_dstAddress;\n    AcIndex m_ac;\n    Ptr<const Packet> m_ptrToPacket;\n    Time m_edcaEnqueueTime{Seconds(0)}; // time the packet was enqueued into an EDCA queue\n    Time m_edcaDequeueTime{Seconds(0)}; // time the packet was dequeued from EDCA queue\n    Time appTypeTxTime{Seconds(0)};     // time the packet was created by app (E2E)\n    Time appTypeRxTime{Seconds(0)};     // time the packet was received by app (E2E)\n    Time m_HoLTime{Seconds(0)};         // time the packet became Head of Line\n    Time m_L2RxTime{Seconds(0)};  // time packet got forwarded up to the Mac Layer (L2 latency =\n                                  // L2RxTime - edcaEnqueueTime)\n    Time m_phyTxTime{Seconds(0)}; // time packet began transmission\n    bool m_dequeued{false};\n};\n\nstd::unordered_map<uint64_t /* UID */, std::list<InFlightPacketInfo>> m_inFlightPacketMap;\n\nuint32_t\nMacAddressToNodeId(Mac48Address address)\n{\n    for (uint32_t i = 0; i < apDevices.GetN(); i++)\n    {\n        if (apDevices.Get(i)->GetAddress() == address)\n        {\n            return apNodes.Get(i)->GetId();\n        }\n    }\n\n    auto it = m_staMacAddressToNodeId.find(address);\n    if (it != m_staMacAddressToNodeId.end())\n    {\n        return it->second;\n    }\n\n    NS_ABORT_MSG(\"Found no node having MAC address \" << address);\n}\n\nvoid\nNotifyEdcaEnqueue(Ptr<const WifiMpdu> item)\n{\n    if (!item->GetHeader().IsQosData())\n    {\n        return;\n    }\n    // std::cout << \"Enqueue UID \" << item->GetPacket()->GetUid() << \"  \" << Simulator::Now()\n    //           << std::endl;\n    // init a map entry if the packet's UID is not present\n    auto mapIt =\n        m_inFlightPacketMap.insert({item->GetPacket()->GetUid(), std::list<InFlightPacketInfo>()})\n            .first;\n\n    InFlightPacketInfo info;\n    info.m_srcAddress = item->GetHeader().GetAddr2();\n    info.m_dstAddress = item->GetHeader().GetAddr1();\n    info.m_ptrToPacket = item->GetPacket();\n    info.m_edcaEnqueueTime = Simulator::Now();\n\n    mapIt->second.insert(mapIt->second.end(), info);\n}\n\nvoid\nNotifyAppTx(Ptr<const Packet> packet, const Address& address)\n{\n    // std::cout << \"App Tx UID \" << packet->GetUid() << std::endl;\n    Ptr<const Packet> p = packet;\n\n    auto mapIt = m_inFlightPacketMap.find(p->GetUid());\n    if (mapIt == m_inFlightPacketMap.end())\n    {\n        // std::cout << \"No packet with UID \" << p->GetUid() << \" is currently in queue\" <<\n        // std::endl;\n        return;\n    }\n\n    auto listIt =\n        std::find_if(mapIt->second.begin(),\n                     mapIt->second.end(),\n                     [&p](const InFlightPacketInfo& info) { return info.m_ptrToPacket == p; });\n\n    if (listIt == mapIt->second.end())\n    {\n        // std::cout << \"Forwarding up a packet that has not been enqueued?\" << std::endl;\n        return;\n    }\n\n    InFlightPacketInfo info;\n    info.m_srcAddress = listIt->m_srcAddress;\n    info.m_dstAddress = listIt->m_dstAddress;\n    info.m_ptrToPacket = packet;\n    info.m_edcaEnqueueTime = listIt->m_edcaEnqueueTime;\n    info.m_edcaDequeueTime = listIt->m_edcaDequeueTime;\n    info.appTypeTxTime = Simulator::Now();\n\n    mapIt->second.erase(listIt);\n    mapIt->second.insert(mapIt->second.end(), info);\n}\n\n/**\n * Parse context strings of the form \"/NodeList/x/DeviceList/x/...\" to extract the NodeId\n * integer\n *\n * \\param context The context to parse.\n * \\return the NodeId\n */\nuint32_t\nContextToNodeId(std::string context)\n{\n    std::string sub = context.substr(10);\n    uint32_t pos = sub.find(\"/Device\");\n    return std::stoi(sub.substr(0, pos));\n}\n\nstd::unordered_map<uint32_t, std::map<uint64_t, std::vector<Time>>> nodePacketTxTime;\nstd::unordered_map<uint32_t, std::map<uint64_t, std::vector<Time>>> nodePacketTxEndTime;\nint totalTx = 0;\n\nvoid\nNotifyPhyTxBegin(std::string context, Ptr<const Packet> p, double txPowerW)\n{\n    totalTx += 1;\n    nodePacketTxTime[ContextToNodeId(context)][p->GetUid()].push_back(Simulator::Now());\n\n    auto mapIt = m_inFlightPacketMap.find(p->GetUid());\n    if (mapIt == m_inFlightPacketMap.end())\n    {\n        return;\n    }\n\n    auto listIt = std::find_if(mapIt->second.begin(),\n                               mapIt->second.end(),\n                               [&p](const InFlightPacketInfo& info) {\n                                   return info.m_ptrToPacket->GetUid() == p->GetUid();\n                               });\n\n    if (listIt == mapIt->second.end())\n    {\n        // std::cout << \"Forwarding up a packet that has not been enqueued?\" << std::endl;\n        return;\n    }\n\n    InFlightPacketInfo info;\n    info.m_srcAddress = listIt->m_srcAddress;\n    info.m_dstAddress = listIt->m_dstAddress;\n    info.m_ptrToPacket = listIt->m_ptrToPacket;\n    info.m_edcaEnqueueTime = listIt->m_edcaEnqueueTime;\n    info.appTypeTxTime = listIt->appTypeTxTime;\n    info.m_phyTxTime = Simulator::Now();\n\n    mapIt->second.erase(listIt);\n    mapIt->second.insert(mapIt->second.end(), info);\n}\n\n/**\n * PHY TX end trace.\n *\n * \\param context The context.\n * \\param p The packet.\n */\nvoid\nPhyTxDoneTrace(std::string context, Ptr<const Packet> p)\n{\n    nodePacketTxEndTime[ContextToNodeId(context)][p->GetUid()].push_back(Simulator::Now());\n}\n\n/**\n * PHY TX drop trace.\n *\n * \\param context The context.\n * \\param p The packet.\n */\nvoid\nPhyTxDropTrace(std::string context, Ptr<const Packet> p)\n{\n    nodePacketTxEndTime[ContextToNodeId(context)][p->GetUid()].push_back(Simulator::Now());\n}\n\nvoid\nNotifyMacForwardUp(Ptr<const Packet> p)\n{\n    // std::cout << \"MacForwardUp UID \" << p->GetUid() << std::endl;\n    // Ptr<const Packet> p = packet;\n\n    auto mapIt = m_inFlightPacketMap.find(p->GetUid());\n    if (mapIt == m_inFlightPacketMap.end())\n    {\n        // std::cout << \"No packet with UID \" << p->GetUid() << \" is currently in queue\" <<\n        // std::endl;\n        return;\n    }\n\n    auto listIt = std::find_if(mapIt->second.begin(),\n                               mapIt->second.end(),\n                               [&p](const InFlightPacketInfo& info) {\n                                   return info.m_ptrToPacket->GetUid() == p->GetUid();\n                               });\n\n    if (listIt == mapIt->second.end())\n    {\n        std::cout << \"Forwarding up a packet that has not been enqueued?\" << std::endl;\n        return;\n    }\n    if (listIt->m_dstAddress.IsGroup())\n    {\n        return;\n    }\n\n    InFlightPacketInfo info;\n    info.m_srcAddress = listIt->m_srcAddress;\n    info.m_dstAddress = listIt->m_dstAddress;\n    info.m_ptrToPacket = listIt->m_ptrToPacket;\n    info.m_edcaEnqueueTime = listIt->m_edcaEnqueueTime;\n    info.appTypeTxTime = listIt->appTypeTxTime;\n    info.m_phyTxTime = listIt->m_phyTxTime;\n    // info.appTypeRxTime = Simulator::Now();\n    info.m_L2RxTime = Simulator::Now();\n\n    mapIt->second.erase(listIt);\n    mapIt->second.insert(mapIt->second.end(), info);\n}\n\nint appTxrec = 0;\n\nvoid\nNotifyAppRx(Ptr<const Packet> packet, const Address& address)\n{\n    // std::cout << \"App Rx UID \" << packet->GetUid() << std::endl;\n\n    Ptr<const Packet> p = packet;\n\n    auto mapIt = m_inFlightPacketMap.find(p->GetUid());\n    if (mapIt == m_inFlightPacketMap.end())\n    {\n        // std::cout << \"No packet with UID \" << p->GetUid() << \" is currently in queue\" <<\n        // std::endl;\n        return;\n    }\n    // mapIt->second.;\n    auto listIt = std::find_if(mapIt->second.begin(),\n                               mapIt->second.end(),\n                               [&p](const InFlightPacketInfo& info) {\n                                   return info.m_ptrToPacket->GetUid() == p->GetUid();\n                               });\n\n    if (listIt == mapIt->second.end())\n    {\n        std::cout << \"Forwarding up a packet that has not been enqueued?\" << std::endl;\n        return;\n    }\n    InFlightPacketInfo info;\n    info.m_srcAddress = listIt->m_srcAddress;\n    info.m_dstAddress = listIt->m_dstAddress;\n    info.m_ptrToPacket = listIt->m_ptrToPacket;\n    info.m_edcaEnqueueTime = listIt->m_edcaEnqueueTime;\n    info.appTypeTxTime = listIt->appTypeTxTime;\n    info.m_phyTxTime = listIt->m_phyTxTime;\n    info.m_L2RxTime = listIt->m_L2RxTime;\n    info.appTypeRxTime = Simulator::Now();\n\n    appTxrec++;\n    // std::cout << \"APRX\" << std::endl;\n\n    mapIt->second.erase(listIt);\n    mapIt->second.insert(mapIt->second.end(), info);\n}\n\nstd::map<uint32_t, Time> dequeueTimes;\n\nvoid\nNotifyMsduDequeuedFromEdcaQueue(Ptr<const WifiMpdu> item)\n{\n    // std::cout << \"Dequeue UID \" << item->GetPacket()->GetUid() << std::endl;\n\n    if (!item->GetHeader().IsQosData() || item->GetHeader().GetAddr1().IsGroup())\n    {\n        // the frame is not a unicast QoS data frame or the MSDU lifetime is higher than the\n        // max queue delay, hence the MSDU has been discarded. Do nothing in this case.\n        return;\n    }\n    Ptr<const Packet> p = item->GetPacket();\n\n    uint64_t srcNodeId = MacAddressToNodeId(item->GetHeader().GetAddr2());\n    auto iter = dequeueTimes.find(srcNodeId);\n    if (iter == dequeueTimes.end())\n    {\n        dequeueTimes.insert(std::make_pair(srcNodeId, Simulator::Now()));\n        return;\n    }\n    if (iter->second == Simulator::Now())\n    {\n        // std::cout << \"last \" << iter->second << \" now \" << Simulator::Now() << std::endl;\n        return;\n    }\n\n    auto mapIt = m_inFlightPacketMap.find(p->GetUid());\n    if (mapIt == m_inFlightPacketMap.end())\n    {\n        // std::cout << \"No packet with UID \" << p->GetUid() << \" is currently in queue\" <<\n        // std::endl;\n        return;\n    }\n\n    auto listIt =\n        std::find_if(mapIt->second.begin(),\n                     mapIt->second.end(),\n                     [&p](const InFlightPacketInfo& info) { return info.m_ptrToPacket == p; });\n\n    if (listIt == mapIt->second.end())\n    {\n        // std::cout << \"Dequeue a packet that has not been enqueued?\" << std::endl;\n        return;\n    }\n\n    InFlightPacketInfo info;\n    info.m_srcAddress = item->GetHeader().GetAddr2();\n    info.m_dstAddress = item->GetHeader().GetAddr1();\n    info.m_ptrToPacket = item->GetPacket();\n    info.m_edcaEnqueueTime = listIt->m_edcaEnqueueTime;\n    info.m_edcaDequeueTime = Simulator::Now();\n    info.appTypeTxTime = listIt->appTypeTxTime;\n    info.m_phyTxTime = listIt->m_phyTxTime;\n    info.appTypeRxTime = listIt->appTypeRxTime;\n    info.m_L2RxTime = listIt->m_L2RxTime;\n    info.m_HoLTime = std::max(listIt->m_edcaEnqueueTime, iter->second);\n    info.m_dequeued = true;\n\n    // HERE CALCULATE ALL DELAYS\n    double newHolSample = (info.m_edcaDequeueTime - info.m_HoLTime).ToDouble(Time::MS);\n    double queingDelay = (info.m_HoLTime - info.m_edcaEnqueueTime).ToDouble(Time::MS);\n    double accessDelay = (info.m_phyTxTime - info.m_HoLTime).ToDouble(Time::MS);\n    double txDelay = (info.m_edcaDequeueTime - info.m_phyTxTime).ToDouble(Time::MS);\n\n    auto it = edcaHolSample.find(srcNodeId);\n    auto ite = intervalEdcaHolSample.find(srcNodeId);\n    if (ite == intervalEdcaHolSample.end())\n    {\n        std::vector<double> tiVec;\n        tiVec.push_back(newHolSample);\n        tiVec.push_back(queingDelay);\n        tiVec.push_back(accessDelay);\n        tiVec.push_back(txDelay);\n        intervalEdcaHolSample.insert(std::make_pair(srcNodeId, tiVec));\n        // std::cout << \"first Sample: \" << newHolSample << \"\\n\";\n    }\n    else\n    {\n        ite->second.push_back(newHolSample);\n        ite->second.push_back(queingDelay);\n        ite->second.push_back(accessDelay);\n        ite->second.push_back(txDelay);\n    }\n    if (it == edcaHolSample.end())\n    {\n        std::vector<double> tiVec;\n        tiVec.push_back(newHolSample);\n        tiVec.push_back(queingDelay);\n        tiVec.push_back(accessDelay);\n        tiVec.push_back(txDelay);\n        edcaHolSample.insert(std::make_pair(srcNodeId, tiVec));\n        // std::cout << \"first Sample: \" << newHolSample << \"\\n\";\n    }\n    else\n    {\n        it->second.push_back(newHolSample);\n        it->second.push_back(queingDelay);\n        it->second.push_back(accessDelay);\n        it->second.push_back(txDelay);\n    }\n\n    iter->second = Simulator::Now();\n    mapIt->second.erase(listIt);\n    mapIt->second.insert(mapIt->second.end(), info);\n}\n\nvoid\nNotifyMsduDroppedAfterDequeueFromEdcaQueue(Ptr<const WifiMpdu> item)\n{\n    // std::cout << \"did it work?\" << std::endl;\n}\n\nvoid\nStartStatistics()\n{\n    for (auto devIt = devices.Begin(); devIt != devices.End(); devIt++)\n    {\n        Ptr<WifiNetDevice> dev = DynamicCast<WifiNetDevice>(*devIt);\n        // trace packets forwarded up by the MAC layer\n        dev->GetMac()->TraceConnectWithoutContext(\"MacRx\", MakeCallback(&NotifyMacForwardUp));\n\n        for (auto& ac : m_aciToString)\n        {\n            dev->GetMac()->GetTxopQueue(ac.first)->TraceConnectWithoutContext(\n                \"Enqueue\",\n                MakeBoundCallback(&NotifyEdcaEnqueue));\n            dev->GetMac()->GetTxopQueue(ac.first)->TraceConnectWithoutContext(\n                \"Dequeue\",\n                MakeCallback(&NotifyMsduDequeuedFromEdcaQueue));\n            dev->GetMac()->GetTxopQueue(ac.first)->TraceConnectWithoutContext(\n                \"DropAfterDequeue\",\n                MakeCallback(&NotifyMsduDroppedAfterDequeueFromEdcaQueue));\n        }\n    }\n}\n\n/**\n * Incremement the counter for a given address.\n *\n * \\param [out] counter The counter to increment.\n * \\param addr The address to incremement the counter for.\n * \\param increment The incremement (1 if omitted).\n */\nvoid\nIncrementCounter(std::map<Mac48Address, uint64_t>& counter,\n                 Mac48Address addr,\n                 uint64_t increment = 1)\n{\n    auto it = counter.find(addr);\n    if (it != counter.end())\n    {\n        it->second += increment;\n    }\n    else\n    {\n        counter.insert(std::make_pair(addr, increment));\n    }\n}\n\nuint32_t associatedStas = 0;\nuint32_t deassociatedStas = 0;\n\n/**\n * Reset the stats.\n */\nvoid\nRestartCalc()\n{\n    bytesReceived.clear();\n    packetsReceived.clear();\n    timeFirstReceived.clear();\n    timeLastReceived.clear();\n    appTxrec = 0;\n    if (associatedStas < staNodes.GetN())\n    {\n        NS_ABORT_MSG(\"Not all STA associated. Missing: \" << (staNodes.GetN() - associatedStas));\n    }\n}\n\n// void\n// TrackTime()\n//{\n//     std::cout << \"Time = \" << Simulator::Now().GetSeconds() << \"s\" << std::endl;\n//     Simulator::Schedule(Seconds(5), &TrackTime);\n// }\n\nvoid\nCheckAssociation()\n{\n    if (associatedStas < staNodes.GetN())\n    {\n        // NS_ABORT_MSG(\"Not all STA associated. Missing: \" << (staNodes.GetN() -\n        // associatedStas));\n        std::cout << \"RESTARTED ASSOCIATION\" << std::endl;\n        for (uint32_t i = 0; i < staNodes.GetN(); i++)\n        {\n            Ptr<NetDevice> dev = staNodes.Get(i)->GetDevice(0);\n            Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n\n            Ptr<WifiPhy> dev_phy = wifi_dev->GetPhy();\n\n            Ptr<WifiMac> q_mac = wifi_dev->GetMac();\n\n            Ptr<StaWifiMac> staMac = StaticCast<StaWifiMac>(q_mac);\n\n            if (!(staMac->IsAssociated()))\n            {\n                staMac->ScanningTimeout(std::nullopt);\n            }\n        }\n        Simulator::Schedule(Seconds(1), &CheckAssociation);\n    }\n    else\n    {\n        std::cout << \"associated N Sta: \" << associatedStas << std::endl;\n    }\n}\n\n/**\n * Parse context strings of the form \"/NodeList/x/DeviceList/x/...\" and fetch the Mac address\n *\n * \\param context The context to parse.\n * \\return the device MAC address\n */\nMac48Address\nContextToMac(std::string context)\n{\n    std::string sub = context.substr(10);\n    uint32_t pos = sub.find(\"/Device\");\n    uint32_t nodeId = std::stoi(sub.substr(0, pos));\n    Ptr<Node> n = NodeList::GetNode(nodeId);\n    Ptr<WifiNetDevice> d;\n    for (uint32_t i = 0; i < n->GetNDevices(); i++)\n    {\n        d = n->GetDevice(i)->GetObject<WifiNetDevice>();\n        if (d)\n        {\n            break;\n        }\n    }\n    return Mac48Address::ConvertFrom(d->GetAddress());\n}\n\nstd::map<uint32_t, std::map<uint32_t, double>> nodeRxPower;\n\nvoid\nGetRxPower(Ptr<TgaxResidentialPropagationLossModel> tgaxPropModel)\n{\n    for (uint32_t i = 0; i < wifiNodes.GetN(); i++)\n    {\n        Ptr<NetDevice> dev = wifiNodes.Get(i)->GetDevice(0);\n        Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n        Ptr<Object> object = wifiNodes.Get(i);\n        Ptr<MobilityModel> model1 = object->GetObject<MobilityModel>();\n        Ptr<WifiPhy> wifi_phy = wifi_dev->GetPhy();\n\n        for (uint32_t x = 0; x < wifiNodes.GetN(); x++)\n        {\n            // Skip same nodes\n            if (i == x)\n            {\n                continue;\n            }\n\n            Ptr<NetDevice> dev2 = wifiNodes.Get(x)->GetDevice(0);\n            Ptr<WifiNetDevice> wifi_dev2 = DynamicCast<WifiNetDevice>(dev2);\n            Ssid ssid2 = wifi_dev2->GetMac()->GetSsid();\n            // Receiver must be node in BSS-0\n            if (!ssid2.IsEqual(Ssid(\"BSS-0\")))\n            {\n                continue;\n            }\n            Ptr<Object> object2 = wifiNodes.Get(x);\n            Ptr<MobilityModel> model2 = object2->GetObject<MobilityModel>();\n            double rxPower = 0;\n            for (int j = 0; j < 100; j++)\n            {\n                rxPower += tgaxPropModel->GetRxPower(wifi_phy->GetTxPowerStart(), model1, model2);\n            }\n            nodeRxPower[wifiNodes.Get(i)->GetId()][wifiNodes.Get(x)->GetId()] = (rxPower / 100);\n        }\n    }\n}\n\n/**\n * Print the buildings list in a format that can be used by Gnuplot to draw them.\n *\n * \\param filename The output filename.\n */\nvoid\nPrintPythonPlotCSV(std::string filename)\n{\n    // for (uint32_t i = 0; i < bytes__Received.size(); i++)\n    // {\n    //     std::cout << \"Bytes received: \" << bytes__Received[i] << std::endl;\n    // }\n    std::ofstream outFile;\n    outFile.open(filename.c_str(), std::ios_base::trunc);\n    if (!outFile.is_open())\n    {\n        NS_LOG_ERROR(\"Can't open file \" << filename);\n        return;\n    }\n    //    uint32_t index = 0;\n    Ptr<Building> building;\n    for (BuildingList::Iterator it = BuildingList::Begin(); it != BuildingList::End(); ++it)\n    {\n        //        ++index;\n        Box box = (*it)->GetBoundaries();\n        building = *it;\n        int rowCount = 1;\n        if (apNodeCount > 2)\n        {\n            rowCount = 2;\n        }\n        outFile << \"box,\" << box.xMax - box.xMin << \",\" << box.yMax - box.yMin << \",\" << rowCount\n                << std::endl;\n    }\n    double maxDistance;\n    if (appType != \"setup-done\")\n    { // Formula to draw radius of circle\n        double max_loss = -(ccaSensitivity - txPower);\n        // double maxDistance = std::pow(10, (max_loss - 40.05 - 20 * std::log10(5e9 / 2.4e9)) /\n        // 20);\n        maxDistance = pow(10, ((max_loss - 40.05 - 20 * std::log10(5e9 / 2.4e9)) / 20));\n        // maxDistance = (max_loss - 40.05 - 20 * std::log10(5e9 / 2.4e9)) / (5 - 4 *\n        // std::log10(5));\n    }\n    // double maxDistance_log = std::pow(10, max_loss / (10 * 3));\n\n    // max_loss = txPower - ccaSensitivity;\n    // // double maxDistance2 = std::pow(10, (max_loss - 40.05 - 20 * std::log10(5e9 / 2.4e9)) /\n    // // 20);\n    // double maxDistance2 =\n    //     (max_loss - 40.05 - 20 * std::log10(5e9 / 2.4e9)) / (5 - 4 * std::log10(5));\n\n    for (uint32_t i = 0; i < apNodes.GetN(); i++)\n    {\n        Ptr<NetDevice> dev = apNodes.Get(i)->GetDevice(0);\n        Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n        Ptr<Object> object = apNodes.Get(i);\n        Ptr<MobilityModel> model = object->GetObject<MobilityModel>();\n        Vector pos = model->GetPosition();\n        Ssid ssid = wifi_dev->GetMac()->GetSsid();\n        // Ptr<WifiPhy> wifi_phy = wifi_dev->GetPhy();\n        // wifi_phy->SetCcaSensitivityThreshold();\n\n        if (appType == \"setup-done\")\n        {\n            // std::string configString = configuration[apNodes.Get(i)->GetId()];\n\n            std::string configString = configuration[apNodes.Get(i)->GetId()];\n            std::vector<std::string> configValues = csv_split(configString, ',');\n            double m_ccaSensitivity = std::stoi(configValues[1]);\n            double m_txPower = std::stoi(configValues[2]);\n            //            double m_chWidth = std::stoi(configValues[3]);\n            //            double m_chNumber = std::stoi(configValues[4]);\n\n            // size_t pos = configString.find(',');\n            // configString = configString.substr(pos + 1);\n            // size_t pos2 = configString.find(',');\n            //            std::cout << \"CCaSensitivity: \" << m_ccaSensitivity << std::endl;\n            // double m_ccaSensitivity = std::stoi(configString.substr(0, pos2));\n            //            std::cout << \"apTxPower: \" << m_txPower << std::endl;\n            // double m_txPower = std::stoi(configString.substr(pos2 + 1));\n            // Formula to draw radius of circle\n            double max_loss = -(m_ccaSensitivity - m_txPower); // TODO: fix to specific tx power\n            // double maxDistance = std::pow(10, (max_loss - 40.05 - 20 * std::log10(5e9\n            // / 2.4e9)) / 20);\n            maxDistance =\n                (max_loss - 40.05 - 20 * std::log10(5e9 / 2.4e9)) / (5 - 4 * std::log10(5));\n        }\n        outFile << \"AP,\" << pos.x << \",\" << pos.y << \",\" << ssid.PeekString() << \"-\"\n                << apNodes.Get(i)->GetId() << \"-\"\n                << \"HeMcs\" << nodeMcs[apNodes.Get(i)->GetId()] << \",\" << maxDistance << std::endl;\n    }\n    for (uint32_t i = 0; i < staNodes.GetN(); i++)\n    {\n        Ptr<NetDevice> dev = staNodes.Get(i)->GetDevice(0);\n        Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n        Ptr<Object> object = staNodes.Get(i);\n        Ptr<MobilityModel> model = object->GetObject<MobilityModel>();\n        Vector pos = model->GetPosition();\n        Ssid ssid = wifi_dev->GetMac()->GetSsid();\n\n        if (appType == \"setup-done\")\n        {\n            std::string configString = configuration[staNodes.Get(i)->GetId()];\n\n            std::vector<std::string> configValues = csv_split(configString, ',');\n            double m_ccaSensitivity = std::stoi(configValues[1]);\n            double m_txPower = std::stoi(configValues[2]);\n            //            double m_chWidth = std::stoi(configValues[3]);\n            //            double m_chNumber = std::stoi(configValues[4]);\n\n            // size_t pos = configString.find(',');\n            // configString = configString.substr(pos + 1);\n            // size_t pos2 = configString.find(',');\n            std::cout << \"CCaSensitivity: \" << m_ccaSensitivity << std::endl;\n            // double m_ccaSensitivity = std::stoi(configString.substr(0, pos2));\n            std::cout << \"apTxPower: \" << m_txPower << std::endl;\n\n            // size_t pos = configString.find(',');\n            // configString = configString.substr(pos + 1);\n            // size_t pos2 = configString.find(',');\n            // std::cout << \"CCaSensitivity: \" << configString.substr(0, pos2) << std::endl;\n            // double m_ccaSensitivity = std::stoi(configString.substr(0, pos2));\n            // std::cout << \"apTxPower: \" << configString.substr(pos2 + 1) << std::endl;\n            // double m_txPower = std::stoi(configString.substr(pos2 + 1));\n            // Formula to draw radius of circle\n            double max_loss = -(m_ccaSensitivity - m_txPower); // TODO: fix to specific tx power\n            maxDistance =\n                (max_loss - 40.05 - 20 * std::log10(5e9 / 2.4e9)) / (5 - 4 * std::log10(5));\n        }\n        outFile << \"STA,\" << pos.x << \",\" << pos.y << \",\" << ssid.PeekString() << \"-\"\n                << staNodes.Get(i)->GetId() << \"-\"\n                << \"HeMcs\" << nodeMcs[staNodes.Get(i)->GetId()] << \",\" << maxDistance << std::endl;\n    }\n}\n\nvoid\nRestartIntervalThroughputHolDelay()\n{\n    intervalBytesReceived.clear();\n    // std::cout << \"Amount of samples \" << intervalEdcaHolSample[2].size() << std::endl;\n    intervalEdcaHolSample.clear();\n}\n\nvoid\nMeasureIntervalThroughputHolDelay()\n{\n    Ns3AiMsgInterfaceImpl<Env, Act>* msgInterface =\n        Ns3AiMsgInterface::Get()->GetInterface<Env, Act>();\n    // std::cout << \"\\nInterval T \" << Simulator::Now().GetSeconds() << std::endl;\n    std::map<uint32_t, std::tuple<double, double, double, double>> nodeDelays;\n    for (auto it : intervalEdcaHolSample)\n    {\n        uint32_t srcNodeId = it.first;\n        double sum1 = 0;\n        double sum2 = 0;\n        double sum3 = 0;\n        double sum4 = 0;\n\n        for (double i = 0; i < it.second.size(); i += 4)\n        {\n            sum1 += it.second[i];\n            sum2 += it.second[i + 1];\n            sum3 += it.second[i + 2];\n            sum4 += it.second[i + 3];\n        }\n\n        std::get<0>(nodeDelays[srcNodeId]) = sum1 / (it.second.size() / 4); // Avg HoL Delay\n        std::get<1>(nodeDelays[srcNodeId]) = sum2 / (it.second.size() / 4); // Avg Queuing Delay\n        std::get<2>(nodeDelays[srcNodeId]) = sum3 / (it.second.size() / 4); // Avg Access Delay\n        std::get<3>(nodeDelays[srcNodeId]) = sum4 / (it.second.size() / 4); // Avg Tx Delay\n    }\n\n    Ptr<TgaxResidentialPropagationLossModel> propModel =\n        CreateObject<TgaxResidentialPropagationLossModel>();\n    GetRxPower(propModel);\n\n    msgInterface->CppSendBegin();\n    for (size_t i = 0; i < wifiNodes.GetN(); i++)\n    {\n        uint32_t txNodeId = wifiNodes.Get(i)->GetId();\n        auto& env_struct = msgInterface->GetCpp2PyVector()->at(txNodeId);\n        env_struct.txNode = txNodeId;\n        env_struct.mcs = nodeMcs[txNodeId];\n        env_struct.holDelay = std::get<0>(nodeDelays[txNodeId]);\n        if (txNodeId >= N_BSS) // STAs\n        {\n            env_struct.throughput = (intervalBytesReceived.find(txNodeId)->second * 8) /\n                                    static_cast<double>(Seconds(1).GetMicroSeconds());\n        }\n        else\n        {\n            // Only count for UL traffic\n            env_struct.throughput = 0;\n        }\n        std::cout << \"CPP send: txnode \" << txNodeId << \" tpt \" << env_struct.throughput\n                  << std::endl;\n        for (auto rxNodePower : nodeRxPower[txNodeId])\n        {\n            NS_ASSERT(rxNodePower.first % N_BSS == 0); // only record rx node in first BSS\n            if (rxNodePower.first == txNodeId)\n            {\n                env_struct.rxPower[rxNodePower.first / N_BSS] = 0;\n            }\n            else\n            {\n                env_struct.rxPower[rxNodePower.first / N_BSS] = rxNodePower.second;\n            }\n        }\n    }\n    msgInterface->CppSendEnd();\n\n    msgInterface->CppRecvBegin();\n    double nextCca = msgInterface->GetPy2CppVector()->at(0).newCcaSensitivity;\n    msgInterface->CppRecvEnd();\n\n    std::cout << \"At \" << Simulator::Now().GetMilliSeconds() << \"ms:\" << std::endl;\n\n    // Change CCA of nodes in first BSS\n    for (uint32_t i = 0; i < wifiNodes.GetN(); i += N_BSS)\n    {\n        uint32_t nodeId = wifiNodes.Get(i)->GetId();\n        Ptr<NetDevice> dev = wifiNodes.Get(i)->GetDevice(0);\n        Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n        Ptr<WifiPhy> wifi_phy = wifi_dev->GetPhy();\n        Ssid ssid = wifi_dev->GetMac()->GetSsid();\n        // Only change CCA for nodes in BSS-0\n        NS_ASSERT(ssid.IsEqual(Ssid(\"BSS-0\")));\n        double currentCca = wifi_phy->GetCcaSensitivityThreshold();\n\n        Ptr<ThresholdPreambleDetectionModel> preambleCaptureModel =\n            CreateObject<ThresholdPreambleDetectionModel>();\n        preambleCaptureModel->SetAttribute(\"MinimumRssi\", DoubleValue(nextCca));\n        wifi_phy->SetCcaSensitivityThreshold(nextCca);\n        wifi_phy->SetPreambleDetectionModel(preambleCaptureModel);\n        std::cout << \"-- \" << ssid << \" Node \" << nodeId << \" current CCA \" << currentCca\n                  << \" next CCA \" << nextCca << std::endl;\n    }\n\n    Simulator::ScheduleNow(&RestartIntervalThroughputHolDelay);\n    Simulator::Schedule(Seconds(1), &MeasureIntervalThroughputHolDelay);\n\n    //    // Set position for Nodes\n    //    for (uint32_t i = 0; i < wifiNodes.GetN(); i++)\n    //    {\n    //        double x = 0;\n    //        double y = 0;\n    //\n    //        x = randomX->GetValue() + ((i % apNodeCount) * boxSize);\n    //        y = randomY->GetValue();\n    //\n    //        Vector l1(x, y, 1.5);\n    //        Ptr<Object> object = wifiNodes.Get(i);\n    //        Ptr<MobilityModel> model = object->GetObject<MobilityModel>();\n    //        model->SetPosition(l1);\n    //\n    //        std::cout << \"Node\" << wifiNodes.Get(i)->GetId() << \" \" << x << \",\" << y << std::endl;\n    //        // std::cout << \"Points intersect how many walls? \" <<\n    //        // building->WallInLOS(l1, l2)\n    //        //           << std::endl;\n    //    }\n    //    PrintPythonPlotCSV(\"box.csv\");\n}\n\n// // std::map<uint32_t, std::vector<>>;\n\n// /**\n//  * PHY Rx trace.\n//  *\n//  * \\param context The context.\n//  * \\param p The packet.\n//  * \\param power The Rx power.\n//  */\n// void\n// PhyRxTrace(std::string context, Ptr<const Packet> p, RxPowerWattPerChannelBand power)\n// {\n//     for (auto bandPower : power)\n//     {\n//         std::cout << \"PHY-RX-START time=\" << Simulator::Now()\n//                   << \" node=\" << ContextToNodeId(context) << \" size=\" << p->GetSize()\n//                   << \" Band Start \" << bandPower.first.first << \" Band end \"\n//                   << bandPower.first.second << \" rxPower: \" << bandPower.second << std::endl;\n//     }\n// }\n\nstd::vector<uint64_t> pid_r_packets;\n\n/**\n * Trace a packet reception.\n *\n * \\param context The context.\n * \\param p The packet.\n * \\param channelFreqMhz The channel frequqncy.\n * \\param txVector The TX vector.\n * \\param aMpdu The AMPDU.\n * \\param signalNoise The signal and noise dBm.\n * \\param staId The STA ID.\n */\nvoid\nTracePacketReception(std::string context,\n                     Ptr<const Packet> p,\n                     uint16_t channelFreqMhz,\n                     WifiTxVector txVector,\n                     MpduInfo aMpdu,\n                     SignalNoiseDbm signalNoise,\n                     uint16_t staId)\n{\n    Ptr<Packet> packet = p->Copy();\n    auto it = std::find(pid_r_packets.begin(), pid_r_packets.end(), packet->GetUid());\n\n    if (it == pid_r_packets.end())\n    {\n        pid_r_packets.push_back(packet->GetUid());\n    }\n    else\n    {\n        return;\n    }\n    if (txVector.IsAggregation())\n    {\n        AmpduSubframeHeader subHdr;\n        uint32_t extractedLength;\n        packet->RemoveHeader(subHdr);\n        extractedLength = subHdr.GetLength();\n        packet = packet->CreateFragment(0, static_cast<uint32_t>(extractedLength));\n    }\n    WifiMacHeader hdr;\n    packet->PeekHeader(hdr);\n\n    if (hdr.GetAddr1() != ContextToMac(context))\n    {\n        return;\n    }\n    // std::cout << \"Sender \" << hdr.GetAddr2() << \" Destination (packet) \" << hdr.GetAddr1()\n    //           << \" t_Destination:\" << ContextToMac(context) << std::endl;\n\n    if (hdr.IsData()) // ignore non-data frames\n    {\n        // std::cout << \"Packet size: \" << packet->GetSize() << std::endl;\n        // std::cout << \"SNIFFERRX\" << std::endl;\n\n        IncrementCounter(packetsReceived, hdr.GetAddr2());\n        IncrementCounter(bytesReceived, hdr.GetAddr2(), packet->GetSize());\n        intervalBytesReceived[MacAddressToNodeId(hdr.GetAddr2())] += packet->GetSize();\n        // IncrementCounter(intervalBytesReceived, hdr.GetAddr2(), packet->GetSize());\n        auto itTimeFirstReceived = timeFirstReceived.find(hdr.GetAddr2());\n        if (itTimeFirstReceived == timeFirstReceived.end())\n        {\n            // std::cout << \"First Time see addy: \" << hdr.GetAddr2() << \" at \"\n            //           << Simulator::Now().GetSeconds() << std::endl;\n            timeFirstReceived.insert(std::make_pair(hdr.GetAddr2(), Simulator::Now()));\n        }\n        auto itTimeLastReceived = timeLastReceived.find(hdr.GetAddr2());\n        if (itTimeLastReceived != timeLastReceived.end())\n        {\n            // std::cout << \"Last Time see addy: \" << hdr.GetAddr2() << \" at \"\n            //           << Simulator::Now().GetSeconds() << std::endl;\n            itTimeLastReceived->second = Simulator::Now();\n        }\n        else\n        {\n            timeLastReceived.insert(std::make_pair(hdr.GetAddr2(), Simulator::Now()));\n        }\n    }\n}\n\nint drops = 0;\nint receives = 0;\n// rxNode, packet, reason, time\nstd::map<uint32_t, std::map<uint64_t, std::vector<std::pair<WifiPhyRxfailureReason, Time>>>>\n    nodeFailureCount;\nstd::map<WifiPhyRxfailureReason, int> typeFailCount;\n\nvoid\nPhyDrop(std::string context, Ptr<const Packet> p, WifiPhyRxfailureReason reas)\n{\n    Ptr<Packet> packet = p->Copy();\n\n    WifiMacHeader hdr;\n    packet->PeekHeader(hdr);\n\n    if (hdr.GetAddr1() != ContextToMac(context))\n    {\n        return;\n    }\n\n    nodeFailureCount[ContextToNodeId(context)][p->GetUid()].push_back(\n        std::make_pair(reas, Simulator::Now()));\n    drops++;\n    // if (hdr.HasData()) // ignore non-data frames\n    // {\n    //     if (packet->GetSize() >= pktSize)\n    //     {\n\n    // if (p->GetSize() >= pktSize)\n    // {\n    // std::cout << \"PHYDROPP \" << reas << \" at \" << Simulator::Now().GetSeconds() << \" Packet \"\n    //           << p->GetUid() << std::endl;\n    typeFailCount[reas] += 1;\n\n    //     }\n    // }\n\n    // if (packet->GetSize() >= pktSize) // ignore non-data frames\n    // {\n    //     drops++;\n    //     // std::cout << \"PHYDROP\" << std::endl;\n    // }\n    // if (reas == WifiPhyRxfailureReason(RXING))\n    // {\n\n    // }\n    // nodeFailureCount[ContextToNodeId(context)][reas] += 1;\n\n    // std::cout << \"PHYDROP Reason: \" << reas << std::endl;\n}\n\n// /**\n//  * \\ingroup wifi\n//  * Enumeration of the possible reception failure reasons.\n//  */\n// enum WifiPhyRxfailureReason\n// {\n//     UNKNOWN = 0,\n//     UNSUPPORTED_SETTINGS,\n//     CHANNEL_SWITCHING,\n//     RXING,\n//     TXING,\n//     SLEEPING,\n//     POWERED_OFF,\n//     TRUNCATED_TX,\n//     BUSY_DECODING_PREAMBLE,\n//     PREAMBLE_DETECT_FAILURE,\n//     RECEPTION_ABORTED_BY_TX,\n//     L_SIG_FAILURE,\n//     HT_SIG_FAILURE,\n//     SIG_A_FAILURE,\n//     SIG_B_FAILURE,\n//     U_SIG_FAILURE,\n//     EHT_SIG_FAILURE,\n//     PREAMBLE_DETECTION_PACKET_SWITCH,\n//     FRAME_CAPTURE_PACKET_SWITCH,\n//     OBSS_PD_CCA_RESET,\n//     HE_TB_PPDU_TOO_LATE,\n//     FILTERED,\n//     DMG_HEADER_FAILURE,\n//     DMG_ALLOCATION_ENDED\n// };\n\nstd::map<uint32_t, std::map<uint64_t, Time>> nodeSuccessCount;\n\nvoid\nPhyEnd(std::string context, Ptr<const Packet> p)\n{\n    // std::cout << \"PHYRx End packet\" << p->GetUid() << std::endl;\n    Ptr<Packet> packet = p->Copy();\n\n    WifiMacHeader hdr;\n    packet->PeekHeader(hdr);\n\n    if (hdr.GetAddr1() != ContextToMac(context))\n    {\n        return;\n    }\n    nodeSuccessCount[ContextToNodeId(context)][p->GetUid()] = Simulator::Now();\n    if (packet->GetSize() >= pktSize) // ignore non-data frames\n    {\n        receives++;\n        // std::cout << \"PHYDROP\" << std::endl;\n    }\n}\n\nvoid\nChangeCcaSensitivity(double stepSize, double intervalLength)\n{\n    for (uint32_t i = 0; i < wifiNodes.GetN(); i++)\n    {\n        Ptr<NetDevice> dev = wifiNodes.Get(i)->GetDevice(0);\n        Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n        Ptr<WifiPhy> wifi_phy = wifi_dev->GetPhy();\n        double currentCca = wifi_phy->GetCcaSensitivityThreshold();\n        // std::cout << \"Current Cca: \" << currentCca << \" next Cca: \" << currentCca + stepSize\n        //           << std::endl;\n        Ptr<ThresholdPreambleDetectionModel> preambleCaptureModel =\n            CreateObject<ThresholdPreambleDetectionModel>();\n        preambleCaptureModel->SetAttribute(\"MinimumRssi\", DoubleValue(currentCca + stepSize));\n        wifi_phy->SetCcaSensitivityThreshold(currentCca + stepSize);\n        wifi_phy->SetPreambleDetectionModel(preambleCaptureModel);\n    }\n    Simulator::Schedule(Seconds(intervalLength), &ChangeCcaSensitivity, stepSize, intervalLength);\n}\n\nvoid\nAssociatedSta(uint16_t aid, Mac48Address addy /* addr */)\n{\n    associatedStas++;\n    std::cout << \"Node \" << MacAddressToNodeId(addy)\n              << \" associated at T=\" << Simulator::Now().GetSeconds() << std::endl;\n}\n\nvoid\nDeAssociatedSta(uint16_t aid, Mac48Address /* addr */)\n{\n    deassociatedStas++;\n}\n\nstd::string\nAddressToString(const Address& addr)\n{\n    std::stringstream addressStr;\n    addressStr << InetSocketAddress::ConvertFrom(addr).GetIpv4() << \":\"\n               << InetSocketAddress::ConvertFrom(addr).GetPort();\n    return addressStr.str();\n}\n\nvoid\nFragmentTx(Ptr<const Packet> fragment,\n           const Address& from,\n           const Address& to,\n           const SeqTsSizeFragHeader& header)\n{\n    NS_LOG_INFO(\"Sent fragment \" << header.GetFragSeq() << \"/\" << header.GetFrags()\n                                 << \" of burst seq=\" << header.GetSeq()\n                                 << \" of header.GetSize ()=\" << header.GetSize()\n                                 << \" (fragment->GetSize ()=\" << fragment->GetSize()\n                                 << \") bytes from \" << AddressToString(from) << \" to \"\n                                 << AddressToString(to) << \" at \" << header.GetTs().As(Time::S));\n    Ptr<const Packet> p = fragment;\n\n    auto mapIt = m_inFlightPacketMap.find(p->GetUid());\n    if (mapIt == m_inFlightPacketMap.end())\n    {\n        // std::cout << \"No packet with UID \" << p->GetUid() << \" is currently in queue\" <<\n        // std::endl;\n        return;\n    }\n\n    auto listIt =\n        std::find_if(mapIt->second.begin(),\n                     mapIt->second.end(),\n                     [&p](const InFlightPacketInfo& info) { return info.m_ptrToPacket == p; });\n\n    if (listIt == mapIt->second.end())\n    {\n        // std::cout << \"Forwarding up a packet that has not been enqueued?\" << std::endl;\n        return;\n    }\n\n    InFlightPacketInfo info;\n    info.m_srcAddress = listIt->m_srcAddress;\n    info.m_dstAddress = listIt->m_dstAddress;\n    info.m_ptrToPacket = listIt->m_ptrToPacket;\n    info.m_edcaEnqueueTime = listIt->m_edcaEnqueueTime;\n    info.m_edcaDequeueTime = listIt->m_edcaDequeueTime;\n    info.appTypeTxTime = Simulator::Now();\n\n    mapIt->second.erase(listIt);\n    mapIt->second.insert(mapIt->second.end(), info);\n}\n\nvoid\nFragmentRx(Ptr<const Packet> fragment,\n           const Address& from,\n           const Address& to,\n           const SeqTsSizeFragHeader& header)\n{\n    NS_LOG_INFO(\"Received fragment \"\n                << header.GetFragSeq() << \"/\" << header.GetFrags() << \" of burst seq=\"\n                << header.GetSeq() << \" of header.GetSize ()=\" << header.GetSize()\n                << \" (fragment->GetSize ()=\" << fragment->GetSize() << \") bytes from \"\n                << AddressToString(from) << \" to \" << AddressToString(to) << \" at \"\n                << header.GetTs().As(Time::S));\n    Ptr<const Packet> p = fragment;\n\n    auto mapIt = m_inFlightPacketMap.find(p->GetUid());\n    if (mapIt == m_inFlightPacketMap.end())\n    {\n        std::cout << \"No packet with UID \" << p->GetUid() << \" is currently in queue\" << std::endl;\n        return;\n    }\n    // mapIt->second.;\n    auto listIt = std::find_if(mapIt->second.begin(),\n                               mapIt->second.end(),\n                               [&p](const InFlightPacketInfo& info) {\n                                   return info.m_ptrToPacket->GetUid() == p->GetUid();\n                               });\n\n    if (listIt == mapIt->second.end())\n    {\n        std::cout << \"Forwarding up a packet that has not been enqueued?\" << std::endl;\n        return;\n    }\n    InFlightPacketInfo info;\n    info.m_srcAddress = listIt->m_srcAddress;\n    info.m_dstAddress = listIt->m_dstAddress;\n    info.m_ptrToPacket = listIt->m_ptrToPacket;\n    info.m_edcaEnqueueTime = listIt->m_edcaEnqueueTime;\n    info.appTypeTxTime = listIt->appTypeTxTime;\n    info.m_phyTxTime = listIt->m_phyTxTime;\n    info.m_L2RxTime = listIt->m_L2RxTime;\n    info.appTypeRxTime = Simulator::Now();\n    // if (p->GetSize() >= pktSize) // ignore non-data frames\n    // {\n    appTxrec++;\n    // }\n    // else\n    // {\n    //     std::cout << \"Size \" << p->GetSize() << std::endl;\n    // }\n    // std::cout << \"APRX\" << std::endl;\n\n    mapIt->second.erase(listIt);\n    mapIt->second.insert(mapIt->second.end(), info);\n    // appTxrec++;\n}\n\nvoid\nBurstTx(Ptr<const Packet> burst,\n        const Address& from,\n        const Address& to,\n        const SeqTsSizeFragHeader& header)\n{\n    NS_LOG_INFO(\"Sent burst seq=\" << header.GetSeq() << \" of header.GetSize ()=\" << header.GetSize()\n                                  << \" (burst->GetSize ()=\" << burst->GetSize() << \") bytes from \"\n                                  << AddressToString(from) << \" to \" << AddressToString(to)\n                                  << \" at \" << header.GetTs().As(Time::S));\n    // std::cout << \"APPTX\" << std::endl;\n}\n\nvoid\nBurstRx(Ptr<const Packet> burst,\n        const Address& from,\n        const Address& to,\n        const SeqTsSizeFragHeader& header)\n{\n    NS_LOG_INFO(\"Received burst seq=\"\n                << header.GetSeq() << \" of header.GetSize ()=\" << header.GetSize()\n                << \" (burst->GetSize ()=\" << burst->GetSize() << \") bytes from \"\n                << AddressToString(from) << \" to \" << AddressToString(to) << \" at \"\n                << header.GetTs().As(Time::S));\n    // std::cout << \"APPRX\" << std::endl;\n    // appTxrec++;\n    // appTxrec++;\n    // std::cout << \"APRX\" << std::endl;\n\n    // Ptr<const Packet> p = burst;\n\n    // auto mapIt = m_inFlightPacketMap.find(p->GetUid());\n    // if (mapIt == m_inFlightPacketMap.end())\n    // {\n    //     std::cout << \"No packet with UID \" << p->GetUid() << \" is currently in queue\" <<\n    //     std::endl; return;\n    // }\n    // // mapIt->second.;\n    // auto listIt = std::find_if(mapIt->second.begin(),\n    //                            mapIt->second.end(),\n    //                            [&p](const InFlightPacketInfo& info) {\n    //                                return info.m_ptrToPacket->GetUid() == p->GetUid();\n    //                            });\n\n    // if (listIt == mapIt->second.end())\n    // {\n    //     std::cout << \"Forwarding up a packet that has not been enqueued?\" << std::endl;\n    //     return;\n    // }\n    // InFlightPacketInfo info;\n    // info.m_srcAddress = listIt->m_srcAddress;\n    // info.m_dstAddress = listIt->m_dstAddress;\n    // info.m_ptrToPacket = listIt->m_ptrToPacket;\n    // info.m_edcaEnqueueTime = listIt->m_edcaEnqueueTime;\n    // info.appTypeTxTime = listIt->appTypeTxTime;\n    // info.m_phyTxTime = listIt->m_phyTxTime;\n    // info.m_L2RxTime = listIt->m_L2RxTime;\n    // info.appTypeRxTime = Simulator::Now();\n\n    // // appTxrec++;\n    // // std::cout << \"APRX\" << std::endl;\n\n    // mapIt->second.erase(listIt);\n    // mapIt->second.insert(mapIt->second.end(), info);\n}\n\n// Works by reading the full string into a file to later be parsed in main\nstd::map<int, std::string>\nreadConfigFile(const std::string& filename)\n{\n    std::map<int, std::string> config;\n\n    std::ifstream configFile(filename);\n    if (!configFile)\n    {\n        std::cerr << \"Error opening configuration file: \" << filename << std::endl;\n        return config;\n    }\n\n    std::string line;\n    std::string ready;\n    while (std::getline(configFile, line))\n    {\n        if (!line.find('#'))\n        {\n            continue;\n        }\n        size_t delimiterPos = line.find(':');\n        if (delimiterPos != std::string::npos)\n        {\n            // std::cout << line.substr(0, delimiterPos) << std::endl;\n            int node = std::stoi(line.substr(0, delimiterPos));\n            std::string configLine = line.substr(delimiterPos + 1);\n            config[node] = configLine;\n        }\n    }\n\n    configFile.close();\n    return config;\n}\n\nvoid\nCreateTrafficConfigurationTemplate(std::string filename)\n{\n    std::ofstream outFile;\n    outFile.open(filename.c_str(), std::ios_base::trunc);\n    if (!outFile.is_open())\n    {\n        NS_LOG_ERROR(\"Can't open file \" << filename);\n        return;\n    }\n    outFile << \"#NodeId:TrafficType,CcaSensitivity,TxPower,ChannelWidth,ChannelNumber\\n\"\n            << std::endl;\n    for (uint32_t i = 0; i < apNodes.GetN(); i++)\n    {\n        outFile << \"#BSS-\" << i << \"\\n#AP\\n\"\n                << i << \":\"\n                << \"\\n#STA\" << std::endl;\n        for (uint32_t x = 0; x < staNodes.GetN(); x += apNodes.GetN())\n        {\n            outFile << staNodes.Get(x + i)->GetId() << \":\" << std::endl;\n        }\n        outFile << std::endl;\n    }\n    outFile.close();\n}\n\n/**\n * Contention window trace.\n *\n * \\param context The context.\n * \\param cw The contention window.\n */\nvoid\nCwTrace(std::string context, uint32_t cw, uint8_t /* linkId */)\n{\n    // std::cout << Simulator::Now().GetSeconds() << \" \" << ContextToNodeId(context) << \" \" <<\n    // cw\n    //           << std::endl;\n    nodeCw[ContextToNodeId(context)].push_back(cw);\n}\n\n/**\n * Backoff trace.\n *\n * \\param context The context.\n * \\param newVal The backoff value.\n */\nvoid\nBackoffTrace(std::string context, uint32_t newVal, uint8_t /* linkId */)\n{\n    // std::cout << Simulator::Now().GetSeconds() << \" \" << ContextToNodeId(context) << \" \" <<\n    // newVal\n    //           << std::endl;\n    nodeBackoff[ContextToNodeId(context)].push_back(newVal);\n}\n\nstruct overlappingPackets\n{\n    uint32_t nodeID{0};\n    uint32_t ifNodeID{0};\n    uint32_t rxNodeID{0};\n    uint64_t packet{0};\n    uint64_t ifPacket{0};\n    Time startTime{0};\n    Time endTime{0};\n    Time ifStartTime{0};\n    Time ifEndTime{0};\n    Time phyDropTime{0};\n    WifiPhyRxfailureReason reason;\n    std::string sync{\"\"};\n\n    bool operator==(const overlappingPackets& other)\n    {\n        return (nodeID == other.nodeID) && (ifNodeID == other.ifNodeID) &&\n               (rxNodeID == other.rxNodeID) && (packet == other.packet) &&\n               (ifPacket == other.ifPacket) && (reason == other.reason);\n    }\n};\n\nstd::vector<overlappingPackets> packetOverlapList;\nstd::vector<overlappingPackets> packetOverlapSuccessList;\nstd::unordered_map<WifiPhyRxfailureReason, int> typeOverlapCount;\nint totalSimulTx = 0;\n\nvoid\ncreatePacketPairs()\n{\n    std::vector<overlappingPackets> packetPossibleOverlapList;\n    // packetPossibleOverlapList.reserve(nodePacketTxTime.size() * average_packets_per_node);\n\n    for (const auto& nodePacketTime : nodePacketTxTime)\n    {\n        uint32_t nodeID = nodePacketTime.first;\n\n        for (const auto& packetTime : nodePacketTime.second)\n        {\n            uint32_t packetID = packetTime.first;\n\n            const auto& txEndTimes = nodePacketTxEndTime[nodeID][packetID];\n            const size_t overlapCount = std::min(packetTime.second.size(), txEndTimes.size());\n\n            for (size_t i = 0; i < overlapCount; i++)\n            {\n                overlappingPackets oPackets;\n                oPackets.nodeID = nodeID;\n                oPackets.packet = packetID;\n                oPackets.startTime = packetTime.second[i];\n                oPackets.endTime = txEndTimes[i];\n                packetPossibleOverlapList.push_back(oPackets);\n            }\n        }\n    }\n\n    std::vector<overlappingPackets> packetOverlapList2;\n    packetOverlapList2.reserve(packetPossibleOverlapList.size());\n\n    for (const auto& packet : packetPossibleOverlapList)\n    {\n        for (const auto& ifPacket : packetPossibleOverlapList)\n        {\n            if (packet.endTime >= ifPacket.startTime && packet.startTime <= ifPacket.endTime)\n            {\n                overlappingPackets oPackets;\n                oPackets = packet;\n                oPackets.ifNodeID = ifPacket.nodeID;\n                oPackets.ifPacket = ifPacket.packet;\n                oPackets.ifStartTime = ifPacket.startTime;\n                oPackets.ifEndTime = ifPacket.endTime;\n                oPackets.sync = (std::abs(packet.startTime.GetMicroSeconds() -\n                                          ifPacket.startTime.GetMicroSeconds()) < 4)\n                                    ? \"synchronously\"\n                                    : \"asynchronously\";\n                packetOverlapList2.push_back(oPackets);\n            }\n        }\n    }\n\n    for (const auto& packet : packetOverlapList2)\n    {\n        for (const auto& packetReasTime : nodeFailureCount)\n        {\n            auto iter = packetReasTime.second.find(packet.packet);\n            if (iter != packetReasTime.second.end())\n            {\n                for (const auto& reasTime : iter->second)\n                {\n                    if (packet.startTime < reasTime.second && packet.endTime > reasTime.second)\n                    {\n                        // std::cout << \"Time difference between end of tx and rx drop\"\n                        //           << packet.endTime.GetMicroSeconds() -\n                        //                  reasTime.second.GetMicroSeconds()\n                        //           << std::endl;\n                        overlappingPackets oPackets;\n                        oPackets = packet;\n                        oPackets.rxNodeID = packetReasTime.first;\n                        oPackets.reason = reasTime.first;\n                        oPackets.phyDropTime = reasTime.second;\n                        // Skip adding overlap if source node is the same as interfering node or the\n                        // interfering packet is the same as the tx packet\n                        if (!((packet.nodeID == packet.ifNodeID) ||\n                              (packet.packet == packet.ifPacket)))\n                        {\n                            // Skip adding if the drop reason is TXING and the ifNode is not the\n                            // rxNode (how could you be txing if the interferer is not the node that\n                            // noticed the txing? <-basically)\n                            if (((oPackets.reason == WifiPhyRxfailureReason(TXING)) ||\n                                 oPackets.reason ==\n                                     WifiPhyRxfailureReason(RECEPTION_ABORTED_BY_TX)) &&\n                                (packet.ifNodeID != oPackets.rxNodeID))\n                            {\n                                // std::cout << \"drop txing\" << std::endl;\n                                continue;\n                            }\n                            // Skip adding if the drop reason is RXING or BUSY_DECODING_PREAMBLE and\n                            // the interferer node is the receiving node\n                            else if (((oPackets.reason == WifiPhyRxfailureReason(RXING)) ||\n                                      (oPackets.reason ==\n                                       WifiPhyRxfailureReason(BUSY_DECODING_PREAMBLE)) ||\n                                      (oPackets.reason ==\n                                       WifiPhyRxfailureReason(PREAMBLE_DETECT_FAILURE))) &&\n                                     (packet.ifNodeID == oPackets.rxNodeID))\n                            {\n                                // std::cout << \"dropped rxing\" << std::endl;\n                                continue;\n                            }\n                            // Skip adding overlapping packets that were received at the same time\n                            // but got dropped due to RXING because it means a previous packet was\n                            // already being decoded when this two additional signals colided due to\n                            // the same backoff\n                            else if (oPackets.reason == WifiPhyRxfailureReason(RXING) &&\n                                     oPackets.sync == \"synchronously\")\n                            {\n                                // packetOverlapList.emplace_back(oPackets);\n                                continue;\n                            }\n                            else\n                            {\n                                packetOverlapList.emplace_back(oPackets);\n                            }\n                        }\n                        else\n                        {\n                            continue;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (const auto& packetSTime : nodeSuccessCount)\n    {\n        for (const auto& packet : packetOverlapList2)\n        {\n            auto iter = packetSTime.second.find(packet.packet);\n            if (iter != packetSTime.second.end())\n            {\n                if (!((packet.nodeID == packet.ifNodeID) || (packet.packet == packet.ifPacket)))\n                {\n                    // std::cout << \"Packet \" << iter->first\n                    //           << \" Time difference between end of tx and rx done \"\n                    //           << iter->second.GetNanoSeconds() - packet.endTime.GetNanoSeconds()\n                    //           << \" start time: \" << packet.startTime << std::endl;\n                    if (packet.ifEndTime.GetSeconds() != 0)\n                    {\n                        if (std::abs(iter->second.GetNanoSeconds() -\n                                     packet.endTime.GetNanoSeconds()) <= 30)\n                        {\n                            // if ((duration + 10) - iter->second.GetSeconds() > 0.1)\n                            // {\n                            overlappingPackets oPackets;\n                            oPackets = packet;\n                            oPackets.rxNodeID = packetSTime.first;\n                            oPackets.phyDropTime = iter->second;\n                            // std::cout << \"Node \" << oPackets.nodeID << \" Tx the packet \"\n                            //           << oPackets.packet << \" and it overlapped \" <<\n                            //           oPackets.sync\n                            //           << \" with packet \" << oPackets.ifPacket << \" from Node\n                            //           \"\n                            //           << oPackets.ifNodeID\n                            //           << \"\\n but the first packet did not get dropped. It was\n                            //           \"\n                            //              \"succesfully received at T= \"\n                            //           << oPackets.phyDropTime.GetSeconds() << \"\\n\"\n                            //           << std::endl;\n                            packetOverlapSuccessList.emplace_back(oPackets);\n                            // }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * Report Rate changed.\n *\n * \\param oldVal Old value.\n * \\param newVal New value.\n */\nvoid\nRateChange(std::string context, uint64_t oldVal, uint64_t newVal)\n{\n    nodeMcs[ContextToNodeId(context)] = dataRateToMcs[newVal];\n    // std::cout << \"Datarate: \" << dataRateToMcs[newVal] << std::endl;\n    // nodeMcs\n}\n\nstd::unordered_map<uint64_t, int> bssNode;\n\nint\nmain(int argc, char* argv[])\n{\n    auto interface = Ns3AiMsgInterface::Get();\n    interface->SetIsMemoryCreator(false);\n    interface->SetUseVector(true);\n    interface->SetHandleFinish(true);\n    duration = 100;    ///< duration (in seconds)\n    bool pcap = false; ///< Flag to enable/disable PCAP files generation\n    uint32_t seedNumber = 1;\n    std::string traceFolder =\n        \"src/vr-app/model/BurstGeneratorTraces/\"; // example traces can be found here\n    std::string traceFile = \"ge_cities_20mbps_30fps.csv\";\n\n    std::string phyMode = \"OfdmRate54Mbps\"; ///< Constant PHY mode\n    double frequency = 5;                   ///< The operating frequency band in GHz: 2.4, 5 or 6\n    uint16_t channelWidths = 20;     ///< The constant channel width in MHz (only for 11n/ac/ax)\n    uint16_t guardIntervalNs = 3200; ///< The guard interval in nanoseconds (800 or 400 for\n                                     ///< 11n/ac, 800 or 1600 or 3200 for 11 ax)\n    uint16_t pktInterval =\n        1000; ///< The socket packet interval in microseconds (a higher value is needed to reach\n    ///< saturation conditions as the channel bandwidth or the MCS increases)\n\n    txPower = 16; ///< The transmit power of all nodes in dBm (or if --app=setup-done, custom\n                  ///< txPowers)\n    ccaSensitivity = -82;\n    std::string standard(\"11ax\"); ///< the 802.11 standard\n    // Disable fragmentation and RTS/CTS\n    int mcs = -1;\n\n    networkSize = 0;\n\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::FragmentationThreshold\",\n                       StringValue(\"22000\"));\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"22000\"));\n    // Disable short retransmission failure (make retransmissions persistent)\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::MaxSlrc\",\n                       UintegerValue(std::numeric_limits<uint32_t>::max()));\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::MaxSsrc\",\n                       UintegerValue(std::numeric_limits<uint32_t>::max()));\n    // Set maximum queue size to the largest value and set maximum queue delay to be larger than\n    // the simulation time\n    Config::SetDefault(\"ns3::WifiMacQueue::MaxSize\",\n                       QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS,\n                                                100))); // TODO: set to a smaller value. 100?\n    Config::SetDefault(\"ns3::WifiMacQueue::MaxDelay\", TimeValue(Seconds(20 * duration)));\n    bool calculateStats = false;\n    int ring = 0;\n    bool autoMCS = false;\n    std::string configFileName = \"foo.config.txt\";\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"pktSize\", \"The packet size in bytes\", pktSize);\n    cmd.AddValue(\"rng\", \"The seed run number\", seedNumber);\n    cmd.AddValue(\"app\",\n                 \"The type of application to set. (constant,bursty,bursty-trace,setup-setup-done)\",\n                 appType);\n    cmd.AddValue(\"prop\", \"The propagation loss model\", propagationModel);\n    cmd.AddValue(\"ring\", \"Set ring topology or not\", ring);\n    cmd.AddValue(\"ccaSensitivity\", \"The cca sensitivity (-82dBm)\", ccaSensitivity);\n    cmd.AddValue(\"duration\", \"Time duration for each trial in seconds\", duration);\n    cmd.AddValue(\"pcap\", \"Enable/disable PCAP tracing\", pcap);\n    cmd.AddValue(\"autoMCS\", \"Enable/disable automatic choice of MCS\", autoMCS);\n    cmd.AddValue(\"traceFolder\", \"The folder containing the trace.\", traceFolder);\n    cmd.AddValue(\"traceFile\", \"The trace file name.\", traceFile);\n    cmd.AddValue(\"networkSize\", \"Number of stations per bss\", networkSize);\n    cmd.AddValue(\"standard\", \"Set the standard (11a, 11b, 11g, 11n, 11ac, 11ax)\", standard);\n    cmd.AddValue(\"apNodes\", \"Number of APs\", apNodeCount); // use 4\n    cmd.AddValue(\"phyMode\", \"Set the constant PHY mode string used to transmit frames\", phyMode);\n    cmd.AddValue(\"frequency\", \"Set the operating frequency band in GHz: 2.4, 5 or 6\", frequency);\n    cmd.AddValue(\"overlapStats\",\n                 \"Enable the calculation of overlapping packets and their source\",\n                 calculateStats);\n    cmd.AddValue(\"channelWidth\",\n                 \"Set the constant channel width in MHz (only for 11n/ac/ax)\",\n                 channelWidths);\n    cmd.AddValue(\"gi\",\n                 \"Set the the guard interval in nanoseconds (800 or 400 for 11n/ac, 800 or 1600 or \"\n                 \"3200 for 11 ax)\",\n                 guardIntervalNs);\n    cmd.AddValue(\"maxMpdus\",\n                 \"Set the maximum number of MPDUs in A-MPDUs (0 to disable MPDU aggregation)\",\n                 maxMpdus);\n    cmd.AddValue(\"distance\", \"Set the distance in meters between the AP and the STAs\", distance);\n    cmd.AddValue(\"txPower\", \"Set the transmit power of all nodes in dBm\", txPower);\n    cmd.AddValue(\"pktInterval\", \"Set the socket packet interval in microseconds\", pktInterval);\n    cmd.AddValue(\"boxsize\", \"Set the size of the box in meters\", boxSize);\n    cmd.AddValue(\"drl\", \"Enable the use of DRL for setting ccaSensitivity\", drlCca);\n    cmd.AddValue(\"configFile\", \"Configuration file of Multi-BSS example\", configFileName);\n    cmd.Parse(argc, argv);\n\n    RngSeedManager::SetSeed(seedNumber);\n    RngSeedManager::SetRun(seedNumber);\n\n    for (int i = 0; i < 12; i++)\n    {\n        // std::cout << \"Datarate: \" << HePhy::GetDataRate(i, channelWidths, guardIntervalNs, 1)\n        //           << std::endl;\n        dataRateToMcs[HePhy::GetDataRate(i, channelWidths, NanoSeconds(guardIntervalNs), 1)] = i;\n    }\n\n    if (phyMode != \"OfdmRate54Mbps\")\n    {\n        mcs = std::stoi(phyMode.substr(phyMode.find(\"s\") + 1));\n    }\n    if (networkSize < 3)\n    {\n        pktInterval = 100;\n    }\n    // LogComponentEnable(\"StaWifiMac\", LOG_LEVEL_ALL);\n    // LogComponentEnable(\"WifiAssocManager\", LOG_LEVEL_ALL);\n    // LogComponentEnable(\"ApWifiMac\", LOG_LEVEL_ALL);\n\n    // LogComponentEnable(\"PhyEntity\", LOG_LEVEL_ALL);\n    int channelWidth = channelWidths;\n    int gi = guardIntervalNs;\n    apNodes.Create(apNodeCount);\n    staNodes.Create(apNodeCount * networkSize);\n    if (appType == \"setup\")\n    {\n        CreateTrafficConfigurationTemplate(configFileName);\n        std::cout << \"Created config files for traffic based on current topology. Specify each \"\n                     \"traffic type and run --app=setup-done. Traffic \"\n                     \"types(none,constant,bursty,bursty-trace-TRACELOCATION)\"\n                  << std::endl;\n        return 0;\n    }\n    else if (appType == \"setup-done\")\n    {\n        configuration = readConfigFile(configFileName);\n    }\n\n    // std::cout << \"Traffic type for STA1: \" << configuration[2] << std::endl;\n\n    WifiStandard wifiStandard;\n    if (standard == \"11a\")\n    {\n        wifiStandard = WIFI_STANDARD_80211a;\n        frequency = 5;\n        channelWidth = 20;\n    }\n    else if (standard == \"11b\")\n    {\n        wifiStandard = WIFI_STANDARD_80211b;\n        frequency = 2.4;\n        channelWidth = 22;\n    }\n    else if (standard == \"11g\")\n    {\n        wifiStandard = WIFI_STANDARD_80211g;\n        frequency = 2.4;\n        channelWidth = 20;\n    }\n    else if (standard == \"11n\")\n    {\n        if (frequency == 2.4)\n        {\n            wifiStandard = WIFI_STANDARD_80211n;\n        }\n        else if (frequency == 5)\n        {\n            wifiStandard = WIFI_STANDARD_80211n;\n        }\n        else\n        {\n            NS_FATAL_ERROR(\"Unsupported frequency band \" << frequency << \" GHz for standard \"\n                                                         << standard);\n        }\n    }\n    else if (standard == \"11ac\")\n    {\n        wifiStandard = WIFI_STANDARD_80211ac;\n        frequency = 5;\n    }\n    else if (standard == \"11ax\")\n    {\n        if (frequency == 2.4)\n        {\n            wifiStandard = WIFI_STANDARD_80211ax;\n        }\n        else if (frequency == 5)\n        {\n            wifiStandard = WIFI_STANDARD_80211ax;\n        }\n        else if (frequency == 6)\n        {\n            wifiStandard = WIFI_STANDARD_80211ax;\n        }\n        else\n        {\n            NS_FATAL_ERROR(\"Unsupported frequency band \" << frequency << \" GHz for standard \"\n                                                         << standard);\n        }\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Unsupported standard: \" << standard);\n    }\n\n    if (appType != \"setup-done\")\n    {\n        std::string channelStr = \"{0, \" + std::to_string(channelWidth) + \", BAND_\" +\n                                 (frequency == 2.4 ? \"2_4\" : (frequency == 5 ? \"5\" : \"6\")) +\n                                 \"GHZ, 0}\";\n        Config::SetDefault(\"ns3::WifiPhy::ChannelSettings\", StringValue(channelStr));\n    }\n\n    YansWifiChannelHelper wifiChannel;\n\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    if (frequency == 6)\n    {\n        if (propagationModel == \"log\")\n        {\n            // Reference Loss for Friss at 1 m with 6.0 GHz\n            wifiChannel.AddPropagationLoss(\"ns3::LogDistancePropagationLossModel\",\n                                           \"Exponent\",\n                                           DoubleValue(2.0),\n                                           \"ReferenceDistance\",\n                                           DoubleValue(1.0),\n                                           \"ReferenceLoss\",\n                                           DoubleValue(49.013));\n        }\n        else if (propagationModel == \"tgax\")\n        {\n            wifiChannel.AddPropagationLoss(\"ns3::TgaxResidentialPropagationLossModel\",\n                                           \"Frequency\",\n                                           DoubleValue(6e9),\n                                           \"ShadowSigma\",\n                                           DoubleValue(5.0));\n        }\n        else if (propagationModel == \"fixed\")\n        {\n            wifiChannel.AddPropagationLoss(\"ns3::FixedRssLossModel\", \"Rss\", DoubleValue(-71));\n        }\n    }\n    else if (frequency == 5)\n    {\n        // Reference Loss for Friss at 1 m with 5.15 GHz\n        if (propagationModel == \"log\")\n        {\n            wifiChannel.AddPropagationLoss(\"ns3::LogDistancePropagationLossModel\",\n                                           \"Exponent\",\n                                           DoubleValue(3.0),\n                                           \"ReferenceDistance\",\n                                           DoubleValue(1.0),\n                                           \"ReferenceLoss\",\n                                           DoubleValue(50));\n        }\n        else if (propagationModel == \"tgax\")\n        {\n            wifiChannel.AddPropagationLoss(\"ns3::TgaxResidentialPropagationLossModel\",\n                                           \"Frequency\",\n                                           DoubleValue(5e9),\n                                           \"ShadowSigma\",\n                                           DoubleValue(5.0));\n        }\n        else if (propagationModel == \"fixed\")\n        {\n            wifiChannel.AddPropagationLoss(\"ns3::FixedRssLossModel\", \"Rss\", DoubleValue(-71));\n        }\n    }\n    else\n    {\n        // Reference Loss for Friss at 1 m with 2.4 GHz\n        if (propagationModel == \"log\")\n        {\n            wifiChannel.AddPropagationLoss(\"ns3::LogDistancePropagationLossModel\",\n                                           \"Exponent\",\n                                           DoubleValue(2.0),\n                                           \"ReferenceDistance\",\n                                           DoubleValue(1.0),\n                                           \"ReferenceLoss\",\n                                           DoubleValue(40.046));\n        }\n        else if (propagationModel == \"tgax\")\n        {\n            wifiChannel.AddPropagationLoss(\"ns3::TgaxResidentialPropagationLossModel\",\n                                           \"Frequency\",\n                                           DoubleValue(2.4e9),\n                                           \"ShadowSigma\",\n                                           DoubleValue(5.0));\n        }\n        else if (propagationModel == \"fixed\")\n        {\n            wifiChannel.AddPropagationLoss(\"ns3::FixedRssLossModel\", \"Rss\", DoubleValue(-71));\n        }\n    }\n\n    WifiHelper wifi;\n    wifi.SetStandard(wifiStandard);\n    if (!autoMCS)\n    {\n        wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                     \"DataMode\",\n                                     StringValue(phyMode),\n                                     \"ControlMode\",\n                                     StringValue(\"OfdmRate54Mbps\"));\n    }\n    else\n    {\n        Config::SetDefault(\"ns3::AutoMcsWifiManager::autoMCS\", BooleanValue(autoMCS));\n        wifi.SetRemoteStationManager(\"ns3::AutoMcsWifiManager\");\n    }\n    YansWifiPhyHelper phy;\n    phy.SetErrorRateModel(\"ns3::NistErrorRateModel\");\n\n    phy.SetChannel(wifiChannel.Create());\n    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n\n    // // phy.Set (\"RxSensitivity\", DoubleValue (-91));\n    // phy.DisablePreambleDetectionModel();\n    // // phy.SetCcaSensitivityThreshold(m_CcaSensitivityDbm);\n    // phy.Set(\"CcaEdThreshold\", DoubleValue(ccaSensitivity + 40));\n\n    if (appType != \"setup-done\")\n    {\n        phy.SetPreambleDetectionModel(\"ns3::ThresholdPreambleDetectionModel\",\n                                      \"MinimumRssi\",\n                                      DoubleValue(ccaSensitivity));\n        phy.Set(\"CcaSensitivity\", DoubleValue(ccaSensitivity));\n        // phy.Set(\"CcaEdThreshold\", DoubleValue(ccaSensitivity + 20));\n        phy.Set(\"TxPowerStart\", DoubleValue(txPower));\n        phy.Set(\"TxPowerEnd\", DoubleValue(txPower));\n    }\n    uint64_t beaconInterval = 100 * 1024;\n\n    // phy.Set(\"TxPowerStart\", DoubleValue(txPower));\n    // phy.Set(\"TxPowerEnd\", DoubleValue(txPower));\n    WifiMacHelper mac;\n    for (int i = 0; i < apNodeCount; ++i)\n    {\n        if (appType == \"setup-done\")\n        {\n            std::string configString = configuration[apNodes.Get(i)->GetId()];\n            std::vector<std::string> configValues = csv_split(configString, ',');\n            double m_ccaSensitivity = std::stoi(configValues[1]);\n            double m_txPower = std::stoi(configValues[2]);\n            //            double m_chWidth = std::stoi(configValues[3]);\n            //            double m_chNumber = std::stoi(configValues[4]);\n\n            phy.Set(\"CcaSensitivity\", DoubleValue(m_ccaSensitivity));\n            phy.SetPreambleDetectionModel(\"ns3::ThresholdPreambleDetectionModel\",\n                                          \"MinimumRssi\",\n                                          DoubleValue(m_ccaSensitivity));\n            phy.Set(\"TxPowerStart\", DoubleValue(m_txPower));\n            phy.Set(\"TxPowerEnd\", DoubleValue(m_txPower));\n            std::string chStr = \"{\" + configValues[4] + \",\" + configValues[3] + \", BAND_5GHZ, 0}\";\n            phy.Set(\"ChannelSettings\", StringValue(chStr));\n            // phy.Set(\"ChannelWidth\", UintegerValue(m_chWidth));\n            // phy.Set(\"ChannelNumber\", UintegerValue(m_chNumber));\n            // phy.Set(\"Frequency\", UintegerValue(frequency));\n            // for(auto it :configValues ){\n            //     std::cout << \"AP Values \" << it << std::endl;\n            // }\n\n            // double m_ccaSensitivity = std::stoi(configValues[0]);\n\n            // size_t pos = configString.find(',');\n            // configString = configString.substr(pos + 1);\n            // size_t pos2 = configString.find(',');\n            // std::cout << \"CCaSensitivity: \" << configString.substr(0, pos2) << std::endl;\n            // double m_ccaSensitivity = std::stoi(configString.substr(0, pos2));\n            // std::cout << \"apTxPower: \" << configString.substr(pos2 + 1) << std::endl;\n            // double m_txPower = std::stoi(configString.substr(pos2 + 1));\n            // phy.Set(\"CcaSensitivity\", DoubleValue(m_ccaSensitivity));\n            // phy.SetPreambleDetectionModel(\"ns3::ThresholdPreambleDetectionModel\",\n            //                               \"MinimumRssi\",\n            //                               DoubleValue(m_ccaSensitivity));\n            // phy.Set(\"TxPowerStart\", DoubleValue(m_txPower));\n            // phy.Set(\"TxPowerEnd\", DoubleValue(m_txPower));\n        }\n        std::string ssi = \"BSS-\" + std::to_string(i);\n        Ssid ssid = Ssid(ssi);\n        bssNode[apNodes.Get(i)->GetId()] = i;\n        mac.SetType(\"ns3::ApWifiMac\",\n                    \"BeaconInterval\",\n                    TimeValue(MicroSeconds(beaconInterval)),\n                    \"Ssid\",\n                    SsidValue(ssid));\n        NetDeviceContainer tmp = wifi.Install(phy, mac, apNodes.Get(i));\n\n        apDevices.Add(tmp.Get(0));\n        devices.Add(tmp.Get(0));\n        wifiNodes.Add(apNodes.Get(i));\n        std::cout << \"AP MAC: \" << tmp.Get(0)->GetAddress() << \",\" << ssi << std::endl;\n    }\n    phy.EnablePcap(\"AP\", apDevices);\n\n    // std::cout << \"AP addy: \" << devices.Get(0)->GetAddress() << std::endl;\n    // std::cout << \"STA addy: \" << devices.Get(i)->GetAddress() << std::endl;\n\n    for (uint32_t i = 0; i < (apNodeCount * networkSize); ++i)\n    {\n        if (appType == \"setup-done\")\n        {\n            std::string configString = configuration[staNodes.Get(i)->GetId()];\n\n            std::vector<std::string> configValues = csv_split(configString, ',');\n            // for(auto it :configValues ){\n            //     std::cout << \"STA Values \" << it << std::endl;\n            // }\n\n            std::cout << \"STA node id \" << staNodes.Get(i)->GetId() << \" : \" << configValues[0]\n                      << \", \" << configValues[1] << \", \" << configValues[2] << \", \"\n                      << configValues[3] << \", \" << configValues[4] << \", \" << std::endl;\n\n            double m_ccaSensitivity = std::stoi(configValues[1]);\n            double m_txPower = std::stoi(configValues[2]);\n            //            double m_chWidth = std::stoi(configValues[3]);\n            //            double m_chNumber = std::stoi(configValues[4]);\n\n            phy.Set(\"CcaSensitivity\", DoubleValue(m_ccaSensitivity));\n            phy.SetPreambleDetectionModel(\"ns3::ThresholdPreambleDetectionModel\",\n                                          \"MinimumRssi\",\n                                          DoubleValue(m_ccaSensitivity));\n            phy.Set(\"TxPowerStart\", DoubleValue(m_txPower));\n            phy.Set(\"TxPowerEnd\", DoubleValue(m_txPower));\n\n            std::string chStr = \"{\" + configValues[4] + \",\" + configValues[3] + \", BAND_5GHZ, 0}\";\n            phy.Set(\"ChannelSettings\", StringValue(chStr));\n\n            // phy.Set(\"ChannelWidth\", UintegerValue(m_chWidth));\n            //  phy.Set(\"ChannelNumber\", UintegerValue(m_chNumber));\n            //  phy.Set(\"Frequency\", UintegerValue(frequency));\n            // size_t pos = configString.find(',');\n            // configString = configString.substr(pos + 1);\n            // size_t pos2 = configString.find(',');\n            // std::cout << \"CCaSensitivity: \" << configString.substr(0, pos2) << std::endl;\n            // double m_ccaSensitivity = std::stoi(configString.substr(0, pos2));\n            // std::cout << \"apTxPower: \" << configString.substr(pos2 + 1) << std::endl;\n            // double m_txPower = std::stoi(configString.substr(pos2 + 1));\n            // phy.Set(\"CcaSensitivity\", DoubleValue(m_ccaSensitivity));\n            // phy.SetPreambleDetectionModel(\"ns3::ThresholdPreambleDetectionModel\",\n            //                               \"MinimumRssi\",\n            //                               DoubleValue(m_ccaSensitivity));\n            // phy.Set(\"TxPowerStart\", DoubleValue(m_txPower));\n            // phy.Set(\"TxPowerEnd\", DoubleValue(m_txPower));\n        }\n        // i % apNodeCount makes it so you can give each sta of the appropiate AP the correct\n        // SSID\n        std::string ssi = \"BSS-\" + std::to_string(i % apNodeCount);\n        Ssid ssid = Ssid(ssi);\n        bssNode[staNodes.Get(i)->GetId()] = i % apNodeCount;\n        mac.SetType(\"ns3::StaWifiMac\",\n                    \"MaxMissedBeacons\",\n                    UintegerValue(std::numeric_limits<uint32_t>::max()),\n                    \"Ssid\",\n                    SsidValue(ssid));\n        NetDeviceContainer tmp = wifi.Install(phy, mac, staNodes.Get(i));\n\n        devices.Add(tmp.Get(0));\n        staDevices.Add(tmp.Get(0));\n        wifiNodes.Add(staNodes.Get(i));\n        // // TODO this is only according to what Hao wants to measure, this could change\n        // if (i % apNodeCount == 0)\n        // {\n        //     // Trace PHY Rx start events\n        //     Config::Connect(\n        //         \"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/PhyRxBegin\",\n        //         MakeCallback(&PhyRxTrace));\n        // }\n        std::cout << \"STA: \" << i << std::endl;\n        std::cout << \"STA MAC: \" << tmp.Get(0)->GetAddress() << \",\" << ssi << std::endl;\n    }\n    // phy.EnablePcap(\"STA\", staDevices.Get(7));\n    // phy.EnablePcap(\"STA\", staDevices.Get(3));\n    wifi.AssignStreams(devices, 0);\n\n    // Set guard interval\n    Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HeConfiguration/\"\n                \"GuardInterval\",\n                TimeValue(NanoSeconds(gi)));\n\n    // Configure AP aggregation\n    for (int i = 0; i < apNodeCount; ++i)\n    {\n        Ptr<NetDevice> dev = apNodes.Get(i)->GetDevice(0);\n\n        Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n        wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\",\n                                         UintegerValue(maxMpdus * (pktSize + 50)));\n        wifi_dev->GetMac()->SetAttribute(\"BK_MaxAmpduSize\",\n                                         UintegerValue(maxMpdus * (pktSize + 50)));\n        wifi_dev->GetMac()->SetAttribute(\"VO_MaxAmpduSize\",\n                                         UintegerValue(maxMpdus * (pktSize + 50)));\n        wifi_dev->GetMac()->SetAttribute(\"VI_MaxAmpduSize\",\n                                         UintegerValue(maxMpdus * (pktSize + 50)));\n\n        // count associations\n        wifi_dev->GetMac()->TraceConnectWithoutContext(\"AssociatedSta\",\n                                                       MakeCallback(&AssociatedSta));\n        // count Desassociations\n        wifi_dev->GetMac()->TraceConnectWithoutContext(\"DeAssociatedSta\",\n                                                       MakeCallback(&DeAssociatedSta));\n    }\n    // Configure STA aggregation\n    for (uint32_t i = 0; i < (apNodeCount * networkSize); ++i)\n    {\n        Ptr<NetDevice> dev = staNodes.Get(i)->GetDevice(0);\n\n        Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n        wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\",\n                                         UintegerValue(maxMpdus * (pktSize + 50)));\n        wifi_dev->GetMac()->SetAttribute(\"BK_MaxAmpduSize\",\n                                         UintegerValue(maxMpdus * (pktSize + 50)));\n        wifi_dev->GetMac()->SetAttribute(\"VO_MaxAmpduSize\",\n                                         UintegerValue(maxMpdus * (pktSize + 50)));\n        wifi_dev->GetMac()->SetAttribute(\"VI_MaxAmpduSize\",\n                                         UintegerValue(maxMpdus * (pktSize + 50)));\n    }\n\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    // create a set of rooms in a building\n\n    double xRoomCount = apNodeCount;\n    double yRoomCount = 1;\n    if (apNodeCount >= 3)\n    {\n        xRoomCount = 2;\n        yRoomCount = 2;\n    }\n\n    double floorCount = 1;\n\n    double buildingSizeX = boxSize * xRoomCount; // m\n    double buildingSizeY = boxSize * yRoomCount; // m\n    double buildingHeight = 3 * floorCount;      // m\n\n    Ptr<Building> building;\n    building = CreateObject<Building>();\n\n    building->SetBoundaries(Box(0, buildingSizeX, 0, buildingSizeY, 0, buildingHeight));\n    building->SetNRoomsX(xRoomCount);\n    building->SetNRoomsY(yRoomCount);\n    building->SetNFloors(floorCount);\n\n    randomX->SetAttribute(\"Stream\", IntegerValue(seedNumber));\n    randomX->SetAttribute(\"Max\", DoubleValue(boxSize));\n    randomX->SetAttribute(\"Min\", DoubleValue(0.0));\n\n    randomY->SetAttribute(\"Stream\", IntegerValue(seedNumber + 1));\n    randomY->SetAttribute(\"Max\", DoubleValue(boxSize));\n    randomY->SetAttribute(\"Min\", DoubleValue(0.0));\n    //    double ap_x = 0;\n    //    double ap_y = 0;\n    // Set postion for AP\n    for (uint32_t i = 0; i < apNodes.GetN(); i++)\n    {\n        if (ring)\n        {\n            double x = (boxSize / 2);\n            double y = (boxSize / 2);\n            if (i == 1)\n            {\n                x = (boxSize / 2) + (boxSize);\n                y = (boxSize / 2);\n            }\n            if (i == 2)\n            {\n                x = (boxSize / 2);\n                y = (boxSize / 2) + (boxSize);\n            }\n            else if (i == 3)\n            {\n                x = (boxSize / 2) + (boxSize);\n                y = (boxSize / 2) + (boxSize);\n            }\n            Vector l1(x, y, 1.5);\n            positionAlloc->Add(l1);\n            std::cout << \"AP\" << i << \" \" << x << \",\" << y << std::endl;\n            // boxOutput << \"AP,\" << x << \",\" << y << std::endl;\n        }\n        else\n        {\n            double x = randomX->GetValue();\n            double y = randomY->GetValue();\n            if (i == 0)\n            {\n                //                ap_x = x;\n                //                ap_y = y;\n            }\n            if (i == 1)\n            {\n                x = (boxSize / 2) + (boxSize);\n                y = (boxSize / 2);\n            }\n            if (i == 2)\n            {\n                x = (boxSize / 2);\n                y = (boxSize / 2) + (boxSize);\n            }\n            else if (i == 3)\n            {\n                x = (boxSize / 2) + (boxSize);\n                y = (boxSize / 2) + (boxSize);\n            }\n            Vector l1(x, y, 1.5);\n            positionAlloc->Add(l1);\n            std::cout << \"AP\" << i << \" \" << x << \",\" << y << std::endl;\n            // boxOutput << \"AP,\" << x << \",\" << y << std::endl;\n            // Vector l2(5.0, 5.0, 1.5);\n            // std::cout << \"Points intersect how many walls? \" <<\n            // building->WallInLOS(l1, l2)\n            //           << std::endl;}\n        }\n    }\n    std::vector<Vector> ringPos;\n    if (ring)\n    {\n        for (uint32_t i = 0; i < networkSize; i++)\n        {\n            double angle = (static_cast<double>(360) / (networkSize));\n            double x = (boxSize / 2) + (distance * cos(((i * angle * PI) / 180)));\n            double y = (boxSize / 2) + (distance * sin(((i * angle * PI) / 180)));\n            Vector l1(x, y, 1.5);\n            ringPos.push_back(l1);\n        }\n        for (auto it : ringPos)\n        {\n            for (int i = 0; i < apNodeCount; i++)\n            {\n                double x = it.x;\n                double y = it.y;\n                if (i == 1)\n                {\n                    x = x + (boxSize);\n                    //                    y = y;\n                }\n                if (i == 2)\n                {\n                    //                    x = x;\n                    y = y + (boxSize);\n                }\n                else if (i == 3)\n                {\n                    x = x + (boxSize);\n                    y = y + (boxSize);\n                }\n                Vector l1(x, y, 1.5);\n                positionAlloc->Add(l1);\n                std::cout << \"STA\" << i << \" \" << x << \",\" << y << std::endl;\n                // std::cout << \"STA \" << (it.x) + (10 * (i % apNodeCount)) <<\n                // \",\" << it.y\n                //           << std::endl;\n            }\n        }\n        // positionAlloc->Add(l1);\n        // std::cout << \"STA\" << i << \" \" << x << \",\" << y << std::endl;\n    }\n    else\n    {\n        // Set postion for STAs\n        for (uint32_t i = 0; i < staNodes.GetN(); i++)\n        {\n            double x = randomX->GetValue();\n            double y = randomY->GetValue();\n            double currentAp = bssNode[staNodes.Get(i)->GetId()];\n            // if (i == 0)\n            // {\n            //     x = ((ap_x + distance) <= boxSize) ? (ap_x + distance) : (ap_x - distance);\n            //     y = ((ap_y + distance) <= boxSize) ? (ap_y + distance) : (ap_y - distance);\n            // }\n            if (currentAp == 1)\n            {\n                x = x + (boxSize);\n                //                y = y;\n            }\n            if (currentAp == 2)\n            {\n                //                x = x;\n                y = y + (boxSize);\n            }\n            else if (currentAp == 3)\n            {\n                x = x + (boxSize);\n                y = y + (boxSize);\n            }\n            Vector l1(x, y, 1.5);\n            positionAlloc->Add(l1);\n            std::cout << \"STA\" << i << \" \" << x << \",\" << y << std::endl;\n            // std::cout << \"Points intersect how many walls? \" <<\n            // building->WallInLOS(l1, l2)\n            //           << std::endl;\n        }\n    }\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(wifiNodes);\n    BuildingsHelper::Install(wifiNodes);\n\n    if (drlCca)\n    {\n        Simulator::Schedule(Seconds(11), &MeasureIntervalThroughputHolDelay);\n    }\n\n    // Vector l1(7.1, 5.5, 1);\n    // Vector l2(25.0, 5.5, 1);\n    // // building->WallInLOS(l1, l2);\n    // std::cout << \"Points intersect how many walls? \" <<\n    // building->WallInLOS(l1, l2) << std::endl;\n    if (appType == \"constant\")\n    {\n        PacketSocketHelper packetSocket;\n        packetSocket.Install(wifiNodes);\n\n        ApplicationContainer apps;\n        Ptr<UniformRandomVariable> startTime = CreateObject<UniformRandomVariable>();\n\n        startTime->SetAttribute(\"Stream\", IntegerValue(0));\n        startTime->SetAttribute(\"Min\", DoubleValue(6));\n        startTime->SetAttribute(\"Max\", DoubleValue(8));\n\n        double start = 0;\n        for (int i = 0; i < apNodeCount; i++)\n        {\n            Ptr<WifiNetDevice> wifi_apDev = DynamicCast<WifiNetDevice>(apDevices.Get(i));\n            Ptr<ApWifiMac> ap_mac = DynamicCast<ApWifiMac>(wifi_apDev->GetMac());\n            Ptr<PacketSocketServer> server = CreateObject<PacketSocketServer>();\n            server->TraceConnectWithoutContext(\"Rx\", MakeCallback(&NotifyAppRx));\n\n            for (uint32_t x = 0; x < staNodes.GetN(); x += apNodeCount)\n            {\n                Ptr<WifiNetDevice> wifi_staDev = DynamicCast<WifiNetDevice>(staDevices.Get(x + i));\n                Ptr<StaWifiMac> sta_mac = DynamicCast<StaWifiMac>(wifi_staDev->GetMac());\n\n                std::cout << \"Sta: \" << staNodes.Get(x + i)->GetId() << \" AP: \" << i << std::endl;\n                PacketSocketAddress socketAddr;\n                socketAddr.SetSingleDevice(staDevices.Get((x + i))->GetIfIndex());\n                socketAddr.SetPhysicalAddress(apDevices.Get(i)->GetAddress());\n                socketAddr.SetProtocol(1);\n\n                Ptr<PacketSocketClient> client = CreateObject<PacketSocketClient>();\n                client->SetRemote(socketAddr);\n\n                client->TraceConnectWithoutContext(\"Tx\", MakeCallback(&NotifyAppTx));\n\n                staNodes.Get(x + i)->AddApplication(client);\n                client->SetAttribute(\"PacketSize\", UintegerValue(pktSize));\n                client->SetAttribute(\"MaxPackets\", UintegerValue(0));\n                client->SetAttribute(\"Interval\", TimeValue(Time(MicroSeconds(pktInterval))));\n                start = startTime->GetValue();\n                client->SetStartTime(Seconds(start));\n                std::cout << \"APP START: \" << start << std::endl;\n\n                server->SetLocal(socketAddr);\n            }\n            apNodes.Get(i)->AddApplication(server);\n        }\n    }\n    else if (appType == \"setup-done\")\n    {\n        Ptr<UniformRandomVariable> startTime = CreateObject<UniformRandomVariable>();\n        startTime->SetAttribute(\"Stream\", IntegerValue(0));\n        startTime->SetAttribute(\"Min\", DoubleValue(6));\n        startTime->SetAttribute(\"Max\", DoubleValue(8));\n\n        // PacketSocketHelper packetSocket;\n        // packetSocket.Install(wifiNodes);\n\n        ApplicationContainer apps;\n\n        InternetStackHelper stack;\n        stack.Install(wifiNodes);\n\n        uint16_t portNumber = 50000;\n\n        Ipv4AddressHelper address;\n        address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n\n        Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n        Ipv4InterfaceContainer apInterfaces = address.Assign(apDevices);\n\n        for (int i = 0; i < apNodeCount; i++)\n        {\n            Ipv4Address apAddress = apInterfaces.GetAddress(i);\n            // Create bursty application helper\n            BurstyHelper burstyHelper(\"ns3::UdpSocketFactory\",\n                                      InetSocketAddress(apAddress, portNumber));\n            burstyHelper.SetAttribute(\"FragmentSize\", UintegerValue(pktSize));\n\n            // Create burst sink helper\n            BurstSinkHelper burstSinkHelper(\"ns3::UdpSocketFactory\",\n                                            InetSocketAddress(apAddress, portNumber));\n\n            // Install burst sink\n            ApplicationContainer apApps = burstSinkHelper.Install(apNodes.Get(i));\n            Ptr<BurstSink> burstSink = apApps.Get(0)->GetObject<BurstSink>();\n\n            for (uint32_t x = 0; x < staNodes.GetN(); x += apNodeCount)\n            {\n                std::string trafficType = configuration[staNodes.Get(x + i)->GetId()];\n                size_t pos = trafficType.find(',');\n                trafficType = trafficType.substr(0, pos);\n                std::cout << \"Sta: \" << staNodes.Get(x + i)->GetId() << \" Traffic \" << trafficType\n                          << std::endl;\n                if (trafficType == \"constant\")\n                {\n                    Ptr<WifiNetDevice> wifi_apDev = DynamicCast<WifiNetDevice>(apDevices.Get(i));\n                    Ptr<ApWifiMac> ap_mac = DynamicCast<ApWifiMac>(wifi_apDev->GetMac());\n                    Ptr<PacketSocketServer> server = CreateObject<PacketSocketServer>();\n                    server->TraceConnectWithoutContext(\"Rx\", MakeCallback(&NotifyAppRx));\n                    Ptr<WifiNetDevice> wifi_staDev =\n                        DynamicCast<WifiNetDevice>(staDevices.Get(x + i));\n                    Ptr<StaWifiMac> sta_mac = DynamicCast<StaWifiMac>(wifi_staDev->GetMac());\n\n                    // std::cout << \"Sta: \" << staNodes.Get(x + i)->GetId() << \" AP: \" << i\n                    //           << std::endl;\n                    PacketSocketAddress socketAddr;\n                    socketAddr.SetSingleDevice(staDevices.Get((x + i))->GetIfIndex());\n                    socketAddr.SetPhysicalAddress(apDevices.Get(i)->GetAddress());\n                    socketAddr.SetProtocol(1);\n\n                    Ptr<PacketSocketClient> client = CreateObject<PacketSocketClient>();\n                    client->SetRemote(socketAddr);\n\n                    client->TraceConnectWithoutContext(\"Tx\", MakeCallback(&NotifyAppTx));\n\n                    staNodes.Get(x + i)->AddApplication(client);\n                    client->SetAttribute(\"PacketSize\", UintegerValue(pktSize));\n                    client->SetAttribute(\"MaxPackets\", UintegerValue(0));\n                    client->SetAttribute(\"Interval\", TimeValue(Time(MicroSeconds(pktInterval))));\n\n                    client->SetStartTime(Seconds(startTime->GetValue()));\n                    // std::cout << \"APP START: \" << start << std::endl;\n\n                    server->SetLocal(socketAddr);\n                    if (x == 0)\n                    {\n                        apNodes.Get(i)->AddApplication(server);\n                    }\n                }\n                else if (trafficType == \"bursty\")\n                {\n                    // Example of connecting to the trace sources\n                    burstSink->TraceConnectWithoutContext(\"BurstRx\", MakeCallback(&BurstRx));\n                    burstSink->TraceConnectWithoutContext(\"FragmentRx\", MakeCallback(&FragmentRx));\n                    burstyHelper.SetBurstGenerator(\n                        \"ns3::SimpleBurstGenerator\",\n                        \"PeriodRv\",\n                        StringValue(\"ns3::ConstantRandomVariable[Constant=5e-3]\"),\n                        \"BurstSizeRv\",\n                        StringValue(\"ns3::ConstantRandomVariable[Constant=25e3]\"));\n\n                    // Install bursty application\n                    ApplicationContainer staApps = burstyHelper.Install(staNodes.Get(i + x));\n                    Ptr<BurstyApplication> burstyApp =\n                        staApps.Get(0)->GetObject<BurstyApplication>();\n\n                    // Example of connecting to the trace sources\n                    burstyApp->TraceConnectWithoutContext(\"FragmentTx\", MakeCallback(&FragmentTx));\n                    burstyApp->TraceConnectWithoutContext(\"BurstTx\", MakeCallback(&BurstTx));\n                }\n                else if (trafficType == \"none\")\n                {\n                    continue;\n                }\n                else\n                {\n                    size_t pos = trafficType.find('-');\n                    traceFile = trafficType.substr(pos + 1);\n                    // std::cout << traceFile << std::endl;\n                    burstSink->TraceConnectWithoutContext(\"BurstRx\", MakeCallback(&BurstRx));\n                    burstSink->TraceConnectWithoutContext(\"FragmentRx\", MakeCallback(&FragmentRx));\n                    burstyHelper.SetBurstGenerator(\"ns3::TraceFileBurstGenerator\",\n                                                   \"TraceFile\",\n                                                   StringValue(traceFolder + traceFile),\n                                                   \"StartTime\",\n                                                   DoubleValue(startTime->GetValue()));\n\n                    // Install bursty application\n                    ApplicationContainer staApps = burstyHelper.Install(staNodes.Get(i + x));\n                    Ptr<BurstyApplication> burstyApp =\n                        staApps.Get(0)->GetObject<BurstyApplication>();\n\n                    // Extract TraceFileBurstGenerator and check if able to fill the entire\n                    // simulation\n                    PointerValue val;\n                    burstyApp->GetAttribute(\"BurstGenerator\", val);\n                    Ptr<TraceFileBurstGenerator> tfbg =\n                        DynamicCast<TraceFileBurstGenerator>(val.GetObject());\n                    NS_ASSERT_MSG(tfbg,\n                                  \"The bursty application should be a TraceFileBurstGenerator\");\n\n                    if (((10) + duration) > tfbg->GetTraceDuration())\n                    {\n                        NS_ABORT_MSG(\n                            \"The trace file will end before the simulation ends. Please choose \"\n                            \"a \"\n                            \"different start time, a longer trace, or reduce the simulation \"\n                            \"duration.\");\n                    }\n\n                    // Example of connecting to the trace sources\n                    burstyApp->TraceConnectWithoutContext(\"FragmentTx\", MakeCallback(&FragmentTx));\n                    burstyApp->TraceConnectWithoutContext(\"BurstTx\", MakeCallback(&BurstTx));\n                }\n            }\n        }\n    }\n    else\n    {\n        InternetStackHelper stack;\n        stack.Install(wifiNodes);\n\n        uint16_t portNumber = 50000;\n\n        Ipv4AddressHelper address;\n        address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n\n        Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n        Ipv4InterfaceContainer apInterfaces = address.Assign(apDevices);\n\n        Ptr<UniformRandomVariable> startTime = CreateObject<UniformRandomVariable>();\n\n        startTime->SetAttribute(\"Stream\", IntegerValue(0));\n        startTime->SetAttribute(\"Min\", DoubleValue(6));\n        startTime->SetAttribute(\"Max\", DoubleValue(8));\n\n        for (int i = 0; i < apNodeCount; i++)\n        {\n            Ipv4Address apAddress = apInterfaces.GetAddress(i);\n            // Create bursty application helper\n            BurstyHelper burstyHelper(\"ns3::UdpSocketFactory\",\n                                      InetSocketAddress(apAddress, portNumber));\n            burstyHelper.SetAttribute(\"FragmentSize\", UintegerValue(pktSize));\n\n            // Create burst sink helper\n            BurstSinkHelper burstSinkHelper(\"ns3::UdpSocketFactory\",\n                                            InetSocketAddress(apAddress, portNumber));\n\n            // Install burst sink\n            ApplicationContainer apApps = burstSinkHelper.Install(apNodes.Get(i));\n            Ptr<BurstSink> burstSink = apApps.Get(0)->GetObject<BurstSink>();\n\n            // Example of connecting to the trace sources\n            burstSink->TraceConnectWithoutContext(\"BurstRx\", MakeCallback(&BurstRx));\n            burstSink->TraceConnectWithoutContext(\"FragmentRx\", MakeCallback(&FragmentRx));\n            for (uint32_t x = 0; x < staNodes.GetN(); x += apNodeCount)\n            {\n                // Ipv4Address staAddress = staInterfaces.GetAddress(x + i); // 0.0.0.0\n                std::cout << \"Sta: \" << staNodes.Get(x + i)->GetId() << \" AP: \" << i << std::endl;\n                if (appType == \"bursty\")\n                {\n                    burstyHelper.SetBurstGenerator(\n                        \"ns3::SimpleBurstGenerator\",\n                        \"PeriodRv\",\n                        StringValue(\"ns3::ConstantRandomVariable[Constant=100e-3]\"),\n                        \"BurstSizeRv\",\n                        StringValue(\"ns3::ConstantRandomVariable[Constant=10e3]\"));\n                }\n                else if (appType == \"bursty-trace\")\n                {\n                    burstyHelper.SetBurstGenerator(\"ns3::TraceFileBurstGenerator\",\n                                                   \"TraceFile\",\n                                                   StringValue(traceFolder + traceFile),\n                                                   \"StartTime\",\n                                                   DoubleValue(startTime->GetValue()));\n                }\n                // Install bursty application\n                ApplicationContainer staApps = burstyHelper.Install(staNodes.Get(i + x));\n                Ptr<BurstyApplication> burstyApp = staApps.Get(0)->GetObject<BurstyApplication>();\n                if (appType == \"bursty-trace\")\n                {\n                    // Extract TraceFileBurstGenerator and check if able to fill the entire\n                    // simulation\n                    PointerValue val;\n                    burstyApp->GetAttribute(\"BurstGenerator\", val);\n                    Ptr<TraceFileBurstGenerator> tfbg =\n                        DynamicCast<TraceFileBurstGenerator>(val.GetObject());\n                    NS_ASSERT_MSG(tfbg,\n                                  \"The bursty application should be a TraceFileBurstGenerator\");\n\n                    if (((10) + duration) > tfbg->GetTraceDuration())\n                    {\n                        NS_ABORT_MSG(\n                            \"The trace file will end before the simulation ends. Please choose \"\n                            \"a \"\n                            \"different start time, a longer trace, or reduce the simulation \"\n                            \"duration.\");\n                    }\n                }\n                // Example of connecting to the trace sources\n                burstyApp->TraceConnectWithoutContext(\"FragmentTx\", MakeCallback(&FragmentTx));\n                burstyApp->TraceConnectWithoutContext(\"BurstTx\", MakeCallback(&BurstTx));\n\n                // Stop bursty app after simTimeSec\n                // staApps.Stop(Seconds(simTimeSec));\n            }\n        }\n    }\n\n    Simulator::Schedule(Seconds(0), &StartStatistics);\n    // populate m_staMacAddressToNodeId map\n    for (auto it = staDevices.Begin(); it != staDevices.End(); it++)\n    {\n        m_staMacAddressToNodeId[Mac48Address::ConvertFrom((*it)->GetAddress())] =\n            (*it)->GetNode()->GetId();\n    }\n    for (int i = 0; i < apNodeCount; ++i)\n    {\n        // Log packet receptions\n        std::string configPath = \"/NodeList/\" + std::to_string(apNodes.Get(i)->GetId()) +\n                                 \"/DeviceList/*/$ns3::WifiNetDevice/Phys/*/$ns3::WifiPhy/\"\n                                 \"MonitorSnifferRx\";\n        Config::Connect(configPath, MakeCallback(&TracePacketReception));\n\n        // Log packet drops\n        configPath = \"/NodeList/\" + std::to_string(apNodes.Get(i)->GetId()) +\n                     \"/DeviceList/*/$ns3::WifiNetDevice/Phys/*/$ns3::WifiPhy/\"\n                     \"PhyRxDrop\";\n        Config::Connect(configPath, MakeCallback(&PhyDrop));\n\n        // Log packet reception\n        configPath = \"/NodeList/\" + std::to_string(apNodes.Get(i)->GetId()) +\n                     \"/DeviceList/*/$ns3::WifiNetDevice/Phys/*/$ns3::WifiPhy/\"\n                     \"PhyRxEnd\";\n        Config::Connect(configPath, MakeCallback(&PhyEnd));\n    }\n    if (autoMCS)\n    {\n        Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/\"\n                        \"$ns3::AutoMcsWifiManager/Rate\",\n                        MakeCallback(&RateChange));\n    }\n    else\n    {\n        for (size_t i = 0; i < wifiNodes.GetN(); i++)\n        {\n            nodeMcs[wifiNodes.Get(i)->GetId()] = mcs;\n        }\n    }\n\n    // Trace CW evolution\n\n    Config::Connect(\n        \"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/$ns3::WifiMac/BE_Txop/CwTrace\",\n        MakeCallback(&CwTrace));\n    // Trace backoff evolution\n\n    Config::Connect(\n        \"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/$ns3::WifiMac/BE_Txop/BackoffTrace\",\n        MakeCallback(&BackoffTrace));\n\n    // Trace PHY Tx begin events\n    Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/PhyTxBegin\",\n                    MakeCallback(&NotifyPhyTxBegin));\n\n    // Trace PHY Tx end events\n    Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/PhyTxEnd\",\n                    MakeCallback(&PhyTxDoneTrace));\n\n    // Trace PHY Tx drop events\n    Config::Connect(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::WifiPhy/PhyTxDrop\",\n                    MakeCallback(&PhyTxDropTrace));\n\n    // // Trace CW evolution\n\n    // Config::Connect(\n    //     \"/NodeList/9/DeviceList/*/$ns3::WifiNetDevice/Mac/$ns3::WifiMac/BE_Txop/CwTrace\",\n    //     MakeCallback(&CwTrace));\n    // // Trace backoff evolution\n\n    // Config::Connect(\n    //     \"/NodeList/9/DeviceList/*/$ns3::WifiNetDevice/Mac/$ns3::WifiMac/BE_Txop/BackoffTrace\",\n    //     MakeCallback(&BackoffTrace));\n\n    // Simulator::Schedule(Seconds(10), &ChangeCcaSensitivity, 1, 1);\n    Simulator::Schedule(Seconds(10), &RestartIntervalThroughputHolDelay);\n    Simulator::Schedule(Seconds(1.5), &CheckAssociation);\n    Simulator::Schedule(Seconds(10), &RestartCalc);\n    //    Simulator::Schedule(Seconds(10), &TrackTime);\n    Simulator::Stop(Seconds((10) + duration));\n    Simulator::Run();\n\n    std::ostream& os = std::cout;\n\n    // for (auto it : nodeBackoff)\n    // {\n    //     double backoff = 0;\n    //     int count = 0;\n    //     for (auto value : it.second)\n    //     {\n    //         backoff += value;\n    //         count++;\n    //     }\n    //     os << \"Node\" << it.first << \"AVG Backoff: \" << backoff / count << std::endl;\n    // }\n\n    // for (auto it : nodeCw)\n    // {\n    //     double cwT = 0;\n    //     int count = 0;\n    //     for (auto value : it.second)\n    //     {\n    //         cwT += value;\n    //         count++;\n    //     }\n    //     os << \"Node\" << it.first << \"AVG ContentionWindow: \" << cwT / count << std::endl;\n    // }\n    // double cwT = 0;\n    // for (auto it : nodeCw)\n    // {\n    //     cwT += it;\n    // }\n    // os << \"Node9 CW: \" << cwT << std::endl;\n    // os << \"Node9 Backoff: \" << backoff << std::endl;\n\n    // backoff = 0;\n    // for (auto it : nodeBackoff[5])\n    // {\n    //     backoff += it;\n    // }\n    // cwT = 0;\n    // for (auto it : nodeBackoff[5])\n    // {\n    //     cwT += it;\n    // }\n    // os << \"Node5 CW: \" << cwT << std::endl;\n    // os << \"Node5 Backoff: \" << backoff << std::endl;\n\n    // for (auto& nodeEntry : nodePacketTxTime)\n    // {\n    //     uint32_t nodeID = nodeEntry.first;\n    //     std::map<uint64_t, std::vector<Time>>& eventMap = nodeEntry.second;\n\n    //     for (auto& eventEntry : eventMap)\n    //     {\n    //         uint64_t eventID = eventEntry.first;\n    //         std::vector<Time>& eventTimes = eventEntry.second;\n    //         std::vector<Time>& eventEndTimes = nodePacketTxEndTime[nodeID][eventID];\n    //         if ((eventTimes.size() != eventEndTimes.size()))\n    //         {\n    //             std::cout << \"diff amount of times \" << eventTimes.size() << \" and \"\n    //                       << eventEndTimes.size() << std::endl;\n    //             nodePacketTxEndTime[nodeID]->erase(eventID);\n    //             continue;\n    //         }\n    //         // for (size_t i = 0; i < eventTimes.size(); i++)\n    //         // {\n    //         //     std::cout << \"Packet: \" << eventID << \" Start: \" <<\n    //         eventTimes[i].GetSeconds()\n    //         //               << std::endl;\n    //         //     std::cout << \"Packet: \" << eventID << \" end: \" <<\n    //         eventEndTimes[i].GetSeconds()\n    //         //               << std::endl;\n    //         // }\n    //     }\n    // }\n\n    std::cout << \"\\n\" << std::endl;\n    if (calculateStats)\n    {\n        createPacketPairs();\n        overlappingPackets other;\n        int interBssCollissionsFails = 0;\n        int intraBssCollissionsFails = 0;\n        for (auto packet : packetOverlapList)\n        {\n            // Skip two entries that share everything except the interferer packet and\n            // interferer node. It is possible that the ifPacket are different but it is the same\n            // entry\n            if ((packet.nodeID == other.nodeID) && (packet.rxNodeID == other.rxNodeID) &&\n                (packet.packet == other.packet) && (packet.reason == other.reason) &&\n                (packet.phyDropTime == other.phyDropTime))\n            {\n                // std::cout << \"SKIP\" << std::endl;\n                // typeOverlapCount[packet.reason] += 1;\n                continue;\n            }\n            other = packet;\n            int bss1 = bssNode[packet.nodeID];\n            int bss2 = bssNode[packet.ifNodeID];\n            // std::cout << \"Tx Node BSS\" << bss1 << \" IF Node BSS\" << bss2 << std::endl;\n            if (bss1 != bss2)\n            {\n                interBssCollissionsFails++;\n            }\n            else\n            {\n                intraBssCollissionsFails++;\n            }\n            typeOverlapCount[packet.reason] += 1;\n            totalDropsByOverlap++;\n            // std::cout << \"Node \" << packet.nodeID << \" Tx to Node \" << packet.rxNodeID\n            //           << \" the packet \" << packet.packet << \" and it overlapped \" << packet.sync\n            //           << \" with packet \" << packet.ifPacket << \" from Node \" << packet.ifNodeID\n            //           << \"\\nCausing the first packet to drop due to \" << packet.reason\n            //           << \" at T= \" << packet.phyDropTime.GetSeconds() << \"\\n\"\n            //           << std::endl;\n        }\n        int sucessfullSimulTx = 0;\n        int interBssCollissionsSuccess = 0;\n        int intraBssCollissionsSuccess = 0;\n        overlappingPackets other2;\n        for (auto packet : packetOverlapSuccessList)\n        {\n            if ((packet.packet == other2.packet) && (packet.nodeID == other2.nodeID) &&\n                (packet.startTime == other2.startTime))\n            {\n                // std::cout << \"SKIP\" << std::endl;\n                // typeOverlapCount[packet.reason] += 1;\n                continue;\n            }\n            other2 = packet;\n            int bss1 = bssNode[packet.nodeID];\n            int bss2 = bssNode[packet.ifNodeID];\n            // std::cout << \"Tx Node BSS\" << bss1 << \" IF Node BSS\" << bss2 << std::endl;\n            if (bss1 != bss2)\n            {\n                interBssCollissionsSuccess++;\n            }\n            else\n            {\n                intraBssCollissionsSuccess++;\n\n                std::cout << \"Node \" << other2.nodeID << \" Tx the packet \" << other2.packet\n                          << \" and it overlapped \" << other2.sync << \" with packet \"\n                          << other2.ifPacket << \" from Node \" << other2.ifNodeID\n                          << \"\\n but the first packet did not get dropped\"\n                          << \".It was succesfully received at T= \"\n                          << other2.phyDropTime.GetSeconds() << \"\\n\"\n                          << std::endl;\n            }\n            // std::cout << \"Node \" << other.nodeID << \" Tx the packet \" << other.packet\n            //           << \" and it overlapped \" << other.sync << \" with packet \" << other.ifPacket\n            //           << \" from Node \" << other.ifNodeID\n            //           << \"\\n but the first packet did not get dropped \"\n            //           << \".It was succesfully received at T= \" << other.phyDropTime.GetSeconds()\n            //           << \"\\n\"\n            //           << std::endl;\n            sucessfullSimulTx++;\n        }\n\n        // int totalTx = 0;\n        // for (auto nodePacketTime : nodePacketTxTime)\n        // {\n        //     for (auto nodePacket : nodePacketTime.second)\n        //     {\n        //         totalTx += nodePacket.second.size();\n        //     }\n        // }\n\n        // for (auto packet : packetOverlapSuccessList)\n        // {\n        //     sucessfullSimulTx++;\n        // }\n\n        for (auto fails : typeFailCount)\n        {\n            std::cout << \"Failure Reason \" << fails.first << \" count \" << fails.second << std::endl;\n        }\n        //        int failedSimulTx = 0;\n        //        for (auto fails : typeOverlapCount)\n        //        {\n        //            failedSimulTx += fails.second;\n        //        }\n\n        for (auto fails : typeOverlapCount)\n        {\n            std::cout << \"\\nOverlap Reason \" << fails.first << \" \"\n                      << (fails.second * 100.0) / (totalDropsByOverlap + sucessfullSimulTx) << \"%\"\n                      << \" Count \" << fails.second << std::endl;\n            //            failedSimulTx += fails.second;\n        }\n        std::cout << \"Total Tx: \" << totalTx << std::endl;\n        std::cout << \"Total Simultaneus Tx: \" << totalDropsByOverlap + sucessfullSimulTx << \" \"\n                  << ((totalDropsByOverlap + sucessfullSimulTx) * 100) / totalTx << \"%\"\n                  << std::endl;\n        std::cout << \"Total Succesful Simultaneus Tx: \" << sucessfullSimulTx << std::endl;\n        std::cout << \"Total Failed Simultaneus Tx: \" << totalDropsByOverlap << \" \"\n                  << (totalDropsByOverlap * 100.0) / (totalDropsByOverlap + sucessfullSimulTx)\n                  << \"%\" << std::endl;\n\n        std::cout << \"Succesfull \\nIntraBss Collisions: \" << intraBssCollissionsSuccess << \" \"\n                  << (intraBssCollissionsSuccess * 100.0) /\n                         (totalDropsByOverlap + sucessfullSimulTx)\n                  << \"%\"\n                  << \"\\nInterBss Collisions: \" << interBssCollissionsSuccess << \" \"\n                  << (interBssCollissionsSuccess * 100.0) /\n                         (totalDropsByOverlap + sucessfullSimulTx)\n                  << \"%\" << std::endl;\n\n        // std::cout << \"Succesfull \\nIntraBss Collisions: \"\n        //           << (intraBssCollissionsSuccess * 100) / (totalDropsByOverlap +\n        //           sucessfullSimulTx)\n        //           << \"\\nInterBss Collisions: \"\n        //           << (interBssCollissionsSuccess * 100) / (totalDropsByOverlap +\n        //           sucessfullSimulTx)\n        //           << std::endl;\n        // std::cout << \"Succesfull \\nIntraBss Collisions: \"\n        //           << (intraBssCollissionsSuccess * 100) / (totalDropsByOverlap +\n        //           sucessfullSimulTx)\n        //           << \"\\nInterBss Collisions: \"\n        //           << (interBssCollissionsSuccess * 100) / (totalDropsByOverlap +\n        //           sucessfullSimulTx)\n        //           << std::endl;\n        std::cout << \"Failures \\nIntraBss Collisions: \" << intraBssCollissionsFails\n                  << \"\\nInterBss Collisions: \" << interBssCollissionsFails << std::endl;\n    }\n    std::cout << \"\\n\" << std::endl;\n    double throughput = 0;\n    double rPackets = 0;\n\n    // for (auto nodePacketTime : nodePacketTxTime)\n    // {\n    //     for (auto packetTime : nodePacketTime.second)\n    //     {\n    //         double startT = 0;\n    //         double endT = 0;\n\n    //         for (auto t : packetTime.second)\n    //         {\n    //             if (startT == 0)\n    //             {\n    //                 startT = t.GetSeconds();\n    //             }\n    //             else\n    //             {\n    //                 endT = t.GetSeconds();\n    //             }\n    //             // std::cout << \"packet \" << packetTime.first << \" times: \" << t <<\n    //             std::endl; if (endT != 0)\n    //             {\n    //                 std::cout << \"Node \" << nodePacketTime.first << \" packet \" <<\n    //                 packetTime.first\n    //                           << \" start: \" << startT << \" end: \" << endT << std::endl;\n    //             }\n    //         }\n\n    //         if (endT == 0)\n    //         {\n    //             nodePacketTime.second.erase(packetTime.first);\n    //         }\n    //     }\n    // }\n\n    for (auto it = timeFirstReceived.begin(); it != timeFirstReceived.end(); it++)\n    {\n        Time first = it->second;\n        Time last = timeLastReceived.find(it->first)->second;\n        Time dataTransferDuration = last - first;\n        if (dataTransferDuration.GetSeconds() <= 0)\n        {\n            os << \"Link \" << MacAddressToNodeId(it->first) << \" Throughput: 0\" << std::endl;\n            continue;\n        }\n        double node_thru = (bytesReceived.find(it->first)->second * 8) /\n                           static_cast<double>(dataTransferDuration.GetMicroSeconds());\n        rPackets += packetsReceived.find(it->first)->second;\n\n        throughput += node_thru;\n\n        os << \"Node \" << MacAddressToNodeId(it->first) << \" Aggregated Throughput: \" << node_thru\n           << std::endl;\n    }\n    // std::cout << \"percentage lost: \" << ((rPackets + drops) / (drops * 100))\n    // << std::endl;\n    os << \"MCS value\"\n       << \"\\t\\t\"\n       << \"Channel width\"\n       << \"\\t\\t\"\n       << \"GI\"\n       << \"\\t\\t\\t\"\n       << \"Throughput\" << '\\n';\n    os << mcs << \"\\t\\t\\t\" << channelWidth << \" MHz\\t\\t\\t\" << gi << \" ns\\t\\t\\t\" << throughput\n       << \" Mbit/s\" << std::endl;\n    // Create a csv file to store the results\n    std::ofstream out;\n    out.open(\"results.csv\", std::ios::trunc);\n    out << \"srcNodeId,\"\n        << \"pktSize,\"\n        << \"lastPacketTime,\"\n        << \"dequeueTime,\"\n        << \"HOL,\"\n        << \"queuingDelay,\"\n        << \"accessDelay,\"\n        << \"txDelay\"\n        << \"\\n\";\n\n    for (auto mapIt : m_inFlightPacketMap)\n    {\n        for (auto listIt : mapIt.second)\n        {\n            if (listIt.m_dequeued)\n            {\n                uint32_t srcNodeId = MacAddressToNodeId(listIt.m_srcAddress);\n                out << srcNodeId << \",\" << listIt.m_ptrToPacket->GetSize() << \",\"\n                    << listIt.m_HoLTime << \",\" << listIt.m_edcaDequeueTime << \",\"\n                    << (listIt.m_edcaDequeueTime - listIt.m_HoLTime).ToDouble(Time::MS) << \",\"\n                    << (listIt.m_HoLTime - listIt.m_edcaEnqueueTime).ToDouble(Time::MS) << \",\"\n                    << (listIt.m_phyTxTime - listIt.m_HoLTime).ToDouble(Time::MS) << \",\"\n                    << (listIt.m_edcaDequeueTime - listIt.m_phyTxTime).ToDouble(Time::MS) << \",\"\n                    << std::endl;\n            }\n        }\n    }\n\n    for (auto it : edcaHolSample)\n    {\n        uint32_t srcNodeId = it.first;\n        double sum1 = 0;\n        double sum2 = 0;\n        double sum3 = 0;\n        double sum4 = 0;\n\n        for (double i = 0; i < it.second.size(); i += 4)\n        {\n            sum1 += it.second[i];\n            sum2 += it.second[i + 1];\n            sum3 += it.second[i + 2];\n            sum4 += it.second[i + 3];\n        }\n\n        os << \"NodeID: \" << srcNodeId << \" \\n Average HoLd: \" << sum1 / (it.second.size() / 4)\n           << \"ms\"\n           << \" \\n Average Queuing Delay: \" << sum2 / (it.second.size() / 4) << \"ms\"\n           << \" \\n Average Access Delay: \" << sum3 / (it.second.size() / 4) << \"ms\"\n           << \" \\n Average Tx Delay: \" << sum4 / (it.second.size() / 4) << \"ms\" << std::endl;\n        // os << \"Size: \" << it.second.size() << \"\\n\";\n    }\n    os << \"\\n\";\n    out.close();\n    std::cout << \"PHYDROPs: \" << drops << std::endl;\n    std::cout << \"PHYDROP counted as overlap: \" << totalDropsByOverlap << std::endl;\n    std::cout << \"ReceivedPackets: \" << rPackets << std::endl;\n    std::cout << \"AppReceivedPackets: \" << appTxrec << std::endl;\n    // std::cout << \"PHY Receives: \" << receives << std::endl;\n\n    out.open(\"test.csv\", std::ios::app);\n    // out << \"phyMode,ccaSensitivity,throughput\" << std::endl;\n    out << phyMode << \",\" << ccaSensitivity << \",\" << throughput << std::endl;\n    out.close();\n    std::cout << \"Aggregated Throughput: \" << throughput << std::endl;\n    if (deassociatedStas > 0)\n    {\n        NS_ABORT_MSG(\"There was a station dessasociated\");\n    }\n    //    if (drlCca)\n    //    {\n    //        rlAlgo.SetFinish();\n    //    }\n    PrintPythonPlotCSV(\"box.csv\");\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/multi-bss/tgax-residential-propagation-loss-model.cc",
      "code": "/*\n * Copyright (c) 2023 University of Washington\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"tgax-residential-propagation-loss-model.h\"\n\n#include \"ns3/double.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/pointer.h\"\n#include <ns3/mobility-building-info.h>\n\n#include <cmath>\n\nnamespace ns3\n{\n\nNS_LOG_COMPONENT_DEFINE(\"TgaxResidentialPropagationLossModel\");\n\nNS_OBJECT_ENSURE_REGISTERED(TgaxResidentialPropagationLossModel);\n\nTypeId\nTgaxResidentialPropagationLossModel::GetTypeId()\n{\n    static TypeId tid =\n        TypeId(\"ns3::TgaxResidentialPropagationLossModel\")\n            .SetParent<PropagationLossModel>()\n            .SetGroupName(\"Wifi\")\n            .AddConstructor<TgaxResidentialPropagationLossModel>()\n            .AddAttribute(\"Frequency\",\n                          \"The carrier frequency (in Hz) at which propagation occurs\",\n                          DoubleValue(2.437e9),\n                          MakeDoubleAccessor(&TgaxResidentialPropagationLossModel::m_frequencyHz),\n                          MakeDoubleChecker<double>())\n            .AddAttribute(\n                \"ShadowSigma\",\n                \"Standard deviation (dB) of the normal distribution used to calculate shadowing \"\n                \"loss\",\n                DoubleValue(5.0),\n                MakeDoubleAccessor(&TgaxResidentialPropagationLossModel::m_shadowingSigma),\n                MakeDoubleChecker<double>());\n    return tid;\n}\n\nTgaxResidentialPropagationLossModel::TgaxResidentialPropagationLossModel()\n{\n    m_shadowingRandomVariable = CreateObject<NormalRandomVariable>();\n}\n\ndouble\nTgaxResidentialPropagationLossModel::GetRxPower(double txPowerDbm,\n                                                Ptr<MobilityModel> a,\n                                                Ptr<MobilityModel> b) const\n{\n    double distance = a->GetDistanceFrom(b);\n\n    if (distance == 0)\n    {\n        return txPowerDbm;\n    }\n\n    distance = std::max(1.0, distance); // 1m minimum distance\n    //\n    // Based on the IEEE 802.11-14/0980r6 document, 1 - Residential Scenario\n    //\n    //     PL(d) = 40.05 + 20 * log10(fc/2.4) + 20 * log10(min(d,5)) +\n    //             18.3 * (d/floors)^(((d/floors)+2)/((d/floors)+1) - 0.46) + 5 * (d/walls)\n    //\n    //  if d>5 then\n    //     PL(d) += 35 * log10(d/5)\n    //\n\n    double pathlossDb;\n    //    double shadowingDb = 0;\n    double breakpointDistance = 5; // meters\n    double fc = 2.4e9;             // carrier frequency, Hz\n    uint16_t floors = 0;\n    uint16_t walls = 0;\n    Ptr<MobilityBuildingInfo> aInfo = a->GetObject<MobilityBuildingInfo>();\n    Ptr<MobilityBuildingInfo> bInfo = b->GetObject<MobilityBuildingInfo>();\n    if (aInfo && bInfo)\n    {\n        if (!aInfo->IsIndoor() || !bInfo->IsIndoor())\n        {\n            NS_LOG_DEBUG(\"One or both nodes is outdoor, so returning zero signal power\");\n            return 0;\n        }\n        floors = std::abs(aInfo->GetFloorNumber() - bInfo->GetFloorNumber());\n        walls = std::abs(aInfo->GetRoomNumberX() - bInfo->GetRoomNumberX()) +\n                std::abs(aInfo->GetRoomNumberY() - bInfo->GetRoomNumberY());\n    }\n\n    pathlossDb = 40.05 + 20 * std::log10(m_frequencyHz / fc) +\n                 20 * std::log10(std::min(distance, breakpointDistance));\n    if (distance > breakpointDistance)\n    {\n        pathlossDb += 35 * std::log10(distance / 5);\n    }\n    if (floors)\n    {\n        pathlossDb +=\n            18.3 * std::pow((distance / floors),\n                            ((distance / floors) + 2.0) / ((distance / floors) + 1.0) - 0.46);\n    }\n    if (walls)\n    {\n        pathlossDb += 5.0 * (walls); // Changed (distance/walls) to only (walls) because the\n                                     // pathloss would isolate the rooms\n    }\n\n    // TODO:  cache the shadowingDb value and reuse until positions change\n    //    shadowingDb = m_shadowingRandomVariable->GetValue(\n    //        0,\n    //        m_shadowingSigma * m_shadowingSigma); // Disabled shadowing because nodes do not move\n    // std::cout << \"Distance \" << distance << \" Pathloss \" << pathlossDb << \" Floor \" << floors\n    //           << \" walls \" << walls << std::endl;\n    return txPowerDbm - pathlossDb;\n    // -shadowingDb;\n}\n\ndouble\nTgaxResidentialPropagationLossModel::DoCalcRxPower(double txPowerDbm,\n                                                   Ptr<MobilityModel> a,\n                                                   Ptr<MobilityModel> b) const\n{\n    double distance = a->GetDistanceFrom(b);\n\n    if (distance == 0)\n    {\n        return txPowerDbm;\n    }\n\n    distance = std::max(1.0, distance); // 1m minimum distance\n    //\n    // Based on the IEEE 802.11-14/0980r6 document, 1 - Residential Scenario\n    //\n    //     PL(d) = 40.05 + 20 * log10(fc/2.4) + 20 * log10(min(d,5)) +\n    //             18.3 * (d/floors)^(((d/floors)+2)/((d/floors)+1) - 0.46) + 5 * (d/walls)\n    //\n    //  if d>5 then\n    //     PL(d) += 35 * log10(d/5)\n    //\n\n    double pathlossDb;\n    //    double shadowingDb = 0;\n    double breakpointDistance = 5; // meters\n    double fc = 2.4e9;             // carrier frequency, Hz\n    uint16_t floors = 0;\n    uint16_t walls = 0;\n    Ptr<MobilityBuildingInfo> aInfo = a->GetObject<MobilityBuildingInfo>();\n    Ptr<MobilityBuildingInfo> bInfo = b->GetObject<MobilityBuildingInfo>();\n    if (aInfo && bInfo)\n    {\n        if (!aInfo->IsIndoor() || !bInfo->IsIndoor())\n        {\n            NS_LOG_DEBUG(\"One or both nodes is outdoor, so returning zero signal power\");\n            return 0;\n        }\n        floors = std::abs(aInfo->GetFloorNumber() - bInfo->GetFloorNumber());\n        walls = std::abs(aInfo->GetRoomNumberX() - bInfo->GetRoomNumberX()) +\n                std::abs(aInfo->GetRoomNumberY() - bInfo->GetRoomNumberY());\n    }\n\n    pathlossDb = 40.05 + 20 * std::log10(m_frequencyHz / fc) +\n                 20 * std::log10(std::min(distance, breakpointDistance));\n    if (distance > breakpointDistance)\n    {\n        pathlossDb += 35 * std::log10(distance / 5);\n    }\n    if (floors)\n    {\n        pathlossDb +=\n            18.3 * std::pow((distance / floors),\n                            ((distance / floors) + 2.0) / ((distance / floors) + 1.0) - 0.46);\n    }\n    if (walls)\n    {\n        pathlossDb += 5.0 * (walls); // Changed (distance/walls) to only (walls) because the\n                                     // pathloss would isolate the rooms\n    }\n\n    // TODO:  cache the shadowingDb value and reuse until positions change\n    //    shadowingDb = m_shadowingRandomVariable->GetValue(0, m_shadowingSigma * m_shadowingSigma);\n    //    // std::cout << \"Distance \" << distance << \" Pathloss \" << pathlossDb << \" Floor \" <<\n    //    floors\n    //    //           << \" walls \" << walls << std::endl;\n    return txPowerDbm - pathlossDb;\n}\n\nint64_t\nTgaxResidentialPropagationLossModel::DoAssignStreams(int64_t stream)\n{\n    m_shadowingRandomVariable->SetStream(stream);\n    return 1;\n}\n\n} // namespace ns3\n"
    },
    {
      "file_path": "examples/multi-bss/vr-app/examples/bursty-application-example.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2021 SIGNET Lab, Department of Information Engineering,\n * University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/burst-sink-helper.h\"\n#include \"ns3/bursty-helper.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/seq-ts-size-frag-header.h\"\n\n/**\n * An example of how the BurstyApplication works.\n * Traces for RX/TX fragments/bursts are extracted as well as the setup of\n * a BurstyApplication with a SimpleBurstGenerator.\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BurstyApplicationExample\");\n\nstd::string\nAddressToString(const Address& addr)\n{\n    std::stringstream addressStr;\n    addressStr << InetSocketAddress::ConvertFrom(addr).GetIpv4() << \":\"\n               << InetSocketAddress::ConvertFrom(addr).GetPort();\n    return addressStr.str();\n}\n\nvoid\nFragmentTx(Ptr<const Packet> fragment,\n           const Address& from,\n           const Address& to,\n           const SeqTsSizeFragHeader& header)\n{\n    NS_LOG_INFO(\"Sent fragment \" << header.GetFragSeq() << \"/\" << header.GetFrags()\n                                 << \" of burst seq=\" << header.GetSeq()\n                                 << \" of header.GetSize ()=\" << header.GetSize()\n                                 << \" (fragment->GetSize ()=\" << fragment->GetSize()\n                                 << \") bytes from \" << AddressToString(from) << \" to \"\n                                 << AddressToString(to) << \" at \" << header.GetTs().As(Time::S));\n}\n\nvoid\nFragmentRx(Ptr<const Packet> fragment,\n           const Address& from,\n           const Address& to,\n           const SeqTsSizeFragHeader& header)\n{\n    NS_LOG_INFO(\"Received fragment \"\n                << header.GetFragSeq() << \"/\" << header.GetFrags() << \" of burst seq=\"\n                << header.GetSeq() << \" of header.GetSize ()=\" << header.GetSize()\n                << \" (fragment->GetSize ()=\" << fragment->GetSize() << \") bytes from \"\n                << AddressToString(from) << \" to \" << AddressToString(to) << \" at \"\n                << header.GetTs().As(Time::S));\n}\n\nvoid\nBurstTx(Ptr<const Packet> burst,\n        const Address& from,\n        const Address& to,\n        const SeqTsSizeFragHeader& header)\n{\n    NS_LOG_INFO(\"Sent burst seq=\" << header.GetSeq() << \" of header.GetSize ()=\" << header.GetSize()\n                                  << \" (burst->GetSize ()=\" << burst->GetSize() << \") bytes from \"\n                                  << AddressToString(from) << \" to \" << AddressToString(to)\n                                  << \" at \" << header.GetTs().As(Time::S));\n}\n\nvoid\nBurstRx(Ptr<const Packet> burst,\n        const Address& from,\n        const Address& to,\n        const SeqTsSizeFragHeader& header)\n{\n    NS_LOG_INFO(\"Received burst seq=\"\n                << header.GetSeq() << \" of header.GetSize ()=\" << header.GetSize()\n                << \" (burst->GetSize ()=\" << burst->GetSize() << \") bytes from \"\n                << AddressToString(from) << \" to \" << AddressToString(to) << \" at \"\n                << header.GetTs().As(Time::S));\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double simTimeSec = 10;\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"SimulationTime\", \"Length of simulation in seconds.\", simTimeSec);\n    cmd.Parse(argc, argv);\n\n    Time::SetResolution(Time::NS);\n    LogComponentEnableAll(LOG_PREFIX_TIME);\n    LogComponentEnable(\"BurstyApplicationExample\", LOG_INFO);\n\n    // Setup two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    uint16_t portNumber = 50000;\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    Ipv4Address serverAddress = interfaces.GetAddress(0);\n    Ipv4Address sinkAddress = Ipv4Address::GetAny(); // 0.0.0.0\n\n    // Create bursty application helper\n    BurstyHelper burstyHelper(\"ns3::UdpSocketFactory\",\n                              InetSocketAddress(serverAddress, portNumber));\n    burstyHelper.SetAttribute(\"FragmentSize\", UintegerValue(1200));\n    burstyHelper.SetBurstGenerator(\"ns3::SimpleBurstGenerator\",\n                                   \"PeriodRv\",\n                                   StringValue(\"ns3::ConstantRandomVariable[Constant=100e-3]\"),\n                                   \"BurstSizeRv\",\n                                   StringValue(\"ns3::ConstantRandomVariable[Constant=10e3]\"));\n\n    // Install bursty application\n    ApplicationContainer serverApps = burstyHelper.Install(nodes.Get(1));\n    Ptr<BurstyApplication> burstyApp = serverApps.Get(0)->GetObject<BurstyApplication>();\n\n    // Example of connecting to the trace sources\n    burstyApp->TraceConnectWithoutContext(\"FragmentTx\", MakeCallback(&FragmentTx));\n    burstyApp->TraceConnectWithoutContext(\"BurstTx\", MakeCallback(&BurstTx));\n\n    // Create burst sink helper\n    BurstSinkHelper burstSinkHelper(\"ns3::UdpSocketFactory\",\n                                    InetSocketAddress(sinkAddress, portNumber));\n\n    // Install burst sink\n    ApplicationContainer clientApps = burstSinkHelper.Install(nodes.Get(0));\n    Ptr<BurstSink> burstSink = clientApps.Get(0)->GetObject<BurstSink>();\n\n    // Example of connecting to the trace sources\n    burstSink->TraceConnectWithoutContext(\"BurstRx\", MakeCallback(&BurstRx));\n    burstSink->TraceConnectWithoutContext(\"FragmentRx\", MakeCallback(&FragmentRx));\n\n    // Stop bursty app after simTimeSec\n    serverApps.Stop(Seconds(simTimeSec));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    // Stats\n    std::cout << \"Total RX bursts: \" << burstyApp->GetTotalTxBursts() << \"/\"\n              << burstSink->GetTotalRxBursts() << std::endl;\n    std::cout << \"Total RX fragments: \" << burstyApp->GetTotalTxFragments() << \"/\"\n              << burstSink->GetTotalRxFragments() << std::endl;\n    std::cout << \"Total RX bytes: \" << burstyApp->GetTotalTxBytes() << \"/\"\n              << burstSink->GetTotalRxBytes() << std::endl;\n\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/multi-bss/vr-app/examples/sample-mixture-random-variable.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2021 SIGNET Lab, Department of Information Engineering,\n * University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n#include \"ns3/command-line.h\"\n#include \"ns3/double.h\"\n#include \"ns3/my-random-variable-stream.h\"\n#include \"ns3/nstime.h\"\n#include \"ns3/object-factory.h\"\n#include \"ns3/random-variable-stream.h\"\n#include \"ns3/simulator.h\"\n\n#include <iostream>\n#include <vector>\n\n/**\n * \\file\n * \\ingroup core-examples\n * \\ingroup randomvariable\n * Example program illustrating use of ns3::MixtureRandomVariable\n */\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t nSamples = 1000000;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nSamples\", \"Number of samples\", nSamples);\n    cmd.Parse(argc, argv);\n\n    Ptr<MixtureRandomVariable> x = CreateObject<MixtureRandomVariable>();\n\n    // setup weights cdf\n    std::vector<double> w{0.7, 1.0}; // p1 = 0.7, p2 = 0.3\n    // setup random variables\n    std::vector<Ptr<RandomVariableStream>> rvs;\n    rvs.push_back(CreateObjectWithAttributes<NormalRandomVariable>(\"Mean\",\n                                                                   DoubleValue(5),\n                                                                   \"Variance\",\n                                                                   DoubleValue(1)));\n    rvs.push_back(CreateObjectWithAttributes<NormalRandomVariable>(\"Mean\",\n                                                                   DoubleValue(10),\n                                                                   \"Variance\",\n                                                                   DoubleValue(4)));\n\n    x->SetRvs(w, rvs);\n\n    for (uint32_t i = 0; i < nSamples; i++)\n    {\n        std::cout << x->GetValue() << std::endl;\n    }\n\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/multi-bss/vr-app/examples/stats-calculator-example.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2021 SIGNET Lab, Department of Information Engineering,\n * University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/burst-sink-helper.h\"\n#include \"ns3/bursty-app-stats-calculator.h\"\n#include \"ns3/bursty-helper.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/seq-ts-size-frag-header.h\"\n\n/**\n * An example on how to use the BurstyAppStatsCalculator.\n * Example based on bursty-application-example.\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BurstyApplicationExample\");\n\nstd::string\nAddressToString(const Address& addr)\n{\n    std::stringstream addressStr;\n    addressStr << InetSocketAddress::ConvertFrom(addr).GetIpv4() << \":\"\n               << InetSocketAddress::ConvertFrom(addr).GetPort();\n    return addressStr.str();\n}\n\nvoid\nBurstTx(uint32_t nodeId,\n        Ptr<BurstyAppStatsCalculator> statsCalculator,\n        Ptr<const Packet> burst,\n        const Address& from,\n        const Address& to,\n        const SeqTsSizeFragHeader& header)\n{\n    NS_LOG_INFO(\"Sent burst seq=\" << header.GetSeq() << \" of header.GetSize ()=\" << header.GetSize()\n                                  << \" (burst->GetSize ()=\" << burst->GetSize() << \") bytes from \"\n                                  << AddressToString(from) << \" to \" << AddressToString(to)\n                                  << \" at \" << header.GetTs().As(Time::S));\n    statsCalculator->TxBurst(nodeId, burst, from, to, header);\n}\n\nvoid\nBurstRx(uint32_t nodeId,\n        Ptr<BurstyAppStatsCalculator> statsCalculator,\n        Ptr<const Packet> burst,\n        const Address& from,\n        const Address& to,\n        const SeqTsSizeFragHeader& header)\n{\n    NS_LOG_INFO(\"Received burst seq=\"\n                << header.GetSeq() << \" of header.GetSize ()=\" << header.GetSize()\n                << \" (burst->GetSize ()=\" << burst->GetSize() << \") bytes from \"\n                << AddressToString(from) << \" to \" << AddressToString(to) << \" at \"\n                << header.GetTs().As(Time::S));\n\n    statsCalculator->RxBurst(nodeId, burst, from, to, header);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double simTimeSec = 10;\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"SimulationTime\", \"Length of simulation in seconds.\", simTimeSec);\n    cmd.Parse(argc, argv);\n\n    Time::SetResolution(Time::NS);\n    LogComponentEnableAll(LOG_PREFIX_TIME);\n    LogComponentEnable(\"BurstyApplicationExample\", LOG_INFO);\n\n    Config::SetDefault(\"ns3::BurstyAppStatsCalculator::EpochDuration\", TimeValue(Seconds(0.1)));\n    Config::SetDefault(\"ns3::BurstyAppStatsCalculator::WriteToFile\", BooleanValue(true));\n\n    // Setup two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    uint16_t portNumber = 50000;\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    Ipv4Address serverAddress = interfaces.GetAddress(0);\n    Ipv4Address sinkAddress = Ipv4Address::GetAny(); // 0.0.0.0\n\n    // Create bursty application helper\n    BurstyHelper burstyHelper(\"ns3::UdpSocketFactory\",\n                              InetSocketAddress(serverAddress, portNumber));\n    burstyHelper.SetAttribute(\"FragmentSize\", UintegerValue(1200));\n    burstyHelper.SetBurstGenerator(\"ns3::SimpleBurstGenerator\",\n                                   \"PeriodRv\",\n                                   StringValue(\"ns3::ConstantRandomVariable[Constant=100e-3]\"),\n                                   \"BurstSizeRv\",\n                                   StringValue(\"ns3::ConstantRandomVariable[Constant=10e3]\"));\n\n    // Install bursty application\n    ApplicationContainer serverApps = burstyHelper.Install(nodes.Get(1));\n    Ptr<BurstyApplication> burstyApp = serverApps.Get(0)->GetObject<BurstyApplication>();\n    Ptr<BurstyAppStatsCalculator> statsCalculator = CreateObject<BurstyAppStatsCalculator>();\n\n    // Example of connecting to the trace sources\n    burstyApp->TraceConnectWithoutContext(\n        \"BurstTx\",\n        MakeBoundCallback(&BurstTx, nodes.Get(1)->GetId(), statsCalculator));\n\n    // Create burst sink helper\n    BurstSinkHelper burstSinkHelper(\"ns3::UdpSocketFactory\",\n                                    InetSocketAddress(sinkAddress, portNumber));\n\n    // Install burst sink\n    ApplicationContainer clientApps = burstSinkHelper.Install(nodes.Get(0));\n    Ptr<BurstSink> burstSink = clientApps.Get(0)->GetObject<BurstSink>();\n\n    // Example of connecting to the trace sources\n    burstSink->TraceConnectWithoutContext(\n        \"BurstRx\",\n        MakeBoundCallback(&BurstRx, nodes.Get(0)->GetId(), statsCalculator));\n\n    // Stop bursty app after simTimeSec\n    serverApps.Stop(Seconds(simTimeSec));\n    Simulator::Stop(Seconds(simTimeSec));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    // Stats\n    std::cout << \"Total RX bursts: \" << burstyApp->GetTotalTxBursts() << \"/\"\n              << burstSink->GetTotalRxBursts() << std::endl;\n    std::cout << \"Total RX fragments: \" << burstyApp->GetTotalTxFragments() << \"/\"\n              << burstSink->GetTotalRxFragments() << std::endl;\n    std::cout << \"Total RX bytes: \" << burstyApp->GetTotalTxBytes() << \"/\"\n              << burstSink->GetTotalRxBytes() << std::endl;\n\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/multi-bss/vr-app/examples/trace-file-burst-application-example.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2021 SIGNET Lab, Department of Information Engineering,\n * University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/burst-sink-helper.h\"\n#include \"ns3/bursty-helper.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/seq-ts-size-frag-header.h\"\n#include \"ns3/trace-file-burst-generator.h\"\n\n#include <iomanip>\n\n/**\n * Example of BurstyApplication using a TraceFileBurstGenerator.\n * Some example traces are provided, obtained from a real VR source.\n * Please read the reference paper for further information (see README.md).\n */\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BurstyApplicationExample\");\n\nstd::string\nAddressToString(const Address& addr)\n{\n    std::stringstream addressStr;\n    addressStr << InetSocketAddress::ConvertFrom(addr).GetIpv4() << \":\"\n               << InetSocketAddress::ConvertFrom(addr).GetPort();\n    return addressStr.str();\n}\n\nvoid\nBurstRx(Ptr<const Packet> burst,\n        const Address& from,\n        const Address& to,\n        const SeqTsSizeFragHeader& header)\n{\n    NS_LOG_INFO(\"Received burst seq=\" << header.GetSeq() << \" of \" << header.GetSize()\n                                      << \" bytes transmitted at \" << std::setprecision(9)\n                                      << header.GetTs().As(Time::S));\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string traceFolder = \"./BurstGeneratorTraces/\"; // example traces can be found here\n    std::string traceFile = \"ge_cities_20mbps_30fps.csv\";\n    double startTime = 0;\n    double simTime = 20;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"traceFolder\", \"The folder containing the trace.\", traceFolder);\n    cmd.AddValue(\"traceFile\", \"The trace file name.\", traceFile);\n    cmd.AddValue(\"startTime\", \"The start time offset of the trace [s].\", startTime);\n    cmd.AddValue(\"simTime\", \"Length of simulation [s].\", simTime);\n    cmd.Parse(argc, argv);\n\n    Time::SetResolution(Time::NS);\n    LogComponentEnableAll(LOG_PREFIX_TIME);\n    LogComponentEnable(\"BurstyApplicationExample\", LOG_INFO);\n\n    // Setup two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    uint16_t portNumber = 50000;\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    Ipv4Address serverAddress = interfaces.GetAddress(0);\n    Ipv4Address sinkAddress = Ipv4Address::GetAny(); // 0.0.0.0\n\n    // Create bursty application helper\n    BurstyHelper burstyHelper(\"ns3::UdpSocketFactory\",\n                              InetSocketAddress(serverAddress, portNumber));\n    burstyHelper.SetAttribute(\"FragmentSize\", UintegerValue(1200));\n    burstyHelper.SetBurstGenerator(\"ns3::TraceFileBurstGenerator\",\n                                   \"TraceFile\",\n                                   StringValue(traceFolder + traceFile),\n                                   \"StartTime\",\n                                   DoubleValue(startTime));\n\n    // Install bursty application\n    ApplicationContainer serverApps = burstyHelper.Install(nodes.Get(1));\n    Ptr<BurstyApplication> burstyApp = serverApps.Get(0)->GetObject<BurstyApplication>();\n\n    // Extract TraceFileBurstGenerator and check if able to fill the entire simulation\n    PointerValue val;\n    burstyApp->GetAttribute(\"BurstGenerator\", val);\n    Ptr<TraceFileBurstGenerator> tfbg = DynamicCast<TraceFileBurstGenerator>(val.GetObject());\n    NS_ASSERT_MSG(tfbg, \"The bursty application should be a TraceFileBurstGenerator\");\n\n    if (startTime + simTime > tfbg->GetTraceDuration())\n    {\n        NS_LOG_WARN(\"The trace file will end before the simulation ends. Please choose a different \"\n                    << \"start time, a longer trace, or reduce the simulation duration.\");\n    }\n\n    // Create burst sink helper\n    BurstSinkHelper burstSinkHelper(\"ns3::UdpSocketFactory\",\n                                    InetSocketAddress(sinkAddress, portNumber));\n\n    // Install HTTP client\n    ApplicationContainer clientApps = burstSinkHelper.Install(nodes.Get(0));\n    Ptr<BurstSink> burstSink = clientApps.Get(0)->GetObject<BurstSink>();\n\n    // Example of connecting to the trace sources\n    burstSink->TraceConnectWithoutContext(\"BurstRx\", MakeCallback(&BurstRx));\n\n    // TraceFileBurstGenerator stops automatically, but we add an early stop to make the example\n    // quicker\n    serverApps.Stop(Seconds(simTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    // Stats\n    std::cout << \"Total RX bursts: \" << burstyApp->GetTotalTxBursts() << \"/\"\n              << burstSink->GetTotalRxBursts() << std::endl;\n    std::cout << \"Total RX fragments: \" << burstyApp->GetTotalTxFragments() << \"/\"\n              << burstSink->GetTotalRxFragments() << std::endl;\n    std::cout << \"Total RX bytes: \" << burstyApp->GetTotalTxBytes() << \"/\"\n              << burstSink->GetTotalRxBytes() << std::endl;\n\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/multi-bss/vr-app/examples/vr-app-n-stas.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2021 SIGNET Lab, Department of Information Engineering,\n * University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n\n#include \"ns3/boolean.h\"\n#include \"ns3/burst-sink-helper.h\"\n#include \"ns3/bursty-helper.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/pointer.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/system-path.h\"\n#include \"ns3/trace-file-burst-generator.h\"\n#include \"ns3/trace-helper.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <iomanip>\n\n// This example was built starting from examples/wireless/wifi-simple-ht-hidden-stations.cc\n//\n// Network topology: `nStas` are equally spaced over a circle of radius `distance` from the AP.\n// Example with 2 nodes:\n//\n//  n1\n//  |\n//  *\n//\n//  AP\n//\n//  *\n//  |\n//  n2\n//\n// The results of this script are shown in the first reference paper (see README.md).\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"VrAppNStas\");\n\nstd::vector<std::string>\nSplitString(const std::string& str, char delimiter)\n{\n    std::stringstream ss(str);\n    std::string token;\n    std::vector<std::string> container;\n\n    while (getline(ss, token, delimiter))\n    {\n        container.push_back(token);\n    }\n    return container;\n}\n\nstd::string\nGetInputPath()\n{\n    std::string systemPath = SystemPath::FindSelfDirectory();\n    std::vector<std::string> pathComponents = SplitString(systemPath, '/');\n\n    std::string inputPath = \"/\";\n    std::string dir;\n    for (size_t i = 0; i < pathComponents.size(); ++i)\n    {\n        dir = pathComponents.at(i);\n        if (dir == \"\")\n            continue;\n        inputPath += dir + \"/\";\n        if (dir == \"ns-3-dev\")\n            break;\n    }\n    return inputPath;\n}\n\nstd::string\nAddressToString(const Address& addr)\n{\n    std::stringstream addressStr;\n    addressStr << InetSocketAddress::ConvertFrom(addr).GetIpv4();\n    return addressStr.str();\n}\n\nvoid\nBurstRx(Ptr<OutputStreamWrapper> traceFile,\n        Ptr<const Packet> burst,\n        const Address& from,\n        const Address& to,\n        const SeqTsSizeFragHeader& header)\n{\n    *traceFile->GetStream() << AddressToString(from) << \",\" << header.GetTs().GetNanoSeconds()\n                            << \",\" << Simulator::Now().GetNanoSeconds() << \",\" << header.GetSeq()\n                            << \",\" << header.GetSize() << \"\\n\";\n}\n\nvoid\nFragmentRx(Ptr<OutputStreamWrapper> traceFile,\n           Ptr<const Packet> fragment,\n           const Address& from,\n           const Address& to,\n           const SeqTsSizeFragHeader& header)\n{\n    *traceFile->GetStream() << AddressToString(from) << \",\" << header.GetTs().GetNanoSeconds()\n                            << \",\" << Simulator::Now().GetNanoSeconds() << \",\" << header.GetSeq()\n                            << \",\" << header.GetFragSeq() << \",\" << header.GetFrags() << \",\"\n                            << fragment->GetSize() << \"\\n\";\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t nStas = 2;                    // the number of STAs around the AP\n    double distance = 1;                   // the distance from the AP [m]\n    std::string appRate = \"50Mbps\";        // the app target data rate\n    double frameRate = 60;                 // the app frame rate [FPS]\n    std::string vrAppName = \"VirusPopper\"; // the app name\n    std::string burstGeneratorType =\n        \"model\";                // type of burst generator {\"model\", \"trace\", \"deterministic\"}\n    double simulationTime = 10; // simulation time in seconds\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nStas\", \"the number of STAs around the AP\", nStas);\n    // cmd.AddValue (\"distance\", \"the distance from the AP [m]\", distance);\n    cmd.AddValue(\"appRate\", \"the app target data rate\", appRate);\n    cmd.AddValue(\"frameRate\", \"the app frame rate [FPS]\", frameRate);\n    cmd.AddValue(\"vrAppName\", \"the app name\", vrAppName);\n    cmd.AddValue(\"burstGeneratorType\",\n                 \"type of burst generator {\\\"model\\\", \\\"trace\\\", \\\"deterministic\\\"}\",\n                 burstGeneratorType);\n    cmd.AddValue(\"simulationTime\", \"Simulation time in seconds\", simulationTime);\n    cmd.Parse(argc, argv);\n\n    uint32_t fragmentSize = 1472; // bytes\n    uint32_t channelWidth = 160;  // MHz\n    double frequency = 5;         // GHz\n    bool sgi = true;              // Use short guard interval\n\n    LogComponentEnableAll(LOG_PREFIX_ALL);\n    LogComponentEnable(\"VrAppNStas\", LOG_INFO);\n    LogComponentEnable(\"BurstSink\", LOG_INFO);\n\n    // Disable RTS/CTS\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"999999\"));\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(nStas);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211ac);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"VhtMcs9\"),\n                                 \"ControlMode\",\n                                 StringValue(\"VhtMcs0\"));\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    if (frequency != 5)\n    {\n        NS_ABORT_MSG(\"Frequency=\" << frequency << \"GHz not supported by this wifi standard.\");\n    }\n\n    phy.Set(\"ChannelSettings\",\n            StringValue(std::string(\"{0, \") + std::to_string(channelWidth) + \", BAND_5GHZ, 0}\"));\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"vr-app-n-stas\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    Config::Set(\n        \"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HtConfiguration/ShortGuardIntervalSupported\",\n        BooleanValue(sgi));\n    // Setting mobility model\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n    // AP is in the center\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n\n    // STAs around the AP in a circle of fixed radius\n    double dTheta = 2 * M_PI / nStas;\n    for (uint32_t i = 0; i < nStas; i++)\n    {\n        positionAlloc->Add(\n            Vector(std::cos(i * dTheta) * distance, std::sin(i * dTheta) * distance, 0.0));\n    }\n    mobility.SetPositionAllocator(positionAlloc);\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiStaNodes);\n\n    // Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterface;\n    StaInterface = address.Assign(staDevices);\n    Ipv4InterfaceContainer ApInterface;\n    ApInterface = address.Assign(apDevice);\n\n    // Setting applications\n    uint16_t port = 50000;\n    BurstSinkHelper server(\"ns3::UdpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = server.Install(wifiApNode);\n    serverApp.Start(Seconds(0.0));\n    serverApp.Stop(Seconds(simulationTime + 1));\n\n    BurstyHelper client(\"ns3::UdpSocketFactory\",\n                        InetSocketAddress(ApInterface.GetAddress(0), port));\n    client.SetAttribute(\"FragmentSize\", UintegerValue(fragmentSize));\n\n    if (burstGeneratorType == \"model\")\n    {\n        NS_LOG_DEBUG(\"VR generator with framerate=\" << frameRate << \", appRate=\" << appRate\n                                                    << \", vrAppName=\" << vrAppName);\n\n        client.SetBurstGenerator(\"ns3::VrBurstGenerator\",\n                                 \"FrameRate\",\n                                 DoubleValue(frameRate),\n                                 \"TargetDataRate\",\n                                 DataRateValue(DataRate(appRate)),\n                                 \"VrAppName\",\n                                 StringValue(vrAppName));\n    }\n    else if (burstGeneratorType == \"trace\")\n    {\n        uint32_t dataRateMbps = uint32_t(DataRate(appRate).GetBitRate() / 1e6);\n        std::string appAbbrev;\n        if (vrAppName == \"VirusPopper\")\n        {\n            appAbbrev = \"vp\";\n        }\n        else if (vrAppName == \"Minecraft\")\n        {\n            appAbbrev = \"mc\";\n        }\n        else if (vrAppName == \"GoogleEarthVrCities\")\n        {\n            appAbbrev = \"ge_cities\";\n        }\n        else if (vrAppName == \"GoogleEarthVrTour\")\n        {\n            appAbbrev = \"ge_tour\";\n        }\n        else\n        {\n            NS_ABORT_MSG(\"vrAppName=\" << vrAppName << \" was not recognized\");\n        }\n\n        std::ostringstream filenameSs;\n        filenameSs << GetInputPath() << \"./BurstGeneratorTraces/\" << appAbbrev << \"_\"\n                   << dataRateMbps << \"mbps_\" << uint32_t(frameRate) << \"fps.csv\";\n\n        NS_LOG_DEBUG(\"Trace file generator with filename=\" << filenameSs.str());\n\n        client.SetBurstGenerator(\"ns3::TraceFileBurstGenerator\",\n                                 \"TraceFile\",\n                                 StringValue(filenameSs.str()));\n    }\n    else if (burstGeneratorType == \"deterministic\")\n    {\n        double avgPeriod = 1 / frameRate;\n        double avgBurstSize = DataRate(appRate).GetBitRate() / 8.0 / frameRate;\n\n        std::ostringstream periodSs;\n        periodSs << \"ns3::ConstantRandomVariable[Constant=\" << avgPeriod << \"]\";\n        std::ostringstream burstSizeSs;\n        burstSizeSs << \"ns3::ConstantRandomVariable[Constant=\" << avgBurstSize << \"]\";\n\n        NS_LOG_DEBUG(\"Simple generator with period=\" << periodSs.str()\n                                                     << \", burstSize=\" << burstSizeSs.str());\n\n        client.SetBurstGenerator(\"ns3::SimpleBurstGenerator\",\n                                 \"PeriodRv\",\n                                 StringValue(periodSs.str()),\n                                 \"BurstSizeRv\",\n                                 StringValue(burstSizeSs.str()));\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"burstGeneratorType=\" << burstGeneratorType << \" not recognized\");\n    }\n\n    // Saturated UDP traffic from stations to AP\n    ApplicationContainer clientApps = client.Install(wifiStaNodes);\n    Ptr<UniformRandomVariable> x =\n        CreateObjectWithAttributes<UniformRandomVariable>(\"Min\",\n                                                          DoubleValue(0),\n                                                          \"Max\",\n                                                          DoubleValue(1));\n    Ptr<UniformRandomVariable> y = CreateObject<UniformRandomVariable>();\n    for (uint32_t i = 0; i < nStas; i++)\n    {\n        Time startTime = Seconds(x->GetValue());\n        NS_LOG_UNCOND(\"STA\" << i << \" will start at \" << startTime.As(Time::S));\n        Ptr<BurstyApplication> app = DynamicCast<BurstyApplication>(clientApps.Get(i));\n        app->SetStartTime(startTime);\n\n        // decouple trace file burst generators\n        PointerValue val;\n        app->GetAttribute(\"BurstGenerator\", val);\n        Ptr<TraceFileBurstGenerator> tfbg = DynamicCast<TraceFileBurstGenerator>(val.GetObject());\n        if (tfbg)\n        {\n            NS_ABORT_MSG_IF(tfbg->GetTraceDuration() < simulationTime,\n                            \"Trace too short for this simulation\");\n\n            double traceStartTime = y->GetValue(0, tfbg->GetTraceDuration() - simulationTime);\n            NS_LOG_UNCOND(\"STA\" << i << \" will start its trace from \" << traceStartTime);\n            tfbg->SetAttribute(\"StartTime\", DoubleValue(traceStartTime));\n        }\n    }\n    clientApps.Stop(Seconds(simulationTime + 1));\n\n    // Setup traces\n    AsciiTraceHelper ascii;\n    Ptr<OutputStreamWrapper> burstTrace = ascii.CreateFileStream(\"burstTrace.csv\");\n    *burstTrace->GetStream() << \"SrcAddress,TxTime_ns,RxTime_ns,BurstSeq,BurstSize\" << std::endl;\n    Ptr<OutputStreamWrapper> fragmentTrace = ascii.CreateFileStream(\"fragmentTrace.csv\");\n    *fragmentTrace->GetStream()\n        << \"SrcAddress,TxTime_ns,RxTime_ns,BurstSeq,FragSeq,TotFrags,FragSize\" << std::endl;\n\n    DynamicCast<BurstSink>(serverApp.Get(0))\n        ->TraceConnectWithoutContext(\"BurstRx\", MakeBoundCallback(&BurstRx, burstTrace));\n    DynamicCast<BurstSink>(serverApp.Get(0))\n        ->TraceConnectWithoutContext(\"FragmentRx\", MakeBoundCallback(&FragmentRx, fragmentTrace));\n\n    // Start simulation\n    Simulator::Stop(Seconds(simulationTime + 1));\n    Simulator::Run();\n\n    // burst info\n    Ptr<OutputStreamWrapper> txBurstsBySta = ascii.CreateFileStream(\"txBurstsBySta.csv\");\n    Ptr<OutputStreamWrapper> rxBursts = ascii.CreateFileStream(\"rxBursts.csv\");\n\n    uint64_t totBurstSent = 0;\n    for (uint32_t i = 0; i < nStas; i++)\n    {\n        uint64_t burstsSent = DynamicCast<BurstyApplication>(clientApps.Get(i))->GetTotalTxBursts();\n        totBurstSent += burstsSent;\n\n        std::cout << \"burstsSent(\" << i << \")=\" << burstsSent << \", \";\n        *txBurstsBySta->GetStream() << burstsSent << std::endl;\n    }\n    uint64_t burstsReceived = DynamicCast<BurstSink>(serverApp.Get(0))->GetTotalRxBursts();\n\n    std::cout << \"burstsReceived=\" << burstsReceived << \" (\"\n              << double(burstsReceived) / totBurstSent * 100 << \"%)\" << std::endl;\n    *rxBursts->GetStream() << burstsReceived << std::endl;\n\n    // fragment info\n    Ptr<OutputStreamWrapper> txFragmentsBySta = ascii.CreateFileStream(\"txFragmentsBySta.csv\");\n    Ptr<OutputStreamWrapper> rxFragments = ascii.CreateFileStream(\"rxFragments.csv\");\n\n    uint64_t totFragmentSent = 0;\n    for (uint32_t i = 0; i < nStas; i++)\n    {\n        uint64_t fragmentsSent =\n            DynamicCast<BurstyApplication>(clientApps.Get(i))->GetTotalTxFragments();\n        totFragmentSent += fragmentsSent;\n\n        std::cout << \"fragmentsSent(\" << i << \")=\" << fragmentsSent << \", \";\n        *txFragmentsBySta->GetStream() << fragmentsSent << std::endl;\n    }\n    uint64_t fragmentsReceived = DynamicCast<BurstSink>(serverApp.Get(0))->GetTotalRxFragments();\n\n    std::cout << \"fragmentsReceived=\" << fragmentsReceived << \" (\"\n              << double(fragmentsReceived) / totFragmentSent * 100 << \"%)\" << std::endl;\n    *rxFragments->GetStream() << fragmentsReceived << std::endl;\n\n    Simulator::Destroy();\n\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/multi-bss/vr-app/examples/vr-application-example.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2021 SIGNET Lab, Department of Information Engineering,\n * University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/burst-sink-helper.h\"\n#include \"ns3/bursty-helper.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/seq-ts-size-frag-header.h\"\n#include \"ns3/vr-burst-generator.h\"\n\n#include <iomanip>\n\nusing namespace ns3;\n\n/**\n * An example of synthetic traces for VR applications.\n * For further information please check the reference paper (see README.md).\n */\n\nNS_LOG_COMPONENT_DEFINE(\"BurstyApplicationExample\");\n\nstd::string\nAddressToString(const Address& addr)\n{\n    std::stringstream addressStr;\n    addressStr << InetSocketAddress::ConvertFrom(addr).GetIpv4() << \":\"\n               << InetSocketAddress::ConvertFrom(addr).GetPort();\n    return addressStr.str();\n}\n\nvoid\nBurstRx(Ptr<const Packet> burst,\n        const Address& from,\n        const Address& to,\n        const SeqTsSizeFragHeader& header)\n{\n    NS_LOG_INFO(\"Received burst seq=\" << header.GetSeq() << \" of \" << header.GetSize()\n                                      << \" bytes transmitted at \" << std::setprecision(9)\n                                      << header.GetTs().As(Time::S));\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double simTime = 20;\n    double frameRate = 30;\n    std::string targetDataRate = \"40Mbps\";\n    std::string vrAppName = \"VirusPopper\";\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"frameRate\", \"VR application frame rate [FPS].\", frameRate);\n    cmd.AddValue(\"targetDataRate\", \"Target data rate of the VR application.\", targetDataRate);\n    cmd.AddValue(\"vrAppName\", \"The VR application on which the model is based upon.\", vrAppName);\n    cmd.AddValue(\"simTime\", \"Length of simulation [s].\", simTime);\n    cmd.Parse(argc, argv);\n\n    Time::SetResolution(Time::NS);\n    LogComponentEnableAll(LOG_PREFIX_TIME);\n    LogComponentEnable(\"BurstyApplicationExample\", LOG_INFO);\n\n    // Setup two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    uint16_t portNumber = 50000;\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    Ipv4Address serverAddress = interfaces.GetAddress(0);\n    Ipv4Address sinkAddress = Ipv4Address::GetAny(); // 0.0.0.0\n\n    // Create bursty application helper\n    BurstyHelper burstyHelper(\"ns3::UdpSocketFactory\",\n                              InetSocketAddress(serverAddress, portNumber));\n    burstyHelper.SetAttribute(\"FragmentSize\", UintegerValue(1200));\n    burstyHelper.SetBurstGenerator(\"ns3::VrBurstGenerator\",\n                                   \"FrameRate\",\n                                   DoubleValue(frameRate),\n                                   \"TargetDataRate\",\n                                   DataRateValue(DataRate(targetDataRate)),\n                                   \"VrAppName\",\n                                   StringValue(vrAppName));\n\n    // Install bursty application\n    ApplicationContainer serverApps = burstyHelper.Install(nodes.Get(1));\n    Ptr<BurstyApplication> burstyApp = serverApps.Get(0)->GetObject<BurstyApplication>();\n\n    // Create burst sink helper\n    BurstSinkHelper burstSinkHelper(\"ns3::UdpSocketFactory\",\n                                    InetSocketAddress(sinkAddress, portNumber));\n\n    // Install HTTP client\n    ApplicationContainer clientApps = burstSinkHelper.Install(nodes.Get(0));\n    Ptr<BurstSink> burstSink = clientApps.Get(0)->GetObject<BurstSink>();\n\n    // Example of connecting to the trace sources\n    burstSink->TraceConnectWithoutContext(\"BurstRx\", MakeCallback(&BurstRx));\n\n    // Stop bursty app after simTime\n    serverApps.Stop(Seconds(simTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    // Stats\n    std::cout << \"Total RX bursts: \" << burstyApp->GetTotalTxBursts() << \"/\"\n              << burstSink->GetTotalRxBursts() << std::endl;\n    std::cout << \"Total RX fragments: \" << burstyApp->GetTotalTxFragments() << \"/\"\n              << burstSink->GetTotalRxFragments() << std::endl;\n    std::cout << \"Total RX bytes: \" << burstyApp->GetTotalTxBytes() << \"/\"\n              << burstSink->GetTotalRxBytes() << std::endl;\n\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/multi-bss/vr-app/helper/burst-sink-helper.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2021 SIGNET Lab, Department of Information Engineering,\n * University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include \"burst-sink-helper.h\"\n\n#include \"ns3/inet-socket-address.h\"\n#include \"ns3/names.h\"\n#include \"ns3/string.h\"\n\nnamespace ns3\n{\n\nBurstSinkHelper::BurstSinkHelper(std::string protocol, Address address)\n{\n    m_factory.SetTypeId(\"ns3::BurstSink\");\n    m_factory.Set(\"Protocol\", StringValue(protocol));\n    m_factory.Set(\"Local\", AddressValue(address));\n}\n\nvoid\nBurstSinkHelper::SetAttribute(std::string name, const AttributeValue& value)\n{\n    m_factory.Set(name, value);\n}\n\nApplicationContainer\nBurstSinkHelper::Install(Ptr<Node> node) const\n{\n    return ApplicationContainer(InstallPriv(node));\n}\n\nApplicationContainer\nBurstSinkHelper::Install(std::string nodeName) const\n{\n    Ptr<Node> node = Names::Find<Node>(nodeName);\n    return ApplicationContainer(InstallPriv(node));\n}\n\nApplicationContainer\nBurstSinkHelper::Install(NodeContainer c) const\n{\n    ApplicationContainer apps;\n    for (NodeContainer::Iterator i = c.Begin(); i != c.End(); ++i)\n    {\n        apps.Add(InstallPriv(*i));\n    }\n\n    return apps;\n}\n\nPtr<Application>\nBurstSinkHelper::InstallPriv(Ptr<Node> node) const\n{\n    Ptr<Application> app = m_factory.Create<Application>();\n    node->AddApplication(app);\n\n    return app;\n}\n\n} // namespace ns3\n"
    },
    {
      "file_path": "examples/multi-bss/vr-app/helper/bursty-app-stats-calculator.cc",
      "code": "/* -*-  Mode: C++; c-file-style: \"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n *\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU General Public License version 2 as\n *   published by the Free Software Foundation;\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU General Public License for more details.\n *\n *   You should have received a copy of the GNU General Public License\n *   along with this program; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n\n#include \"bursty-app-stats-calculator.h\"\n\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/nstime.h\"\n#include \"ns3/seq-ts-size-frag-header.h\"\n#include \"ns3/string.h\"\n#include <ns3/boolean.h>\n#include <ns3/log.h>\n\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BurstyAppStatsCalculator\");\n\nNS_OBJECT_ENSURE_REGISTERED(BurstyAppStatsCalculator);\n\nBurstyAppStatsCalculator::BurstyAppStatsCalculator()\n    : m_firstWrite(true),\n      m_pendingOutput(false),\n      m_aggregatedStats(true)\n{\n    NS_LOG_FUNCTION(this);\n}\n\nBurstyAppStatsCalculator::~BurstyAppStatsCalculator()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nTypeId\nBurstyAppStatsCalculator::GetTypeId(void)\n{\n    static TypeId tid =\n        TypeId(\"ns3::BurstyAppStatsCalculator\")\n            .SetParent<Object>()\n            .SetGroupName(\"Applications\")\n            .AddConstructor<BurstyAppStatsCalculator>()\n            .AddAttribute(\"StartTime\",\n                          \"Start time of the on going epoch.\",\n                          TimeValue(Seconds(0.)),\n                          MakeTimeAccessor(&BurstyAppStatsCalculator::SetStartTime,\n                                           &BurstyAppStatsCalculator::GetStartTime),\n                          MakeTimeChecker())\n            .AddAttribute(\"EpochDuration\",\n                          \"Epoch duration.\",\n                          TimeValue(Seconds(0.25)),\n                          MakeTimeAccessor(&BurstyAppStatsCalculator::GetEpoch,\n                                           &BurstyAppStatsCalculator::SetEpoch),\n                          MakeTimeChecker())\n            .AddAttribute(\"OutputFilename\",\n                          \"Name of the file where the downlink results will be saved.\",\n                          StringValue(\"AppStats.txt\"),\n                          MakeStringAccessor(&BurstyAppStatsCalculator::SetOutputFilename,\n                                             &BurstyAppStatsCalculator::GetOutputFilename),\n                          MakeStringChecker())\n            .AddAttribute(\"AggregatedStats\",\n                          \"Choice to show the results aggregated of disaggregated. As of now, \"\n                          \"non-aggregated stats are not supported\",\n                          BooleanValue(true),\n                          MakeBooleanAccessor(&BurstyAppStatsCalculator::m_aggregatedStats),\n                          MakeBooleanChecker())\n            .AddAttribute(\"ManualUpdate\",\n                          \"Choice to perform manual statistics update, e.g., triggered by an \"\n                          \"external class.\",\n                          BooleanValue(false),\n                          MakeBooleanAccessor(&BurstyAppStatsCalculator::GetManualUpdate,\n                                              &BurstyAppStatsCalculator::SetManualUpdate),\n                          MakeBooleanChecker())\n            .AddAttribute(\"WriteToFile\",\n                          \"Choice to write stats to file besides computing and exchange them \"\n                          \"with external classes\",\n                          BooleanValue(false),\n                          MakeBooleanAccessor(&BurstyAppStatsCalculator::m_writeToFile),\n                          MakeBooleanChecker());\n    return tid;\n}\n\nvoid\nBurstyAppStatsCalculator::DoDispose()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nBurstyAppStatsCalculator::SetStartTime(Time t)\n{\n    m_startTime = t;\n    if (m_aggregatedStats)\n    {\n        RescheduleEndEpoch();\n    }\n}\n\nTime\nBurstyAppStatsCalculator::GetStartTime() const\n{\n    return m_startTime;\n}\n\nvoid\nBurstyAppStatsCalculator::SetEpoch(Time e)\n{\n    m_epochDuration = e;\n    if (m_aggregatedStats)\n    {\n        RescheduleEndEpoch();\n    }\n}\n\nTime\nBurstyAppStatsCalculator::GetEpoch() const\n{\n    return m_epochDuration;\n}\n\nvoid\nBurstyAppStatsCalculator::SetManualUpdate(bool u)\n{\n    NS_LOG_FUNCTION(this);\n    m_manualUpdate = u;\n    if (m_manualUpdate)\n    {\n        NS_LOG_UNCOND(\"Cancel EndEpoch event\");\n        m_endEpochEvent.Cancel();\n    }\n}\n\nbool\nBurstyAppStatsCalculator::GetManualUpdate() const\n{\n    NS_LOG_FUNCTION(this);\n    return m_manualUpdate;\n}\n\nvoid\nBurstyAppStatsCalculator::TxBurst(uint32_t nodeId,\n                                  Ptr<const Packet> burst,\n                                  const Address& from,\n                                  const Address& to,\n                                  const SeqTsSizeFragHeader& header)\n{\n    NS_LOG_FUNCTION(this << \" TxBurst nodeId=\" << nodeId << \" burst seq=\" << header.GetSeq()\n                         << \" of \" << header.GetSize() << \" bytes transmitted at \"\n                         << std::setprecision(9) << header.GetTs().As(Time::S));\n\n    if (m_aggregatedStats)\n    {\n        if (Simulator::Now() >= m_startTime)\n        {\n            m_txBursts[nodeId]++;\n            m_txData[nodeId] += header.GetSize();\n        }\n        m_pendingOutput = true;\n    }\n}\n\nvoid\nBurstyAppStatsCalculator::RxBurst(uint32_t nodeId,\n                                  Ptr<const Packet> burst,\n                                  const Address& from,\n                                  const Address& to,\n                                  const SeqTsSizeFragHeader& header)\n{\n    NS_LOG_FUNCTION(this << \" RxBurst nodeId=\" << nodeId << \" burst seq=\" << header.GetSeq()\n                         << \" of \" << header.GetSize() << \" bytes transmitted at \"\n                         << std::setprecision(9) << header.GetTs().As(Time::S));\n    if (m_aggregatedStats)\n    {\n        if (Simulator::Now() >= m_startTime)\n        {\n            m_rxBursts[nodeId]++;\n            m_rxData[nodeId] += header.GetSize();\n\n            auto it = m_delay.find(nodeId);\n            if (it == m_delay.end())\n            {\n                NS_LOG_DEBUG(this << \" Creating delay stats calculator for node \" << nodeId);\n                m_delay[nodeId] = CreateObject<MinMaxAvgTotalCalculator<uint64_t>>();\n            }\n\n            uint64_t delay = Simulator::Now().GetNanoSeconds() - header.GetTs().GetNanoSeconds();\n            m_delay[nodeId]->Update(delay);\n        }\n        m_pendingOutput = true;\n    }\n}\n\nstd::map<uint16_t, AppResults>\nBurstyAppStatsCalculator::ReadResults(void)\n{\n    NS_LOG_FUNCTION(this);\n\n    // Get the list of node IDs\n    std::vector<uint32_t> nodeIdsVector;\n    for (auto it = m_txBursts.begin(); it != m_txBursts.end(); ++it)\n    {\n        if (find(nodeIdsVector.begin(), nodeIdsVector.end(), (*it).first) == nodeIdsVector.end())\n        {\n            nodeIdsVector.push_back((*it).first);\n        }\n    }\n\n    std::map<uint16_t, AppResults> results;\n    for (auto it = nodeIdsVector.begin(); it != nodeIdsVector.end(); ++it)\n    {\n        AppResults item;\n        uint32_t nodeId = *it;\n        item.imsi = nodeId;\n\n        item.txBursts = m_txBursts[nodeId];\n        item.txData = m_txData[nodeId];\n\n        item.rxBursts = m_rxBursts[nodeId];\n        item.rxData = m_rxData[nodeId];\n\n        auto iter = m_delay.find(nodeId);\n\n        // if no delay info have been recorded yet, put it to zero\n        if (iter == m_delay.end())\n        {\n            item.delayMean = 0.0;\n            item.delayStdev = 0.0;\n            item.delayMin = 0.0;\n            item.delayMax = 0.0;\n        }\n        else\n        {\n            item.delayMean = m_delay[nodeId]->getMean();\n            item.delayStdev = m_delay[nodeId]->getStddev();\n            item.delayMin = m_delay[nodeId]->getMin();\n            item.delayMax = m_delay[nodeId]->getMax();\n        }\n        results.insert(std::make_pair(item.imsi, item));\n    }\n    if (m_writeToFile)\n    {\n        ShowResults();\n    }\n    ResetResults();\n    return results;\n}\n\nvoid\nBurstyAppStatsCalculator::ShowResults(void)\n{\n    std::ofstream outFile;\n\n    if (m_firstWrite == true)\n    {\n        outFile.open(GetOutputFilename().c_str());\n        if (!outFile.is_open())\n        {\n            NS_LOG_ERROR(\"Can't open file \" << GetOutputFilename().c_str());\n            return;\n        }\n\n        m_firstWrite = false;\n        outFile << \"start\\tend\\tNodeId\\tnTxBursts\\tTxBytes\\tnRxBursts\\tRxBytes\\tdelay\\tstdDev\\tmin\"\n                   \"\\tmax\\t\";\n        outFile << std::endl;\n    }\n    else\n    {\n        outFile.open(GetOutputFilename().c_str(), std::ios_base::app);\n        if (!outFile.is_open())\n        {\n            NS_LOG_ERROR(\"Can't open file \" << GetOutputFilename().c_str());\n            return;\n        }\n    }\n\n    WriteResults(outFile);\n    m_pendingOutput = false;\n}\n\nvoid\nBurstyAppStatsCalculator::WriteResults(std::ofstream& outFile)\n{\n    NS_LOG_FUNCTION(this);\n\n    // Get the list of node IDs\n\n    std::vector<uint32_t> nodeIdsVector;\n    for (auto it = m_txBursts.begin(); it != m_txBursts.end(); ++it)\n    {\n        if (find(nodeIdsVector.begin(), nodeIdsVector.end(), (*it).first) == nodeIdsVector.end())\n        {\n            nodeIdsVector.push_back((*it).first);\n        }\n    }\n\n    // Check if there is some ID missing\n    for (auto it = m_rxBursts.begin(); it != m_rxBursts.end(); ++it)\n    {\n        if (find(nodeIdsVector.begin(), nodeIdsVector.end(), (*it).first) == nodeIdsVector.end())\n        {\n            nodeIdsVector.push_back((*it).first);\n        }\n    }\n\n    Time endTime;\n    if (m_manualUpdate)\n    {\n        endTime = Simulator::Now();\n    }\n    else\n    {\n        endTime = m_startTime + m_epochDuration;\n    }\n\n    for (auto it = nodeIdsVector.begin(); it != nodeIdsVector.end(); ++it)\n    {\n        uint32_t nodeId = *it;\n        outFile << m_startTime.GetNanoSeconds() / 1.0e9 << \"\\t\";\n        outFile << endTime.GetNanoSeconds() / 1.0e9 << \"\\t\";\n\n        outFile << nodeId << \"\\t\";\n\n        outFile << m_txBursts[nodeId] << \"\\t\";\n        outFile << m_txData[nodeId] << \"\\t\";\n\n        outFile << m_rxBursts[nodeId] << \"\\t\";\n        outFile << m_rxData[nodeId] << \"\\t\";\n\n        auto iter = m_delay.find(nodeId);\n\n        // if no delay info have been recorded yet, put it to zero\n        if (iter == m_delay.end())\n        {\n            outFile << 0.0 << \"\\t\";\n            outFile << 0.0 << \"\\t\";\n            outFile << 0.0 << \"\\t\";\n            outFile << 0.0 << \"\\t\";\n        }\n        else\n        {\n            outFile << m_delay[nodeId]->getMean() << \"\\t\";\n            outFile << m_delay[nodeId]->getStddev() << \"\\t\";\n            outFile << m_delay[nodeId]->getMin() << \"\\t\";\n            outFile << m_delay[nodeId]->getMax() << \"\\t\";\n        }\n\n        outFile << std::endl;\n    }\n\n    outFile.close();\n}\n\nvoid\nBurstyAppStatsCalculator::ResetResults(void)\n{\n    NS_LOG_FUNCTION(this);\n\n    m_rxBursts.erase(m_rxBursts.begin(), m_rxBursts.end());\n    m_txBursts.erase(m_txBursts.begin(), m_txBursts.end());\n\n    m_txData.erase(m_txData.begin(), m_txData.end());\n    m_rxData.erase(m_rxData.begin(), m_rxData.end());\n\n    m_delay.erase(m_delay.begin(), m_delay.end());\n}\n\nvoid\nBurstyAppStatsCalculator::RescheduleEndEpoch(void)\n{\n    NS_LOG_FUNCTION(this);\n    m_endEpochEvent.Cancel();\n    NS_ASSERT(Simulator::Now().GetMilliSeconds() == 0); // below event time assumes this\n    m_endEpochEvent = Simulator::Schedule(m_startTime + m_epochDuration,\n                                          &BurstyAppStatsCalculator::EndEpoch,\n                                          this);\n}\n\nvoid\nBurstyAppStatsCalculator::EndEpoch(void)\n{\n    NS_LOG_FUNCTION(this);\n    ShowResults();\n    ResetResults();\n    m_startTime += m_epochDuration;\n    m_endEpochEvent =\n        Simulator::Schedule(m_epochDuration, &BurstyAppStatsCalculator::EndEpoch, this);\n}\n\nvoid\nBurstyAppStatsCalculator::SetOutputFilename(std::string filename)\n{\n    m_outputFilename = filename;\n}\n\nstd::string\nBurstyAppStatsCalculator::GetOutputFilename(void) const\n{\n    return m_outputFilename;\n}\n"
    },
    {
      "file_path": "examples/multi-bss/vr-app/helper/bursty-helper.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2021 SIGNET Lab, Department of Information Engineering,\n * University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n#include \"bursty-helper.h\"\n\n#include \"ns3/bursty-application.h\"\n#include \"ns3/data-rate.h\"\n#include \"ns3/inet-socket-address.h\"\n#include \"ns3/names.h\"\n#include \"ns3/packet-socket-address.h\"\n#include \"ns3/pointer.h\"\n#include \"ns3/random-variable-stream.h\"\n#include \"ns3/simple-burst-generator.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/vr-burst-generator.h\"\n\nnamespace ns3\n{\n\nBurstyHelper::BurstyHelper(std::string protocol, Address address)\n{\n    m_burstyApplicationFactory.SetTypeId(\"ns3::BurstyApplication\");\n    m_burstyApplicationFactory.Set(\"Protocol\", StringValue(protocol));\n    m_burstyApplicationFactory.Set(\"Remote\", AddressValue(address));\n}\n\nvoid\nBurstyHelper::SetAttribute(std::string name, const AttributeValue& value)\n{\n    m_burstyApplicationFactory.Set(name, value);\n}\n\nvoid\nBurstyHelper::SetBurstGenerator(std::string type,\n                                std::string n1,\n                                const AttributeValue& v1,\n                                std::string n2,\n                                const AttributeValue& v2,\n                                std::string n3,\n                                const AttributeValue& v3,\n                                std::string n4,\n                                const AttributeValue& v4)\n{\n    m_burstGeneratorFactory.SetTypeId(type);\n    m_burstGeneratorFactory.Set(n1, v1);\n    m_burstGeneratorFactory.Set(n2, v2);\n    m_burstGeneratorFactory.Set(n3, v3);\n    m_burstGeneratorFactory.Set(n4, v4);\n}\n\nvoid\nBurstyHelper::SetBurstGeneratorAttribute(std::string name, const AttributeValue& value)\n{\n    m_burstGeneratorFactory.Set(name, value);\n}\n\nApplicationContainer\nBurstyHelper::Install(Ptr<Node> node) const\n{\n    return ApplicationContainer(InstallPriv(node));\n}\n\nApplicationContainer\nBurstyHelper::Install(std::string nodeName) const\n{\n    Ptr<Node> node = Names::Find<Node>(nodeName);\n    return ApplicationContainer(InstallPriv(node));\n}\n\nApplicationContainer\nBurstyHelper::Install(NodeContainer c) const\n{\n    ApplicationContainer apps;\n    for (NodeContainer::Iterator i = c.Begin(); i != c.End(); ++i)\n    {\n        apps.Add(InstallPriv(*i));\n    }\n\n    return apps;\n}\n\nPtr<Application>\nBurstyHelper::InstallPriv(Ptr<Node> node) const\n{\n    Ptr<BurstyApplication> app = m_burstyApplicationFactory.Create<BurstyApplication>();\n    Ptr<BurstGenerator> generator = m_burstGeneratorFactory.Create<BurstGenerator>();\n\n    app->SetAttribute(\"BurstGenerator\", PointerValue(generator));\n    node->AddApplication(app);\n\n    return app;\n}\n\nint64_t\nBurstyHelper::AssignStreams(NodeContainer c, int64_t stream)\n{\n    int64_t currentStream = stream;\n    Ptr<Node> node;\n    for (NodeContainer::Iterator i = c.Begin(); i != c.End(); ++i)\n    {\n        node = (*i);\n        for (uint32_t j = 0; j < node->GetNApplications(); j++)\n        {\n            Ptr<BurstyApplication> app = DynamicCast<BurstyApplication>(node->GetApplication(j));\n            if (app)\n            {\n                Ptr<SimpleBurstGenerator> simpleGenerator =\n                    DynamicCast<SimpleBurstGenerator>(app->GetBurstGenerator()); // TODO improve\n                if (simpleGenerator)\n                {\n                    currentStream += simpleGenerator->AssignStreams(currentStream);\n                }\n                Ptr<VrBurstGenerator> vrGenerator =\n                    DynamicCast<VrBurstGenerator>(app->GetBurstGenerator()); // TODO improve\n                if (vrGenerator)\n                {\n                    currentStream += vrGenerator->AssignStreams(currentStream);\n                }\n            }\n        }\n    }\n    return (currentStream - stream);\n}\n\n} // namespace ns3\n"
    },
    {
      "file_path": "examples/multi-bss/vr-app/model/burst-sink.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2021 SIGNET Lab, Department of Information Engineering,\n * University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n#include \"burst-sink.h\"\n\n#include \"ns3/address-utils.h\"\n#include \"ns3/address.h\"\n#include \"ns3/boolean.h\"\n#include \"ns3/inet-socket-address.h\"\n#include \"ns3/inet6-socket-address.h\"\n#include \"ns3/log.h\"\n#include \"ns3/node.h\"\n#include \"ns3/packet.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/socket-factory.h\"\n#include \"ns3/socket.h\"\n#include \"ns3/trace-source-accessor.h\"\n#include \"ns3/udp-socket-factory.h\"\n#include \"ns3/udp-socket.h\"\n\nnamespace ns3\n{\n\nNS_LOG_COMPONENT_DEFINE(\"BurstSink\");\n\nNS_OBJECT_ENSURE_REGISTERED(BurstSink);\n\nTypeId\nBurstSink::GetTypeId(void)\n{\n    static TypeId tid = TypeId(\"ns3::BurstSink\")\n                            .SetParent<Application>()\n                            .SetGroupName(\"Applications\")\n                            .AddConstructor<BurstSink>()\n                            .AddAttribute(\"Local\",\n                                          \"The Address on which to Bind the rx socket.\",\n                                          AddressValue(),\n                                          MakeAddressAccessor(&BurstSink::m_local),\n                                          MakeAddressChecker())\n                            .AddAttribute(\"Protocol\",\n                                          \"The type id of the protocol to use for the rx socket.\",\n                                          TypeIdValue(UdpSocketFactory::GetTypeId()),\n                                          MakeTypeIdAccessor(&BurstSink::m_tid),\n                                          MakeTypeIdChecker())\n                            .AddTraceSource(\"FragmentRx\",\n                                            \"A fragment has been received\",\n                                            MakeTraceSourceAccessor(&BurstSink::m_rxFragmentTrace),\n                                            \"ns3::BurstSink::SeqTsSizeFragCallback\")\n                            .AddTraceSource(\"BurstRx\",\n                                            \"A burst has been successfully received\",\n                                            MakeTraceSourceAccessor(&BurstSink::m_rxBurstTrace),\n                                            \"ns3::BurstSink::SeqTsSizeFragCallback\");\n    return tid;\n}\n\nBurstSink::BurstSink()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nBurstSink::~BurstSink()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nuint64_t\nBurstSink::GetTotalRxBytes() const\n{\n    NS_LOG_FUNCTION(this);\n    return m_totRxBytes;\n}\n\nuint64_t\nBurstSink::GetTotalRxFragments() const\n{\n    NS_LOG_FUNCTION(this);\n    return m_totRxFragments;\n}\n\nuint64_t\nBurstSink::GetTotalRxBursts() const\n{\n    NS_LOG_FUNCTION(this);\n    return m_totRxBursts;\n}\n\nPtr<Socket>\nBurstSink::GetListeningSocket(void) const\n{\n    NS_LOG_FUNCTION(this);\n    return m_socket;\n}\n\nstd::list<Ptr<Socket>>\nBurstSink::GetAcceptedSockets(void) const\n{\n    NS_LOG_FUNCTION(this);\n    return m_socketList;\n}\n\nvoid\nBurstSink::DoDispose(void)\n{\n    NS_LOG_FUNCTION(this);\n    m_socket = 0;\n    m_socketList.clear();\n\n    // chain up\n    Application::DoDispose();\n}\n\n// Application Methods\nvoid\nBurstSink::StartApplication() // Called at time specified by Start\n{\n    NS_LOG_FUNCTION(this);\n    // Create the socket if not already\n    if (!m_socket)\n    {\n        m_socket = Socket::CreateSocket(GetNode(), m_tid);\n        if (m_socket->Bind(m_local) == -1)\n        {\n            NS_FATAL_ERROR(\"Failed to bind socket\");\n        }\n        m_socket->Listen();\n        m_socket->ShutdownSend();\n        if (addressUtils::IsMulticast(m_local))\n        {\n            Ptr<UdpSocket> udpSocket = DynamicCast<UdpSocket>(m_socket);\n            if (udpSocket)\n            {\n                // equivalent to setsockopt (MCAST_JOIN_GROUP)\n                udpSocket->MulticastJoinGroup(0, m_local);\n            }\n            else\n            {\n                NS_FATAL_ERROR(\"Error: joining multicast on a non-UDP socket\");\n            }\n        }\n    }\n\n    m_socket->SetRecvCallback(MakeCallback(&BurstSink::HandleRead, this));\n    m_socket->SetAcceptCallback(MakeNullCallback<bool, Ptr<Socket>, const Address&>(),\n                                MakeCallback(&BurstSink::HandleAccept, this));\n    m_socket->SetCloseCallbacks(MakeCallback(&BurstSink::HandlePeerClose, this),\n                                MakeCallback(&BurstSink::HandlePeerError, this));\n}\n\nvoid\nBurstSink::StopApplication() // Called at time specified by Stop\n{\n    NS_LOG_FUNCTION(this);\n    while (!m_socketList.empty()) // these are accepted sockets, close them\n    {\n        Ptr<Socket> acceptedSocket = m_socketList.front();\n        m_socketList.pop_front();\n        acceptedSocket->Close();\n    }\n    if (m_socket)\n    {\n        m_socket->Close();\n        m_socket->SetRecvCallback(MakeNullCallback<void, Ptr<Socket>>());\n    }\n}\n\nvoid\nBurstSink::HandleRead(Ptr<Socket> socket)\n{\n    NS_LOG_FUNCTION(this << socket);\n    Ptr<Packet> fragment;\n    Address from;\n    Address localAddress;\n    while ((fragment = socket->RecvFrom(from)))\n    {\n        if (fragment->GetSize() == 0)\n        { // EOF\n            break;\n        }\n        m_totRxBytes += fragment->GetSize();\n\n        std::stringstream addressStr;\n        if (InetSocketAddress::IsMatchingType(from))\n        {\n            addressStr << InetSocketAddress::ConvertFrom(from).GetIpv4() << \" port \"\n                       << InetSocketAddress::ConvertFrom(from).GetPort();\n        }\n        else if (Inet6SocketAddress::IsMatchingType(from))\n        {\n            addressStr << Inet6SocketAddress::ConvertFrom(from).GetIpv6() << \" port \"\n                       << Inet6SocketAddress::ConvertFrom(from).GetPort();\n        }\n        else\n        {\n            addressStr << \"UNKNOWN ADDRESS TYPE\";\n        }\n\n        NS_LOG_INFO(\"At time \" << Simulator::Now().As(Time::S) << \" burst sink received \"\n                               << fragment->GetSize() << \" bytes from \" << addressStr.str()\n                               << \" total Rx \" << m_totRxBytes << \" bytes\");\n\n        socket->GetSockName(localAddress);\n\n        // handle received fragment\n        auto itBuffer = m_burstHandlerMap.find(from); // rename m_burstBufferMap, itBuffer\n        if (itBuffer == m_burstHandlerMap.end())\n        {\n            NS_LOG_LOGIC(\"New stream from \" << from);\n            itBuffer = m_burstHandlerMap.insert(std::make_pair(from, BurstHandler())).first;\n        }\n        FragmentReceived(itBuffer->second, fragment, from, localAddress);\n    }\n}\n\nvoid\nBurstSink::FragmentReceived(BurstHandler& burstHandler,\n                            const Ptr<Packet>& f,\n                            const Address& from,\n                            const Address& localAddress)\n{\n    NS_LOG_FUNCTION(this << f);\n\n    SeqTsSizeFragHeader header;\n    f->PeekHeader(header);\n    NS_ABORT_IF(header.GetSize() == 0);\n\n    m_totRxFragments++;\n    m_rxFragmentTrace(f,\n                      from,\n                      localAddress,\n                      header); // TODO should fragment still include header in trace?\n\n    NS_LOG_DEBUG(\"Get BurstHandler for from=\"\n                 << from << \" with m_currentBurstSeq=\" << burstHandler.m_currentBurstSeq\n                 << \", m_fragmentsMerged=\" << burstHandler.m_fragmentsMerged\n                 << \", m_unorderedFragments.size ()=\" << burstHandler.m_unorderedFragments.size()\n                 << \", m_burstBuffer.GetSize ()=\" << burstHandler.m_burstBuffer->GetSize()\n                 << \", for fragment with header: \" << header);\n\n    if (header.GetSeq() < burstHandler.m_currentBurstSeq)\n    {\n        NS_LOG_LOGIC(\"Ignoring fragment from previous burst. Fragment burst seq=\"\n                     << header.GetSeq()\n                     << \", current burst seq=\" << burstHandler.m_currentBurstSeq);\n        return;\n    }\n\n    if (header.GetSeq() > burstHandler.m_currentBurstSeq)\n    {\n        // fragment of new burst: discard previous burst if incomplete\n        NS_LOG_LOGIC(\"Start mering new burst seq \"\n                     << header.GetSeq() << \" (previous=\" << burstHandler.m_currentBurstSeq << \")\");\n\n        burstHandler.m_currentBurstSeq = header.GetSeq();\n        burstHandler.m_fragmentsMerged = 0;\n        burstHandler.m_unorderedFragments.clear();\n        burstHandler.m_burstBuffer = Create<Packet>(0);\n    }\n\n    if (header.GetSeq() == burstHandler.m_currentBurstSeq)\n    {\n        // fragment of current burst\n        NS_ASSERT_MSG(header.GetFragSeq() >= burstHandler.m_fragmentsMerged,\n                      header.GetFragSeq() << \" >= \" << burstHandler.m_fragmentsMerged);\n\n        NS_LOG_DEBUG(\"fragment sequence=\" << header.GetFragSeq() << \", fragments merged=\"\n                                          << burstHandler.m_fragmentsMerged);\n        if (header.GetFragSeq() == burstHandler.m_fragmentsMerged)\n        {\n            // following packet: merge it\n            f->RemoveHeader(header);\n            burstHandler.m_burstBuffer->AddAtEnd(f);\n            burstHandler.m_fragmentsMerged++;\n            NS_LOG_LOGIC(\"Fragments merged \" << burstHandler.m_fragmentsMerged << \"/\"\n                                             << header.GetFrags() << \" for burst \"\n                                             << header.GetSeq());\n\n            // if present, merge following unordered fragments\n            auto nextFragmentIt = burstHandler.m_unorderedFragments.begin();\n            while (\n                nextFragmentIt !=\n                    burstHandler.m_unorderedFragments.end() && // there are unordered packets\n                nextFragmentIt->first ==\n                    burstHandler.m_fragmentsMerged) // the following fragment was already received\n            {\n                Ptr<Packet> storedFragment = nextFragmentIt->second;\n                storedFragment->RemoveHeader(header);\n                burstHandler.m_burstBuffer->AddAtEnd(storedFragment);\n                burstHandler.m_fragmentsMerged++;\n                NS_LOG_LOGIC(\"Unordered fragments merged \" << burstHandler.m_fragmentsMerged << \"/\"\n                                                           << header.GetFrags() << \" for burst \"\n                                                           << header.GetSeq());\n\n                nextFragmentIt = burstHandler.m_unorderedFragments.erase(nextFragmentIt);\n            }\n        }\n        else\n        {\n            // add to unordered fragments buffer\n            NS_LOG_LOGIC(\"Add unordered fragment \" << header.GetFragSeq() << \" of burst \"\n                                                   << header.GetSeq() << \" to buffer \");\n            burstHandler.m_unorderedFragments.insert(\n                std::pair<uint16_t, const Ptr<Packet>>(header.GetFragSeq(), f));\n        }\n    }\n\n    // check if burst is complete\n    if (burstHandler.m_fragmentsMerged == header.GetFrags())\n    {\n        // all fragments have been merged\n        NS_ASSERT_MSG(burstHandler.m_burstBuffer->GetSize() == header.GetSize(),\n                      burstHandler.m_burstBuffer->GetSize() << \" == \" << header.GetSize());\n\n        NS_LOG_LOGIC(\"Burst received: \" << header.GetFrags() << \" fragments for a total of \"\n                                        << header.GetSize() << \" B\");\n        m_totRxBursts++;\n        m_rxBurstTrace(burstHandler.m_burstBuffer,\n                       from,\n                       localAddress,\n                       header); // TODO header size does not include payload, why?\n    }\n}\n\nvoid\nBurstSink::HandlePeerClose(Ptr<Socket> socket)\n{\n    NS_LOG_FUNCTION(this << socket);\n}\n\nvoid\nBurstSink::HandlePeerError(Ptr<Socket> socket)\n{\n    NS_LOG_FUNCTION(this << socket);\n}\n\nvoid\nBurstSink::HandleAccept(Ptr<Socket> s, const Address& from)\n{\n    NS_LOG_FUNCTION(this << s << from);\n    s->SetRecvCallback(MakeCallback(&BurstSink::HandleRead, this));\n    m_socketList.push_back(s);\n}\n\n} // Namespace ns3\n"
    },
    {
      "file_path": "examples/multi-bss/vr-app/model/bursty-application.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n//\n// Copyright (c) 2021 SIGNET Lab, Department of Information Engineering,\n// University of Padova\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License version 2 as\n// published by the Free Software Foundation;\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n\n#include \"bursty-application.h\"\n\n#include \"ns3/address.h\"\n#include \"ns3/boolean.h\"\n#include \"ns3/burst-generator.h\"\n#include \"ns3/data-rate.h\"\n#include \"ns3/inet-socket-address.h\"\n#include \"ns3/inet6-socket-address.h\"\n#include \"ns3/log.h\"\n#include \"ns3/node.h\"\n#include \"ns3/nstime.h\"\n#include \"ns3/packet-socket-address.h\"\n#include \"ns3/packet.h\"\n#include \"ns3/pointer.h\"\n#include \"ns3/random-variable-stream.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/socket-factory.h\"\n#include \"ns3/socket.h\"\n#include \"ns3/trace-source-accessor.h\"\n#include \"ns3/udp-socket-factory.h\"\n#include \"ns3/uinteger.h\"\n\nnamespace ns3\n{\n\nNS_LOG_COMPONENT_DEFINE(\"BurstyApplication\");\n\nNS_OBJECT_ENSURE_REGISTERED(BurstyApplication);\n\nTypeId\nBurstyApplication::GetTypeId(void)\n{\n    static TypeId tid =\n        TypeId(\"ns3::BurstyApplication\")\n            .SetParent<Application>()\n            .SetGroupName(\"Applications\")\n            .AddConstructor<BurstyApplication>()\n            .AddAttribute(\"FragmentSize\",\n                          \"The size of packets sent in a burst including SeqTsSizeFragHeader\",\n                          UintegerValue(1200),\n                          MakeUintegerAccessor(&BurstyApplication::m_fragSize),\n                          MakeUintegerChecker<uint32_t>(1))\n            .AddAttribute(\"Remote\",\n                          \"The address of the destination\",\n                          AddressValue(),\n                          MakeAddressAccessor(&BurstyApplication::m_peer),\n                          MakeAddressChecker())\n            .AddAttribute(\"Local\",\n                          \"The Address on which to bind the socket. If not set, it is generated \"\n                          \"automatically.\",\n                          AddressValue(),\n                          MakeAddressAccessor(&BurstyApplication::m_local),\n                          MakeAddressChecker())\n            .AddAttribute(\"BurstGenerator\",\n                          \"The BurstGenerator used by this application\",\n                          PointerValue(0),\n                          MakePointerAccessor(&BurstyApplication::m_burstGenerator),\n                          MakePointerChecker<BurstGenerator>())\n            .AddAttribute(\"Protocol\",\n                          \"The type of protocol to use. This should be \"\n                          \"a subclass of ns3::SocketFactory\",\n                          TypeIdValue(UdpSocketFactory::GetTypeId()),\n                          MakeTypeIdAccessor(&BurstyApplication::m_socketTid),\n                          MakeTypeIdChecker())\n            .AddTraceSource(\"FragmentTx\",\n                            \"A fragment of the burst is sent\",\n                            MakeTraceSourceAccessor(&BurstyApplication::m_txFragmentTrace),\n                            \"ns3::BurstSink::SeqTsSizeFragCallback\")\n            .AddTraceSource(\"BurstTx\",\n                            \"A burst of packet is created and sent\",\n                            MakeTraceSourceAccessor(&BurstyApplication::m_txBurstTrace),\n                            \"ns3::BurstSink::SeqTsSizeFragCallback\");\n    return tid;\n}\n\nBurstyApplication::BurstyApplication()\n    : m_socket(0),\n      m_connected(false),\n      m_totTxBursts(0),\n      m_totTxFragments(0),\n      m_totTxBytes(0)\n{\n    NS_LOG_FUNCTION(this);\n}\n\nBurstyApplication::~BurstyApplication()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nPtr<Socket>\nBurstyApplication::GetSocket(void) const\n{\n    NS_LOG_FUNCTION(this);\n    return m_socket;\n}\n\nPtr<BurstGenerator>\nBurstyApplication::GetBurstGenerator(void) const\n{\n    return m_burstGenerator;\n}\n\nvoid\nBurstyApplication::DoDispose(void)\n{\n    NS_LOG_FUNCTION(this);\n\n    CancelEvents();\n    m_socket = 0;\n    m_burstGenerator = 0;\n\n    // chain up\n    Application::DoDispose();\n}\n\nvoid\nBurstyApplication::StartApplication()\n{\n    NS_LOG_FUNCTION(this);\n\n    // Create the socket if not already\n    if (!m_socket)\n    {\n        m_socket = Socket::CreateSocket(GetNode(), m_socketTid);\n        int ret = -1;\n\n        if (!m_local.IsInvalid())\n        {\n            NS_ABORT_MSG_IF((Inet6SocketAddress::IsMatchingType(m_peer) &&\n                             InetSocketAddress::IsMatchingType(m_local)) ||\n                                (InetSocketAddress::IsMatchingType(m_peer) &&\n                                 Inet6SocketAddress::IsMatchingType(m_local)),\n                            \"Incompatible peer and local address IP version\");\n            ret = m_socket->Bind(m_local);\n        }\n        else\n        {\n            if (Inet6SocketAddress::IsMatchingType(m_peer))\n            {\n                ret = m_socket->Bind6();\n            }\n            else if (InetSocketAddress::IsMatchingType(m_peer) ||\n                     PacketSocketAddress::IsMatchingType(m_peer))\n            {\n                ret = m_socket->Bind();\n            }\n        }\n\n        if (ret == -1)\n        {\n            NS_FATAL_ERROR(\"Failed to bind socket\");\n        }\n\n        m_socket->Connect(m_peer);\n        m_socket->SetAllowBroadcast(true);\n        m_socket->ShutdownRecv();\n\n        m_socket->SetConnectCallback(MakeCallback(&BurstyApplication::ConnectionSucceeded, this),\n                                     MakeCallback(&BurstyApplication::ConnectionFailed, this));\n    }\n\n    // Ensure no pending event\n    CancelEvents();\n    SendBurst();\n}\n\nvoid\nBurstyApplication::StopApplication()\n{\n    NS_LOG_FUNCTION(this);\n\n    CancelEvents();\n    if (m_socket)\n    {\n        m_socket->Close();\n    }\n    else\n    {\n        NS_LOG_WARN(\"BurstyApplication found null socket to close in StopApplication\");\n    }\n}\n\nvoid\nBurstyApplication::CancelEvents()\n{\n    NS_LOG_FUNCTION(this);\n\n    // Cancel next burst event\n    Simulator::Cancel(m_nextBurstEvent);\n}\n\nvoid\nBurstyApplication::SendBurst()\n{\n    NS_LOG_FUNCTION(this);\n    NS_ASSERT(m_nextBurstEvent.IsExpired());\n\n    // get burst info\n    uint32_t burstSize = 0;\n    Time period;\n    // packets must be at least as big as the header\n    while (burstSize < 24) // TODO: find a way to improve this\n    {\n        if (!m_burstGenerator->HasNextBurst())\n        {\n            NS_LOG_LOGIC(\"Burst generator has no next burst: stopping application\");\n            StopApplication();\n            return;\n        }\n\n        std::tie(burstSize, period) = m_burstGenerator->GenerateBurst();\n        NS_LOG_DEBUG(\"Generated burstSize=\" << burstSize << \", period=\" << period.As(Time::MS));\n    }\n\n    NS_ASSERT_MSG(period.IsPositive(),\n                  \"Period must be non-negative, instead found period=\" << period.As(Time::S));\n\n    // send packets for current burst\n    SendFragmentedBurst(burstSize);\n\n    // schedule next burst\n    NS_LOG_DEBUG(\"Next burst scheduled in \" << period.As(Time::S));\n    m_nextBurstEvent = Simulator::Schedule(period, &BurstyApplication::SendBurst, this);\n}\n\nvoid\nBurstyApplication::SendFragmentedBurst(uint32_t burstSize)\n{\n    NS_LOG_FUNCTION(this << burstSize);\n\n    // prepare header\n    SeqTsSizeFragHeader hdrTmp;\n\n    NS_ABORT_MSG_IF(burstSize < hdrTmp.GetSerializedSize(),\n                    burstSize << \" < \" << hdrTmp.GetSerializedSize());\n    NS_ABORT_MSG_IF(m_fragSize < hdrTmp.GetSerializedSize(),\n                    m_fragSize << \" < \" << hdrTmp.GetSerializedSize());\n\n    // compute number of fragments and sizes\n    uint32_t numFullFrags = burstSize / m_fragSize; // integer division\n    uint32_t lastFragSize = burstSize % m_fragSize; // modulo\n\n    uint32_t secondToLastFragSize = 0;\n    if (numFullFrags > 0)\n    {\n        // if there is at least one full fragment, there exist a second-to-last of full size\n        secondToLastFragSize = m_fragSize;\n        numFullFrags--;\n    }\n    if (secondToLastFragSize > 0 &&                // there exist a second-to-last fragment\n        lastFragSize > 0 &&                        // last smaller fragment is needed\n        lastFragSize < hdrTmp.GetSerializedSize()) // the last fragment is below the minimum size\n    {\n        // reduce second-to-last fragment to make last fragment of minimum size\n        secondToLastFragSize = m_fragSize + lastFragSize - hdrTmp.GetSerializedSize();\n        lastFragSize =\n            hdrTmp.GetSerializedSize(); // TODO packet with no payload: might be a problem\n    }\n    NS_ABORT_MSG_IF(0 < secondToLastFragSize && secondToLastFragSize < hdrTmp.GetSerializedSize(),\n                    secondToLastFragSize << \" < \" << hdrTmp.GetSerializedSize());\n    NS_ABORT_MSG_IF(0 < lastFragSize && lastFragSize < hdrTmp.GetSerializedSize(),\n                    lastFragSize << \" < \" << hdrTmp.GetSerializedSize());\n\n    // total number of fragments\n    uint32_t totFrags = numFullFrags;\n    if (secondToLastFragSize > 0)\n    {\n        totFrags++;\n    }\n    if (lastFragSize > 0)\n    {\n        totFrags++;\n    }\n    uint64_t burstPayload = burstSize - (hdrTmp.GetSerializedSize() * totFrags);\n    uint64_t fullFragmentPayload = m_fragSize - hdrTmp.GetSerializedSize();\n    NS_LOG_DEBUG(\"Current burst size: \"\n                 << burstSize << \" B: \" << totFrags << \" fragments with total payload \"\n                 << burstPayload << \" B. \"\n                 << \"Sending fragments: \" << numFullFrags << \" x \" << m_fragSize << \"B, + \"\n                 << secondToLastFragSize << \" B + \" << lastFragSize << \" B\");\n\n    Ptr<Packet> burst = Create<Packet>(burstPayload);\n    // Trace before adding header, for consistency with BurstSink\n    Address from, to;\n    m_socket->GetSockName(from);\n    m_socket->GetPeerName(to);\n\n    // TODO improve\n    hdrTmp.SetSeq(m_totTxBursts);\n    hdrTmp.SetSize(burstPayload);\n    hdrTmp.SetFrags(totFrags);\n    hdrTmp.SetFragSeq(0);\n\n    m_txBurstTrace(burst, from, to, hdrTmp);\n\n    uint64_t fragmentStart = 0;\n    uint16_t fragmentSeq = 0;\n    for (uint32_t i = 0; i < numFullFrags; i++)\n    {\n        Ptr<Packet> fragment = Create<Packet>(fullFragmentPayload);\n        fragmentStart += fullFragmentPayload;\n        SendFragment(fragment, burstPayload, totFrags, fragmentSeq++);\n    }\n\n    if (secondToLastFragSize > 0)\n    {\n        uint64_t secondToLastFragPayload = secondToLastFragSize - hdrTmp.GetSerializedSize();\n        Ptr<Packet> fragment = Create<Packet>(secondToLastFragPayload);\n        fragmentStart += secondToLastFragPayload;\n        SendFragment(fragment, burstPayload, totFrags, fragmentSeq++);\n    }\n\n    if (lastFragSize > 0)\n    {\n        uint64_t lastFragPayload = lastFragSize - hdrTmp.GetSerializedSize();\n        Ptr<Packet> fragment = Create<Packet>(lastFragPayload);\n        fragmentStart += lastFragPayload;\n        SendFragment(fragment, burstPayload, totFrags, fragmentSeq++);\n    }\n\n    NS_ASSERT(fragmentStart == burst->GetSize());\n\n    m_totTxBursts++;\n}\n\nvoid\nBurstyApplication::SendFragment(Ptr<Packet> fragment,\n                                uint64_t burstSize,\n                                uint16_t totFrags,\n                                uint16_t fragmentSeq)\n{\n    NS_LOG_FUNCTION(this << fragment << burstSize << totFrags << fragmentSeq);\n\n    SeqTsSizeFragHeader header;\n    header.SetSeq(m_totTxBursts);\n    header.SetSize(burstSize);\n    header.SetFrags(totFrags);\n    header.SetFragSeq(fragmentSeq);\n    fragment->AddHeader(header);\n\n    uint32_t fragmentSize = fragment->GetSize();\n    int actual = m_socket->Send(fragment);\n    if (uint32_t(actual) == fragmentSize)\n    {\n        Address from, to;\n        m_socket->GetSockName(from);\n        m_socket->GetPeerName(to);\n\n        m_txFragmentTrace(fragment,\n                          from,\n                          to,\n                          header); // TODO should fragment already include header in trace?\n        m_totTxFragments++;\n        m_totTxBytes += fragmentSize;\n\n        std::stringstream addressStr;\n        if (InetSocketAddress::IsMatchingType(m_peer))\n        {\n            addressStr << InetSocketAddress::ConvertFrom(m_peer).GetIpv4() << \" port \"\n                       << InetSocketAddress::ConvertFrom(m_peer).GetPort();\n        }\n        else if (Inet6SocketAddress::IsMatchingType(m_peer))\n        {\n            addressStr << Inet6SocketAddress::ConvertFrom(m_peer).GetIpv6() << \" port \"\n                       << Inet6SocketAddress::ConvertFrom(m_peer).GetPort();\n        }\n        else\n        {\n            addressStr << \"UNKNOWN ADDRESS TYPE\";\n        }\n\n        NS_LOG_INFO(\"At time \" << Simulator::Now().As(Time::S)\n                               << \" bursty application sent fragment of \" << fragment->GetSize()\n                               << \" bytes to \" << addressStr.str() << \" with header=\" << header);\n    }\n    else\n    {\n        NS_LOG_DEBUG(\"Unable to send fragment: fragment size=\" << fragment->GetSize()\n                                                               << \", socket sent=\" << actual\n                                                               << \"; ignoring unexpected behavior\");\n    }\n}\n\nvoid\nBurstyApplication::ConnectionSucceeded(Ptr<Socket> socket)\n{\n    NS_LOG_FUNCTION(this << socket);\n    m_connected = true;\n}\n\nvoid\nBurstyApplication::ConnectionFailed(Ptr<Socket> socket)\n{\n    NS_LOG_FUNCTION(this << socket);\n    NS_FATAL_ERROR(\"Can't connect\");\n}\n\nuint64_t\nBurstyApplication::GetTotalTxBursts(void) const\n{\n    return m_totTxBursts;\n}\n\nuint64_t\nBurstyApplication::GetTotalTxFragments(void) const\n{\n    return m_totTxFragments;\n}\n\nuint64_t\nBurstyApplication::GetTotalTxBytes(void) const\n{\n    return m_totTxBytes;\n}\n\n} // Namespace ns3\n"
    },
    {
      "file_path": "examples/multi-bss/vr-app/model/seq-ts-size-frag-header.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2021 SIGNET Lab, Department of Information Engineering,\n * University of Padova\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n */\n\n#include \"seq-ts-size-frag-header.h\"\n\n#include \"ns3/log.h\"\n\nnamespace ns3\n{\n\nNS_LOG_COMPONENT_DEFINE(\"SeqTsSizeFragHeader\");\n\nNS_OBJECT_ENSURE_REGISTERED(SeqTsSizeFragHeader);\n\nSeqTsSizeFragHeader::SeqTsSizeFragHeader()\n    : SeqTsSizeHeader()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nTypeId\nSeqTsSizeFragHeader::GetTypeId(void)\n{\n    static TypeId tid = TypeId(\"ns3::SeqTsSizeFragHeader\")\n                            .SetParent<SeqTsSizeHeader>()\n                            .SetGroupName(\"Applications\")\n                            .AddConstructor<SeqTsSizeFragHeader>();\n    return tid;\n}\n\nTypeId\nSeqTsSizeFragHeader::GetInstanceTypeId(void) const\n{\n    return GetTypeId();\n}\n\nvoid\nSeqTsSizeFragHeader::SetFragSeq(uint16_t fragSeq)\n{\n    m_fragSeq = fragSeq;\n}\n\nuint16_t\nSeqTsSizeFragHeader::GetFragSeq(void) const\n{\n    return m_fragSeq;\n}\n\nvoid\nSeqTsSizeFragHeader::SetFrags(uint16_t frags)\n{\n    m_frags = frags;\n}\n\nuint16_t\nSeqTsSizeFragHeader::GetFrags(void) const\n{\n    return m_frags;\n}\n\nvoid\nSeqTsSizeFragHeader::Print(std::ostream& os) const\n{\n    NS_LOG_FUNCTION(this << &os);\n    os << \"(fragSeq=\" << m_fragSeq << \", frags=\" << m_frags << \") AND \";\n    SeqTsSizeHeader::Print(os);\n}\n\nuint32_t\nSeqTsSizeFragHeader::GetSerializedSize(void) const\n{\n    return SeqTsSizeHeader::GetSerializedSize() + 4;\n}\n\nvoid\nSeqTsSizeFragHeader::Serialize(Buffer::Iterator start) const\n{\n    NS_LOG_FUNCTION(this << &start);\n    Buffer::Iterator i = start;\n    i.WriteHtonU16(m_fragSeq);\n    i.WriteHtonU16(m_frags);\n    SeqTsSizeHeader::Serialize(i);\n}\n\nuint32_t\nSeqTsSizeFragHeader::Deserialize(Buffer::Iterator start)\n{\n    NS_LOG_FUNCTION(this << &start);\n    Buffer::Iterator i = start;\n    m_fragSeq = i.ReadNtohU16();\n    m_frags = i.ReadNtohU16();\n    SeqTsSizeHeader::Deserialize(i);\n    return GetSerializedSize();\n}\n\n} // namespace ns3\n"
    },
    {
      "file_path": "examples/multi-bss/vr-app/model/simple-burst-generator.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n//\n// Copyright (c) 2021 SIGNET Lab, Department of Information Engineering,\n// University of Padova\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License version 2 as\n// published by the Free Software Foundation;\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n\n#include \"simple-burst-generator.h\"\n\n#include \"ns3/log.h\"\n#include \"ns3/nstime.h\"\n#include \"ns3/pointer.h\"\n#include \"ns3/random-variable-stream.h\"\n#include \"ns3/string.h\"\n\nnamespace ns3\n{\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleBurstGenerator\");\n\nNS_OBJECT_ENSURE_REGISTERED(SimpleBurstGenerator);\n\nTypeId\nSimpleBurstGenerator::GetTypeId(void)\n{\n    static TypeId tid =\n        TypeId(\"ns3::SimpleBurstGenerator\")\n            .SetParent<BurstGenerator>()\n            .SetGroupName(\"Applications\")\n            .AddConstructor<SimpleBurstGenerator>()\n            .AddAttribute(\"PeriodRv\",\n                          \"A RandomVariableStream used to pick the duration of the period [s].\",\n                          StringValue(\"ns3::ConstantRandomVariable[Constant=1.0]\"),\n                          MakePointerAccessor(&SimpleBurstGenerator::m_periodRv),\n                          MakePointerChecker<RandomVariableStream>())\n            .AddAttribute(\"BurstSizeRv\",\n                          \"A RandomVariableStream used to pick the size of the burst [B].\",\n                          StringValue(\"ns3::ConstantRandomVariable[Constant=1e6]\"),\n                          MakePointerAccessor(&SimpleBurstGenerator::m_burstSizeRv),\n                          MakePointerChecker<RandomVariableStream>());\n    return tid;\n}\n\nSimpleBurstGenerator::SimpleBurstGenerator()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nSimpleBurstGenerator::~SimpleBurstGenerator()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nint64_t\nSimpleBurstGenerator::AssignStreams(int64_t stream)\n{\n    NS_LOG_FUNCTION(this << stream);\n    m_periodRv->SetStream(stream);\n    m_burstSizeRv->SetStream(stream + 1);\n    return 2;\n}\n\nvoid\nSimpleBurstGenerator::DoDispose(void)\n{\n    NS_LOG_FUNCTION(this);\n\n    m_periodRv = 0;\n    m_burstSizeRv = 0;\n\n    // chain up\n    BurstGenerator::DoDispose();\n}\n\nbool\nSimpleBurstGenerator::HasNextBurst(void)\n{\n    NS_LOG_FUNCTION(this);\n    // this burst generator has no limits on the number of bursts\n    return true;\n}\n\nstd::pair<uint32_t, Time>\nSimpleBurstGenerator::GenerateBurst()\n{\n    NS_LOG_FUNCTION(this);\n\n    // sample current burst size\n    // NOTE: limited to 4 GB per burst by GetInteger\n    uint32_t burstSize = m_burstSizeRv->GetInteger();\n\n    // sample period before next burst\n    Time period = Seconds(m_periodRv->GetValue());\n    NS_ABORT_MSG_IF(!period.IsPositive(),\n                    \"Period must be non-negative, instead found period=\" << period.As(Time::S));\n\n    NS_LOG_DEBUG(\"Burst size: \" << burstSize << \" B, period: \" << period.As(Time::S));\n    return std::make_pair(burstSize, period);\n}\n\n} // Namespace ns3\n"
    },
    {
      "file_path": "examples/multi-bss/vr-app/model/trace-file-burst-generator.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n//\n//\n// Copyright (c) 2021 SIGNET Lab, Department of Information Engineering,\n// University of Padova\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License version 2 as\n// published by the Free Software Foundation;\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n\n#include \"trace-file-burst-generator.h\"\n\n#include \"ns3/csv-reader.h\"\n#include \"ns3/double.h\"\n#include \"ns3/log.h\"\n#include \"ns3/nstime.h\"\n#include \"ns3/random-variable-stream.h\"\n#include \"ns3/string.h\"\n\nnamespace ns3\n{\n\nNS_LOG_COMPONENT_DEFINE(\"TraceFileBurstGenerator\");\n\nNS_OBJECT_ENSURE_REGISTERED(TraceFileBurstGenerator);\n\nTypeId\nTraceFileBurstGenerator::GetTypeId(void)\n{\n    static TypeId tid =\n        TypeId(\"ns3::TraceFileBurstGenerator\")\n            .SetParent<BurstGenerator>()\n            .SetGroupName(\"Applications\")\n            .AddConstructor<TraceFileBurstGenerator>()\n            .AddAttribute(\"TraceFile\",\n                          \"The path to the trace file\",\n                          StringValue(\"\"),\n                          MakeStringAccessor(&TraceFileBurstGenerator::GetTraceFile,\n                                             &TraceFileBurstGenerator::SetTraceFile),\n                          MakeStringChecker())\n            .AddAttribute(\n                \"StartTime\",\n                \"The trace will only generate traced traffic after a start time offset [s]\",\n                DoubleValue(0.0),\n                MakeDoubleAccessor(&TraceFileBurstGenerator::GetStartTime,\n                                   &TraceFileBurstGenerator::SetStartTime),\n                MakeDoubleChecker<double>(0.0));\n    return tid;\n}\n\nTraceFileBurstGenerator::TraceFileBurstGenerator()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nTraceFileBurstGenerator::~TraceFileBurstGenerator()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nTraceFileBurstGenerator::DoDispose(void)\n{\n    NS_LOG_FUNCTION(this);\n\n    ClearBurstQueue();\n\n    // chain up\n    BurstGenerator::DoDispose();\n}\n\nvoid\nTraceFileBurstGenerator::SetStartTime(double startTime)\n{\n    NS_LOG_FUNCTION(this << startTime);\n    if (startTime != m_startTime)\n    {\n        m_startTime = startTime;\n        m_isFinalized = false;\n    }\n}\n\ndouble\nTraceFileBurstGenerator::GetStartTime(void) const\n{\n    return m_startTime;\n}\n\nvoid\nTraceFileBurstGenerator::SetTraceFile(std::string traceFile)\n{\n    NS_LOG_FUNCTION(this << traceFile);\n    if (traceFile != m_traceFile)\n    {\n        m_traceFile = traceFile;\n        m_isFinalized = false;\n    }\n}\n\nstd::string\nTraceFileBurstGenerator::GetTraceFile(void) const\n{\n    return m_traceFile;\n}\n\ndouble\nTraceFileBurstGenerator::GetTraceDuration(void)\n{\n    if (!m_isFinalized)\n    {\n        ImportTrace();\n    }\n\n    return m_traceDuration;\n}\n\nbool\nTraceFileBurstGenerator::HasNextBurst(void)\n{\n    NS_LOG_FUNCTION(this);\n    if (!m_isFinalized)\n    {\n        ImportTrace();\n    }\n\n    return !m_burstQueue.empty();\n}\n\nstd::pair<uint32_t, Time>\nTraceFileBurstGenerator::GenerateBurst()\n{\n    NS_LOG_FUNCTION(this);\n    if (!m_isFinalized)\n    {\n        ImportTrace();\n    }\n\n    NS_ABORT_MSG_IF(m_burstQueue.empty(),\n                    \"All bursts from the trace have already been generated, \"\n                    \"you should have checked if HasNextBurst\");\n\n    std::pair<uint32_t, Time> burst = m_burstQueue.front();\n    m_burstQueue.pop();\n    NS_LOG_DEBUG(\"Generated std::pair(\" << burst.first << \", \" << burst.second << \"); \"\n                                        << m_burstQueue.size()\n                                        << \" more bursts excluding the current one\");\n    return burst;\n}\n\nvoid\nTraceFileBurstGenerator::ClearBurstQueue(void)\n{\n    NS_LOG_FUNCTION(this);\n    std::queue<std::pair<uint32_t, Time>> empty;\n    std::swap(m_burstQueue, empty);\n}\n\nvoid\nTraceFileBurstGenerator::ImportTrace(void)\n{\n    NS_LOG_FUNCTION(this);\n\n    // extract trace from file\n    CsvReader csv(m_traceFile);\n\n    ClearBurstQueue();\n    m_traceDuration = 0;\n    double cumulativeStartTime = 0;\n    uint32_t burstSize;\n    double period;\n    while (csv.FetchNextRow())\n    {\n        // Ignore blank lines\n        if (csv.IsBlankRow())\n        {\n            continue;\n        }\n\n        // Expecting burst size and period to next burst\n        bool ok = csv.GetValue(0, burstSize);\n        ok |= csv.GetValue(1, period);\n        NS_ABORT_MSG_IF(!ok,\n                        \"Something went wrong on line \" << csv.RowNumber() << \" of file \"\n                                                        << m_traceFile);\n        NS_ABORT_MSG_IF(period < 0,\n                        \"Period to next burst should be non-negative, instead found: \"\n                            << period << \" on line \" << csv.RowNumber());\n\n        // Ignore bursts before m_startTime\n        if (cumulativeStartTime >= m_startTime)\n        {\n            m_burstQueue.push(std::make_pair(burstSize, Seconds(period)));\n            m_traceDuration += period;\n        }\n        cumulativeStartTime += period;\n    } // while FetchNextRow\n\n    m_isFinalized = true;\n    NS_LOG_INFO(\"Parsed \" << m_burstQueue.size() << \" bursts from file \" << m_traceFile);\n}\n\n} // Namespace ns3\n"
    },
    {
      "file_path": "examples/multi-bss/vr-app/model/vr-burst-generator.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n//\n// Copyright (c) 2021 SIGNET Lab, Department of Information Engineering,\n// University of Padova\n//\n// This program is free software; you can redistribute it and/or modify\n// it under the terms of the GNU General Public License version 2 as\n// published by the Free Software Foundation;\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n//\n\n#include \"vr-burst-generator.h\"\n\n#include \"ns3/data-rate.h\"\n#include \"ns3/double.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/log.h\"\n#include \"ns3/nstime.h\"\n#include \"ns3/object-factory.h\"\n#include \"ns3/random-variable-stream.h\"\n\n#include <algorithm>\n\nnamespace ns3\n{\n\nNS_LOG_COMPONENT_DEFINE(\"VrBurstGenerator\");\n\nNS_OBJECT_ENSURE_REGISTERED(VrBurstGenerator);\n\nTypeId\nVrBurstGenerator::GetTypeId(void)\n{\n    static TypeId tid =\n        TypeId(\"ns3::VrBurstGenerator\")\n            .SetParent<BurstGenerator>()\n            .SetGroupName(\"Applications\")\n            .AddConstructor<VrBurstGenerator>()\n            .AddAttribute(\"FrameRate\",\n                          \"The frame rate of the VR application [FPS]. \"\n                          \"Only 30 and 60 FPS are currently supported.\",\n                          DoubleValue(60),\n                          MakeDoubleAccessor(&VrBurstGenerator::SetFrameRate,\n                                             &VrBurstGenerator::GetFrameRate),\n                          MakeDoubleChecker<double>(0))\n            .AddAttribute(\"TargetDataRate\",\n                          \"The target data rate that the VR application will try to achieve.\",\n                          DataRateValue(DataRate(\"20Mbps\")),\n                          MakeDataRateAccessor(&VrBurstGenerator::SetTargetDataRate,\n                                               &VrBurstGenerator::GetTargetDataRate),\n                          MakeDataRateChecker())\n            .AddAttribute(\"VrAppName\",\n                          \"The VR application on which the model is based upon. Check the \"\n                          \"documentation for further information.\",\n                          EnumValue(VrAppName::VirusPopper),\n                          MakeEnumAccessor<VrAppName>(&VrBurstGenerator::m_appName),\n                          MakeEnumChecker(VrAppName::VirusPopper,\n                                          \"VirusPopper\",\n                                          VrAppName::Minecraft,\n                                          \"Minecraft\",\n                                          VrAppName::GoogleEarthVrCities,\n                                          \"GoogleEarthVrCities\",\n                                          VrAppName::GoogleEarthVrTour,\n                                          \"GoogleEarthVrTour\"));\n    return tid;\n}\n\nVrBurstGenerator::VrBurstGenerator()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nVrBurstGenerator::~VrBurstGenerator()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nint64_t\nVrBurstGenerator::AssignStreams(int64_t stream)\n{\n    NS_LOG_FUNCTION(this << stream);\n    m_periodRv->SetStream(stream);\n    m_frameSizeRv->SetStream(stream + 1);\n    return 2;\n}\n\nvoid\nVrBurstGenerator::DoDispose(void)\n{\n    NS_LOG_FUNCTION(this);\n\n    m_periodRv = 0;\n    m_frameSizeRv = 0;\n\n    // chain up\n    BurstGenerator::DoDispose();\n}\n\nvoid\nVrBurstGenerator::SetFrameRate(double frameRate)\n{\n    NS_LOG_FUNCTION(this << frameRate);\n\n    NS_ABORT_MSG_UNLESS(frameRate == 30 || frameRate == 60,\n                        \"Frame rate must be either 30 or 60 FPS, instead frameRate=\" << frameRate);\n    m_frameRate = frameRate;\n\n    SetupModel();\n}\n\ndouble\nVrBurstGenerator::GetFrameRate(void) const\n{\n    return m_frameRate;\n}\n\nvoid\nVrBurstGenerator::SetTargetDataRate(DataRate targetDataRate)\n{\n    NS_LOG_FUNCTION(this << targetDataRate);\n\n    NS_ABORT_MSG_IF(targetDataRate.GetBitRate() <= 0,\n                    \"Target data rate must be positive, instead: \" << targetDataRate);\n    m_targetDataRate = targetDataRate;\n\n    SetupModel();\n}\n\nDataRate\nVrBurstGenerator::GetTargetDataRate(void) const\n{\n    return m_targetDataRate;\n}\n\nvoid\nVrBurstGenerator::SetVrAppName(VrBurstGenerator::VrAppName vrAppName)\n{\n    NS_LOG_FUNCTION(this << vrAppName);\n\n    m_appName = vrAppName;\n    SetupModel();\n}\n\nVrBurstGenerator::VrAppName\nVrBurstGenerator::GetVrAppName(void) const\n{\n    return m_appName;\n}\n\nbool\nVrBurstGenerator::HasNextBurst(void)\n{\n    NS_LOG_FUNCTION(this);\n    // this burst generator has no limits on the number of bursts\n    return true;\n}\n\nstd::pair<uint32_t, Time>\nVrBurstGenerator::GenerateBurst()\n{\n    NS_LOG_FUNCTION(this);\n\n    // sample current frame size\n    uint32_t frameSize = m_frameSizeRv->GetInteger();\n\n    // sample period before next frame\n    Time period = Seconds(m_periodRv->GetValue());\n    NS_ABORT_MSG_IF(!period.IsPositive(),\n                    \"Period must be non-negative, instead found period=\" << period.As(Time::S));\n\n    NS_LOG_DEBUG(\"Frame size: \" << frameSize << \" B, period: \" << period.As(Time::S));\n    return std::make_pair(frameSize, period);\n}\n\nvoid\nVrBurstGenerator::SetupModel()\n{\n    NS_LOG_FUNCTION(this);\n\n    double alpha{0};\n    double beta{0};\n    double gamma{0};\n    double delta{0};\n    double epsilon{0};\n\n    switch (m_appName)\n    {\n    case VrAppName::VirusPopper:\n        alpha = 0.17843005544386825;\n        beta = -0.24033549;\n        if (m_frameRate == 60)\n        {\n            gamma = 0.03720502322046791;\n        }\n        else if (m_frameRate == 30)\n        {\n            delta = 0.014333111298430356;\n            epsilon = 0.17636808;\n        }\n        else\n        {\n            NS_ABORT_MSG(\"Unexpected frame rate: \" << m_frameRate);\n        }\n        break;\n\n    case VrAppName::Minecraft:\n        alpha = 0.18570635904452573;\n        beta = -0.18721216;\n        if (m_frameRate == 60)\n        {\n            gamma = 0.07132669841811076;\n        }\n        else if (m_frameRate == 30)\n        {\n            delta = 0.024192743507827373;\n            epsilon = 0.22666163;\n        }\n        else\n        {\n            NS_ABORT_MSG(\"Unexpected frame rate: \" << m_frameRate);\n        }\n        break;\n\n    case VrAppName::GoogleEarthVrCities:\n        alpha = 0.259684566301378;\n        beta = -0.25390119;\n        if (m_frameRate == 60)\n        {\n            gamma = 0.034571656202610615;\n        }\n        else if (m_frameRate == 30)\n        {\n            delta = 0.008953037116942649;\n            epsilon = 0.3119082;\n        }\n        else\n        {\n            NS_ABORT_MSG(\"Unexpected frame rate: \" << m_frameRate);\n        }\n        break;\n\n    case VrAppName::GoogleEarthVrTour:\n        alpha = 0.25541435742159037;\n        beta = -0.20308171;\n        if (m_frameRate == 60)\n        {\n            gamma = 0.03468230656563422;\n        }\n        else if (m_frameRate == 30)\n        {\n            delta = 0.010559650431826953;\n            epsilon = 0.27560183;\n        }\n        else\n        {\n            NS_ABORT_MSG(\"Unexpected frame rate: \" << m_frameRate);\n        }\n        break;\n\n    default:\n        NS_ABORT_MSG(\"m_appName was not recognized\");\n        break;\n    }\n\n    double fsAvg = m_targetDataRate.GetBitRate() / 8.0 / m_frameRate; // expected frame size [B]\n    double ifiAvg = 1.0 / m_frameRate; // expected inter frame interarrival [s]\n    double targetRate_mbps = m_targetDataRate.GetBitRate() / 1e6;\n\n    // Model frame size stats\n    double fsDispersion = alpha * std::pow(targetRate_mbps, beta);\n    double fsScale = fsAvg * fsDispersion;\n    NS_LOG_DEBUG(\"Frame size: loc=\" << fsAvg << \", scale=\" << fsScale\n                                    << \" (dispersion=\" << fsDispersion << \")\");\n\n    m_frameSizeRv = CreateObjectWithAttributes<LogisticRandomVariable>(\"Location\",\n                                                                       DoubleValue(fsAvg),\n                                                                       \"Scale\",\n                                                                       DoubleValue(fsScale),\n                                                                       \"Bound\",\n                                                                       DoubleValue(fsAvg));\n\n    // Model IFI stats\n    double ifiDispersion;\n    if (m_frameRate == 60)\n    {\n        ifiDispersion = gamma;\n    }\n    else if (m_frameRate == 30)\n    {\n        ifiDispersion = delta * std::pow(targetRate_mbps, epsilon);\n    }\n    else\n    {\n        NS_ABORT_MSG(\"Unexpected frame rate: \" << m_frameRate);\n    }\n    double ifiScale = ifiAvg * ifiDispersion;\n    NS_LOG_DEBUG(\"IFI: loc=\" << ifiAvg << \", scale=\" << ifiScale << \" (dispersion=\" << ifiDispersion\n                             << \")\");\n\n    m_periodRv = CreateObjectWithAttributes<LogisticRandomVariable>(\"Location\",\n                                                                    DoubleValue(ifiAvg),\n                                                                    \"Scale\",\n                                                                    DoubleValue(ifiScale),\n                                                                    \"Bound\",\n                                                                    DoubleValue(ifiAvg));\n}\n\n} // Namespace ns3\n"
    },
    {
      "file_path": "examples/rate-control/rate-control.cc",
      "code": "/*\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Based on 'examples/tutorials/third.cc'\n * Modify: Xun Deng <dorence@hust.edu.cn>\n *         Hao Yin <haoyin@uw.edu>\n *         Muyuan Shen <muyuan_shen@hust.edu.cn>\n */\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/flow-monitor.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-flow-classifier.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <fstream>\n#include <iostream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RateControl\");\n\nGlobalValue gThompsonSamplingStream(\"TSStream\",\n                                    \"Stream Value of Thompson Sampling\",\n                                    IntegerValue(100),\n                                    MakeIntegerChecker<int64_t>());\n\n// This structure stores global variables, which are needed to calculate throughput and delay every\n// second\nstruct DataForThpt\n{\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor;\n    uint32_t totalRxPackets; // Total number of received packets in all flows\n    uint64_t totalRxBytes;   // Total bytes received in all flows\n    double totalDelaySum;    // Total delay sum in all flows\n\n    // average delay (ms)\n    double averageDelay()\n    {\n        return totalRxPackets ? totalDelaySum / totalRxPackets / 1000000 : 0;\n    }\n} data; // data is a structure variable which will store all these global variables.\n\ndouble duration = 5.0;     // Duration of simulation (s)\ndouble statInterval = 0.1; // Time interval of calling function Throughput\n\n// This function is being called every 'statInterval' seconds, It measures delay and throughput in\n// every 'statInterval' time window. It calculates overall throughput in that window of all flows in\n// the network.\nstatic void\nThroughput()\n{\n    data.monitor->CheckForLostPackets();\n    // Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>\n    // (data.flowmon.GetClassifier ());\n    const FlowMonitor::FlowStatsContainer stats = data.monitor->GetFlowStats();\n\n    uint64_t totalRxBytes = 0;\n    uint32_t totalRxPackets = 0;\n    double totalDelaySum = 0;\n\n    // Iterating through every flow\n    for (FlowMonitor::FlowStatsContainerCI iter = stats.begin(); iter != stats.end(); iter++)\n    {\n        totalRxBytes += iter->second.rxBytes;\n        totalDelaySum += iter->second.delaySum.GetDouble();\n        totalRxPackets += iter->second.rxPackets;\n    }\n    uint64_t rxBytesDiff = totalRxBytes - data.totalRxBytes;\n    uint32_t rxPacketsDiff = totalRxPackets - data.totalRxPackets;\n    double delayDiff = totalDelaySum - data.totalDelaySum;\n\n    data.totalRxBytes = totalRxBytes;\n    data.totalRxPackets = totalRxPackets;\n    data.totalDelaySum = totalDelaySum;\n\n    double delay = 0.0; // ms\n    if (rxPacketsDiff != 0 && delayDiff != 0)\n    {\n        delay = delayDiff / rxPacketsDiff / 1000000;\n    }\n    double tpt = 8.0 * rxBytesDiff / statInterval / (1024 * 1024); // Mbps\n\n    std::cout << \"Delay: \" << delay << \"ms, Throughput: \" << tpt << \"Mbps\" << std::endl;\n    Simulator::Schedule(Seconds(statInterval), &Throughput);\n}\n\nint\nsetWifiStandard(WifiHelper& wifi, const std::string standard)\n{\n    if (standard == \"11a\")\n    {\n        wifi.SetStandard(WIFI_STANDARD_80211a);\n    }\n    else if (standard == \"11n\")\n    {\n        wifi.SetStandard(WIFI_STANDARD_80211n);\n    }\n    else if (standard == \"11ac\")\n    {\n        wifi.SetStandard(WIFI_STANDARD_80211ac);\n    }\n    else if (standard == \"11ax\")\n    {\n        wifi.SetStandard(WIFI_STANDARD_80211ax);\n    }\n    else\n    {\n        std::cout << \"Unknown OFDM standard\" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    // LogComponentEnable (\"AiThompsonSamplingWifiManager\", LOG_LEVEL_ALL);\n\n    bool tracing = false;\n    bool verbose = true;\n    uint32_t nCsma = 3; // Number of CSMA(LAN) nodes\n    uint32_t nWifi = 3; // Number of STA(Stations)\n    uint32_t maxBytes = 0;\n\n    std::string errorModelType = \"ns3::NistErrorRateModel\"; // Error Model\n    std::string raaAlgo = \"MinstrelHt\";                     // RAA algorithm (WifiManager Class)\n    std::string standard = \"11ac\";\n\n    // Variables to set rates of various channels in topology, Refer base topology structure.\n    uint32_t csmaRate = 150;\n    uint32_t csmaDelay = 9000;\n    uint32_t p2pRate = 50;\n    uint32_t p2pDelay = 10;\n\n    // Command-Line argument to make it interactive.\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"duration\", \"Duration of simulation (s)\", duration);\n    cmd.AddValue(\"nCsma\", \"Number of \\\"extra\\\" CSMA nodes/devices\", nCsma);\n    cmd.AddValue(\"nWifi\", \"Number of wifi STA devices\", nWifi);\n    cmd.AddValue(\"verbose\", \"Tell echo applications to log if true\", verbose);\n    cmd.AddValue(\"tracing\", \"Enable pcap tracing\", tracing);\n    cmd.AddValue(\"raa\", \"Rate adaptation algorithm, AiConstantRate or AiThompsonSampling\", raaAlgo);\n    cmd.AddValue(\"maxBytes\", \"Max number of Bytes to be sent\", maxBytes);\n    cmd.AddValue(\"p2pRate\", \"Mbps\", p2pRate);\n    cmd.AddValue(\"p2pDelay\", \"MilliSeconds\", p2pDelay);\n    cmd.AddValue(\"csmaDelay\", \"NanoSeconds\", csmaDelay);\n    cmd.AddValue(\"csmaRate\", \"Mbps\", csmaRate);\n    cmd.AddValue(\"standard\", \"WiFi standard\", standard);\n    cmd.Parse(argc, argv);\n    std::cout << \"nWifi: \" << nWifi << \", RAA Algorithm: \" << raaAlgo << \", duration: \" << duration\n              << std::endl;\n\n    raaAlgo = \"ns3::\" + raaAlgo + \"WifiManager\";\n\n    // The underlying restriction of 18 is due to the grid position\n    // allocator's configuration; the grid layout will exceed the\n    // bounding box if more than 18 nodes are provided.\n    if (nWifi > 18)\n    {\n        std::cout << \"nWifi should be 18 or less; otherwise grid layout exceeds the bounding box\"\n                  << std::endl;\n        return 1;\n    }\n\n    NodeContainer p2pNodes;\n    p2pNodes.Create(2);\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(std::to_string(p2pRate) + \"Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(std::to_string(p2pDelay) + \"ms\"));\n\n    NetDeviceContainer p2pDevices;\n    p2pDevices = pointToPoint.Install(p2pNodes);\n\n    NodeContainer csmaNodes;\n    csmaNodes.Add(p2pNodes.Get(1));\n    csmaNodes.Create(nCsma);\n\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(std::to_string(csmaRate) + \"Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(csmaDelay)));\n\n    NetDeviceContainer csmaDevices;\n    csmaDevices = csma.Install(csmaNodes);\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(nWifi);\n    NodeContainer wifiApNode = p2pNodes.Get(0);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n\n    // Delay model\n    channel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n\n    // Loss model\n    channel.AddPropagationLoss(\"ns3::LogDistancePropagationLossModel\",\n                               \"Exponent\",\n                               DoubleValue(0.3),\n                               \"ReferenceLoss\",\n                               DoubleValue(4.0));\n\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    // Error Model\n    phy.SetErrorRateModel(errorModelType);\n\n    WifiHelper wifi;\n\n    // Setting Wifi Standard (enum WifiStandard)\n    setWifiStandard(wifi, standard);\n\n    // Setting Raa Algorithm, refer to 'src/wifi/model/rate-control'\n    wifi.SetRemoteStationManager(raaAlgo);\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer apDevices;\n    apDevices = wifi.Install(phy, mac, wifiApNode);\n\n    if (raaAlgo == \"ns3::ThompsonSamplingWifiManager\")\n    {\n        IntegerValue ival;\n        gThompsonSamplingStream.GetValue(ival);\n        NS_LOG_UNCOND(\"ThompsonSamplingWifiManager stream \" << ival.Get());\n        wifi.AssignStreams(apDevices, ival.Get());\n        wifi.AssignStreams(staDevices, ival.Get());\n    }\n\n    MobilityHelper mobility;\n\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\",\n                                  DoubleValue(0.0),\n                                  \"MinY\",\n                                  DoubleValue(0.0),\n                                  \"DeltaX\",\n                                  DoubleValue(5.0),\n                                  \"DeltaY\",\n                                  DoubleValue(10.0),\n                                  \"GridWidth\",\n                                  UintegerValue(3),\n                                  \"LayoutType\",\n                                  StringValue(\"RowFirst\"));\n\n    // Bounds for the Rectangle Grid\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Speed\",\n                              StringValue(\"ns3::ConstantRandomVariable[Constant=1.0]\"),\n                              \"Bounds\",\n                              RectangleValue(Rectangle(-100, 100, -100, 100)));\n    mobility.Install(wifiStaNodes);\n\n    // Setting Mobility model\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n\n    InternetStackHelper stack;\n    stack.Install(csmaNodes);\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n\n    Ipv4AddressHelper address;\n\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer p2pInterfaces;\n    p2pInterfaces = address.Assign(p2pDevices);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer csmaInterfaces;\n    csmaInterfaces = address.Assign(csmaDevices);\n\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    address.Assign(staDevices);\n    address.Assign(apDevices);\n\n    NS_LOG_INFO(\"Create Applications.\");\n\n    // Creating a BulkSendApplication and install it on one of the wifi-nodes(except AP)\n\n    uint16_t port = 8808; // random port for TCP server listening.\n\n    // Setting packetsize (Bytes)\n    uint32_t packetSize = 1024;\n    BulkSendHelper source(\"ns3::TcpSocketFactory\",\n                          InetSocketAddress(csmaInterfaces.GetAddress(nCsma), port));\n    // Set the amount of data to send in bytes.  Zero is unlimited.\n    source.SetAttribute(\"MaxBytes\", UintegerValue(maxBytes));\n    source.SetAttribute(\"SendSize\", UintegerValue(packetSize));\n    ApplicationContainer sourceApps;\n    for (int i = 0; i < int(nWifi); i++)\n    {\n        sourceApps.Add(source.Install(wifiStaNodes.Get(i)));\n    }\n    sourceApps.Start(Seconds(2.0));\n    sourceApps.Stop(Seconds(2.0 + duration));\n\n    // Creating a PacketSinkApplication and install it on one of the CSMA nodes\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\",\n                          InetSocketAddress(csmaInterfaces.GetAddress(nCsma), port));\n    ApplicationContainer sinkApps = sink.Install(csmaNodes.Get(nCsma));\n    sinkApps.Start(Seconds(2.0 - 1.0));\n    sinkApps.Stop(Seconds(2.0 + duration));\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Initialisation of global variable which are used for Throughput and Delay Calculation.\n    data.monitor = data.flowmon.InstallAll();\n    data.totalDelaySum = 0;\n    data.totalRxBytes = 0;\n    data.totalRxPackets = 0;\n    Simulator::Schedule(Seconds(2.0 - 1.0), &Throughput);\n\n    Simulator::Stop(Seconds(2.0 + duration + 1.0));\n\n    if (tracing)\n    {\n        pointToPoint.EnablePcapAll(\"third_p2p\");\n        phy.EnablePcap(\"third_phy\", apDevices.Get(0));\n        csma.EnablePcap(\"third_csma\", csmaDevices.Get(0), true);\n    }\n\n    Simulator::Run();\n\n    Ptr<PacketSink> sink1 = DynamicCast<PacketSink>(sinkApps.Get(0));\n    std::cout << \"Total Bytes Received: \" << sink1->GetTotalRx() << std::endl;\n    std::cout << \"Average Throughput: \" << sink1->GetTotalRx() * 8.0 / duration / (1024 * 1024)\n              << \"Mbps\" << std::endl;\n    std::cout << \"Average Delay: \" << data.averageDelay() << \"ms\" << std::endl;\n\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/rl-tcp/pure-cpp/rl-tcp.cc",
      "code": "/*\n * Copyright (c) 2018 Piotr Gawlowicz\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Piotr Gawlowicz <gawlowicz.p@gmail.com>\n * Based on script: ./examples/tcp/tcp-variants-comparison.cc\n * Modify: Pengyu Liu <eic_lpy@hust.edu.cn>\n *         Hao Yin <haoyin@uw.edu>\n *         Muyuan Shen <muyuan_shen@hust.edu.cn>\n * Topology:\n *\n *   Left Leafs (Clients)                       Right Leafs (Sinks)\n *           |            \\                    /        |\n *           |             \\    bottleneck    /         |\n *           |              R0--------------R1          |\n *           |             /                  \\         |\n *           |   access   /                    \\ access |\n *\n */\n\n#include \"ns3/ai-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/error-model.h\"\n#include \"ns3/event-id.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-layout-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/tcp-header.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"rl-tcp-example\");\n\nstatic std::vector<uint32_t> rxPkts;\n\nstatic void\nCountRxPkts(uint32_t sinkId, Ptr<const Packet> packet, const Address& srcAddr)\n{\n    rxPkts[sinkId]++;\n}\n\nstatic void\nPrintRxCount()\n{\n    uint32_t size = rxPkts.size();\n    NS_LOG_UNCOND(\"RxPkts:\");\n    for (uint32_t i = 0; i < size; i++)\n    {\n        NS_LOG_UNCOND(\"---SinkId: \" << i << \" RxPkts: \" << rxPkts.at(i));\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double tcpEnvTimeStep = 0.1;\n    uint32_t nLeaf = 1;\n    std::string transport_prot = \"TcpRlTimeBased\";\n    double error_p = 0.0;\n    std::string bottleneck_bandwidth = \"2Mbps\";\n    std::string bottleneck_delay = \"0.01ms\";\n    std::string access_bandwidth = \"10Mbps\";\n    std::string access_delay = \"20ms\";\n    std::string prefix_file_name = \"TcpVariantsComparison\";\n    uint64_t data_mbytes = 0;\n    uint32_t mtu_bytes = 400;\n    double duration = 1000.0;\n    uint32_t run = 0;\n    bool flow_monitor = false;\n    bool sack = true;\n    std::string queue_disc_type = \"ns3::PfifoFastQueueDisc\";\n    std::string recovery = \"ns3::TcpClassicRecovery\";\n\n    CommandLine cmd;\n    // seed related\n    cmd.AddValue(\"simSeed\", \"Seed for random generator. Default: 0\", run);\n    // other\n    cmd.AddValue(\"envTimeStep\",\n                 \"Time step interval for TcpRlTimeBased. Default: 0.1s\",\n                 tcpEnvTimeStep);\n    cmd.AddValue(\"nLeaf\", \"Number of left and right side leaf nodes\", nLeaf);\n    cmd.AddValue(\"transport_prot\",\n                 \"Transport protocol to use: TcpNewReno, TcpHybla, TcpHighSpeed, TcpHtcp, \"\n                 \"TcpVegas, TcpScalable, TcpVeno, TcpBic, TcpYeah, TcpIllinois, TcpWestwood, \"\n                 \"TcpWestwoodPlus, TcpLedbat, TcpLp, TcpRlTimeBased, TcpRlEventBased\",\n                 transport_prot);\n    cmd.AddValue(\"error_p\", \"Packet error rate\", error_p);\n    cmd.AddValue(\"bottleneck_bandwidth\", \"Bottleneck bandwidth\", bottleneck_bandwidth);\n    cmd.AddValue(\"bottleneck_delay\", \"Bottleneck delay\", bottleneck_delay);\n    cmd.AddValue(\"access_bandwidth\", \"Access link bandwidth\", access_bandwidth);\n    cmd.AddValue(\"access_delay\", \"Access link delay\", access_delay);\n    cmd.AddValue(\"prefix_name\", \"Prefix of output trace file\", prefix_file_name);\n    cmd.AddValue(\"data\", \"Number of Megabytes of data to transmit\", data_mbytes);\n    cmd.AddValue(\"mtu\", \"Size of IP packets to send in bytes\", mtu_bytes);\n    cmd.AddValue(\"duration\", \"Time to allow flows to run in seconds\", duration);\n    cmd.AddValue(\"flow_monitor\", \"Enable flow monitor\", flow_monitor);\n    cmd.AddValue(\"queue_disc_type\",\n                 \"Queue disc type for gateway (e.g. ns3::CoDelQueueDisc)\",\n                 queue_disc_type);\n    cmd.AddValue(\"sack\", \"Enable or disable SACK option\", sack);\n    cmd.AddValue(\"recovery\", \"Recovery algorithm type to use (e.g., ns3::TcpPrrRecovery\", recovery);\n    cmd.Parse(argc, argv);\n\n    // There are two kinds of Tcp congestion control algorithm using RL:\n    // 1. TcpRlTimeBased\n    // 2. TcpRlEventBased\n    // The only difference is when interaction occurs (at fixed interval or at event).\n    if (transport_prot == \"TcpRlTimeBased\")\n    {\n        Config::SetDefault(\"ns3::TcpTimeStepEnv::StepTime\", TimeValue(Seconds(tcpEnvTimeStep)));\n    }\n\n    transport_prot = std::string(\"ns3::\") + transport_prot;\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\",\n                       TypeIdValue(TypeId::LookupByName(transport_prot)));\n\n    SeedManager::SetSeed(1);\n    SeedManager::SetRun(run);\n\n    NS_LOG_UNCOND(\"C++ side random seed: \" << run);\n    NS_LOG_UNCOND(\"Tcp version: \" << transport_prot);\n\n    // Calculate the ADU size\n    Header* temp_header = new Ipv4Header();\n    uint32_t ip_header = temp_header->GetSerializedSize();\n    NS_LOG_LOGIC(\"IP Header size is: \" << ip_header);\n    delete temp_header;\n    temp_header = new TcpHeader();\n    uint32_t tcp_header = temp_header->GetSerializedSize();\n    NS_LOG_LOGIC(\"TCP Header size is: \" << tcp_header);\n    delete temp_header;\n    uint32_t tcp_adu_size = mtu_bytes - 20 - (ip_header + tcp_header);\n    NS_LOG_LOGIC(\"TCP ADU size is: \" << tcp_adu_size);\n\n    // Set the simulation start and stop time\n    double start_time = 0.1;\n    double stop_time = start_time + duration;\n\n    // 4 MB of TCP buffer\n    Config::SetDefault(\"ns3::TcpSocket::RcvBufSize\", UintegerValue(1 << 21));\n    Config::SetDefault(\"ns3::TcpSocket::SndBufSize\", UintegerValue(1 << 21));\n    Config::SetDefault(\"ns3::TcpSocketBase::Sack\", BooleanValue(sack));\n    Config::SetDefault(\"ns3::TcpSocket::DelAckCount\", UintegerValue(2));\n\n    Config::SetDefault(\"ns3::TcpL4Protocol::RecoveryType\",\n                       TypeIdValue(TypeId::LookupByName(recovery)));\n\n    // Configure the error model\n    // Here we use RateErrorModel with packet error rate\n    Ptr<UniformRandomVariable> uv = CreateObject<UniformRandomVariable>();\n    uv->SetStream(50);\n    RateErrorModel error_model;\n    error_model.SetRandomVariable(uv);\n    error_model.SetUnit(RateErrorModel::ERROR_UNIT_PACKET);\n    error_model.SetRate(error_p);\n\n    // Create the point-to-point link helpers\n    PointToPointHelper bottleNeckLink;\n    bottleNeckLink.SetDeviceAttribute(\"DataRate\", StringValue(bottleneck_bandwidth));\n    bottleNeckLink.SetChannelAttribute(\"Delay\", StringValue(bottleneck_delay));\n    // bottleNeckLink.SetDeviceAttribute  (\"ReceiveErrorModel\", PointerValue (&error_model));\n\n    PointToPointHelper pointToPointLeaf;\n    pointToPointLeaf.SetDeviceAttribute(\"DataRate\", StringValue(access_bandwidth));\n    pointToPointLeaf.SetChannelAttribute(\"Delay\", StringValue(access_delay));\n\n    PointToPointDumbbellHelper d(nLeaf, pointToPointLeaf, nLeaf, pointToPointLeaf, bottleNeckLink);\n\n    // Install IP stack\n    InternetStackHelper stack;\n    stack.InstallAll();\n\n    // Traffic Control\n    TrafficControlHelper tchPfifo;\n    tchPfifo.SetRootQueueDisc(\"ns3::PfifoFastQueueDisc\");\n\n    TrafficControlHelper tchCoDel;\n    tchCoDel.SetRootQueueDisc(\"ns3::CoDelQueueDisc\");\n\n    DataRate access_b(access_bandwidth);\n    DataRate bottle_b(bottleneck_bandwidth);\n    Time access_d(access_delay);\n    Time bottle_d(bottleneck_delay);\n\n    uint32_t size = static_cast<uint32_t>((std::min(access_b, bottle_b).GetBitRate() / 8) *\n                                          ((access_d + bottle_d + access_d) * 2).GetSeconds());\n\n    Config::SetDefault(\"ns3::PfifoFastQueueDisc::MaxSize\",\n                       QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, size / mtu_bytes)));\n    Config::SetDefault(\"ns3::CoDelQueueDisc::MaxSize\",\n                       QueueSizeValue(QueueSize(QueueSizeUnit::BYTES, size)));\n\n    if (queue_disc_type == \"ns3::PfifoFastQueueDisc\")\n    {\n        tchPfifo.Install(d.GetLeft()->GetDevice(1));\n        tchPfifo.Install(d.GetRight()->GetDevice(1));\n    }\n    else if (queue_disc_type == \"ns3::CoDelQueueDisc\")\n    {\n        tchCoDel.Install(d.GetLeft()->GetDevice(1));\n        tchCoDel.Install(d.GetRight()->GetDevice(1));\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Queue not recognized. Allowed values are ns3::CoDelQueueDisc or \"\n                       \"ns3::PfifoFastQueueDisc\");\n    }\n\n    // Assign IP Addresses\n    d.AssignIpv4Addresses(Ipv4AddressHelper(\"10.1.1.0\", \"255.255.255.0\"),\n                          Ipv4AddressHelper(\"10.2.1.0\", \"255.255.255.0\"),\n                          Ipv4AddressHelper(\"10.3.1.0\", \"255.255.255.0\"));\n\n    NS_LOG_INFO(\"Initialize Global Routing.\");\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Install apps in left and right nodes\n    uint16_t port = 50000;\n    Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n    ApplicationContainer sinkApps;\n    for (uint32_t i = 0; i < d.RightCount(); ++i)\n    {\n        sinkHelper.SetAttribute(\"Protocol\", TypeIdValue(TcpSocketFactory::GetTypeId()));\n        sinkApps.Add(sinkHelper.Install(d.GetRight(i)));\n    }\n    sinkApps.Start(Seconds(0.0));\n    sinkApps.Stop(Seconds(stop_time));\n\n    for (uint32_t i = 0; i < d.LeftCount(); ++i)\n    {\n        // Create an on/off app sending packets to the left side\n        AddressValue remoteAddress(InetSocketAddress(d.GetRightIpv4Address(i), port));\n        Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(tcp_adu_size));\n        BulkSendHelper ftp(\"ns3::TcpSocketFactory\", Address());\n        ftp.SetAttribute(\"Remote\", remoteAddress);\n        ftp.SetAttribute(\"SendSize\", UintegerValue(tcp_adu_size));\n        ftp.SetAttribute(\"MaxBytes\", UintegerValue(data_mbytes * 1000000));\n\n        ApplicationContainer clientApp = ftp.Install(d.GetLeft(i));\n        clientApp.Start(Seconds(start_time * i)); // Start after sink\n        clientApp.Stop(Seconds(stop_time - 3));   // Stop before the sink\n    }\n\n    // Flow monitor\n    FlowMonitorHelper flowHelper;\n    if (flow_monitor)\n    {\n        flowHelper.InstallAll();\n    }\n\n    // Count RX packets\n    for (uint32_t i = 0; i < d.RightCount(); ++i)\n    {\n        rxPkts.push_back(0);\n        Ptr<PacketSink> pktSink = DynamicCast<PacketSink>(sinkApps.Get(i));\n        pktSink->TraceConnectWithoutContext(\"Rx\", MakeBoundCallback(&CountRxPkts, i));\n    }\n\n    Simulator::Stop(Seconds(stop_time));\n    Simulator::Run();\n\n    if (flow_monitor)\n    {\n        flowHelper.SerializeToXmlFile(prefix_file_name + \".flowmonitor\", true, true);\n    }\n\n    PrintRxCount();\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/rl-tcp/pure-cpp/tcp-rl.cc",
      "code": "/*\n * Copyright (c) 2018 Technische Universit\u00e4t Berlin\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Piotr Gawlowicz <gawlowicz@tkn.tu-berlin.de>\n * Modify: Pengyu Liu <eic_lpy@hust.edu.cn>\n *         Hao Yin <haoyin@uw.edu>\n *         Muyuan Shen <muyuan_shen@hust.edu.cn>\n */\n\n#include \"tcp-rl.h\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/node-list.h\"\n#include \"ns3/object.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/tcp-header.h\"\n#include \"ns3/tcp-l4-protocol.h\"\n#include \"ns3/tcp-socket-base.h\"\n\nnamespace ns3\n{\n\nNS_LOG_COMPONENT_DEFINE(\"tcp-rl-purecpp\");\n\nNS_OBJECT_ENSURE_REGISTERED(TcpSocketDerived);\n\nTypeId\nTcpSocketDerived::GetTypeId()\n{\n    static TypeId tid = TypeId(\"ns3::TcpSocketDerived\")\n                            .SetParent<TcpSocketBase>()\n                            .SetGroupName(\"Internet\")\n                            .AddConstructor<TcpSocketDerived>();\n    return tid;\n}\n\nTypeId\nTcpSocketDerived::GetInstanceTypeId() const\n{\n    return TcpSocketDerived::GetTypeId();\n}\n\nTcpSocketDerived::TcpSocketDerived()\n{\n}\n\nPtr<TcpCongestionOps>\nTcpSocketDerived::GetCongestionControlAlgorithm()\n{\n    return m_congestionControl;\n}\n\nTcpSocketDerived::~TcpSocketDerived()\n{\n}\n\n/////////////////////////////////////////////////////////////////////////\n\nNS_OBJECT_ENSURE_REGISTERED(TcpRlTimeBased);\n\nTcpRlTimeBased::TcpRlTimeBased()\n    : TcpCongestionOps()\n{\n    NS_LOG_FUNCTION(this);\n    //  std::cerr << \"in TcpRlTimeBased (void), this = \" << this << std::endl;\n}\n\nTcpRlTimeBased::TcpRlTimeBased(const TcpRlTimeBased& sock)\n    : TcpCongestionOps(sock)\n{\n    NS_LOG_FUNCTION(this);\n    //  std::cerr << \"in TcpRlTimeBased (const TcpRlTimeBased &sock), this = \" << this << std::endl;\n}\n\nTcpRlTimeBased::~TcpRlTimeBased()\n{\n    //  std::cerr << \"in ~TcpRlTimeBased (void), this = \" << this << std::endl;\n}\n\nTypeId\nTcpRlTimeBased::GetTypeId()\n{\n    static TypeId tid = TypeId(\"ns3::TcpRlTimeBased\")\n                            .SetParent<TcpSocketBase>()\n                            .AddConstructor<TcpRlTimeBased>()\n                            .SetGroupName(\"Internet\");\n    return tid;\n}\n\nuint64_t\nTcpRlTimeBased::GenerateUuid()\n{\n    static uint64_t uuid = 0;\n    uuid++;\n    return uuid;\n}\n\nvoid\nTcpRlTimeBased::CreateEnv()\n{\n    //  std::cerr << \"in CreateEnv (), this = \" << this << std::endl;\n    NS_LOG_FUNCTION(this);\n    env = CreateObject<TcpTimeStepEnv>();\n    //  std::cerr << \"CreateEnv\" << (env == nullptr) << std::endl;\n    env->SetSocketUuid(TcpRlTimeBased::GenerateUuid());\n\n    ConnectSocketCallbacks();\n}\n\nvoid\nTcpRlTimeBased::ConnectSocketCallbacks()\n{\n    //  std::cerr << \"in ConnectSocketCallbacks (), this = \" << this << std::endl;\n    NS_LOG_FUNCTION(this);\n\n    bool foundSocket = false;\n    for (NodeList::Iterator i = NodeList::Begin(); i != NodeList::End(); ++i)\n    {\n        Ptr<Node> node = *i;\n        Ptr<TcpL4Protocol> tcp = node->GetObject<TcpL4Protocol>();\n\n        ObjectVectorValue socketVec;\n        tcp->GetAttribute(\"SocketList\", socketVec);\n        NS_LOG_DEBUG(\"Node: \" << node->GetId() << \" TCP socket num: \" << socketVec.GetN());\n\n        uint32_t sockNum = socketVec.GetN();\n        for (uint32_t j = 0; j < sockNum; j++)\n        {\n            Ptr<Object> sockObj = socketVec.Get(j);\n            Ptr<TcpSocketBase> tcpSocket = DynamicCast<TcpSocketBase>(sockObj);\n            NS_LOG_DEBUG(\"Node: \" << node->GetId() << \" TCP Socket: \" << tcpSocket);\n            if (!tcpSocket)\n            {\n                continue;\n            }\n\n            Ptr<TcpSocketDerived> dtcpSocket = StaticCast<TcpSocketDerived>(tcpSocket);\n            Ptr<TcpCongestionOps> ca = dtcpSocket->GetCongestionControlAlgorithm();\n            NS_LOG_DEBUG(\"CA name: \" << ca->GetName());\n            Ptr<TcpRlTimeBased> rlCa = DynamicCast<TcpRlTimeBased>(ca);\n            if (rlCa == this)\n            {\n                NS_LOG_DEBUG(\"Found TcpRl CA!\");\n                foundSocket = true;\n                //              m_tcpSocket = tcpSocket;\n                m_tcpSocket = PeekPointer(tcpSocket);\n                break;\n            }\n        }\n\n        if (foundSocket)\n        {\n            break;\n        }\n    }\n\n    NS_ASSERT_MSG(m_tcpSocket, \"TCP socket was not found.\");\n\n    if (m_tcpSocket)\n    {\n        NS_LOG_DEBUG(\"Found TCP Socket: \" << m_tcpSocket);\n        m_tcpSocket->TraceConnectWithoutContext(\"Tx\",\n                                                MakeCallback(&TcpTimeStepEnv::TxPktTrace, env));\n        m_tcpSocket->TraceConnectWithoutContext(\"Rx\",\n                                                MakeCallback(&TcpTimeStepEnv::RxPktTrace, env));\n        NS_LOG_DEBUG(\"Connect socket callbacks \" << m_tcpSocket->GetNode()->GetId());\n        env->SetNodeId(m_tcpSocket->GetNode()->GetId());\n    }\n}\n\nstd::string\nTcpRlTimeBased::GetName() const\n{\n    return \"TcpRlTimeBased\";\n}\n\nuint32_t\nTcpRlTimeBased::GetSsThresh(Ptr<const TcpSocketState> state, uint32_t bytesInFlight)\n{\n    NS_LOG_FUNCTION(this << state << bytesInFlight);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n\n    uint32_t newSsThresh = env->GetSsThresh(state, bytesInFlight);\n\n    return newSsThresh;\n}\n\nvoid\nTcpRlTimeBased::IncreaseWindow(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked)\n{\n    NS_LOG_FUNCTION(this << tcb << segmentsAcked);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n    env->IncreaseWindow(tcb, segmentsAcked);\n}\n\nvoid\nTcpRlTimeBased::PktsAcked(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked, const Time& rtt)\n{\n    NS_LOG_FUNCTION(this);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n    env->PktsAcked(tcb, segmentsAcked, rtt);\n}\n\nvoid\nTcpRlTimeBased::CongestionStateSet(Ptr<TcpSocketState> tcb,\n                                   const TcpSocketState::TcpCongState_t newState)\n{\n    NS_LOG_FUNCTION(this);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n    env->CongestionStateSet(tcb, newState);\n}\n\nvoid\nTcpRlTimeBased::CwndEvent(Ptr<TcpSocketState> tcb, const TcpSocketState::TcpCAEvent_t event)\n{\n    NS_LOG_FUNCTION(this);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n    env->CwndEvent(tcb, event);\n}\n\nPtr<TcpCongestionOps>\nTcpRlTimeBased::Fork()\n{\n    //  std::cerr << \"in TcpRlTimeBased::Fork (), this = \" << this << std::endl;\n    return CopyObject<TcpRlTimeBased>(this);\n}\n\nNS_OBJECT_ENSURE_REGISTERED(TcpRlEventBased);\n\nTypeId\nTcpRlEventBased::GetTypeId()\n{\n    static TypeId tid = TypeId(\"ns3::TcpRlEventBased\")\n                            .SetParent<TcpSocketBase>()\n                            .AddConstructor<TcpRlEventBased>()\n                            .SetGroupName(\"Internet\");\n    return tid;\n}\n\nTcpRlEventBased::TcpRlEventBased()\n    : TcpCongestionOps()\n{\n}\n\nTcpRlEventBased::TcpRlEventBased(const TcpRlEventBased& sock)\n    : TcpCongestionOps(sock)\n{\n}\n\nTcpRlEventBased::~TcpRlEventBased()\n{\n}\n\nstd::string\nTcpRlEventBased::GetName() const\n{\n    return \"TcpRlEventBased\";\n}\n\nuint32_t\nTcpRlEventBased::GetSsThresh(Ptr<const TcpSocketState> state, uint32_t bytesInFlight)\n{\n    NS_LOG_FUNCTION(this << state << bytesInFlight);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n\n    uint32_t newSsThresh = env->GetSsThresh(state, bytesInFlight);\n\n    return newSsThresh;\n}\n\nvoid\nTcpRlEventBased::IncreaseWindow(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked)\n{\n    NS_LOG_FUNCTION(this << tcb << segmentsAcked);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n    env->IncreaseWindow(tcb, segmentsAcked);\n}\n\nvoid\nTcpRlEventBased::PktsAcked(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked, const Time& rtt)\n{\n    NS_LOG_FUNCTION(this);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n    env->PktsAcked(tcb, segmentsAcked, rtt);\n}\n\nvoid\nTcpRlEventBased::CongestionStateSet(Ptr<TcpSocketState> tcb,\n                                    const TcpSocketState::TcpCongState_t newState)\n{\n    NS_LOG_FUNCTION(this);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n    env->CongestionStateSet(tcb, newState);\n}\n\nvoid\nTcpRlEventBased::CwndEvent(Ptr<TcpSocketState> tcb, const TcpSocketState::TcpCAEvent_t event)\n{\n    NS_LOG_FUNCTION(this);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n    env->CwndEvent(tcb, event);\n}\n\nPtr<TcpCongestionOps>\nTcpRlEventBased::Fork()\n{\n    return CopyObject<TcpRlEventBased>(this);\n}\n\nuint64_t\nTcpRlEventBased::GenerateUuid()\n{\n    static uint64_t uuid = 0;\n    uuid++;\n    return uuid;\n}\n\nvoid\nTcpRlEventBased::CreateEnv()\n{\n    //  std::cerr << \"in CreateEnv (), this = \" << this << std::endl;\n    NS_LOG_FUNCTION(this);\n    env = CreateObject<TcpEventBasedEnv>();\n    std::cerr << \"CreateEnv\" << (env == nullptr) << std::endl;\n    env->SetSocketUuid(TcpRlEventBased::GenerateUuid());\n\n    ConnectSocketCallbacks();\n}\n\nvoid\nTcpRlEventBased::ConnectSocketCallbacks()\n{\n    //  std::cerr << \"in ConnectSocketCallbacks (), this = \" << this << std::endl;\n    NS_LOG_FUNCTION(this);\n\n    bool foundSocket = false;\n    for (NodeList::Iterator i = NodeList::Begin(); i != NodeList::End(); ++i)\n    {\n        Ptr<Node> node = *i;\n        Ptr<TcpL4Protocol> tcp = node->GetObject<TcpL4Protocol>();\n\n        ObjectVectorValue socketVec;\n        tcp->GetAttribute(\"SocketList\", socketVec);\n        NS_LOG_DEBUG(\"Node: \" << node->GetId() << \" TCP socket num: \" << socketVec.GetN());\n\n        uint32_t sockNum = socketVec.GetN();\n        for (uint32_t j = 0; j < sockNum; j++)\n        {\n            Ptr<Object> sockObj = socketVec.Get(j);\n            Ptr<TcpSocketBase> tcpSocket = DynamicCast<TcpSocketBase>(sockObj);\n            NS_LOG_DEBUG(\"Node: \" << node->GetId() << \" TCP Socket: \" << tcpSocket);\n            if (!tcpSocket)\n            {\n                continue;\n            }\n\n            Ptr<TcpSocketDerived> dtcpSocket = StaticCast<TcpSocketDerived>(tcpSocket);\n            Ptr<TcpCongestionOps> ca = dtcpSocket->GetCongestionControlAlgorithm();\n            NS_LOG_DEBUG(\"CA name: \" << ca->GetName());\n            Ptr<TcpRlEventBased> rlCa = DynamicCast<TcpRlEventBased>(ca);\n            if (rlCa == this)\n            {\n                NS_LOG_DEBUG(\"Found TcpRl CA!\");\n                foundSocket = true;\n                //              m_tcpSocket = tcpSocket;\n                m_tcpSocket = PeekPointer(tcpSocket);\n                break;\n            }\n        }\n\n        if (foundSocket)\n        {\n            break;\n        }\n    }\n\n    NS_ASSERT_MSG(m_tcpSocket, \"TCP socket was not found.\");\n\n    if (m_tcpSocket)\n    {\n        NS_LOG_DEBUG(\"Found TCP Socket: \" << m_tcpSocket);\n        m_tcpSocket->TraceConnectWithoutContext(\"Tx\",\n                                                MakeCallback(&TcpEventBasedEnv::TxPktTrace, env));\n        m_tcpSocket->TraceConnectWithoutContext(\"Rx\",\n                                                MakeCallback(&TcpEventBasedEnv::RxPktTrace, env));\n        NS_LOG_DEBUG(\"Connect socket callbacks \" << m_tcpSocket->GetNode()->GetId());\n        env->SetNodeId(m_tcpSocket->GetNode()->GetId());\n    }\n}\n\n} // namespace ns3\n"
    },
    {
      "file_path": "examples/rl-tcp/use-gym/sim.cc",
      "code": "/*\n * Copyright (c) 2018 Piotr Gawlowicz\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Piotr Gawlowicz <gawlowicz.p@gmail.com>\n * Based on script: ./examples/tcp/tcp-variants-comparison.cc\n * Modify: Pengyu Liu <eic_lpy@hust.edu.cn>\n *         Hao Yin <haoyin@uw.edu>\n *         Muyuan Shen <muyuan_shen@hust.edu.cn>\n * Topology:\n *\n *   Left Leafs (Clients)                       Right Leafs (Sinks)\n *           |            \\                    /        |\n *           |             \\    bottleneck    /         |\n *           |              R0--------------R1          |\n *           |             /                  \\         |\n *           |   access   /                    \\ access |\n *\n */\n\n#include \"ns3/ai-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/error-model.h\"\n#include \"ns3/event-id.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-layout-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/tcp-header.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"rl-tcp-example\");\n\nstatic std::vector<uint32_t> rxPkts;\n\nstatic void\nCountRxPkts(uint32_t sinkId, Ptr<const Packet> packet, const Address& srcAddr)\n{\n    rxPkts[sinkId]++;\n}\n\nstatic void\nPrintRxCount()\n{\n    uint32_t size = rxPkts.size();\n    NS_LOG_UNCOND(\"RxPkts:\");\n    for (uint32_t i = 0; i < size; i++)\n    {\n        NS_LOG_UNCOND(\"---SinkId: \" << i << \" RxPkts: \" << rxPkts.at(i));\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double tcpEnvTimeStep = 0.1;\n    uint32_t nLeaf = 1;\n    std::string transport_prot = \"TcpRlTimeBased\";\n    double error_p = 0.0;\n    std::string bottleneck_bandwidth = \"2Mbps\";\n    std::string bottleneck_delay = \"0.01ms\";\n    std::string access_bandwidth = \"10Mbps\";\n    std::string access_delay = \"20ms\";\n    std::string prefix_file_name = \"TcpVariantsComparison\";\n    uint64_t data_mbytes = 0;\n    uint32_t mtu_bytes = 400;\n    double duration = 1000.0;\n    uint32_t run = 0;\n    bool flow_monitor = false;\n    bool sack = true;\n    std::string queue_disc_type = \"ns3::PfifoFastQueueDisc\";\n    std::string recovery = \"ns3::TcpClassicRecovery\";\n\n    CommandLine cmd;\n    // seed related\n    cmd.AddValue(\"simSeed\", \"Seed for random generator. Default: 0\", run);\n    // other\n    cmd.AddValue(\"envTimeStep\",\n                 \"Time step interval for TcpRlTimeBased. Default: 0.1s\",\n                 tcpEnvTimeStep);\n    cmd.AddValue(\"nLeaf\", \"Number of left and right side leaf nodes\", nLeaf);\n    cmd.AddValue(\"transport_prot\",\n                 \"Transport protocol to use: TcpNewReno, TcpHybla, TcpHighSpeed, TcpHtcp, \"\n                 \"TcpVegas, TcpScalable, TcpVeno, TcpBic, TcpYeah, TcpIllinois, TcpWestwood, \"\n                 \"TcpWestwoodPlus, TcpLedbat, TcpLp, TcpRlTimeBased, TcpRlEventBased\",\n                 transport_prot);\n    cmd.AddValue(\"error_p\", \"Packet error rate\", error_p);\n    cmd.AddValue(\"bottleneck_bandwidth\", \"Bottleneck bandwidth\", bottleneck_bandwidth);\n    cmd.AddValue(\"bottleneck_delay\", \"Bottleneck delay\", bottleneck_delay);\n    cmd.AddValue(\"access_bandwidth\", \"Access link bandwidth\", access_bandwidth);\n    cmd.AddValue(\"access_delay\", \"Access link delay\", access_delay);\n    cmd.AddValue(\"prefix_name\", \"Prefix of output trace file\", prefix_file_name);\n    cmd.AddValue(\"data\", \"Number of Megabytes of data to transmit\", data_mbytes);\n    cmd.AddValue(\"mtu\", \"Size of IP packets to send in bytes\", mtu_bytes);\n    cmd.AddValue(\"duration\", \"Time to allow flows to run in seconds\", duration);\n    cmd.AddValue(\"flow_monitor\", \"Enable flow monitor\", flow_monitor);\n    cmd.AddValue(\"queue_disc_type\",\n                 \"Queue disc type for gateway (e.g. ns3::CoDelQueueDisc)\",\n                 queue_disc_type);\n    cmd.AddValue(\"sack\", \"Enable or disable SACK option\", sack);\n    cmd.AddValue(\"recovery\", \"Recovery algorithm type to use (e.g., ns3::TcpPrrRecovery\", recovery);\n    cmd.Parse(argc, argv);\n\n    // There are two kinds of Tcp congestion control algorithm using RL:\n    // 1. TcpRlTimeBased\n    // 2. TcpRlEventBased\n    // The only difference is when interaction occurs (at fixed interval or at event).\n    if (transport_prot == \"TcpRlTimeBased\")\n    {\n        Config::SetDefault(\"ns3::TcpTimeStepEnv::StepTime\", TimeValue(Seconds(tcpEnvTimeStep)));\n    }\n\n    transport_prot = std::string(\"ns3::\") + transport_prot;\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\",\n                       TypeIdValue(TypeId::LookupByName(transport_prot)));\n\n    // OpenGym Env --- has to be created before any other thing\n    Ptr<OpenGymInterface> openGymInterface;\n    if (transport_prot == \"ns3::TcpRlTimeBased\" or transport_prot == \"ns3::TcpRlEventBased\")\n    {\n        openGymInterface = OpenGymInterface::Get();\n    }\n\n    SeedManager::SetSeed(1);\n    SeedManager::SetRun(run);\n\n    NS_LOG_UNCOND(\"C++ side random seed: \" << run);\n    NS_LOG_UNCOND(\"Tcp version: \" << transport_prot);\n\n    // Calculate the ADU size\n    Header* temp_header = new Ipv4Header();\n    uint32_t ip_header = temp_header->GetSerializedSize();\n    NS_LOG_LOGIC(\"IP Header size is: \" << ip_header);\n    delete temp_header;\n    temp_header = new TcpHeader();\n    uint32_t tcp_header = temp_header->GetSerializedSize();\n    NS_LOG_LOGIC(\"TCP Header size is: \" << tcp_header);\n    delete temp_header;\n    uint32_t tcp_adu_size = mtu_bytes - 20 - (ip_header + tcp_header);\n    NS_LOG_LOGIC(\"TCP ADU size is: \" << tcp_adu_size);\n\n    // Set the simulation start and stop time\n    double start_time = 0.1;\n    double stop_time = start_time + duration;\n\n    // 4 MB of TCP buffer\n    Config::SetDefault(\"ns3::TcpSocket::RcvBufSize\", UintegerValue(1 << 21));\n    Config::SetDefault(\"ns3::TcpSocket::SndBufSize\", UintegerValue(1 << 21));\n    Config::SetDefault(\"ns3::TcpSocketBase::Sack\", BooleanValue(sack));\n    Config::SetDefault(\"ns3::TcpSocket::DelAckCount\", UintegerValue(2));\n\n    Config::SetDefault(\"ns3::TcpL4Protocol::RecoveryType\",\n                       TypeIdValue(TypeId::LookupByName(recovery)));\n\n    // Configure the error model\n    // Here we use RateErrorModel with packet error rate\n    Ptr<UniformRandomVariable> uv = CreateObject<UniformRandomVariable>();\n    uv->SetStream(50);\n    RateErrorModel error_model;\n    error_model.SetRandomVariable(uv);\n    error_model.SetUnit(RateErrorModel::ERROR_UNIT_PACKET);\n    error_model.SetRate(error_p);\n\n    // Create the point-to-point link helpers\n    PointToPointHelper bottleNeckLink;\n    bottleNeckLink.SetDeviceAttribute(\"DataRate\", StringValue(bottleneck_bandwidth));\n    bottleNeckLink.SetChannelAttribute(\"Delay\", StringValue(bottleneck_delay));\n    // bottleNeckLink.SetDeviceAttribute  (\"ReceiveErrorModel\", PointerValue (&error_model));\n\n    PointToPointHelper pointToPointLeaf;\n    pointToPointLeaf.SetDeviceAttribute(\"DataRate\", StringValue(access_bandwidth));\n    pointToPointLeaf.SetChannelAttribute(\"Delay\", StringValue(access_delay));\n\n    PointToPointDumbbellHelper d(nLeaf, pointToPointLeaf, nLeaf, pointToPointLeaf, bottleNeckLink);\n\n    // Install IP stack\n    InternetStackHelper stack;\n    stack.InstallAll();\n\n    // Traffic Control\n    TrafficControlHelper tchPfifo;\n    tchPfifo.SetRootQueueDisc(\"ns3::PfifoFastQueueDisc\");\n\n    TrafficControlHelper tchCoDel;\n    tchCoDel.SetRootQueueDisc(\"ns3::CoDelQueueDisc\");\n\n    DataRate access_b(access_bandwidth);\n    DataRate bottle_b(bottleneck_bandwidth);\n    Time access_d(access_delay);\n    Time bottle_d(bottleneck_delay);\n\n    uint32_t size = static_cast<uint32_t>((std::min(access_b, bottle_b).GetBitRate() / 8) *\n                                          ((access_d + bottle_d + access_d) * 2).GetSeconds());\n\n    Config::SetDefault(\"ns3::PfifoFastQueueDisc::MaxSize\",\n                       QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, size / mtu_bytes)));\n    Config::SetDefault(\"ns3::CoDelQueueDisc::MaxSize\",\n                       QueueSizeValue(QueueSize(QueueSizeUnit::BYTES, size)));\n\n    if (queue_disc_type == \"ns3::PfifoFastQueueDisc\")\n    {\n        tchPfifo.Install(d.GetLeft()->GetDevice(1));\n        tchPfifo.Install(d.GetRight()->GetDevice(1));\n    }\n    else if (queue_disc_type == \"ns3::CoDelQueueDisc\")\n    {\n        tchCoDel.Install(d.GetLeft()->GetDevice(1));\n        tchCoDel.Install(d.GetRight()->GetDevice(1));\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Queue not recognized. Allowed values are ns3::CoDelQueueDisc or \"\n                       \"ns3::PfifoFastQueueDisc\");\n    }\n\n    // Assign IP Addresses\n    d.AssignIpv4Addresses(Ipv4AddressHelper(\"10.1.1.0\", \"255.255.255.0\"),\n                          Ipv4AddressHelper(\"10.2.1.0\", \"255.255.255.0\"),\n                          Ipv4AddressHelper(\"10.3.1.0\", \"255.255.255.0\"));\n\n    NS_LOG_INFO(\"Initialize Global Routing.\");\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Install apps in left and right nodes\n    uint16_t port = 50000;\n    Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n    ApplicationContainer sinkApps;\n    for (uint32_t i = 0; i < d.RightCount(); ++i)\n    {\n        sinkHelper.SetAttribute(\"Protocol\", TypeIdValue(TcpSocketFactory::GetTypeId()));\n        sinkApps.Add(sinkHelper.Install(d.GetRight(i)));\n    }\n    sinkApps.Start(Seconds(0.0));\n    sinkApps.Stop(Seconds(stop_time));\n\n    for (uint32_t i = 0; i < d.LeftCount(); ++i)\n    {\n        // Create an on/off app sending packets to the left side\n        AddressValue remoteAddress(InetSocketAddress(d.GetRightIpv4Address(i), port));\n        Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(tcp_adu_size));\n        BulkSendHelper ftp(\"ns3::TcpSocketFactory\", Address());\n        ftp.SetAttribute(\"Remote\", remoteAddress);\n        ftp.SetAttribute(\"SendSize\", UintegerValue(tcp_adu_size));\n        ftp.SetAttribute(\"MaxBytes\", UintegerValue(data_mbytes * 1000000));\n\n        ApplicationContainer clientApp = ftp.Install(d.GetLeft(i));\n        clientApp.Start(Seconds(start_time * i)); // Start after sink\n        clientApp.Stop(Seconds(stop_time - 3));   // Stop before the sink\n    }\n\n    // Flow monitor\n    FlowMonitorHelper flowHelper;\n    if (flow_monitor)\n    {\n        flowHelper.InstallAll();\n    }\n\n    // Count RX packets\n    for (uint32_t i = 0; i < d.RightCount(); ++i)\n    {\n        rxPkts.push_back(0);\n        Ptr<PacketSink> pktSink = DynamicCast<PacketSink>(sinkApps.Get(i));\n        pktSink->TraceConnectWithoutContext(\"Rx\", MakeBoundCallback(&CountRxPkts, i));\n    }\n\n    Simulator::Stop(Seconds(stop_time));\n    Simulator::Run();\n\n    if (flow_monitor)\n    {\n        flowHelper.SerializeToXmlFile(prefix_file_name + \".flowmonitor\", true, true);\n    }\n\n    if (transport_prot == \"ns3::TcpRlTimeBased\" or transport_prot == \"ns3::TcpRlEventBased\")\n    {\n        openGymInterface->NotifySimulationEnd();\n    }\n\n    PrintRxCount();\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/rl-tcp/use-gym/tcp-rl-env.cc",
      "code": "/*\n * Copyright (c) 2018 Technische Universit\u00e4t Berlin\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Piotr Gawlowicz <gawlowicz@tkn.tu-berlin.de>\n * Modify: Muyuan Shen <muyuan_shen@hust.edu.cn>\n */\n\n#include \"tcp-rl-env.h\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/object.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/tcp-header.h\"\n#include \"ns3/tcp-socket-base.h\"\n\n#include <numeric>\n#include <vector>\n\nnamespace ns3\n{\n\nNS_LOG_COMPONENT_DEFINE(\"tcp-rl-env-gym\");\n\nNS_OBJECT_ENSURE_REGISTERED(TcpEnvBase);\n\nTcpEnvBase::TcpEnvBase()\n{\n    NS_LOG_FUNCTION(this);\n    SetOpenGymInterface(OpenGymInterface::Get());\n}\n\nTcpEnvBase::~TcpEnvBase()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nTypeId\nTcpEnvBase::GetTypeId()\n{\n    static TypeId tid = TypeId(\"ns3::TcpEnvBase\").SetParent<OpenGymEnv>().SetGroupName(\"Ns3Ai\");\n\n    return tid;\n}\n\nvoid\nTcpEnvBase::DoDispose()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nTcpEnvBase::SetNodeId(uint32_t id)\n{\n    NS_LOG_FUNCTION(this);\n    m_nodeId = id;\n}\n\nvoid\nTcpEnvBase::SetSocketUuid(uint32_t id)\n{\n    NS_LOG_FUNCTION(this);\n    m_socketUuid = id;\n}\n\nstd::string\nTcpEnvBase::GetTcpCongStateName(const TcpSocketState::TcpCongState_t state)\n{\n    std::string stateName = \"UNKNOWN\";\n    switch (state)\n    {\n    case TcpSocketState::CA_OPEN:\n        stateName = \"CA_OPEN\";\n        break;\n    case TcpSocketState::CA_DISORDER:\n        stateName = \"CA_DISORDER\";\n        break;\n    case TcpSocketState::CA_CWR:\n        stateName = \"CA_CWR\";\n        break;\n    case TcpSocketState::CA_RECOVERY:\n        stateName = \"CA_RECOVERY\";\n        break;\n    case TcpSocketState::CA_LOSS:\n        stateName = \"CA_LOSS\";\n        break;\n    case TcpSocketState::CA_LAST_STATE:\n        stateName = \"CA_LAST_STATE\";\n        break;\n    default:\n        stateName = \"UNKNOWN\";\n        break;\n    }\n    return stateName;\n}\n\nstd::string\nTcpEnvBase::GetTcpCAEventName(const TcpSocketState::TcpCAEvent_t event)\n{\n    std::string eventName = \"UNKNOWN\";\n    switch (event)\n    {\n    case TcpSocketState::CA_EVENT_TX_START:\n        eventName = \"CA_EVENT_TX_START\";\n        break;\n    case TcpSocketState::CA_EVENT_CWND_RESTART:\n        eventName = \"CA_EVENT_CWND_RESTART\";\n        break;\n    case TcpSocketState::CA_EVENT_COMPLETE_CWR:\n        eventName = \"CA_EVENT_COMPLETE_CWR\";\n        break;\n    case TcpSocketState::CA_EVENT_LOSS:\n        eventName = \"CA_EVENT_LOSS\";\n        break;\n    case TcpSocketState::CA_EVENT_ECN_NO_CE:\n        eventName = \"CA_EVENT_ECN_NO_CE\";\n        break;\n    case TcpSocketState::CA_EVENT_ECN_IS_CE:\n        eventName = \"CA_EVENT_ECN_IS_CE\";\n        break;\n    case TcpSocketState::CA_EVENT_DELAYED_ACK:\n        eventName = \"CA_EVENT_DELAYED_ACK\";\n        break;\n    case TcpSocketState::CA_EVENT_NON_DELAYED_ACK:\n        eventName = \"CA_EVENT_NON_DELAYED_ACK\";\n        break;\n    default:\n        eventName = \"UNKNOWN\";\n        break;\n    }\n    return eventName;\n}\n\n/*\nDefine action space\n*/\nPtr<OpenGymSpace>\nTcpEnvBase::GetActionSpace()\n{\n    // new_ssThresh\n    // new_cWnd\n    uint32_t parameterNum = 2;\n    float low = 0.0;\n    float high = 65535;\n    std::vector<uint32_t> shape = {\n        parameterNum,\n    };\n    std::string dtype = TypeNameGet<uint32_t>();\n\n    Ptr<OpenGymBoxSpace> box = CreateObject<OpenGymBoxSpace>(low, high, shape, dtype);\n    NS_LOG_INFO(\"MyGetActionSpace: \" << box);\n    return box;\n}\n\n/*\nDefine game over condition\n*/\nbool\nTcpEnvBase::GetGameOver()\n{\n    return false;\n}\n\n/*\nDefine reward function\n*/\nfloat\nTcpEnvBase::GetReward()\n{\n    NS_LOG_INFO(\"MyGetReward: \" << m_envReward);\n    return m_envReward;\n}\n\n/*\nDefine extra info. Optional\n*/\nstd::string\nTcpEnvBase::GetExtraInfo()\n{\n    NS_LOG_INFO(\"MyGetExtraInfo: \" << m_info);\n    return m_info;\n}\n\n/*\nExecute received actions\n*/\nbool\nTcpEnvBase::ExecuteActions(Ptr<OpenGymDataContainer> action)\n{\n    Ptr<OpenGymBoxContainer<uint32_t>> box = DynamicCast<OpenGymBoxContainer<uint32_t>>(action);\n    m_new_ssThresh = box->GetValue(0);\n    m_new_cWnd = box->GetValue(1);\n\n    NS_LOG_INFO(\"MyExecuteActions: \" << action);\n    return true;\n}\n\nNS_OBJECT_ENSURE_REGISTERED(TcpTimeStepEnv);\n\nTcpTimeStepEnv::TcpTimeStepEnv()\n    : TcpEnvBase()\n{\n    NS_LOG_FUNCTION(this);\n    m_envReward = 0.0;\n}\n\nvoid\nTcpTimeStepEnv::ScheduleNextStateRead()\n{\n    NS_LOG_FUNCTION(this);\n    Simulator::Schedule(m_timeStep, &TcpTimeStepEnv::ScheduleNextStateRead, this);\n    Notify();\n}\n\nTcpTimeStepEnv::~TcpTimeStepEnv()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nTypeId\nTcpTimeStepEnv::GetTypeId()\n{\n    static TypeId tid = TypeId(\"ns3::TcpTimeStepEnv\")\n                            .SetParent<TcpEnvBase>()\n                            .SetGroupName(\"Ns3Ai\")\n                            .AddConstructor<TcpTimeStepEnv>()\n                            .AddAttribute(\"StepTime\",\n                                          \"Step interval used in TCP env. Default: 100ms\",\n                                          TimeValue(MilliSeconds(100)),\n                                          MakeTimeAccessor(&TcpTimeStepEnv::m_timeStep),\n                                          MakeTimeChecker());\n\n    return tid;\n}\n\nvoid\nTcpTimeStepEnv::DoDispose()\n{\n    NS_LOG_FUNCTION(this);\n}\n\n/*\nDefine observation space\n*/\nPtr<OpenGymSpace>\nTcpTimeStepEnv::GetObservationSpace()\n{\n    // socket unique ID\n    // tcp env type: event-based = 0 / time-based = 1\n    // sim time in us\n    // node ID\n    // ssThresh\n    // cWnd\n    // segmentSize\n    // bytesInFlightSum\n    // bytesInFlightAvg\n    // segmentsAckedSum\n    // segmentsAckedAvg\n    // avgRtt\n    // minRtt\n    // avgInterTx\n    // avgInterRx\n    // throughput\n    uint32_t parameterNum = 16;\n    float low = 0.0;\n    float high = 1000000000.0;\n    std::vector<uint32_t> shape = {\n        parameterNum,\n    };\n    std::string dtype = TypeNameGet<uint64_t>();\n\n    Ptr<OpenGymBoxSpace> box = CreateObject<OpenGymBoxSpace>(low, high, shape, dtype);\n    NS_LOG_INFO(\"MyGetObservationSpace: \" << box);\n    return box;\n}\n\n/*\nCollect observations\n*/\nPtr<OpenGymDataContainer>\nTcpTimeStepEnv::GetObservation()\n{\n    uint32_t parameterNum = 16;\n    std::vector<uint32_t> shape = {\n        parameterNum,\n    };\n\n    Ptr<OpenGymBoxContainer<uint64_t>> box = CreateObject<OpenGymBoxContainer<uint64_t>>(shape);\n\n    box->AddValue(m_socketUuid);\n    box->AddValue(1);\n    box->AddValue(Simulator::Now().GetMicroSeconds());\n    box->AddValue(m_nodeId);\n    box->AddValue(m_tcb->m_ssThresh);\n    box->AddValue(m_tcb->m_cWnd);\n    box->AddValue(m_tcb->m_segmentSize);\n\n    // bytesInFlightSum\n    uint64_t bytesInFlightSum = std::accumulate(m_bytesInFlight.begin(), m_bytesInFlight.end(), 0);\n    box->AddValue(bytesInFlightSum);\n\n    // bytesInFlightAvg\n    uint64_t bytesInFlightAvg = 0;\n    if (!m_bytesInFlight.empty())\n    {\n        bytesInFlightAvg = bytesInFlightSum / m_bytesInFlight.size();\n    }\n    box->AddValue(bytesInFlightAvg);\n\n    // segmentsAckedSum\n    uint64_t segmentsAckedSum = std::accumulate(m_segmentsAcked.begin(), m_segmentsAcked.end(), 0);\n    box->AddValue(segmentsAckedSum);\n\n    // segmentsAckedAvg\n    uint64_t segmentsAckedAvg = 0;\n    if (!m_segmentsAcked.empty())\n    {\n        segmentsAckedAvg = segmentsAckedSum / m_segmentsAcked.size();\n    }\n    box->AddValue(segmentsAckedAvg);\n\n    // avgRtt\n    Time avgRtt = Seconds(0.0);\n    if (m_rttSampleNum)\n    {\n        avgRtt = m_rttSum / m_rttSampleNum;\n    }\n    box->AddValue(avgRtt.GetMicroSeconds());\n\n    // m_minRtt\n    box->AddValue(m_tcb->m_minRtt.GetMicroSeconds());\n\n    // avgInterTx\n    Time avgInterTx = Seconds(0.0);\n    if (m_interTxTimeNum)\n    {\n        avgInterTx = m_interTxTimeSum / m_interTxTimeNum;\n    }\n    box->AddValue(avgInterTx.GetMicroSeconds());\n\n    // avgInterRx\n    Time avgInterRx = Seconds(0.0);\n    if (m_interRxTimeNum)\n    {\n        avgInterRx = m_interRxTimeSum / m_interRxTimeNum;\n    }\n    box->AddValue(avgInterRx.GetMicroSeconds());\n\n    // throughput  bytes/s\n    float throughput = (segmentsAckedSum * m_tcb->m_segmentSize) / m_timeStep.GetSeconds();\n    box->AddValue(throughput);\n\n    // Print data\n    NS_LOG_INFO(\"MyGetObservation: \" << box);\n\n    m_bytesInFlight.clear();\n    m_segmentsAcked.clear();\n\n    m_rttSampleNum = 0;\n    m_rttSum = MicroSeconds(0.0);\n\n    m_interTxTimeNum = 0;\n    m_interTxTimeSum = MicroSeconds(0.0);\n\n    m_interRxTimeNum = 0;\n    m_interRxTimeSum = MicroSeconds(0.0);\n\n    return box;\n}\n\nvoid\nTcpTimeStepEnv::TxPktTrace(Ptr<const Packet>, const TcpHeader&, Ptr<const TcpSocketBase>)\n{\n    NS_LOG_FUNCTION(this);\n    if (m_lastPktTxTime > MicroSeconds(0.0))\n    {\n        Time interTxTime = Simulator::Now() - m_lastPktTxTime;\n        m_interTxTimeSum += interTxTime;\n        m_interTxTimeNum++;\n    }\n\n    m_lastPktTxTime = Simulator::Now();\n}\n\nvoid\nTcpTimeStepEnv::RxPktTrace(Ptr<const Packet>, const TcpHeader&, Ptr<const TcpSocketBase>)\n{\n    NS_LOG_FUNCTION(this);\n    if (m_lastPktRxTime > MicroSeconds(0.0))\n    {\n        Time interRxTime = Simulator::Now() - m_lastPktRxTime;\n        m_interRxTimeSum += interRxTime;\n        m_interRxTimeNum++;\n    }\n\n    m_lastPktRxTime = Simulator::Now();\n}\n\nuint32_t\nTcpTimeStepEnv::GetSsThresh(Ptr<const TcpSocketState> tcb, uint32_t bytesInFlight)\n{\n    NS_LOG_FUNCTION(this);\n    NS_LOG_INFO(Simulator::Now() << \" Node: \" << m_nodeId\n                                 << \" GetSsThresh, BytesInFlight: \" << bytesInFlight);\n    m_tcb = tcb;\n    m_bytesInFlight.push_back(bytesInFlight);\n\n    if (!m_started)\n    {\n        m_started = true;\n        //        Notify();\n        ScheduleNextStateRead();\n    }\n\n    // action\n    return m_new_ssThresh;\n}\n\nvoid\nTcpTimeStepEnv::IncreaseWindow(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked)\n{\n    NS_LOG_FUNCTION(this);\n    NS_LOG_INFO(Simulator::Now() << \" Node: \" << m_nodeId\n                                 << \" IncreaseWindow, SegmentsAcked: \" << segmentsAcked);\n    m_tcb = tcb;\n    m_segmentsAcked.push_back(segmentsAcked);\n    m_bytesInFlight.push_back(tcb->m_bytesInFlight);\n\n    if (!m_started)\n    {\n        m_started = true;\n        //        Notify();\n        ScheduleNextStateRead();\n    }\n    // action\n    tcb->m_cWnd = m_new_cWnd;\n}\n\nvoid\nTcpTimeStepEnv::PktsAcked(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked, const Time& rtt)\n{\n    NS_LOG_FUNCTION(this);\n    NS_LOG_INFO(Simulator::Now() << \" Node: \" << m_nodeId << \" PktsAcked, SegmentsAcked: \"\n                                 << segmentsAcked << \" Rtt: \" << rtt);\n    m_tcb = tcb;\n    m_rttSum += rtt;\n    m_rttSampleNum++;\n}\n\nvoid\nTcpTimeStepEnv::CongestionStateSet(Ptr<TcpSocketState> tcb,\n                                   const TcpSocketState::TcpCongState_t newState)\n{\n    NS_LOG_FUNCTION(this);\n    std::string stateName = GetTcpCongStateName(newState);\n    NS_LOG_INFO(Simulator::Now() << \" Node: \" << m_nodeId << \" CongestionStateSet: \" << newState\n                                 << \" \" << stateName);\n    m_tcb = tcb;\n}\n\nvoid\nTcpTimeStepEnv::CwndEvent(Ptr<TcpSocketState> tcb, const TcpSocketState::TcpCAEvent_t event)\n{\n    NS_LOG_FUNCTION(this);\n    std::string eventName = GetTcpCAEventName(event);\n    NS_LOG_INFO(Simulator::Now() << \" Node: \" << m_nodeId << \" CwndEvent: \" << event << \" \"\n                                 << eventName);\n    m_tcb = tcb;\n}\n\nNS_OBJECT_ENSURE_REGISTERED(TcpEventBasedEnv);\n\nTcpEventBasedEnv::TcpEventBasedEnv()\n    : TcpEnvBase()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nTcpEventBasedEnv::~TcpEventBasedEnv()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nTypeId\nTcpEventBasedEnv::GetTypeId()\n{\n    static TypeId tid = TypeId(\"ns3::TcpEventBasedEnv\")\n                            .SetParent<TcpEnvBase>()\n                            .SetGroupName(\"Ns3Ai\")\n                            .AddConstructor<TcpEventBasedEnv>();\n\n    return tid;\n}\n\nvoid\nTcpEventBasedEnv::DoDispose()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nTcpEventBasedEnv::SetReward(float value)\n{\n    NS_LOG_FUNCTION(this);\n    m_reward = value;\n}\n\nvoid\nTcpEventBasedEnv::SetPenalty(float value)\n{\n    NS_LOG_FUNCTION(this);\n    m_penalty = value;\n}\n\n/*\nDefine observation space\n*/\nPtr<OpenGymSpace>\nTcpEventBasedEnv::GetObservationSpace()\n{\n    // socket unique ID\n    // tcp env type: event-based = 0 / time-based = 1\n    // sim time in us\n    // node ID\n    // ssThresh\n    // cWnd\n    // segmentSize\n    // segmentsAcked\n    // bytesInFlight\n    // rtt in us\n    // min rtt in us\n    // called func\n    // congetsion algorithm (CA) state\n    // CA event\n    // ECN state\n    uint32_t parameterNum = 15;\n    float low = 0.0;\n    float high = 1000000000.0;\n    std::vector<uint32_t> shape = {\n        parameterNum,\n    };\n    std::string dtype = TypeNameGet<uint64_t>();\n\n    Ptr<OpenGymBoxSpace> box = CreateObject<OpenGymBoxSpace>(low, high, shape, dtype);\n    NS_LOG_INFO(\"MyGetObservationSpace: \" << box);\n    return box;\n}\n\n/*\nCollect observations\n*/\nPtr<OpenGymDataContainer>\nTcpEventBasedEnv::GetObservation()\n{\n    uint32_t parameterNum = 15;\n    std::vector<uint32_t> shape = {\n        parameterNum,\n    };\n\n    Ptr<OpenGymBoxContainer<uint64_t>> box = CreateObject<OpenGymBoxContainer<uint64_t>>(shape);\n\n    box->AddValue(m_socketUuid);\n    box->AddValue(0);\n    box->AddValue(Simulator::Now().GetMicroSeconds());\n    box->AddValue(m_nodeId);\n    box->AddValue(m_tcb->m_ssThresh);\n    box->AddValue(m_tcb->m_cWnd);\n    box->AddValue(m_tcb->m_segmentSize);\n    box->AddValue(m_segmentsAcked);\n    box->AddValue(m_bytesInFlight);\n    box->AddValue(m_rtt.GetMicroSeconds());\n    box->AddValue(m_tcb->m_minRtt.GetMicroSeconds());\n    box->AddValue(m_calledFunc);\n    box->AddValue(m_tcb->m_congState);\n    box->AddValue(m_event);\n    box->AddValue(m_tcb->m_ecnState);\n\n    // Print data\n    NS_LOG_INFO(\"MyGetObservation: \" << box);\n    return box;\n}\n\nvoid\nTcpEventBasedEnv::TxPktTrace(Ptr<const Packet>, const TcpHeader&, Ptr<const TcpSocketBase>)\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nTcpEventBasedEnv::RxPktTrace(Ptr<const Packet>, const TcpHeader&, Ptr<const TcpSocketBase>)\n{\n    NS_LOG_FUNCTION(this);\n}\n\nuint32_t\nTcpEventBasedEnv::GetSsThresh(Ptr<const TcpSocketState> tcb, uint32_t bytesInFlight)\n{\n    NS_LOG_FUNCTION(this);\n    // pkt was lost, so penalty\n    m_envReward = m_penalty;\n\n    NS_LOG_INFO(Simulator::Now() << \" Node: \" << m_nodeId\n                                 << \" GetSsThresh, BytesInFlight: \" << bytesInFlight);\n    m_calledFunc = CalledFunc_t::GET_SS_THRESH;\n    m_info = \"GetSsThresh\";\n    m_tcb = tcb;\n    m_bytesInFlight = bytesInFlight;\n    Notify();\n    return m_new_ssThresh;\n}\n\nvoid\nTcpEventBasedEnv::IncreaseWindow(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked)\n{\n    NS_LOG_FUNCTION(this);\n    // pkt was acked, so reward\n    m_envReward = m_reward;\n\n    NS_LOG_INFO(Simulator::Now() << \" Node: \" << m_nodeId\n                                 << \" IncreaseWindow, SegmentsAcked: \" << segmentsAcked);\n    m_calledFunc = CalledFunc_t::INCREASE_WINDOW;\n    m_info = \"IncreaseWindow\";\n    m_tcb = tcb;\n    m_segmentsAcked = segmentsAcked;\n    Notify();\n    tcb->m_cWnd = m_new_cWnd;\n}\n\nvoid\nTcpEventBasedEnv::PktsAcked(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked, const Time& rtt)\n{\n    NS_LOG_FUNCTION(this);\n    NS_LOG_INFO(Simulator::Now() << \" Node: \" << m_nodeId << \" PktsAcked, SegmentsAcked: \"\n                                 << segmentsAcked << \" Rtt: \" << rtt);\n    m_calledFunc = CalledFunc_t::PKTS_ACKED;\n    m_info = \"PktsAcked\";\n    m_tcb = tcb;\n    m_segmentsAcked = segmentsAcked;\n    m_rtt = rtt;\n}\n\nvoid\nTcpEventBasedEnv::CongestionStateSet(Ptr<TcpSocketState> tcb,\n                                     const TcpSocketState::TcpCongState_t newState)\n{\n    NS_LOG_FUNCTION(this);\n    std::string stateName = GetTcpCongStateName(newState);\n    NS_LOG_INFO(Simulator::Now() << \" Node: \" << m_nodeId << \" CongestionStateSet: \" << newState\n                                 << \" \" << stateName);\n\n    m_calledFunc = CalledFunc_t::CONGESTION_STATE_SET;\n    m_info = \"CongestionStateSet\";\n    m_tcb = tcb;\n}\n\nvoid\nTcpEventBasedEnv::CwndEvent(Ptr<TcpSocketState> tcb, const TcpSocketState::TcpCAEvent_t event)\n{\n    NS_LOG_FUNCTION(this);\n    std::string eventName = GetTcpCAEventName(event);\n    NS_LOG_INFO(Simulator::Now() << \" Node: \" << m_nodeId << \" CwndEvent: \" << event << \" \"\n                                 << eventName);\n\n    m_calledFunc = CalledFunc_t::CWND_EVENT;\n    m_info = \"CwndEvent\";\n    m_tcb = tcb;\n    m_event = event;\n}\n\n} // namespace ns3\n"
    },
    {
      "file_path": "examples/rl-tcp/use-gym/tcp-rl.cc",
      "code": "/*\n * Copyright (c) 2018 Technische Universit\u00e4t Berlin\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Piotr Gawlowicz <gawlowicz@tkn.tu-berlin.de>\n * Modify: Muyuan Shen <muyuan_shen@hust.edu.cn>\n */\n\n#include \"tcp-rl.h\"\n\n#include \"tcp-rl-env.h\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/node-list.h\"\n#include \"ns3/object.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/tcp-header.h\"\n#include \"ns3/tcp-l4-protocol.h\"\n#include \"ns3/tcp-socket-base.h\"\n\nnamespace ns3\n{\n\nNS_LOG_COMPONENT_DEFINE(\"tcp-rl-gym\");\n\nNS_OBJECT_ENSURE_REGISTERED(TcpSocketDerived);\n\nTypeId\nTcpSocketDerived::GetTypeId()\n{\n    static TypeId tid = TypeId(\"ns3::TcpSocketDerived\")\n                            .SetParent<TcpSocketBase>()\n                            .SetGroupName(\"Internet\")\n                            .AddConstructor<TcpSocketDerived>();\n    return tid;\n}\n\nTypeId\nTcpSocketDerived::GetInstanceTypeId() const\n{\n    return TcpSocketDerived::GetTypeId();\n}\n\nTcpSocketDerived::TcpSocketDerived()\n{\n}\n\nPtr<TcpCongestionOps>\nTcpSocketDerived::GetCongestionControlAlgorithm()\n{\n    return m_congestionControl;\n}\n\nTcpSocketDerived::~TcpSocketDerived()\n{\n}\n\nNS_OBJECT_ENSURE_REGISTERED(TcpRlBase);\n\nTypeId\nTcpRlBase::GetTypeId()\n{\n    static TypeId tid = TypeId(\"ns3::TcpRlBase\")\n                            .SetParent<TcpCongestionOps>()\n                            .SetGroupName(\"Internet\")\n                            .AddConstructor<TcpRlBase>();\n    return tid;\n}\n\nTcpRlBase::TcpRlBase()\n    : TcpCongestionOps()\n{\n    NS_LOG_FUNCTION(this);\n    m_tcpSocket = nullptr;\n    m_TcpEnvBase = nullptr;\n}\n\nTcpRlBase::TcpRlBase(const TcpRlBase& sock)\n    : TcpCongestionOps(sock)\n{\n    NS_LOG_FUNCTION(this);\n    m_tcpSocket = nullptr;\n    m_TcpEnvBase = nullptr;\n}\n\nTcpRlBase::~TcpRlBase()\n{\n    m_tcpSocket = nullptr;\n    m_TcpEnvBase = nullptr;\n}\n\nuint64_t\nTcpRlBase::GenerateUuid()\n{\n    static uint64_t uuid = 0;\n    uuid++;\n    return uuid;\n}\n\nvoid\nTcpRlBase::CreateGymEnv()\n{\n    NS_LOG_FUNCTION(this);\n    // should never be called, only child classes: TcpRlEventBased and TcpRlTimeBased\n}\n\nvoid\nTcpRlBase::ConnectSocketCallbacks()\n{\n    NS_LOG_FUNCTION(this);\n\n    bool foundSocket = false;\n    for (NodeList::Iterator i = NodeList::Begin(); i != NodeList::End(); ++i)\n    {\n        Ptr<Node> node = *i;\n        Ptr<TcpL4Protocol> tcp = node->GetObject<TcpL4Protocol>();\n\n        ObjectVectorValue socketVec;\n        tcp->GetAttribute(\"SocketList\", socketVec);\n        NS_LOG_DEBUG(\"Node: \" << node->GetId() << \" TCP socket num: \" << socketVec.GetN());\n\n        uint32_t sockNum = socketVec.GetN();\n        for (uint32_t j = 0; j < sockNum; j++)\n        {\n            Ptr<Object> sockObj = socketVec.Get(j);\n            Ptr<TcpSocketBase> tcpSocket = DynamicCast<TcpSocketBase>(sockObj);\n            NS_LOG_DEBUG(\"Node: \" << node->GetId() << \" TCP Socket: \" << tcpSocket);\n            if (!tcpSocket)\n            {\n                continue;\n            }\n\n            Ptr<TcpSocketDerived> dtcpSocket = StaticCast<TcpSocketDerived>(tcpSocket);\n            Ptr<TcpCongestionOps> ca = dtcpSocket->GetCongestionControlAlgorithm();\n            NS_LOG_DEBUG(\"CA name: \" << ca->GetName());\n            Ptr<TcpRlBase> rlCa = DynamicCast<TcpRlBase>(ca);\n            if (rlCa == this)\n            {\n                NS_LOG_DEBUG(\"Found TcpRl CA!\");\n                foundSocket = true;\n                m_tcpSocket = tcpSocket;\n                break;\n            }\n        }\n\n        if (foundSocket)\n        {\n            break;\n        }\n    }\n\n    NS_ASSERT_MSG(m_tcpSocket, \"TCP socket was not found.\");\n\n    if (m_tcpSocket)\n    {\n        NS_LOG_DEBUG(\"Found TCP Socket: \" << m_tcpSocket);\n        m_tcpSocket->TraceConnectWithoutContext(\n            \"Tx\",\n            MakeCallback(&TcpEnvBase::TxPktTrace, m_TcpEnvBase));\n        m_tcpSocket->TraceConnectWithoutContext(\n            \"Rx\",\n            MakeCallback(&TcpEnvBase::RxPktTrace, m_TcpEnvBase));\n        NS_LOG_DEBUG(\"Connect socket callbacks \" << m_tcpSocket->GetNode()->GetId());\n        m_TcpEnvBase->SetNodeId(m_tcpSocket->GetNode()->GetId());\n    }\n}\n\nstd::string\nTcpRlBase::GetName() const\n{\n    return \"TcpRlBase\";\n}\n\nuint32_t\nTcpRlBase::GetSsThresh(Ptr<const TcpSocketState> state, uint32_t bytesInFlight)\n{\n    NS_LOG_FUNCTION(this << state << bytesInFlight);\n\n    if (!m_TcpEnvBase)\n    {\n        CreateGymEnv();\n    }\n\n    uint32_t newSsThresh = 0;\n    if (m_TcpEnvBase)\n    {\n        newSsThresh = m_TcpEnvBase->GetSsThresh(state, bytesInFlight);\n    }\n\n    return newSsThresh;\n}\n\nvoid\nTcpRlBase::IncreaseWindow(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked)\n{\n    NS_LOG_FUNCTION(this << tcb << segmentsAcked);\n\n    if (!m_TcpEnvBase)\n    {\n        CreateGymEnv();\n    }\n\n    if (m_TcpEnvBase)\n    {\n        m_TcpEnvBase->IncreaseWindow(tcb, segmentsAcked);\n    }\n}\n\nvoid\nTcpRlBase::PktsAcked(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked, const Time& rtt)\n{\n    NS_LOG_FUNCTION(this);\n\n    if (!m_TcpEnvBase)\n    {\n        CreateGymEnv();\n    }\n\n    if (m_TcpEnvBase)\n    {\n        m_TcpEnvBase->PktsAcked(tcb, segmentsAcked, rtt);\n    }\n}\n\nvoid\nTcpRlBase::CongestionStateSet(Ptr<TcpSocketState> tcb,\n                              const TcpSocketState::TcpCongState_t newState)\n{\n    NS_LOG_FUNCTION(this);\n\n    if (!m_TcpEnvBase)\n    {\n        CreateGymEnv();\n    }\n\n    if (m_TcpEnvBase)\n    {\n        m_TcpEnvBase->CongestionStateSet(tcb, newState);\n    }\n}\n\nvoid\nTcpRlBase::CwndEvent(Ptr<TcpSocketState> tcb, const TcpSocketState::TcpCAEvent_t event)\n{\n    NS_LOG_FUNCTION(this);\n\n    if (!m_TcpEnvBase)\n    {\n        CreateGymEnv();\n    }\n\n    if (m_TcpEnvBase)\n    {\n        m_TcpEnvBase->CwndEvent(tcb, event);\n    }\n}\n\nPtr<TcpCongestionOps>\nTcpRlBase::Fork()\n{\n    return CopyObject<TcpRlBase>(this);\n}\n\nNS_OBJECT_ENSURE_REGISTERED(TcpRlTimeBased);\n\nTypeId\nTcpRlTimeBased::GetTypeId()\n{\n    static TypeId tid = TypeId(\"ns3::TcpRlTimeBased\")\n                            .SetParent<TcpRlBase>()\n                            .SetGroupName(\"Internet\")\n                            .AddConstructor<TcpRlTimeBased>();\n    return tid;\n}\n\nTcpRlTimeBased::TcpRlTimeBased()\n    : TcpRlBase()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nTcpRlTimeBased::TcpRlTimeBased(const TcpRlTimeBased& sock)\n    : TcpRlBase(sock)\n{\n    NS_LOG_FUNCTION(this);\n}\n\nTcpRlTimeBased::~TcpRlTimeBased()\n{\n}\n\nstd::string\nTcpRlTimeBased::GetName() const\n{\n    return \"TcpRlTimeBased\";\n}\n\nvoid\nTcpRlTimeBased::CreateGymEnv()\n{\n    NS_LOG_FUNCTION(this);\n    Ptr<TcpTimeStepEnv> env = CreateObject<TcpTimeStepEnv>();\n    env->SetSocketUuid(TcpRlBase::GenerateUuid());\n    m_TcpEnvBase = env;\n\n    ConnectSocketCallbacks();\n}\n\nNS_OBJECT_ENSURE_REGISTERED(TcpRlEventBased);\n\nTypeId\nTcpRlEventBased::GetTypeId()\n{\n    static TypeId tid = TypeId(\"ns3::TcpRlEventBased\")\n                            .SetParent<TcpRlBase>()\n                            .SetGroupName(\"Internet\")\n                            .AddConstructor<TcpRlEventBased>()\n                            .AddAttribute(\"Reward\",\n                                          \"Reward when increasing congestion window.\",\n                                          DoubleValue(1.0),\n                                          MakeDoubleAccessor(&TcpRlEventBased::m_reward),\n                                          MakeDoubleChecker<double>())\n                            .AddAttribute(\"Penalty\",\n                                          \"Penalty after a loss event.\",\n                                          DoubleValue(-10.0),\n                                          MakeDoubleAccessor(&TcpRlEventBased::m_penalty),\n                                          MakeDoubleChecker<double>());\n    return tid;\n}\n\nTcpRlEventBased::TcpRlEventBased()\n    : TcpRlBase()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nTcpRlEventBased::TcpRlEventBased(const TcpRlEventBased& sock)\n    : TcpRlBase(sock)\n{\n    NS_LOG_FUNCTION(this);\n}\n\nTcpRlEventBased::~TcpRlEventBased()\n{\n}\n\nstd::string\nTcpRlEventBased::GetName() const\n{\n    return \"TcpRlEventBased\";\n}\n\nvoid\nTcpRlEventBased::CreateGymEnv()\n{\n    NS_LOG_FUNCTION(this);\n    Ptr<TcpEventBasedEnv> env = CreateObject<TcpEventBasedEnv>();\n    env->SetSocketUuid(TcpRlBase::GenerateUuid());\n    env->SetReward(m_reward);\n    env->SetPenalty(m_penalty);\n    m_TcpEnvBase = env;\n\n    ConnectSocketCallbacks();\n}\n\n} // namespace ns3\n"
    },
    {
      "file_path": "examples/rl-tcp/use-msg/rl-tcp.cc",
      "code": "/*\n * Copyright (c) 2018 Piotr Gawlowicz\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Piotr Gawlowicz <gawlowicz.p@gmail.com>\n * Based on script: ./examples/tcp/tcp-variants-comparison.cc\n * Modify: Pengyu Liu <eic_lpy@hust.edu.cn>\n *         Hao Yin <haoyin@uw.edu>\n *         Muyuan Shen <muyuan_shen@hust.edu.cn>\n * Topology:\n *\n *   Left Leafs (Clients)                       Right Leafs (Sinks)\n *           |            \\                    /        |\n *           |             \\    bottleneck    /         |\n *           |              R0--------------R1          |\n *           |             /                  \\         |\n *           |   access   /                    \\ access |\n *\n */\n\n#include \"ns3/ai-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/error-model.h\"\n#include \"ns3/event-id.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-layout-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/tcp-header.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"rl-tcp-example\");\n\nstatic std::vector<uint32_t> rxPkts;\n\nstatic void\nCountRxPkts(uint32_t sinkId, Ptr<const Packet> packet, const Address& srcAddr)\n{\n    rxPkts[sinkId]++;\n}\n\nstatic void\nPrintRxCount()\n{\n    uint32_t size = rxPkts.size();\n    NS_LOG_UNCOND(\"RxPkts:\");\n    for (uint32_t i = 0; i < size; i++)\n    {\n        NS_LOG_UNCOND(\"---SinkId: \" << i << \" RxPkts: \" << rxPkts.at(i));\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double tcpEnvTimeStep = 0.1;\n    uint32_t nLeaf = 1;\n    std::string transport_prot = \"TcpRlTimeBased\";\n    double error_p = 0.0;\n    std::string bottleneck_bandwidth = \"2Mbps\";\n    std::string bottleneck_delay = \"0.01ms\";\n    std::string access_bandwidth = \"10Mbps\";\n    std::string access_delay = \"20ms\";\n    std::string prefix_file_name = \"TcpVariantsComparison\";\n    uint64_t data_mbytes = 0;\n    uint32_t mtu_bytes = 400;\n    double duration = 1000.0;\n    uint32_t run = 0;\n    bool flow_monitor = false;\n    bool sack = true;\n    std::string queue_disc_type = \"ns3::PfifoFastQueueDisc\";\n    std::string recovery = \"ns3::TcpClassicRecovery\";\n\n    CommandLine cmd;\n    // seed related\n    cmd.AddValue(\"simSeed\", \"Seed for random generator. Default: 0\", run);\n    // other\n    cmd.AddValue(\"envTimeStep\",\n                 \"Time step interval for TcpRlTimeBased. Default: 0.1s\",\n                 tcpEnvTimeStep);\n    cmd.AddValue(\"nLeaf\", \"Number of left and right side leaf nodes\", nLeaf);\n    cmd.AddValue(\"transport_prot\",\n                 \"Transport protocol to use: TcpNewReno, TcpHybla, TcpHighSpeed, TcpHtcp, \"\n                 \"TcpVegas, TcpScalable, TcpVeno, TcpBic, TcpYeah, TcpIllinois, TcpWestwood, \"\n                 \"TcpWestwoodPlus, TcpLedbat, TcpLp, TcpRlTimeBased, TcpRlEventBased\",\n                 transport_prot);\n    cmd.AddValue(\"error_p\", \"Packet error rate\", error_p);\n    cmd.AddValue(\"bottleneck_bandwidth\", \"Bottleneck bandwidth\", bottleneck_bandwidth);\n    cmd.AddValue(\"bottleneck_delay\", \"Bottleneck delay\", bottleneck_delay);\n    cmd.AddValue(\"access_bandwidth\", \"Access link bandwidth\", access_bandwidth);\n    cmd.AddValue(\"access_delay\", \"Access link delay\", access_delay);\n    cmd.AddValue(\"prefix_name\", \"Prefix of output trace file\", prefix_file_name);\n    cmd.AddValue(\"data\", \"Number of Megabytes of data to transmit\", data_mbytes);\n    cmd.AddValue(\"mtu\", \"Size of IP packets to send in bytes\", mtu_bytes);\n    cmd.AddValue(\"duration\", \"Time to allow flows to run in seconds\", duration);\n    cmd.AddValue(\"flow_monitor\", \"Enable flow monitor\", flow_monitor);\n    cmd.AddValue(\"queue_disc_type\",\n                 \"Queue disc type for gateway (e.g. ns3::CoDelQueueDisc)\",\n                 queue_disc_type);\n    cmd.AddValue(\"sack\", \"Enable or disable SACK option\", sack);\n    cmd.AddValue(\"recovery\", \"Recovery algorithm type to use (e.g., ns3::TcpPrrRecovery\", recovery);\n    cmd.Parse(argc, argv);\n\n    // There are two kinds of Tcp congestion control algorithm using RL:\n    // 1. TcpRlTimeBased\n    // 2. TcpRlEventBased\n    // The only difference is when interaction occurs (at fixed interval or at event).\n    if (transport_prot == \"TcpRlTimeBased\")\n    {\n        Config::SetDefault(\"ns3::TcpTimeStepEnv::StepTime\", TimeValue(Seconds(tcpEnvTimeStep)));\n    }\n\n    transport_prot = std::string(\"ns3::\") + transport_prot;\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\",\n                       TypeIdValue(TypeId::LookupByName(transport_prot)));\n\n    SeedManager::SetSeed(1);\n    SeedManager::SetRun(run);\n\n    NS_LOG_UNCOND(\"C++ side random seed: \" << run);\n    NS_LOG_UNCOND(\"Tcp version: \" << transport_prot);\n\n    // Calculate the ADU size\n    Header* temp_header = new Ipv4Header();\n    uint32_t ip_header = temp_header->GetSerializedSize();\n    NS_LOG_LOGIC(\"IP Header size is: \" << ip_header);\n    delete temp_header;\n    temp_header = new TcpHeader();\n    uint32_t tcp_header = temp_header->GetSerializedSize();\n    NS_LOG_LOGIC(\"TCP Header size is: \" << tcp_header);\n    delete temp_header;\n    uint32_t tcp_adu_size = mtu_bytes - 20 - (ip_header + tcp_header);\n    NS_LOG_LOGIC(\"TCP ADU size is: \" << tcp_adu_size);\n\n    // Set the simulation start and stop time\n    double start_time = 0.1;\n    double stop_time = start_time + duration;\n\n    // 4 MB of TCP buffer\n    Config::SetDefault(\"ns3::TcpSocket::RcvBufSize\", UintegerValue(1 << 21));\n    Config::SetDefault(\"ns3::TcpSocket::SndBufSize\", UintegerValue(1 << 21));\n    Config::SetDefault(\"ns3::TcpSocketBase::Sack\", BooleanValue(sack));\n    Config::SetDefault(\"ns3::TcpSocket::DelAckCount\", UintegerValue(2));\n\n    Config::SetDefault(\"ns3::TcpL4Protocol::RecoveryType\",\n                       TypeIdValue(TypeId::LookupByName(recovery)));\n\n    // Configure the error model\n    // Here we use RateErrorModel with packet error rate\n    Ptr<UniformRandomVariable> uv = CreateObject<UniformRandomVariable>();\n    uv->SetStream(50);\n    RateErrorModel error_model;\n    error_model.SetRandomVariable(uv);\n    error_model.SetUnit(RateErrorModel::ERROR_UNIT_PACKET);\n    error_model.SetRate(error_p);\n\n    // Create the point-to-point link helpers\n    PointToPointHelper bottleNeckLink;\n    bottleNeckLink.SetDeviceAttribute(\"DataRate\", StringValue(bottleneck_bandwidth));\n    bottleNeckLink.SetChannelAttribute(\"Delay\", StringValue(bottleneck_delay));\n    // bottleNeckLink.SetDeviceAttribute  (\"ReceiveErrorModel\", PointerValue (&error_model));\n\n    PointToPointHelper pointToPointLeaf;\n    pointToPointLeaf.SetDeviceAttribute(\"DataRate\", StringValue(access_bandwidth));\n    pointToPointLeaf.SetChannelAttribute(\"Delay\", StringValue(access_delay));\n\n    PointToPointDumbbellHelper d(nLeaf, pointToPointLeaf, nLeaf, pointToPointLeaf, bottleNeckLink);\n\n    // Install IP stack\n    InternetStackHelper stack;\n    stack.InstallAll();\n\n    // Traffic Control\n    TrafficControlHelper tchPfifo;\n    tchPfifo.SetRootQueueDisc(\"ns3::PfifoFastQueueDisc\");\n\n    TrafficControlHelper tchCoDel;\n    tchCoDel.SetRootQueueDisc(\"ns3::CoDelQueueDisc\");\n\n    DataRate access_b(access_bandwidth);\n    DataRate bottle_b(bottleneck_bandwidth);\n    Time access_d(access_delay);\n    Time bottle_d(bottleneck_delay);\n\n    uint32_t size = static_cast<uint32_t>((std::min(access_b, bottle_b).GetBitRate() / 8) *\n                                          ((access_d + bottle_d + access_d) * 2).GetSeconds());\n\n    Config::SetDefault(\"ns3::PfifoFastQueueDisc::MaxSize\",\n                       QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, size / mtu_bytes)));\n    Config::SetDefault(\"ns3::CoDelQueueDisc::MaxSize\",\n                       QueueSizeValue(QueueSize(QueueSizeUnit::BYTES, size)));\n\n    if (queue_disc_type == \"ns3::PfifoFastQueueDisc\")\n    {\n        tchPfifo.Install(d.GetLeft()->GetDevice(1));\n        tchPfifo.Install(d.GetRight()->GetDevice(1));\n    }\n    else if (queue_disc_type == \"ns3::CoDelQueueDisc\")\n    {\n        tchCoDel.Install(d.GetLeft()->GetDevice(1));\n        tchCoDel.Install(d.GetRight()->GetDevice(1));\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Queue not recognized. Allowed values are ns3::CoDelQueueDisc or \"\n                       \"ns3::PfifoFastQueueDisc\");\n    }\n\n    // Assign IP Addresses\n    d.AssignIpv4Addresses(Ipv4AddressHelper(\"10.1.1.0\", \"255.255.255.0\"),\n                          Ipv4AddressHelper(\"10.2.1.0\", \"255.255.255.0\"),\n                          Ipv4AddressHelper(\"10.3.1.0\", \"255.255.255.0\"));\n\n    NS_LOG_INFO(\"Initialize Global Routing.\");\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Install apps in left and right nodes\n    uint16_t port = 50000;\n    Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n    ApplicationContainer sinkApps;\n    for (uint32_t i = 0; i < d.RightCount(); ++i)\n    {\n        sinkHelper.SetAttribute(\"Protocol\", TypeIdValue(TcpSocketFactory::GetTypeId()));\n        sinkApps.Add(sinkHelper.Install(d.GetRight(i)));\n    }\n    sinkApps.Start(Seconds(0.0));\n    sinkApps.Stop(Seconds(stop_time));\n\n    for (uint32_t i = 0; i < d.LeftCount(); ++i)\n    {\n        // Create an on/off app sending packets to the left side\n        AddressValue remoteAddress(InetSocketAddress(d.GetRightIpv4Address(i), port));\n        Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(tcp_adu_size));\n        BulkSendHelper ftp(\"ns3::TcpSocketFactory\", Address());\n        ftp.SetAttribute(\"Remote\", remoteAddress);\n        ftp.SetAttribute(\"SendSize\", UintegerValue(tcp_adu_size));\n        ftp.SetAttribute(\"MaxBytes\", UintegerValue(data_mbytes * 1000000));\n\n        ApplicationContainer clientApp = ftp.Install(d.GetLeft(i));\n        clientApp.Start(Seconds(start_time * i)); // Start after sink\n        clientApp.Stop(Seconds(stop_time - 3));   // Stop before the sink\n    }\n\n    // Flow monitor\n    FlowMonitorHelper flowHelper;\n    if (flow_monitor)\n    {\n        flowHelper.InstallAll();\n    }\n\n    // Count RX packets\n    for (uint32_t i = 0; i < d.RightCount(); ++i)\n    {\n        rxPkts.push_back(0);\n        Ptr<PacketSink> pktSink = DynamicCast<PacketSink>(sinkApps.Get(i));\n        pktSink->TraceConnectWithoutContext(\"Rx\", MakeBoundCallback(&CountRxPkts, i));\n    }\n\n    Simulator::Stop(Seconds(stop_time));\n    Simulator::Run();\n\n    if (flow_monitor)\n    {\n        flowHelper.SerializeToXmlFile(prefix_file_name + \".flowmonitor\", true, true);\n    }\n\n    PrintRxCount();\n    Simulator::Destroy();\n    return 0;\n}\n"
    },
    {
      "file_path": "examples/rl-tcp/use-msg/tcp-rl.cc",
      "code": "/*\n * Copyright (c) 2018 Technische Universit\u00e4t Berlin\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Piotr Gawlowicz <gawlowicz@tkn.tu-berlin.de>\n * Modify: Pengyu Liu <eic_lpy@hust.edu.cn>\n *         Hao Yin <haoyin@uw.edu>\n *         Muyuan Shen <muyuan_shen@hust.edu.cn>\n */\n\n#include \"tcp-rl.h\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/log.h\"\n#include \"ns3/node-list.h\"\n#include \"ns3/object.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/tcp-header.h\"\n#include \"ns3/tcp-l4-protocol.h\"\n#include \"ns3/tcp-socket-base.h\"\n\nnamespace ns3\n{\n\nNS_LOG_COMPONENT_DEFINE(\"tcp-rl-msg\");\n\nNS_OBJECT_ENSURE_REGISTERED(TcpSocketDerived);\n\nTypeId\nTcpSocketDerived::GetTypeId()\n{\n    static TypeId tid = TypeId(\"ns3::TcpSocketDerived\")\n                            .SetParent<TcpSocketBase>()\n                            .SetGroupName(\"Internet\")\n                            .AddConstructor<TcpSocketDerived>();\n    return tid;\n}\n\nTypeId\nTcpSocketDerived::GetInstanceTypeId() const\n{\n    return TcpSocketDerived::GetTypeId();\n}\n\nTcpSocketDerived::TcpSocketDerived()\n{\n}\n\nPtr<TcpCongestionOps>\nTcpSocketDerived::GetCongestionControlAlgorithm()\n{\n    return m_congestionControl;\n}\n\nTcpSocketDerived::~TcpSocketDerived()\n{\n}\n\n/////////////////////////////////////////////////////////////////////////\n\nNS_OBJECT_ENSURE_REGISTERED(TcpRlTimeBased);\n\nTcpRlTimeBased::TcpRlTimeBased()\n    : TcpCongestionOps()\n{\n    NS_LOG_FUNCTION(this);\n    //  std::cerr << \"in TcpRlTimeBased (void), this = \" << this << std::endl;\n}\n\nTcpRlTimeBased::TcpRlTimeBased(const TcpRlTimeBased& sock)\n    : TcpCongestionOps(sock)\n{\n    NS_LOG_FUNCTION(this);\n    //  std::cerr << \"in TcpRlTimeBased (const TcpRlTimeBased &sock), this = \" << this << std::endl;\n}\n\nTcpRlTimeBased::~TcpRlTimeBased()\n{\n    //  std::cerr << \"in ~TcpRlTimeBased (void), this = \" << this << std::endl;\n}\n\nTypeId\nTcpRlTimeBased::GetTypeId()\n{\n    static TypeId tid = TypeId(\"ns3::TcpRlTimeBased\")\n                            .SetParent<TcpSocketBase>()\n                            .AddConstructor<TcpRlTimeBased>()\n                            .SetGroupName(\"Internet\");\n    return tid;\n}\n\nuint64_t\nTcpRlTimeBased::GenerateUuid()\n{\n    static uint64_t uuid = 0;\n    uuid++;\n    return uuid;\n}\n\nvoid\nTcpRlTimeBased::CreateEnv()\n{\n    //  std::cerr << \"in CreateEnv (), this = \" << this << std::endl;\n    NS_LOG_FUNCTION(this);\n    env = CreateObject<TcpTimeStepEnv>();\n    //  std::cerr << \"CreateEnv\" << (env == nullptr) << std::endl;\n    env->SetSocketUuid(TcpRlTimeBased::GenerateUuid());\n\n    ConnectSocketCallbacks();\n}\n\nvoid\nTcpRlTimeBased::ConnectSocketCallbacks()\n{\n    //  std::cerr << \"in ConnectSocketCallbacks (), this = \" << this << std::endl;\n    NS_LOG_FUNCTION(this);\n\n    bool foundSocket = false;\n    for (NodeList::Iterator i = NodeList::Begin(); i != NodeList::End(); ++i)\n    {\n        Ptr<Node> node = *i;\n        Ptr<TcpL4Protocol> tcp = node->GetObject<TcpL4Protocol>();\n\n        ObjectVectorValue socketVec;\n        tcp->GetAttribute(\"SocketList\", socketVec);\n        NS_LOG_DEBUG(\"Node: \" << node->GetId() << \" TCP socket num: \" << socketVec.GetN());\n\n        uint32_t sockNum = socketVec.GetN();\n        for (uint32_t j = 0; j < sockNum; j++)\n        {\n            Ptr<Object> sockObj = socketVec.Get(j);\n            Ptr<TcpSocketBase> tcpSocket = DynamicCast<TcpSocketBase>(sockObj);\n            NS_LOG_DEBUG(\"Node: \" << node->GetId() << \" TCP Socket: \" << tcpSocket);\n            if (!tcpSocket)\n            {\n                continue;\n            }\n\n            Ptr<TcpSocketDerived> dtcpSocket = StaticCast<TcpSocketDerived>(tcpSocket);\n            Ptr<TcpCongestionOps> ca = dtcpSocket->GetCongestionControlAlgorithm();\n            NS_LOG_DEBUG(\"CA name: \" << ca->GetName());\n            Ptr<TcpRlTimeBased> rlCa = DynamicCast<TcpRlTimeBased>(ca);\n            if (rlCa == this)\n            {\n                NS_LOG_DEBUG(\"Found TcpRl CA!\");\n                foundSocket = true;\n                //              m_tcpSocket = tcpSocket;\n                m_tcpSocket = PeekPointer(tcpSocket);\n                break;\n            }\n        }\n\n        if (foundSocket)\n        {\n            break;\n        }\n    }\n\n    NS_ASSERT_MSG(m_tcpSocket, \"TCP socket was not found.\");\n\n    if (m_tcpSocket)\n    {\n        NS_LOG_DEBUG(\"Found TCP Socket: \" << m_tcpSocket);\n        m_tcpSocket->TraceConnectWithoutContext(\"Tx\",\n                                                MakeCallback(&TcpTimeStepEnv::TxPktTrace, env));\n        m_tcpSocket->TraceConnectWithoutContext(\"Rx\",\n                                                MakeCallback(&TcpTimeStepEnv::RxPktTrace, env));\n        NS_LOG_DEBUG(\"Connect socket callbacks \" << m_tcpSocket->GetNode()->GetId());\n        env->SetNodeId(m_tcpSocket->GetNode()->GetId());\n    }\n}\n\nstd::string\nTcpRlTimeBased::GetName() const\n{\n    return \"TcpRlTimeBased\";\n}\n\nuint32_t\nTcpRlTimeBased::GetSsThresh(Ptr<const TcpSocketState> state, uint32_t bytesInFlight)\n{\n    NS_LOG_FUNCTION(this << state << bytesInFlight);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n\n    uint32_t newSsThresh = env->GetSsThresh(state, bytesInFlight);\n\n    return newSsThresh;\n}\n\nvoid\nTcpRlTimeBased::IncreaseWindow(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked)\n{\n    NS_LOG_FUNCTION(this << tcb << segmentsAcked);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n    env->IncreaseWindow(tcb, segmentsAcked);\n}\n\nvoid\nTcpRlTimeBased::PktsAcked(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked, const Time& rtt)\n{\n    NS_LOG_FUNCTION(this);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n    env->PktsAcked(tcb, segmentsAcked, rtt);\n}\n\nvoid\nTcpRlTimeBased::CongestionStateSet(Ptr<TcpSocketState> tcb,\n                                   const TcpSocketState::TcpCongState_t newState)\n{\n    NS_LOG_FUNCTION(this);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n    env->CongestionStateSet(tcb, newState);\n}\n\nvoid\nTcpRlTimeBased::CwndEvent(Ptr<TcpSocketState> tcb, const TcpSocketState::TcpCAEvent_t event)\n{\n    NS_LOG_FUNCTION(this);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n    env->CwndEvent(tcb, event);\n}\n\nPtr<TcpCongestionOps>\nTcpRlTimeBased::Fork()\n{\n    //  std::cerr << \"in TcpRlTimeBased::Fork (), this = \" << this << std::endl;\n    return CopyObject<TcpRlTimeBased>(this);\n}\n\nNS_OBJECT_ENSURE_REGISTERED(TcpRlEventBased);\n\nTypeId\nTcpRlEventBased::GetTypeId()\n{\n    static TypeId tid = TypeId(\"ns3::TcpRlEventBased\")\n                            .SetParent<TcpSocketBase>()\n                            .AddConstructor<TcpRlEventBased>()\n                            .SetGroupName(\"Internet\");\n    return tid;\n}\n\nTcpRlEventBased::TcpRlEventBased()\n    : TcpCongestionOps()\n{\n}\n\nTcpRlEventBased::TcpRlEventBased(const TcpRlEventBased& sock)\n    : TcpCongestionOps(sock)\n{\n}\n\nTcpRlEventBased::~TcpRlEventBased()\n{\n}\n\nstd::string\nTcpRlEventBased::GetName() const\n{\n    return \"TcpRlEventBased\";\n}\n\nuint32_t\nTcpRlEventBased::GetSsThresh(Ptr<const TcpSocketState> state, uint32_t bytesInFlight)\n{\n    NS_LOG_FUNCTION(this << state << bytesInFlight);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n\n    uint32_t newSsThresh = env->GetSsThresh(state, bytesInFlight);\n\n    return newSsThresh;\n}\n\nvoid\nTcpRlEventBased::IncreaseWindow(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked)\n{\n    NS_LOG_FUNCTION(this << tcb << segmentsAcked);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n    env->IncreaseWindow(tcb, segmentsAcked);\n}\n\nvoid\nTcpRlEventBased::PktsAcked(Ptr<TcpSocketState> tcb, uint32_t segmentsAcked, const Time& rtt)\n{\n    NS_LOG_FUNCTION(this);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n    env->PktsAcked(tcb, segmentsAcked, rtt);\n}\n\nvoid\nTcpRlEventBased::CongestionStateSet(Ptr<TcpSocketState> tcb,\n                                    const TcpSocketState::TcpCongState_t newState)\n{\n    NS_LOG_FUNCTION(this);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n    env->CongestionStateSet(tcb, newState);\n}\n\nvoid\nTcpRlEventBased::CwndEvent(Ptr<TcpSocketState> tcb, const TcpSocketState::TcpCAEvent_t event)\n{\n    NS_LOG_FUNCTION(this);\n    if (!m_cbConnect)\n    {\n        m_cbConnect = true;\n        CreateEnv();\n    }\n    env->CwndEvent(tcb, event);\n}\n\nPtr<TcpCongestionOps>\nTcpRlEventBased::Fork()\n{\n    return CopyObject<TcpRlEventBased>(this);\n}\n\nuint64_t\nTcpRlEventBased::GenerateUuid()\n{\n    static uint64_t uuid = 0;\n    uuid++;\n    return uuid;\n}\n\nvoid\nTcpRlEventBased::CreateEnv()\n{\n    //  std::cerr << \"in CreateEnv (), this = \" << this << std::endl;\n    NS_LOG_FUNCTION(this);\n    env = CreateObject<TcpEventBasedEnv>();\n    std::cerr << \"CreateEnv\" << (env == nullptr) << std::endl;\n    env->SetSocketUuid(TcpRlEventBased::GenerateUuid());\n\n    ConnectSocketCallbacks();\n}\n\nvoid\nTcpRlEventBased::ConnectSocketCallbacks()\n{\n    //  std::cerr << \"in ConnectSocketCallbacks (), this = \" << this << std::endl;\n    NS_LOG_FUNCTION(this);\n\n    bool foundSocket = false;\n    for (NodeList::Iterator i = NodeList::Begin(); i != NodeList::End(); ++i)\n    {\n        Ptr<Node> node = *i;\n        Ptr<TcpL4Protocol> tcp = node->GetObject<TcpL4Protocol>();\n\n        ObjectVectorValue socketVec;\n        tcp->GetAttribute(\"SocketList\", socketVec);\n        NS_LOG_DEBUG(\"Node: \" << node->GetId() << \" TCP socket num: \" << socketVec.GetN());\n\n        uint32_t sockNum = socketVec.GetN();\n        for (uint32_t j = 0; j < sockNum; j++)\n        {\n            Ptr<Object> sockObj = socketVec.Get(j);\n            Ptr<TcpSocketBase> tcpSocket = DynamicCast<TcpSocketBase>(sockObj);\n            NS_LOG_DEBUG(\"Node: \" << node->GetId() << \" TCP Socket: \" << tcpSocket);\n            if (!tcpSocket)\n            {\n                continue;\n            }\n\n            Ptr<TcpSocketDerived> dtcpSocket = StaticCast<TcpSocketDerived>(tcpSocket);\n            Ptr<TcpCongestionOps> ca = dtcpSocket->GetCongestionControlAlgorithm();\n            NS_LOG_DEBUG(\"CA name: \" << ca->GetName());\n            Ptr<TcpRlEventBased> rlCa = DynamicCast<TcpRlEventBased>(ca);\n            if (rlCa == this)\n            {\n                NS_LOG_DEBUG(\"Found TcpRl CA!\");\n                foundSocket = true;\n                //              m_tcpSocket = tcpSocket;\n                m_tcpSocket = PeekPointer(tcpSocket);\n                break;\n            }\n        }\n\n        if (foundSocket)\n        {\n            break;\n        }\n    }\n\n    NS_ASSERT_MSG(m_tcpSocket, \"TCP socket was not found.\");\n\n    if (m_tcpSocket)\n    {\n        NS_LOG_DEBUG(\"Found TCP Socket: \" << m_tcpSocket);\n        m_tcpSocket->TraceConnectWithoutContext(\"Tx\",\n                                                MakeCallback(&TcpEventBasedEnv::TxPktTrace, env));\n        m_tcpSocket->TraceConnectWithoutContext(\"Rx\",\n                                                MakeCallback(&TcpEventBasedEnv::RxPktTrace, env));\n        NS_LOG_DEBUG(\"Connect socket callbacks \" << m_tcpSocket->GetNode()->GetId());\n        env->SetNodeId(m_tcpSocket->GetNode()->GetId());\n    }\n}\n\n} // namespace ns3\n"
    },
    {
      "file_path": "model/gym-interface/cpp/spaces.cc",
      "code": "/*\n * Copyright (c) 2018 Piotr Gawlowicz\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author: Piotr Gawlowicz <gawlowicz.p@gmail.com>\n * Modify: Muyuan Shen <muyuan_shen@hust.edu.cn>\n *\n */\n\n#include \"spaces.h\"\n\n#include \"ns3/log.h\"\n#include \"ns3/object.h\"\n\nnamespace ns3\n{\n\nNS_LOG_COMPONENT_DEFINE(\"OpenGymSpace\");\nNS_OBJECT_ENSURE_REGISTERED(OpenGymSpace);\n\nTypeId\nOpenGymSpace::GetTypeId()\n{\n    static TypeId tid = TypeId(\"OpenGymSpace\").SetParent<Object>().SetGroupName(\"OpenGym\");\n    return tid;\n}\n\nOpenGymSpace::OpenGymSpace()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nOpenGymSpace::~OpenGymSpace()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nOpenGymSpace::DoDispose()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nOpenGymSpace::DoInitialize()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nTypeId\nOpenGymDiscreteSpace::GetTypeId()\n{\n    static TypeId tid = TypeId(\"OpenGymDiscreteSpace\")\n                            .SetParent<OpenGymSpace>()\n                            .SetGroupName(\"OpenGym\")\n                            .AddConstructor<OpenGymDiscreteSpace>();\n    return tid;\n}\n\nOpenGymDiscreteSpace::OpenGymDiscreteSpace()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nOpenGymDiscreteSpace::OpenGymDiscreteSpace(int n)\n    : m_n(n)\n{\n    NS_LOG_FUNCTION(this);\n}\n\nOpenGymDiscreteSpace::~OpenGymDiscreteSpace()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nOpenGymDiscreteSpace::DoDispose()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nOpenGymDiscreteSpace::DoInitialize()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nint\nOpenGymDiscreteSpace::GetN()\n{\n    NS_LOG_FUNCTION(this);\n    return m_n;\n}\n\nns3_ai_gym::SpaceDescription\nOpenGymDiscreteSpace::GetSpaceDescription()\n{\n    NS_LOG_FUNCTION(this);\n    ns3_ai_gym::SpaceDescription desc;\n    desc.set_type(ns3_ai_gym::Discrete);\n    ns3_ai_gym::DiscreteSpace discreteSpace;\n    discreteSpace.set_n(GetN());\n    desc.mutable_space()->PackFrom(discreteSpace);\n    return desc;\n}\n\nvoid\nOpenGymDiscreteSpace::Print(std::ostream& where) const\n{\n    where << \" DiscreteSpace N: \" << m_n;\n}\n\nTypeId\nOpenGymBoxSpace::GetTypeId()\n{\n    static TypeId tid = TypeId(\"OpenGymBoxSpace\")\n                            .SetParent<OpenGymSpace>()\n                            .SetGroupName(\"OpenGym\")\n                            .AddConstructor<OpenGymBoxSpace>();\n    return tid;\n}\n\nOpenGymBoxSpace::OpenGymBoxSpace()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nOpenGymBoxSpace::OpenGymBoxSpace(float low,\n                                 float high,\n                                 std::vector<uint32_t> shape,\n                                 std::string dtype)\n    : m_low(low),\n      m_high(high),\n      m_shape(shape),\n      m_dtypeName(dtype)\n{\n    NS_LOG_FUNCTION(this);\n    SetDtype();\n}\n\nOpenGymBoxSpace::OpenGymBoxSpace(std::vector<float> low,\n                                 std::vector<float> high,\n                                 std::vector<uint32_t> shape,\n                                 std::string dtype)\n    : m_low(0),\n      m_high(0),\n      m_shape(shape),\n      m_dtypeName(dtype),\n      m_lowVec(low),\n      m_highVec(high)\n\n{\n    NS_LOG_FUNCTION(this);\n    SetDtype();\n}\n\nOpenGymBoxSpace::~OpenGymBoxSpace()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nOpenGymBoxSpace::DoDispose()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nOpenGymBoxSpace::DoInitialize()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nOpenGymBoxSpace::SetDtype()\n{\n    std::string name = m_dtypeName;\n    if (name == \"int8_t\" || name == \"int16_t\" || name == \"int32_t\" || name == \"int64_t\")\n    {\n        m_dtype = ns3_ai_gym::INT;\n    }\n    else if (name == \"uint8_t\" || name == \"uint16_t\" || name == \"uint32_t\" || name == \"uint64_t\")\n    {\n        m_dtype = ns3_ai_gym::UINT;\n    }\n    else if (name == \"float\")\n    {\n        m_dtype = ns3_ai_gym::FLOAT;\n    }\n    else if (name == \"double\")\n    {\n        m_dtype = ns3_ai_gym::DOUBLE;\n    }\n    else\n    {\n        m_dtype = ns3_ai_gym::FLOAT;\n    }\n}\n\nfloat\nOpenGymBoxSpace::GetLow()\n{\n    NS_LOG_FUNCTION(this);\n    return m_low;\n}\n\nfloat\nOpenGymBoxSpace::GetHigh()\n{\n    NS_LOG_FUNCTION(this);\n    return m_high;\n}\n\nstd::vector<uint32_t>\nOpenGymBoxSpace::GetShape()\n{\n    NS_LOG_FUNCTION(this);\n    return m_shape;\n}\n\nns3_ai_gym::SpaceDescription\nOpenGymBoxSpace::GetSpaceDescription()\n{\n    NS_LOG_FUNCTION(this);\n    ns3_ai_gym::SpaceDescription desc;\n    desc.set_type(ns3_ai_gym::Box);\n\n    ns3_ai_gym::BoxSpace boxSpacePb;\n    boxSpacePb.set_low(GetLow());\n    boxSpacePb.set_high(GetHigh());\n\n    std::vector<uint32_t> shape = GetShape();\n    for (auto i = shape.begin(); i != shape.end(); ++i)\n    {\n        boxSpacePb.add_shape(*i);\n    }\n\n    boxSpacePb.set_dtype(m_dtype);\n    desc.mutable_space()->PackFrom(boxSpacePb);\n    return desc;\n}\n\nvoid\nOpenGymBoxSpace::Print(std::ostream& where) const\n{\n    where << \" BoxSpace Low: \" << m_low << \" High: \" << m_high << \" Shape: (\";\n\n    for (auto i = m_shape.begin(); i != m_shape.end(); ++i)\n    {\n        where << *i << \",\";\n    }\n    where << \") Dtype: \" << m_dtypeName;\n}\n\nTypeId\nOpenGymTupleSpace::GetTypeId()\n{\n    static TypeId tid = TypeId(\"OpenGymTupleSpace\")\n                            .SetParent<OpenGymSpace>()\n                            .SetGroupName(\"OpenGym\")\n                            .AddConstructor<OpenGymTupleSpace>();\n    return tid;\n}\n\nOpenGymTupleSpace::OpenGymTupleSpace()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nOpenGymTupleSpace::~OpenGymTupleSpace()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nOpenGymTupleSpace::DoDispose()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nOpenGymTupleSpace::DoInitialize()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nbool\nOpenGymTupleSpace::Add(Ptr<OpenGymSpace> space)\n{\n    NS_LOG_FUNCTION(this);\n    m_tuple.push_back(space);\n    return true;\n}\n\nPtr<OpenGymSpace>\nOpenGymTupleSpace::Get(uint32_t idx)\n{\n    NS_LOG_FUNCTION(this);\n    Ptr<OpenGymSpace> space;\n\n    if (idx < m_tuple.size())\n    {\n        space = m_tuple.at(idx);\n    }\n\n    return space;\n}\n\nns3_ai_gym::SpaceDescription\nOpenGymTupleSpace::GetSpaceDescription()\n{\n    NS_LOG_FUNCTION(this);\n    ns3_ai_gym::SpaceDescription desc;\n    desc.set_type(ns3_ai_gym::Tuple);\n\n    ns3_ai_gym::TupleSpace tupleSpacePb;\n\n    for (auto i = m_tuple.begin(); i != m_tuple.end(); ++i)\n    {\n        Ptr<OpenGymSpace> subSpace = *i;\n        ns3_ai_gym::SpaceDescription subDesc = subSpace->GetSpaceDescription();\n        tupleSpacePb.add_element()->CopyFrom(subDesc);\n    }\n\n    desc.mutable_space()->PackFrom(tupleSpacePb);\n    return desc;\n}\n\nvoid\nOpenGymTupleSpace::Print(std::ostream& where) const\n{\n    where << \" TupleSpace: \" << std::endl;\n\n    for (auto i = m_tuple.begin(); i != m_tuple.end(); ++i)\n    {\n        where << \"---\";\n        (*i)->Print(where);\n        where << std::endl;\n    }\n}\n\nTypeId\nOpenGymDictSpace::GetTypeId()\n{\n    static TypeId tid = TypeId(\"OpenGymDictSpace\")\n                            .SetParent<OpenGymSpace>()\n                            .SetGroupName(\"OpenGym\")\n                            .AddConstructor<OpenGymDictSpace>();\n    return tid;\n}\n\nOpenGymDictSpace::OpenGymDictSpace()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nOpenGymDictSpace::~OpenGymDictSpace()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nOpenGymDictSpace::DoDispose()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nvoid\nOpenGymDictSpace::DoInitialize()\n{\n    NS_LOG_FUNCTION(this);\n}\n\nbool\nOpenGymDictSpace::Add(std::string key, Ptr<OpenGymSpace> space)\n{\n    NS_LOG_FUNCTION(this);\n    m_dict.insert(std::pair<std::string, Ptr<OpenGymSpace>>(key, space));\n    return true;\n}\n\nPtr<OpenGymSpace>\nOpenGymDictSpace::Get(std::string key)\n{\n    NS_LOG_FUNCTION(this);\n    Ptr<OpenGymSpace> space;\n    std::map<std::string, Ptr<OpenGymSpace>>::iterator it = m_dict.find(key);\n    if (it != m_dict.end())\n    {\n        space = it->second;\n    }\n\n    return space;\n}\n\nns3_ai_gym::SpaceDescription\nOpenGymDictSpace::GetSpaceDescription()\n{\n    NS_LOG_FUNCTION(this);\n    ns3_ai_gym::SpaceDescription desc;\n    desc.set_type(ns3_ai_gym::Dict);\n\n    ns3_ai_gym::DictSpace dictSpacePb;\n\n    std::map<std::string, Ptr<OpenGymSpace>>::iterator it;\n    for (it = m_dict.begin(); it != m_dict.end(); ++it)\n    {\n        std::string name = it->first;\n        Ptr<OpenGymSpace> subSpace = it->second;\n\n        ns3_ai_gym::SpaceDescription subDesc = subSpace->GetSpaceDescription();\n        subDesc.set_name(name);\n\n        dictSpacePb.add_element()->CopyFrom(subDesc);\n    }\n\n    desc.mutable_space()->PackFrom(dictSpacePb);\n    return desc;\n}\n\nvoid\nOpenGymDictSpace::Print(std::ostream& where) const\n{\n    where << \" DictSpace: \" << std::endl;\n\n    std::map<std::string, Ptr<OpenGymSpace>> myMap = m_dict;\n    std::map<std::string, Ptr<OpenGymSpace>>::iterator it;\n    for (it = myMap.begin(); it != myMap.end(); ++it)\n    {\n        where << \"---\" << it->first << \":\";\n        it->second->Print(where);\n        where << std::endl;\n    }\n}\n\n} // namespace ns3\n"
    }
  ]
}