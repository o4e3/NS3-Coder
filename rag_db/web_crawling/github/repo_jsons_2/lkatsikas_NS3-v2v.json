{
  "repo_name": "lkatsikas/NS3-v2v",
  "github_url": "https://github.com/lkatsikas/NS3-v2v",
  "readme": "# NS3 - v2v\r\n\r\nNS-3 module for vehicular communications\r\n\r\n## Description\r\n\r\nSource code implementation based on \u201cImplementing clustering for vehicular ad hoc networks in NS 3\u201d\r\nas presented in  WNS3-2015 Call for papers\r\n\r\nv2v module is a custom ns-3 extension containing a clustering algorithm implementation for VANETs.\r\n\r\n## Getting Started\r\n\r\n### Dependencies\r\n\r\n* 3.21 version of NS-3 simulator\r\n\r\n\r\n### Building program\r\n\r\n```\r\n./waf configure --enable-examples`\r\n./waf\r\n```\r\n\r\n### Executing program\r\n\r\n```\r\n./waf --run v2v-clustering-example\r\n```\r\n\r\n\r\n## Authors\r\n\r\nContributors names and contact info\r\n\r\n* [lkatsikas](https://github.com/lkatsikas)\r\n\r\n## License\r\n\r\nThis project is licensed under the GNU License - see the LICENSE.md file for details\r\n\r\n\r\n",
  "examples": [
    {
      "file_path": "examples/v2v-clustering-example.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2015 University of Athens (UOA)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author:  - Lampros Katsikas <lkatsikas@di.uoa.gr>\n *          - Konstantinos Chatzikokolakis <kchatzi@di.uoa.gr>\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/ocb-wifi-mac.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wave-mac-helper.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/wifi-80211p-helper.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/v2v-control-client-helper.h\"\n#include \"ns3/v2v-mobility-model.h\"\n\n\n#define SIMULATION_TIME_FORMAT(s) Seconds(s)\n\n\nusing namespace ns3;\nNS_LOG_COMPONENT_DEFINE(\"V2vClusteringExample\");\n\n\nint main(int argc, char *argv[]) {\n\n    /*--------------------- Logging System Configuration -------------------*/\n    LogLevel logLevel = (LogLevel) (LOG_PREFIX_ALL | LOG_LEVEL_WARN);\n    LogComponentEnable(\"V2vClusteringExample\", logLevel);\n    LogComponentEnable(\"V2vControlClient\", logLevel);\n\n    NS_LOG_INFO(\"/------------------------------------------------\\\\\");\n    NS_LOG_INFO(\" - V2vClusteringExample [Example] -> Cluster vehicles communication\");\n    NS_LOG_INFO(\"\\\\------------------------------------------------/\");\n    /*----------------------------------------------------------------------*/\n\n    /*---------------------- Simulation Default Values ---------------------*/\n    std::string phyMode (\"OfdmRate6MbpsBW10MHz\");\n\n    uint16_t numberOfUes = 10;\n\n    double minimumTdmaSlot = 0.001;         /// Time difference between 2 transmissions\n    double clusterTimeMetric = 3.0;         /// Clustering Time Metric for Waiting Time calculation\n    double speedVariation = 5.0;\n    double incidentWindow = 30.0;\n\n    double simTime = 30.0;\n    /*----------------------------------------------------------------------*/\n\n\n    /*-------------------- Set explicitly default values -------------------*/\n    Config::SetDefault (\"ns3::WifiRemoteStationManager::FragmentationThreshold\",\n                            StringValue (\"2200\"));\n    // turn off RTS/CTS for frames below 2200 bytes\n    Config::SetDefault (\"ns3::WifiRemoteStationManager::RtsCtsThreshold\",\n                            StringValue (\"2200\"));\n    // Fix non-unicast data rate to be the same as that of unicast\n    Config::SetDefault (\"ns3::WifiRemoteStationManager::NonUnicastMode\",\n                            StringValue (phyMode));\n    /*----------------------------------------------------------------------*/\n\n\n    /*-------------------- Command Line Argument Values --------------------*/\n    CommandLine cmd;\n    cmd.AddValue(\"ueNumber\", \"Number of UE\", numberOfUes);\n    cmd.AddValue(\"simTime\", \"Simulation Time in Seconds\", simTime);\n\n    NS_LOG_INFO(\"\");\n    NS_LOG_INFO(\"|---\"<< \" SimTime -> \" << simTime <<\" ---|\\n\");\n    NS_LOG_INFO(\"|---\"<< \" Number of UE -> \" << numberOfUes <<\" ---|\\n\");\n    /*----------------------------------------------------------------------*/\n\n\n    /*------------------------- Create UEs-EnodeBs -------------------------*/\n    NodeContainer ueNodes;\n    ueNodes.Create(numberOfUes);\n\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    /*----------------------------------------------------------------------*/\n\n\n    /*-------------------- Install Mobility Model in Ue --------------------*/\n    MobilityHelper ueMobility;\n    ueMobility.SetMobilityModel (\"ns3::V2vMobilityModel\",\n         \"Mode\", StringValue (\"Time\"),\n         \"Time\", StringValue (\"40s\"),\n         \"Speed\", StringValue (\"ns3::ConstantRandomVariable[Constant=30.0]\"),\n         \"Bounds\", RectangleValue (Rectangle (0, 10000, -1000, 1000)));\n    ueMobility.Install(ueNodes);\n\n    /// Create a 3 line grid of vehicles\n    for (uint16_t i = 0; i < numberOfUes; i++)\n    {\n        if(i % 3 == 0){\n            ueNodes.Get (i)->GetObject<MobilityModel> ()->SetPosition (Vector (i*5, 0, 0));\n        }\n        else if(i % 3 == 1){\n            ueNodes.Get (i)->GetObject<MobilityModel> ()->SetPosition (Vector (i*5, 3, 0));\n        }\n        else{\n            ueNodes.Get (i)->GetObject<MobilityModel> ()->SetPosition (Vector (i*5, 6, 0));\n        }\n\n    }\n    /*----------------------------------------------------------------------*/\n\n\n    /*-------------------------- Setup Wifi nodes --------------------------*/\n    // The below set of helpers will help us to put together the wifi NICs we want\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default ();\n    Ptr<YansWifiChannel> channel = wifiChannel.Create ();\n\n    YansWifiPhyHelper wifiPhy =  YansWifiPhyHelper::Default ();\n    wifiPhy.SetChannel (channel);\n    wifiPhy.SetPcapDataLinkType (YansWifiPhyHelper::DLT_IEEE802_11);\n    wifiPhy.Set (\"TxPowerStart\", DoubleValue(32));\n    wifiPhy.Set (\"TxPowerEnd\", DoubleValue(32));\n    wifiPhy.Set (\"TxGain\", DoubleValue(12));\n    wifiPhy.Set (\"RxGain\", DoubleValue(12));\n    wifiPhy.Set (\"EnergyDetectionThreshold\", DoubleValue(-61.8));\n    wifiPhy.Set (\"CcaMode1Threshold\", DoubleValue(-64.8));\n\n    NqosWaveMacHelper wifi80211pMac = NqosWaveMacHelper::Default ();\n    Wifi80211pHelper wifi80211p = Wifi80211pHelper::Default ();\n    //wifi80211p.EnableLogComponents ();\n\n    wifi80211p.SetRemoteStationManager (\"ns3::ConstantRateWifiManager\",\n                                      \"DataMode\",StringValue (phyMode),\n                                      \"ControlMode\",StringValue (phyMode));\n    NetDeviceContainer wifiDevices1 = wifi80211p.Install (wifiPhy, wifi80211pMac, ueNodes);\n\n    NS_LOG_INFO (\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i1 = ipv4h.Assign (wifiDevices1);\n\n    uint16_t controlPort = 3999;\n    ApplicationContainer controlApps;\n\n    /**\n     * Setting Control Channel\n     */\n    for (uint32_t u = 0; u < ueNodes.GetN(); ++u) {\n\n        //!< Initial TDMA UE synchronization Function\n        double tdmaStart = (u+1)*minimumTdmaSlot;\n\n        Ptr<V2vMobilityModel> mobilityModel = ueNodes.Get(u)->GetObject<V2vMobilityModel>();\n        mobilityModel->SetSpeedVariation(speedVariation);\n        V2vControlClientHelper ueClient(\"ns3::UdpSocketFactory\", Address(InetSocketAddress(Ipv4Address::GetBroadcast(), controlPort)),\n                \"ns3::UdpSocketFactory\",InetSocketAddress(Ipv4Address::GetAny(), controlPort),\n                mobilityModel, tdmaStart, numberOfUes, minimumTdmaSlot, clusterTimeMetric);\n        ueClient.SetAttribute (\"IncidentWindow\", DoubleValue(incidentWindow));\n        controlApps.Add(ueClient.Install(ueNodes.Get(u)));\n    }\n\n    controlApps.Start (Seconds(0.1));\n    controlApps.Stop (Seconds(simTime-0.1));\n\n    AsciiTraceHelper ascii;\n    wifiPhy.EnableAsciiAll(ascii.CreateFileStream (\"src/v2v/examples/output/socket-options-ipv4.txt\"));\n    wifiPhy.EnablePcapAll (\"src/v2v/examples/output/socket.pcap\", false);\n\n    /*----------------------------------------------------------------------*/\n\n\n    /*---------------------- Simulation Stopping Time ----------------------*/\n    Simulator::Stop(SIMULATION_TIME_FORMAT(simTime));\n    /*----------------------------------------------------------------------*/\n\n    /*--------------------------- Simulation Run ---------------------------*/\n    Simulator::Run();\n    Simulator::Destroy();\n    /*----------------------------------------------------------------------*/\n\n    return EXIT_SUCCESS;\n}\n"
    },
    {
      "file_path": "helper/v2v-control-client-helper.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2015 University of Athens (UOA)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author:  - Lampros Katsikas <lkatsikas@di.uoa.gr>\n *          - Konstantinos Chatzikokolakis <kchatzi@di.uoa.gr>\n */\n\n#include \"ns3/names.h\"\n#include \"ns3/double.h\"\n#include \"ns3/string.h\"\n#include \"ns3/pointer.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/inet-socket-address.h\"\n#include \"ns3/v2v-control-client-helper.h\"\n#include \"ns3/packet-socket-address.h\"\n\nnamespace ns3 {\n\nV2vControlClientHelper::V2vControlClientHelper(std::string protocolLocal, Address addressLocal,\n    std::string protocolListeningLocal, Address addressListeningLocal,\n    Ptr<V2vMobilityModel> mobilityModel, double timeWindow, uint32_t maxUes, double minimumTdmaSlot, double clusterTimeMetric)\n{\n  m_factory.SetTypeId (\"ns3::V2vControlClient\");\n  m_factory.Set (\"ProtocolSendingLocal\", StringValue (protocolLocal));\n  m_factory.Set (\"SendingLocal\", AddressValue (addressLocal));\n  m_factory.Set (\"ProtocolListeningLocal\", StringValue (protocolListeningLocal));\n  m_factory.Set (\"ListeningLocal\", AddressValue (addressListeningLocal));\n\n  m_factory.Set (\"ClusterTimeMetric\", DoubleValue (clusterTimeMetric));\n  m_factory.Set (\"MinimumTdmaSlot\", DoubleValue (minimumTdmaSlot));\n  m_factory.Set (\"MaxUes\", UintegerValue (maxUes));\n  m_factory.Set (\"TimeWindow\", DoubleValue(timeWindow));\n  m_factory.Set (\"MobilityModel\", PointerValue (mobilityModel));\n}\n\nvoid\nV2vControlClientHelper::SetAttribute (std::string name, const AttributeValue &value)\n{\n  m_factory.Set (name, value);\n}\n\nApplicationContainer\nV2vControlClientHelper::Install (Ptr<Node> node) const\n{\n  return ApplicationContainer (InstallPriv (node));\n}\n\nApplicationContainer\nV2vControlClientHelper::Install (std::string nodeName) const\n{\n  Ptr<Node> node = Names::Find<Node> (nodeName);\n  return ApplicationContainer (InstallPriv (node));\n}\n\nApplicationContainer\nV2vControlClientHelper::Install (NodeContainer c) const\n{\n  ApplicationContainer apps;\n  for (NodeContainer::Iterator i = c.Begin (); i != c.End (); ++i)\n    {\n      apps.Add (InstallPriv (*i));\n    }\n\n  return apps;\n}\n\nPtr<Application>\nV2vControlClientHelper::InstallPriv (Ptr<Node> node) const\n{\n  Ptr<Application> app = m_factory.Create<V2vControlClient> ();\n  node->AddApplication (app);\n\n  return app;\n}\n\n} // namespace ns3\n"
    },
    {
      "file_path": "model/v2v-cluster-header.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2015 University of Athens (UOA)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author:  - Lampros Katsikas <lkatsikas@di.uoa.gr>\n *          - Konstantinos Chatzikokolakis <kchatzi@di.uoa.gr>\n */\n\n#include \"ns3/simulator.h\"\n#include \"v2v-cluster-header.h\"\n\nNS_LOG_COMPONENT_DEFINE (\"V2vClusterHeader\");\n\nnamespace ns3 {\n\nNS_OBJECT_ENSURE_REGISTERED(V2vClusterInfoHeader);\n\nV2vClusterInfoHeader::V2vClusterInfoHeader() :\n   m_seq(0){\n   NS_LOG_FUNCTION (this);\n}\n\nV2vClusterInfoHeader::~V2vClusterInfoHeader(){\n   NS_LOG_FUNCTION (this);\n}\n\nvoid\nV2vClusterInfoHeader::SetSeq(uint64_t seq) {\n   NS_LOG_FUNCTION (this << seq);\n   m_seq = seq;\n}\n\nuint64_t\nV2vClusterInfoHeader::GetSeq(void) const {\n   NS_LOG_FUNCTION (this);\n   return m_seq;\n}\n\nvoid\nV2vClusterInfoHeader::SetMobilityInfo(V2vClusterSap::NeighborInfo mobilityInfo){\n   NS_LOG_FUNCTION (this << mobilityInfo.imsi);\n   m_mobilityInfo = mobilityInfo;\n}\n\nV2vClusterSap::NeighborInfo\nV2vClusterInfoHeader::GetMobilityInfo(void) const {\n   NS_LOG_FUNCTION (this);\n   return m_mobilityInfo;\n}\n\nTypeId\nV2vClusterInfoHeader::GetTypeId(void) {\n   static TypeId tid = TypeId(\"ns3::V2vClusterInfoHeader\").SetParent<Header>().AddConstructor<V2vClusterInfoHeader>();\n   return tid;\n}\n\nTypeId\nV2vClusterInfoHeader::GetInstanceTypeId(void) const {\n   return GetTypeId();\n}\n\nvoid\nV2vClusterInfoHeader::Print(std::ostream &os) const {\n   NS_LOG_FUNCTION (this << &os);\n   os << \"(seq=\" << m_seq\n           << \"IMSI=\" << m_mobilityInfo.imsi\n           << \"ClusterId=\" << m_mobilityInfo.clusterId\n           << \"Degree=\" << m_mobilityInfo.degree\n           << \"Position=\" << m_mobilityInfo.position\n           << \"Velocity=\" << m_mobilityInfo.velocity\n           << \"Direction=\" << m_mobilityInfo.direction <<\")\";\n}\n\nuint32_t\nV2vClusterInfoHeader::GetSerializedSize(void) const {\n   NS_LOG_FUNCTION (this);\n   return sizeof(uint64_t) + sizeof(V2vClusterSap::NeighborInfo);\n}\n\nvoid\nV2vClusterInfoHeader::Serialize(Buffer::Iterator start) const {\n   NS_LOG_FUNCTION (this << &start);\n\n   Buffer::Iterator i = start;\n   i.WriteHtonU64(m_seq);\n\n   // Write mobility structure\n   unsigned char temp[sizeof(V2vClusterSap::NeighborInfo)];\n   memcpy( temp, &m_mobilityInfo, sizeof(V2vClusterSap::NeighborInfo) );\n   i.Write(temp, sizeof(V2vClusterSap::NeighborInfo));\n\n}\n\nuint32_t\nV2vClusterInfoHeader::Deserialize(Buffer::Iterator start) {\n   NS_LOG_INFO (this << &start);\n\n   Buffer::Iterator i = start;\n   m_seq = i.ReadNtohU64();\n\n   unsigned char temp[sizeof(V2vClusterSap::NeighborInfo)];\n   i.Read(temp, sizeof(V2vClusterSap::NeighborInfo));\n   memcpy(&m_mobilityInfo, &temp, sizeof(V2vClusterSap::NeighborInfo));\n\n   return GetSerializedSize();\n}\n\n\n/////////////////////////////////////////////////////////////////////\nNS_OBJECT_ENSURE_REGISTERED(V2vInitiateClusterHeader);\n\n\nV2vInitiateClusterHeader::V2vInitiateClusterHeader() :\n        m_clusterId(0),\n        m_ts(Simulator::Now().GetTimeStep()),\n        m_seq(0){\n    NS_LOG_FUNCTION (this);\n}\n\nV2vInitiateClusterHeader::~V2vInitiateClusterHeader(){\n    NS_LOG_FUNCTION (this);\n}\n\nTime\nV2vInitiateClusterHeader::GetTs(void) const {\n    NS_LOG_FUNCTION (this);\n    return TimeStep(m_ts);\n}\n\nvoid\nV2vInitiateClusterHeader::SetSeq(uint64_t seq) {\n    NS_LOG_FUNCTION (this << seq);\n    m_seq = seq;\n}\nuint64_t\nV2vInitiateClusterHeader::GetSeq(void) const {\n    NS_LOG_FUNCTION (this);\n    return m_seq;\n}\n\nvoid\nV2vInitiateClusterHeader::SetClusterId(uint64_t clusterId){\n    NS_LOG_FUNCTION (this << clusterId);\n    m_clusterId = clusterId;\n}\n\nuint64_t\nV2vInitiateClusterHeader::GetClusterId(void) const {\n    NS_LOG_FUNCTION (this);\n    return m_clusterId;\n}\n\nTypeId\nV2vInitiateClusterHeader::GetTypeId(void) {\n    static TypeId tid =\n            TypeId(\"ns3::V2vInitiateClusterHeader\").SetParent<Header>().AddConstructor<V2vInitiateClusterHeader>();\n    return tid;\n}\n\nTypeId\nV2vInitiateClusterHeader::GetInstanceTypeId(void) const {\n    return GetTypeId();\n}\n\nvoid\nV2vInitiateClusterHeader::Print(std::ostream &os) const {\n    NS_LOG_FUNCTION (this << &os);\n    os << \"(time=\" << TimeStep(m_ts).GetSeconds() << \" ClusterId=\" << m_clusterId << \" Seq=\" << m_seq <<\")\";\n}\n\nuint32_t\nV2vInitiateClusterHeader::GetSerializedSize(void) const {\n    NS_LOG_FUNCTION (this);\n    return sizeof(uint64_t) + sizeof(uint64_t) + sizeof(uint64_t);\n}\n\nvoid\nV2vInitiateClusterHeader::Serialize(Buffer::Iterator start) const {\n    NS_LOG_FUNCTION (this << &start);\n\n    Buffer::Iterator i = start;\n    i.WriteHtonU64(m_clusterId);\n    i.WriteHtonU64(m_ts);\n    i.WriteHtonU64(m_seq);\n}\n\nuint32_t\nV2vInitiateClusterHeader::Deserialize(Buffer::Iterator start) {\n    NS_LOG_INFO (this << &start);\n\n    Buffer::Iterator i = start;\n    m_clusterId = i.ReadNtohU64 ();\n    m_ts = i.ReadNtohU64 ();\n    m_seq = i.ReadNtohU64 ();\n\n    return GetSerializedSize();\n}\n\n\n/////////////////////////////////////////////////////////////////////\nNS_OBJECT_ENSURE_REGISTERED(V2vFormClusterHeader);\n\nV2vFormClusterHeader::V2vFormClusterHeader() :\n        m_seq(0){\n    NS_LOG_FUNCTION (this);\n}\n\nV2vFormClusterHeader::~V2vFormClusterHeader(){\n    NS_LOG_FUNCTION (this);\n}\n\nvoid\nV2vFormClusterHeader::SetSeq(uint64_t seq) {\n    NS_LOG_FUNCTION (this << seq);\n    m_seq = seq;\n}\nuint64_t\nV2vFormClusterHeader::GetSeq(void) const {\n    NS_LOG_FUNCTION (this);\n    return m_seq;\n}\n\nvoid\nV2vFormClusterHeader::SetMobilityInfo(V2vClusterSap::NeighborInfo mobilityInfo){\n    NS_LOG_FUNCTION (this << mobilityInfo.imsi);\n    m_mobilityInfo = mobilityInfo;\n}\n\nV2vClusterSap::NeighborInfo\nV2vFormClusterHeader::GetMobilityInfo(void) const {\n    NS_LOG_FUNCTION (this);\n    return m_mobilityInfo;\n}\n\nTypeId\nV2vFormClusterHeader::GetTypeId(void) {\n    static TypeId tid =\n            TypeId(\"ns3::V2vFormClusterHeader\").SetParent<Header>().AddConstructor<V2vFormClusterHeader>();\n    return tid;\n}\n\nTypeId\nV2vFormClusterHeader::GetInstanceTypeId(void) const {\n    return GetTypeId();\n}\n\nvoid\nV2vFormClusterHeader::Print(std::ostream &os) const {\n    NS_LOG_FUNCTION (this << &os);\n    os << \"(seq=\" << m_seq\n            << \"IMSI=\" << m_mobilityInfo.imsi\n            << \"ClusterId=\" << m_mobilityInfo.clusterId\n            << \"Degree=\" << m_mobilityInfo.degree\n            << \"Position=\" << m_mobilityInfo.position\n            << \"Velocity=\" << m_mobilityInfo.velocity\n            << \"Direction=\" << m_mobilityInfo.direction <<\")\";\n}\n\nuint32_t\nV2vFormClusterHeader::GetSerializedSize(void) const {\n    NS_LOG_FUNCTION (this);\n    return sizeof(uint64_t) + sizeof(V2vClusterSap::NeighborInfo);\n}\n\nvoid\nV2vFormClusterHeader::Serialize(Buffer::Iterator start) const {\n    NS_LOG_FUNCTION (this << &start);\n\n    Buffer::Iterator i = start;\n    i.WriteHtonU64(m_seq);\n\n    // Write mobility structure\n    unsigned char temp[sizeof(V2vClusterSap::NeighborInfo)];\n    memcpy( temp, &m_mobilityInfo, sizeof(V2vClusterSap::NeighborInfo));\n    i.Write(temp, sizeof(V2vClusterSap::NeighborInfo));\n\n}\n\nuint32_t\nV2vFormClusterHeader::Deserialize(Buffer::Iterator start) {\n    NS_LOG_INFO (this << &start);\n\n    Buffer::Iterator i = start;\n    m_seq = i.ReadNtohU64();\n\n    unsigned char temp[sizeof(V2vClusterSap::NeighborInfo)];\n    i.Read(temp, sizeof(V2vClusterSap::NeighborInfo));\n    memcpy(&m_mobilityInfo, &temp, sizeof(V2vClusterSap::NeighborInfo) );\n\n    return GetSerializedSize();\n}\n\n\n/////////////////////////////////////////////////////////////////////\nNS_OBJECT_ENSURE_REGISTERED(V2vIncidentEventHeader);\n\nV2vIncidentEventHeader::V2vIncidentEventHeader():\n    m_ts(Simulator::Now().GetTimeStep()){\n    NS_LOG_FUNCTION (this);\n}\n\nV2vIncidentEventHeader::~V2vIncidentEventHeader(){\n    NS_LOG_FUNCTION (this);\n}\n\nTime\nV2vIncidentEventHeader::GetTs(void) const {\n    NS_LOG_FUNCTION (this);\n    return TimeStep(m_ts);\n}\n\nvoid\nV2vIncidentEventHeader::SetIncidentInfo(V2vClusterSap::IncidentInfo incidentInfo) {\n    NS_LOG_FUNCTION (this << incidentInfo.clusterId);\n    m_incidentInfo = incidentInfo;\n}\n\nV2vClusterSap::IncidentInfo\nV2vIncidentEventHeader::GetIncidentInfo(void) const {\n    NS_LOG_FUNCTION (this);\n    return m_incidentInfo;\n}\n\nTypeId\nV2vIncidentEventHeader::GetTypeId(void) {\n    static TypeId tid =\n            TypeId(\"ns3::V2vIncidentEventHeader\").SetParent<Header>().AddConstructor<V2vIncidentEventHeader>();\n    return tid;\n}\n\nTypeId\nV2vIncidentEventHeader::GetInstanceTypeId(void) const {\n    return GetTypeId();\n}\n\nvoid\nV2vIncidentEventHeader::Print(std::ostream &os) const {\n    NS_LOG_FUNCTION (this << &os);\n    os << \"(time=\" << TimeStep(m_ts).GetSeconds() << \" ClusterId=\" << m_incidentInfo.clusterId\n       << \" IncidentType =\" << m_incidentInfo.incidentType << \")\";\n}\n\nuint32_t\nV2vIncidentEventHeader::GetSerializedSize(void) const {\n    NS_LOG_FUNCTION (this);\n    return sizeof(uint64_t) + sizeof(V2vClusterSap::IncidentInfo);\n}\n\nvoid\nV2vIncidentEventHeader::Serialize(Buffer::Iterator start) const {\n    NS_LOG_FUNCTION (this << &start);\n\n    Buffer::Iterator i = start;\n    i.WriteHtonU64(m_ts);\n\n    // Write IncidentInfo structure\n    unsigned char temp[sizeof(V2vClusterSap::IncidentInfo)];\n    memcpy( temp, &m_incidentInfo, sizeof(V2vClusterSap::IncidentInfo) );\n    i.Write(temp, sizeof(V2vClusterSap::IncidentInfo));\n}\n\nuint32_t\nV2vIncidentEventHeader::Deserialize(Buffer::Iterator start) {\n    NS_LOG_INFO (this << &start);\n\n    Buffer::Iterator i = start;\n    m_ts = i.ReadNtohU64 ();\n\n    unsigned char temp[sizeof(V2vClusterSap::IncidentInfo)];\n    i.Read(temp, sizeof(V2vClusterSap::IncidentInfo));\n    memcpy(&m_incidentInfo, &temp, sizeof(V2vClusterSap::IncidentInfo) );\n\n    return GetSerializedSize();\n}\n\n} // namespace ns3\n"
    },
    {
      "file_path": "model/v2v-cluster-sap.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2015 University of Athens (UOA)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author:  - Lampros Katsikas <lkatsikas@di.uoa.gr>\n *          - Konstantinos Chatzikokolakis <kchatzi@di.uoa.gr>\n */\n\n#include \"ns3/v2v-cluster-sap.h\"\n\nnamespace ns3 {\n\nV2vClusterSap::~V2vClusterSap () {\n\n}\n\n} // namespace ns3\n"
    },
    {
      "file_path": "model/v2v-control-client.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2015 University of Athens (UOA)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author:  - Lampros Katsikas <lkatsikas@di.uoa.gr>\n *          - Konstantinos Chatzikokolakis <kchatzi@di.uoa.gr>\n */\n\n#include \"ns3/log.h\"\n#include \"ns3/node.h\"\n#include \"ns3/nstime.h\"\n#include \"ns3/socket.h\"\n#include \"ns3/string.h\"\n#include \"ns3/packet.h\"\n#include \"ns3/address.h\"\n#include \"ns3/pointer.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/udp-socket.h\"\n#include \"ns3/address-utils.h\"\n#include \"ns3/socket-factory.h\"\n#include \"ns3/udp-socket-factory.h\"\n#include \"ns3/inet-socket-address.h\"\n#include \"ns3/inet6-socket-address.h\"\n#include \"ns3/packet-socket-address.h\"\n#include \"ns3/trace-source-accessor.h\"\n#include \"v2v-control-client.h\"\n\n#include \"ns3/random-variable.h\"\n\n\nnamespace ns3 {\n\nstatic const std::string\nClusterStatusName[V2vControlClient::CLUSTER_STATES] =\n{\n    \"CLUSTER_INITIALIZATION\",\n    \"CLUSTER_HEAD_ELECTION\",\n    \"CLUSTER_FORMATION\",\n    \"CLUSTER_UPDATE\"\n};\n\nstatic const std::string & ToString (V2vControlClient::NodeStatus status){\n    return ClusterStatusName[status];\n}\n\nstatic const std::string\nIncidentName[V2vClusterSap::INCIDENT_STATES] =\n{\n    \"EMERGENCY_EVENT\",\n    \"NOTIFICATION_EVENT\"\n};\n\nstatic const std::string & ToString (V2vClusterSap::IncidentType incidentType){\n    return IncidentName[incidentType];\n}\n\nstatic const std::string\nDegreeName[V2vClusterSap::DEGREE_STATES] =\n{\n    \"STANDALONE\",\n    \"CH\",\n    \"CM\"\n};\n\nstatic const std::string & ToString (V2vClusterSap::NodeDegree nodeDegree){\n    return DegreeName[nodeDegree];\n}\n\nNS_LOG_COMPONENT_DEFINE (\"V2vControlClient\");\nNS_OBJECT_ENSURE_REGISTERED (V2vControlClient);\n\nTypeId V2vControlClient::GetTypeId(void) {\n\tstatic TypeId tid =\n\t\t\tTypeId(\"ns3::V2vControlClient\").SetParent<Application>()\n\t\t\t.AddConstructor<V2vControlClient>()\n            .AddAttribute(\"ListeningLocal\",\n\t\t\t\t\t\"The Address on which to Bind the rx socket.\",\n                    AddressValue(), MakeAddressAccessor(&V2vControlClient::m_peerListening),\n\t\t\t\t\tMakeAddressChecker())\n            .AddAttribute(\"ProtocolListeningLocal\",\n\t\t\t\t\t\"The type id of the protocol to use for the rx socket.\",\n\t\t\t\t\tTypeIdValue(UdpSocketFactory::GetTypeId()),\n                    MakeTypeIdAccessor(&V2vControlClient::m_tidListening),\n\t\t\t\t\tMakeTypeIdChecker())\n            .AddTraceSource(\"RxLocal\", \"A packet has been received\",\n                    MakeTraceSourceAccessor(&V2vControlClient::m_rxTrace))\n\n            .AddAttribute(\"IncidentWindow\",\n                    \"The incident time window\", DoubleValue(4),\n                    MakeDoubleAccessor(&V2vControlClient::m_incidentWindow),\n                    MakeDoubleChecker<double>())\n            .AddAttribute(\"ClusterTimeMetric\",\n                    \"The maximun size of the TDMA window\", DoubleValue(0.5),\n                    MakeDoubleAccessor(&V2vControlClient::m_clusterTimeMetric),\n                    MakeDoubleChecker<double>())\n            .AddAttribute(\"MinimumTdmaSlot\",\n                    \"The maximun size of the TDMA window\", DoubleValue(0.001),\n                    MakeDoubleAccessor(&V2vControlClient::m_minimumTdmaSlot),\n                    MakeDoubleChecker<double>())\n            .AddAttribute(\"MaxUes\",\n                    \"The maximun size of ues permitted\", UintegerValue(100),\n                    MakeUintegerAccessor(&V2vControlClient::m_maxUes),\n                    MakeUintegerChecker<uint32_t>(1))\n\t\t\t.AddAttribute(\"PacketSize\",\n\t\t\t\t\t\"The size of packets sent in on state\", UintegerValue(512),\n                    MakeUintegerAccessor(&V2vControlClient::m_pktSize),\n\t\t\t\t\tMakeUintegerChecker<uint32_t>(1))\n            .AddAttribute (\"TimeWindow\",\n                    \"The time to wait between packets\", DoubleValue (1.0),\n                    MakeDoubleAccessor (&V2vControlClient::m_timeWindow),\n                    MakeDoubleChecker<double>())\n            .AddAttribute (\"Interval\",\n                    \"The time to wait between packets\", TimeValue (Seconds (1.0)),\n                    MakeTimeAccessor (&V2vControlClient::m_interval),\n                    MakeTimeChecker ())\n            .AddAttribute(\"SendingLocal\",\n\t\t\t\t\t\"The address of the destination\", AddressValue(),\n                    MakeAddressAccessor(&V2vControlClient::m_peer),\n\t\t\t\t\tMakeAddressChecker())\n            .AddAttribute(\"ProtocolSendingLocal\",\n\t\t\t\t\t\"The type of protocol for the tx socket.\",\n\t\t\t\t\tTypeIdValue(UdpSocketFactory::GetTypeId()),\n                    MakeTypeIdAccessor(&V2vControlClient::m_tid),\n\t\t\t\t\tMakeTypeIdChecker())\n\t\t\t.AddAttribute (\"MobilityModel\",\n\t\t\t\t    \"The mobility model of the node.\",\n\t\t\t\t    PointerValue (),\n                    MakePointerAccessor (&V2vControlClient::m_mobilityModel),\n                    MakePointerChecker<V2vMobilityModel> ())\n            .AddTraceSource(\"TxLocal\",\"A new packet is created and is sent\",\n                    MakeTraceSourceAccessor(&V2vControlClient::m_txTrace));\n\treturn tid;\n}\n\n\n// Public Members\nV2vControlClient::V2vControlClient () {\n\tNS_LOG_FUNCTION (this);\n\n    m_socket = 0;\n    m_socketIncident = 0;\n    m_socketListening = 0;\n\n    m_overalDelay = 0;\n    m_sentCounter = 0;\n    m_changesCounter = 0;\n    m_incidentCounter = 0;\n    m_formationCounter = 0;\n\n    m_sendEvent = EventId ();\n    m_chElectionEvent = EventId ();\n}\n\nV2vControlClient::~V2vControlClient () {\n\tNS_LOG_FUNCTION (this);\n\n    m_socket = 0;\n    m_socketIncident = 0;\n    m_socketListening = 0;\n\n    m_overalDelay = 0;\n    m_sentCounter = 0;\n    m_changesCounter = 0;\n    m_incidentCounter = 0;\n    m_formationCounter = 0;\n}\n\nvoid\nV2vControlClient::PrintStatistics (std::ostream &os){\n    if(m_incidentCounter == 0){\n       m_incidentCounter = 1;       // Avoid division with zero\n    }\n\n    os << \"***********************\" << std::endl\n       << \"  - Cluster Metrics -  \" << std::endl\n       << \"Node:\" << m_currentMobility.imsi << \" Sent overal: \" << m_sentCounter << \" Packets.\" << std::endl\n       << \" Formation Messages: \" << m_formationCounter << std::endl\n       << \" Status Changes: \" << m_changesCounter << std::endl\n       << \"-----------------------\" << std::endl\n       << \"  - Insident Metrics -  \" << std::endl\n       << \"Mean delay of incidents delivered: \" << (double) m_overalDelay/m_incidentCounter << std::endl\n       << \"***********************\" << std::endl;\n}\n\n// Protected Members\nvoid\nV2vControlClient::DoDispose (void) {\n\tNS_LOG_FUNCTION (this);\n\n    m_socket = 0;\n    m_socketListening = 0;\n\n\t// chain up\n\tApplication::DoDispose();\n}\n\nvoid\nV2vControlClient::StartApplication (void)\n{\n    NS_LOG_FUNCTION (this);\n    m_status = V2vControlClient::CLUSTER_INITIALIZATION;\n\n\t// Create the socket if not already\n\tif (!m_socket) {\n\t\tm_socket = Socket::CreateSocket(GetNode(), m_tid);\n\t\tif (Inet6SocketAddress::IsMatchingType(m_peer)) {\n\t\t\tm_socket->Bind6();\n\t\t} else if (InetSocketAddress::IsMatchingType(m_peer)\n\t\t\t\t|| PacketSocketAddress::IsMatchingType(m_peer)) {\n\t\t\tm_socket->Bind();\n\t\t}\n\t\tm_socket->Connect(m_peer);\n\t\tm_socket->SetAllowBroadcast(true);\n\t\tm_socket->ShutdownRecv();\n\n\t\tm_socket->SetConnectCallback(\n                MakeCallback(&V2vControlClient::ConnectionSucceeded, this),\n                MakeCallback(&V2vControlClient::ConnectionFailed, this));\n    }\n\n    if(m_maxUes > 100){\n        NS_FATAL_ERROR(\"Error: Maximum number of ues is 100.\");\n    }\n\n    StartListeningLocal();\n    ScheduleTransmit (Seconds (m_timeWindow));\n    AcquireMobilityInfo();\n}\n\nvoid\nV2vControlClient::StartListeningLocal (void)    // Called at time specified by Start\n{\n\tNS_LOG_FUNCTION (this);\n\n    m_clusterList.clear();\n    m_rStableList.clear();\n\tm_2rStableList.clear();\n\t// Create the socket if not already\n\tif (!m_socketListening) {\n\t\tm_socketListening = Socket::CreateSocket(GetNode(), m_tidListening);\n\t\tm_socketListening->Bind(m_peerListening);\n\t\tm_socketListening->Listen();\n\t\tm_socketListening->ShutdownSend();\n\t\tif (addressUtils::IsMulticast(m_peerListening)) {\n\t\t\tPtr<UdpSocket> udpSocket = DynamicCast<UdpSocket>(m_socketListening);\n\t\t\tif (udpSocket) {\n\t\t\t\t// equivalent to setsockopt (MCAST_JOIN_GROUP)\n\t\t\t\tudpSocket->MulticastJoinGroup(0, m_peerListening);\n\t\t\t} else {\n\t\t\t\tNS_FATAL_ERROR(\"Error: joining multicast on a non-UDP socket\");\n\t\t\t}\n\t\t}\n\t}\n\n    m_socketListening->SetRecvCallback(MakeCallback(&V2vControlClient::HandleRead, this));\n\tm_socketListening->SetAcceptCallback(\n\t\t\tMakeNullCallback<bool, Ptr<Socket>, const Address &>(),\n            MakeCallback(&V2vControlClient::HandleAccept, this));\n\tm_socketListening->SetCloseCallbacks(\n            MakeCallback(&V2vControlClient::HandlePeerClose, this),\n            MakeCallback(&V2vControlClient::HandlePeerError, this));\n}\n\nvoid\nV2vControlClient::StopApplication (void) // Called at time specified by Stop\n{\n\tNS_LOG_FUNCTION (this);\n\n\tif (m_socket != 0) {\n\t\tm_socket->Close();\n\t\tm_socket->SetRecvCallback (MakeNullCallback<void, Ptr<Socket> > ());\n\t\tm_socket = 0;\n\t} else {\n\t\tNS_LOG_WARN (\"V2vControlClient found null socket to close in StopApplication\");\n\t}\n\tSimulator::Cancel (m_sendEvent);\n    Simulator::Cancel (m_sendIncidentEvent);\n    StopListeningLocal();\n    PrintStatistics(std::cout);\n}\n\nvoid\nV2vControlClient::StopListeningLocal (void)     // Called at time specified by Stop\n{\n  NS_LOG_FUNCTION (this);\n  if (m_socketListening)\n    {\n\t  m_socketListening->Close ();\n\t  m_socketListening->SetRecvCallback (MakeNullCallback<void, Ptr<Socket> > ());\n\t  m_socketListening = 0;\n    }\n}\n\nPtr<Socket>\nV2vControlClient::GetListeningSocket (void) const {\n    NS_LOG_FUNCTION (this);\n    return m_socketListening;\n}\n\nPtr<Socket>\nV2vControlClient::GetSocket (void) const {\n    NS_LOG_FUNCTION (this);\n    return m_socket;\n}\n\n\n// Private Members\nvoid\nV2vControlClient::HandleRead (Ptr<Socket> socket) {\n\tNS_LOG_FUNCTION (this << socket);\n\tPtr<Packet> packet;\n\tAddress from;\n\twhile ((packet = socket->RecvFrom(from))) {\n\t\tif (packet->GetSize() == 0) { //EOF\n\t\t\tbreak;\n\t\t}\n\n\t\tPacketMetadata::ItemIterator metadataIterator = packet->BeginItem();\n\t\tPacketMetadata::Item item;\n\t\twhile (metadataIterator.HasNext()){\n\t\t    item = metadataIterator.Next();\n\t\t    if(item.tid.GetName() == \"ns3::V2vClusterInfoHeader\"){\n\n                V2vClusterSap::V2vClusterSap::NeighborInfo otherInfo;\n                V2vClusterInfoHeader clusterInfo;\n\t\t    \tpacket->RemoveHeader(clusterInfo);\n                otherInfo = clusterInfo.GetMobilityInfo();\n\n                //!< Update rStable List\n                std::map<uint64_t, V2vClusterSap::NeighborInfo>::iterator itr = m_rStableList.find(otherInfo.imsi);\n                if(IsStable(otherInfo.velocity)){\n                    if(itr == m_rStableList.end()){\n                        NS_LOG_DEBUG(\"[HandleRead] => Node:\" << m_currentMobility.imsi << \" Insert packet:\" << otherInfo.imsi);\n                        m_rStableList.insert(std::map<uint64_t, V2vClusterSap::NeighborInfo>::value_type(otherInfo.imsi, otherInfo));\n                    }\n                    else{\n                        itr->second = otherInfo;\n                    }\n                }\n\n                //!< Update 2rStable and cluster List\n                std::map<uint64_t, V2vClusterSap::NeighborInfo>::iterator it2r = m_2rStableList.find(otherInfo.imsi);\n                if(it2r == m_2rStableList.end()){\n                    NS_LOG_DEBUG(\"[HandleRead] => Node:\" << m_currentMobility.imsi << \" Insert packet:\" << otherInfo.imsi);\n                    m_2rStableList.insert(std::map<uint64_t, V2vClusterSap::NeighborInfo>::value_type(otherInfo.imsi, otherInfo));\n                }\n                else{\n                    it2r->second = otherInfo;\n                }\n\n                if(m_status == V2vControlClient::CLUSTER_UPDATE){\n\n                    if(m_currentMobility.degree == V2vClusterSap::CH){\n                        if(otherInfo.clusterId == m_currentMobility.imsi){\n                            std::map<uint64_t, V2vClusterSap::NeighborInfo>::iterator itc = m_clusterList.find(otherInfo.imsi);\n                            if(itc == m_clusterList.end()){\n                                NS_LOG_DEBUG(\"[HandleRead] => Node:\" << m_currentMobility.imsi << \" - insert node:\" << otherInfo.imsi);\n                                m_clusterList.insert(std::map<uint64_t, V2vClusterSap::NeighborInfo>::value_type(otherInfo.imsi, otherInfo));\n                            }\n                            else{\n                                //!< Update UE Info\n                                NS_LOG_DEBUG(\"[HandleRead] => Node:\" << m_currentMobility.imsi << \" - update node:\" << otherInfo.imsi);\n                                itc->second = otherInfo;\n                            }\n                        }\n                        else{\n                            //!< Check Cluster Merge\n                            if(m_clusterList.size() == 0){\n                                uint64_t potentialCH = MergeCheck();\n\n                                if(m_rStableList.count(potentialCH) > 0){\n                                    V2vClusterSap::NeighborInfo potential = m_rStableList.find(potentialCH)->second;\n\n                                    if(m_currentMobility.imsi < potential.imsi){\n                                        NS_LOG_DEBUG(\"[HandleRead] => Node:\" << m_currentMobility.imsi << \" - merge with node:\" << potential.imsi);\n                                        m_currentMobility.degree = V2vClusterSap::CM;\n                                        m_currentMobility.clusterId = potential.imsi;\n                                        m_changesCounter ++;\n\n                                        RemoveIncidentSocket ();\n                                        CreateIncidentSocket (from);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else if(m_currentMobility.degree == V2vClusterSap::STANDALONE){\n                        uint64_t potentialCH = MergeCheck();\n                        if(m_rStableList.count(potentialCH) > 0){\n                            V2vClusterSap::NeighborInfo potential = m_rStableList.find(potentialCH)->second;\n\n                            NS_LOG_DEBUG(\"[HandleRead] => Node:\" << m_currentMobility.imsi\n                                          << \" - Attach to new CH node:\" << potential.imsi);\n                            m_currentMobility.degree = V2vClusterSap::CM;\n                            m_currentMobility.clusterId = potential.imsi;\n                            m_changesCounter ++;\n\n                            RemoveIncidentSocket ();\n                            CreateIncidentSocket (from);\n                        }\n                        else{\n                            NS_LOG_DEBUG(\"[HandleRead] => To Become new CH: \" << m_currentMobility.imsi);\n\n                            NS_LOG_DEBUG(\"Node Status: \" << ToString(m_status));\n                            m_currentMobility.degree = V2vClusterSap::CH;\n                            m_currentMobility.clusterId = m_currentMobility.imsi;\n                            m_changesCounter ++;\n                        }\n                    }\n                }\n\n\t\t\t\tif (InetSocketAddress::IsMatchingType(from)) {\n                    NS_LOG_INFO (\"[HandleRead] => At time \" << Simulator::Now ().GetSeconds ()\n                            << \"s node [\"<< m_currentMobility.imsi <<\"] received \"\n\t\t\t\t\t\t\t<< packet->GetSize () << \" bytes from \"\n\t\t\t\t\t\t\t<< InetSocketAddress::ConvertFrom(from).GetIpv4 ()\n\t\t\t\t\t\t\t<< \" port \" << InetSocketAddress::ConvertFrom (from).GetPort ()\n                            << \" seq: \" << clusterInfo.GetSeq ()\n                            << \" degree: \" << ToString (otherInfo.degree)\n                            << \" position: \" << otherInfo.position\n                            << \" - Velocity: \" << otherInfo.velocity\n                            << \" - Direction: \" << otherInfo.direction);\n\t\t\t\t} else if (Inet6SocketAddress::IsMatchingType(from)) {\n                    NS_LOG_INFO (\"[HandleRead] => At time \" << Simulator::Now ().GetSeconds ()\n                            << \"s node [\"<< m_currentMobility.imsi <<\"] received \"\n\t\t\t\t\t\t\t<< packet->GetSize () << \" bytes from \"\n\t\t\t\t\t\t\t<< InetSocketAddress::ConvertFrom(from).GetIpv4 ()\n\t\t\t\t\t\t\t<< \" port \" << InetSocketAddress::ConvertFrom (from).GetPort ()\n                            << \" seq: \" << clusterInfo.GetSeq ()\n                            << \" degree: \" << ToString (otherInfo.degree)\n                            << \" position: \" << otherInfo.position\n                            << \" - Velocity: \" << otherInfo.velocity\n                            << \" - Direction: \" << otherInfo.direction);\n                }\n\t\t    }\n\t\t    else if(item.tid.GetName() == \"ns3::V2vInitiateClusterHeader\"){\n\n                if(m_status == V2vControlClient::CLUSTER_INITIALIZATION){\n                    m_status = V2vControlClient::CLUSTER_HEAD_ELECTION;\n\n\t\t\t\t\tif (InetSocketAddress::IsMatchingType(from)) {\n                        NS_LOG_INFO (\"[HandleRead] => At time \" << Simulator::Now ().GetSeconds ()\n                                << \"s node [\"<< m_currentMobility.imsi <<\"] received \"\n\t\t\t\t\t\t\t\t<< packet->GetSize () << \" bytes from \"\n\t\t\t\t\t\t\t\t<< InetSocketAddress::ConvertFrom(from).GetIpv4 ()\n\t\t\t\t\t\t\t\t<< \" port \" << InetSocketAddress::ConvertFrom (from).GetPort ()\n\t\t\t\t\t\t\t\t<< \" to check for CH suitability.\");\n\t\t\t\t\t} else if (Inet6SocketAddress::IsMatchingType(from)) {\n                        NS_LOG_INFO (\"[HandleRead] => At time \" << Simulator::Now ().GetSeconds ()\n                                << \"s node [\"<< m_currentMobility.imsi <<\"] received \"\n\t\t\t\t\t\t\t\t<< packet->GetSize () << \" bytes from \"\n\t\t\t\t\t\t\t\t<< InetSocketAddress::ConvertFrom(from).GetIpv4 ()\n\t\t\t\t\t\t\t\t<< \" port \" << InetSocketAddress::ConvertFrom (from).GetPort ()\n\t\t\t\t\t\t\t\t<< \" to check for CH suitability.\");\n\t\t\t\t\t}\n\n\t\t\t\t\t//!< Parse V2vInitiateClusterHeader Info\n\t\t\t\t\tV2vInitiateClusterHeader initiateCluster;\n\t\t\t\t\tpacket->RemoveHeader (initiateCluster);\n                    m_currentMobility.clusterId = initiateCluster.GetClusterId();\n                    std::map<uint64_t, V2vClusterSap::NeighborInfo>::iterator foundIt = m_2rStableList.find(initiateCluster.GetClusterId());\n                    if( (foundIt != m_2rStableList.end()) ){\n\n                        //!< Suitability check [should be applied to r-distance neighbors]\n                        double waitingTime = SuitabilityCheck();\n                        NS_LOG_UNCOND (\"[HandleRead] => NodeId: \" << m_currentMobility.imsi << \" WaitingTime is: \" << waitingTime);\n\n                        //!< Handle chElection Event\n                        m_chElectionEvent = Simulator::Schedule (Seconds(waitingTime), &V2vControlClient::FormCluster, this);\n\n                        UniformVariable randomIncident ((int)waitingTime + 1, m_incidentWindow);\n                        ScheduleIncidentEvent (Seconds (randomIncident.GetValue ()));\n\t\t\t\t\t}\n\t\t\t\t\telse{\n                        /// Not in 2rStableList\n                        m_status = V2vControlClient::CLUSTER_INITIALIZATION;\n\t\t\t\t\t}\n\t\t    \t}\n\t\t    \telse{\n                    //!< Process only the first request and ignore the rest\n                    NS_LOG_DEBUG (\"[HandleRead] => NodeId: \" << m_currentMobility.imsi << \" Ignore further requests for CH suitability...\");\n\t\t    \t}\n\t\t    }\n\t\t    else if(item.tid.GetName() == \"ns3::V2vFormClusterHeader\"){\n\n                NS_ASSERT( (m_status != V2vControlClient::CLUSTER_HEAD_ELECTION) || (m_status != V2vControlClient::CLUSTER_FORMATION));\n\n                V2vFormClusterHeader formCluster;\n                packet->RemoveHeader (formCluster);\n                std::map<uint64_t, V2vClusterSap::NeighborInfo>::iterator it = m_2rStableList.find(formCluster.GetMobilityInfo().clusterId);\n\n                if(it != m_2rStableList.end()){\n                    if(m_status == V2vControlClient::CLUSTER_HEAD_ELECTION){\n\n                        m_status = V2vControlClient::CLUSTER_FORMATION;\n                        m_chElectionEvent.Cancel();\n                        NS_LOG_DEBUG (\"[HandleRead] => NodeId: \" << m_currentMobility.imsi\n                                      << \" connected to cluster: \" << formCluster.GetMobilityInfo().clusterId);\n\n                        //!< Apply received CH info\n                        m_status = V2vControlClient::CLUSTER_UPDATE;\n                        m_currentMobility.degree = V2vClusterSap::CM;\n                        m_currentMobility.clusterId = formCluster.GetMobilityInfo().clusterId;\n                        ScheduleTransmit (Seconds((m_timeWindow)));\n\n                        double updateTime = (int) Simulator::Now ().GetSeconds () + 1.5;\n                        Simulator::Schedule(Seconds(updateTime-Simulator::Now ().GetSeconds ()), &V2vControlClient::UpdateNeighborList, this);\n\n                        CreateIncidentSocket (from);\n                    }\n                    else if(m_status == V2vControlClient::CLUSTER_FORMATION){\n                        NS_LOG_DEBUG (\"[HandleRead] => NodeId: \" << m_currentMobility.imsi << \" Node is already a Cluster Member.\");\n                    }\n                }\n                else{\n                    /// Not in 2rStableList\n                }\n            }\n            else if(item.tid.GetName() == \"ns3::V2vIncidentEventHeader\"){\n\n                V2vIncidentEventHeader incidentHeader;\n                packet->RemoveHeader (incidentHeader);\n\n                if(m_incidentTimestamp.GetSeconds () == incidentHeader.GetTs().GetSeconds ()){\n\n                    /// Calculate Delay\n                    m_overalDelay += Simulator::Now ().GetSeconds () - m_incidentTimestamp.GetSeconds ();\n                    NS_LOG_UNCOND (\"Node: \" << m_currentMobility.imsi << \" received back V2vIncidentEventHeader:\"\n                                  << \". Incident Delay is: \" << Simulator::Now ().GetSeconds () - m_incidentTimestamp.GetSeconds () << \" Seconds\");\n                    NS_LOG_UNCOND (\"--------------------------------------------------------------------------------------------\");\n                }\n\n                if( (m_currentMobility.degree == V2vClusterSap::CH) && (m_currentMobility.clusterId == incidentHeader.GetIncidentInfo().clusterId) ){\n\n                    //!< Broadcast Incident to Cluster Members\n                    Ptr<Packet> packet = Create<Packet>(0);\n                    packet->AddHeader(incidentHeader);\n\n                    m_socket->Send(packet);\n                    if (InetSocketAddress::IsMatchingType(m_peer)) {\n                        NS_LOG_UNCOND (\"[Send] Broadcast Incident Message from \" << m_currentMobility.imsi << \"=> At time \" << Simulator::Now ().GetSeconds ()\n                                <<\" sent \" << packet->GetSize () << \" bytes to \"\n                                << InetSocketAddress::ConvertFrom(m_peer).GetIpv4 ()\n                                << \" port \" << InetSocketAddress::ConvertFrom (m_peer).GetPort ()\n                                << \" - Event Type is:\" << ToString (incidentHeader.GetIncidentInfo ().incidentType));\n                    } else if (Inet6SocketAddress::IsMatchingType(m_peer)) {\n                        NS_LOG_UNCOND (\"[Send] Broadcast Incident Message from \" << m_currentMobility.imsi << \"=> At time \" << Simulator::Now ().GetSeconds ()\n                                <<\" sent \" << packet->GetSize () << \" bytes to \"\n                                << packet->GetSize () << \" bytes to \"\n                                << Inet6SocketAddress::ConvertFrom(m_peer).GetIpv6 ()\n                                << \" port \" << Inet6SocketAddress::ConvertFrom (m_peer).GetPort ()\n                                << \" - Event Type is:\" << ToString (incidentHeader.GetIncidentInfo ().incidentType));\n                    }\n                }\n\n            }\n            m_rxTrace(packet, from);\n        }\n    }\n}\n\nvoid\nV2vControlClient::CreateIncidentSocket (Address from)\n{\n    NS_LOG_FUNCTION (this);\n\n    //!< Create p2p socket with ClusterHead for incident event transmission\n    Ipv4Address chAddress = InetSocketAddress::ConvertFrom(from).GetIpv4 ();\n    uint16_t chPort = InetSocketAddress::ConvertFrom (m_peer).GetPort ();\n    m_peerIncident = Address(InetSocketAddress(chAddress, chPort));\n\n    // Create the socket if not already\n    if (!m_socketIncident) {\n        m_socketIncident = Socket::CreateSocket(GetNode(), m_tid);\n        if (Inet6SocketAddress::IsMatchingType(m_peerIncident)) {\n            m_socketIncident->Bind6();\n        } else if (InetSocketAddress::IsMatchingType(m_peerIncident)\n                || PacketSocketAddress::IsMatchingType(m_peerIncident)) {\n            m_socketIncident->Bind();\n        }\n        m_socketIncident->Connect(m_peerIncident);\n        m_socketIncident->SetAllowBroadcast(false);\n        m_socketIncident->ShutdownRecv();\n\n        m_socketIncident->SetConnectCallback(\n                MakeCallback(&V2vControlClient::ConnectionCHSucceeded, this),\n                MakeCallback(&V2vControlClient::ConnectionCHFailed, this));\n    }\n}\n\nvoid\nV2vControlClient::RemoveIncidentSocket (void)\n{\n    NS_LOG_FUNCTION (this);\n\n    if (m_socketIncident != 0) {\n        m_socketIncident->Close();\n        m_socketIncident->SetRecvCallback (MakeNullCallback<void, Ptr<Socket> > ());\n        m_socketIncident = 0;\n    } else {\n        NS_LOG_WARN (\"m_socketIncident null socket to close...\");\n    }\n}\n\nvoid\nV2vControlClient::ConnectionCHSucceeded (Ptr<Socket> socket) {\n    NS_LOG_FUNCTION (this << socket);\n    NS_LOG_DEBUG (\"P2P Connection with CH Successful\");\n}\n\nvoid\nV2vControlClient::ConnectionCHFailed (Ptr<Socket> socket) {\n    NS_LOG_FUNCTION (this << socket);\n    NS_FATAL_ERROR(\"Error: joining CH socket\");\n}\n\nuint64_t\nV2vControlClient::MergeCheck (void){\n    uint64_t id = 0;\n    double r = 80;              //!< transmition range\n    double rt = 0.0;            //!< Suitability metric for CH  selection\n    double boundary = 0.0;\n    for(std::map<uint64_t, V2vClusterSap::NeighborInfo>::iterator itSearch = m_rStableList.begin(); itSearch != m_rStableList.end(); ++itSearch){\n        V2vClusterSap::NeighborInfo node = itSearch->second;\n        if(node.degree == V2vClusterSap::CH){\n            if( ((m_currentMobility.position.x < node.position.x) && (m_currentMobility.velocity.x > 0) && fabs(m_currentMobility.velocity.x) < fabs(node.velocity.x))\n                    || ((m_currentMobility.position.x < node.position.x) && (m_currentMobility.velocity.x < 0) && fabs(m_currentMobility.velocity.x) > fabs(node.velocity.x)) ){\n                rt = (r-fabs(m_currentMobility.position.x - node.position.x)) / (fabs(m_currentMobility.velocity.x-node.velocity.x));\n                NS_LOG_DEBUG (\"[MergeCheck] => NODES ARE GETTING FAR AND FAR - RT:\" << rt << \"current Node:\" << m_currentMobility.imsi << \" - with node:\" << node.imsi);\n            }\n            if( ((m_currentMobility.position.x < node.position.x) && (m_currentMobility.velocity.x > 0) && fabs(m_currentMobility.velocity.x) > fabs(node.velocity.x))\n                    || ((m_currentMobility.position.x < node.position.x) && (m_currentMobility.velocity.x < 0) && fabs(m_currentMobility.velocity.x) < fabs(node.velocity.x)) ){\n                rt = (r+fabs(m_currentMobility.position.x - node.position.x)) / (fabs(m_currentMobility.velocity.x-node.velocity.x));\n                NS_LOG_DEBUG(\"[MergeCheck] => NODES ARE GETTING CLOSER AND CLOSER - RT:\" << rt << \"current Node:\" << m_currentMobility.imsi << \" - with node:\" << node.imsi);\n            }\n\n            if( ((m_currentMobility.position.x > node.position.x) && (m_currentMobility.velocity.x > 0) && fabs(m_currentMobility.velocity.x) > fabs(node.velocity.x))\n                    || ((m_currentMobility.position.x > node.position.x) && (m_currentMobility.velocity.x < 0) && fabs(m_currentMobility.velocity.x) < fabs(node.velocity.x)) ){\n                rt = (r-fabs(m_currentMobility.position.x - node.position.x)) / (fabs(m_currentMobility.velocity.x-node.velocity.x));\n                NS_LOG_DEBUG(\"[MergeCheck] => NODES ARE GETTING FAR AND FAR - RT:\" << rt << \"current Node:\" << m_currentMobility.imsi << \" - with node:\" << node.imsi);\n            }\n            if( ((m_currentMobility.position.x > node.position.x) && (m_currentMobility.velocity.x > 0) && fabs(m_currentMobility.velocity.x) < fabs(node.velocity.x))\n                    || ((m_currentMobility.position.x > node.position.x) && (m_currentMobility.velocity.x < 0) && fabs(m_currentMobility.velocity.x) > fabs(node.velocity.x)) ){\n                rt = (r+fabs(m_currentMobility.position.x - node.position.x)) / (fabs(m_currentMobility.velocity.x-node.velocity.x));\n                NS_LOG_DEBUG(\"[MergeCheck] => NODES ARE GETTING CLOSER AND CLOSER - RT:\" << rt << \"current Node:\" << m_currentMobility.imsi << \" - with node:\" << node.imsi);\n            }\n\n            if(rt > boundary){\n                id = itSearch->first;\n                boundary = rt;\n            }\n        }\n    }\n    NS_LOG_DEBUG (\"[MergeCheck] => Returned Id is: \" << id << \" - with Remaining Time(RT):\" << boundary);\n    return id;\n}\n\nvoid V2vControlClient::AcquireMobilityInfo (void){\n\n    //!< Acquire current mobility stats\n    m_currentMobility.ts = Simulator::Now ();\n    m_currentMobility.imsi = this->GetNode()->GetId();\n    m_currentMobility.position = m_mobilityModel->GetPosition();\n    m_currentMobility.velocity = m_mobilityModel->GetVelocity();\n    m_currentMobility.direction = m_mobilityModel->GetDirection();\n}\n\ndouble\nV2vControlClient::SuitabilityCheck (void){\n\n    double size = m_rStableList.size();\n    //!< Find mean value of position and velocity\n    if(m_rStableList.size() == 0){\n        return m_currentMobility.imsi;\n    }\n\n    Vector p,v;\n    for(std::map<uint64_t, V2vClusterSap::NeighborInfo>::iterator it = m_rStableList.begin(); it != m_rStableList.end(); ++it) {\n        uint64_t key = it->first;\n        NS_ASSERT(key != m_currentMobility.imsi);\n\n        V2vClusterSap::NeighborInfo value = it->second;\n        p.x += value.position.x;\n        p.y += value.position.y;\n\n        v.x += value.velocity.x;\n        v.y += value.velocity.y;\n    }\n    p.x = p.x/size;\n    p.y = p.y/size;\n    v.x = v.x/size;\n    v.y = v.y/size;\n\n    NS_LOG_DEBUG(\"[SuitabilityCheck] => Mean p.x = \" << p.x << \" - Mean p.y = \" << p.y);\n    NS_LOG_DEBUG(\"[SuitabilityCheck] => Mean v.x = \" << v.x << \" - Mean v.y = \" << v.y);\n\n\n    //!< Find standard deviation of position and velocity\n    Vector ps,vs;\n    for(std::map<uint64_t, V2vClusterSap::NeighborInfo>::iterator it = m_rStableList.begin(); it != m_rStableList.end(); ++it) {\n        uint64_t key = it->first;\n        NS_ASSERT(key != m_currentMobility.imsi);\n\n        V2vClusterSap::NeighborInfo value = it->second;\n        ps.x += pow((value.position.x - p.x), 2.0);\n        ps.y += pow((value.position.y - p.y), 2.0);\n        vs.x += pow((value.velocity.x - v.x), 2.0);\n        vs.y += pow((value.velocity.y - v.y), 2.0);\n    }\n    ps.x = ps.x/size;\n    ps.y = ps.y/size;\n    vs.x = vs.x/size;\n    vs.y = vs.y/size;\n\n    NS_LOG_DEBUG(\"[SuitabilityCheck] => ps.x = \" << ps.x << \" - ps.y = \" << ps.y);\n    NS_LOG_DEBUG(\"[SuitabilityCheck] => vs.x = \" << vs.x << \" - vs.y = \" << vs.y);\n\n    /// Avoid division with zero if vehicle moves horizontally or vertiacally\n    Vector pNorm;\n    if(ps.x == 0){\n        pNorm.x = (m_currentMobility.position.x - p.x)/1;\n    }\n    else{\n        pNorm.x = (m_currentMobility.position.x - p.x)/ps.x;\n    }\n\n    if(ps.y == 0){\n        pNorm.y = (m_currentMobility.position.y - p.y)/1;\n    }\n    else{\n        pNorm.y = (m_currentMobility.position.y - p.y)/ps.y;\n    }\n\n\n    Vector vNorm;\n    if(vs.x == 0){\n        vNorm.x = (m_currentMobility.velocity.x - v.x)/1;\n    }\n    else{\n        vNorm.x = (m_currentMobility.velocity.x - v.x)/vs.x;\n    }\n\n\n    if(vs.y == 0){\n        vNorm.y = (m_currentMobility.velocity.y - v.y)/1;\n    }\n    else{\n        vNorm.y = (m_currentMobility.velocity.y - v.y)/vs.y;\n    }\n    NS_LOG_DEBUG(\"[SuitabilityCheck] => pNorm.x:\" << pNorm.x << \" - vNorm.x:\" << vNorm.x);\n    NS_LOG_DEBUG(\"[SuitabilityCheck] => pNorm.y:\" << pNorm.y << \" - vNorm.y:\" << vNorm.y);\n\n    double w = fabs(pNorm.x) + fabs(pNorm.y) + fabs(vNorm.x) + fabs(vNorm.y);\n\n    NS_LOG_DEBUG(\"[SuitabilityCheck] => w = \" << w << \" - u = \"\n                 << (double)size* exp((-m_clusterTimeMetric)* w) << \" - size:\" << size);\n\n    return (double)size* exp((-m_clusterTimeMetric)* w);\n}\n\nvoid\nV2vControlClient::FormCluster (void){\n    m_status = V2vControlClient::CLUSTER_FORMATION;\n    ScheduleTransmit (Seconds(0.));\n}\n\nvoid\nV2vControlClient::StatusReport (void){\n\n    NS_LOG_UNCOND(\"\\n\\n-----------------------------------------------------------------------------\");\n    NS_LOG_UNCOND (\"[StatusReport] => At time \" << Simulator::Now ().GetSeconds ()\n                   << \"s node [\"<< m_currentMobility.imsi << \"] is: \" << ToString (m_currentMobility.degree)\n        << \" in Cluster: \" << m_currentMobility.clusterId\n        << \" having  ===> \\n position: \" << m_currentMobility.position << \" - Velocity: \" << m_currentMobility.velocity\n        << \" - Direction: \" << m_currentMobility.direction\n        << \"\\n last packet sent:\" << m_currentMobility.ts<< \"s\"\n        << \"\\n Neighbors: \" << m_2rStableList.size());\n    NS_LOG_UNCOND(\"----------------------------  2rStableList  ---------------------------------\");\n    for(std::map<uint64_t, V2vClusterSap::NeighborInfo>::iterator it = m_2rStableList.begin(); it != m_2rStableList.end(); ++it){\n        uint64_t id = it->first;\n        V2vClusterSap::NeighborInfo node = it->second;\n        NS_LOG_UNCOND(\" * key: \" << id << \" clusterId: \" << node.clusterId\n                << \" Degree:\" << ToString (node.degree) << \" Imsi:\" << node.imsi\n                << \" Position:\" << node.position << \" Velocity\" << node.velocity\n                << \" Direction:\" << node.direction\n                << \" last packet sent:\" << node.ts<< \"s\");\n    }\n    NS_LOG_UNCOND(\"-----------------------------  rStableList  ---------------------------------\");\n    for(std::map<uint64_t, V2vClusterSap::NeighborInfo>::iterator it = m_rStableList.begin(); it != m_rStableList.end(); ++it){\n        uint64_t id = it->first;\n        V2vClusterSap::NeighborInfo node = it->second;\n        NS_LOG_UNCOND(\" * key: \" << id << \" clusterId: \" << node.clusterId\n                << \" Degree:\" << ToString (node.degree)\n                << \" Imsi:\" << node.imsi\n                << \" Position:\" << node.position << \" Velocity\" << node.velocity\n                << \" Direction:\" << node.direction);\n    }\n    NS_LOG_UNCOND(\"-----------------------------  clusterList  ---------------------------------\");\n    for(std::map<uint64_t, V2vClusterSap::NeighborInfo>::iterator it = m_clusterList.begin(); it != m_clusterList.end(); ++it){\n        uint64_t id = it->first;\n        V2vClusterSap::NeighborInfo node = it->second;\n        NS_LOG_UNCOND(\" * key: \" << id << \" clusterId: \" << node.clusterId\n                << \" Degree:\" << ToString (node.degree)\n                << \" Imsi:\" << node.imsi\n                << \" Position:\" << node.position << \" Velocity\" << node.velocity\n                << \" Direction:\" << node.direction);\n    }\n}\n\nvoid\nV2vControlClient::HandleAccept (Ptr<Socket> s, const Address& from) {\n\tNS_LOG_FUNCTION (this << s << from);\n    s->SetRecvCallback(MakeCallback(&V2vControlClient::HandleRead, this));\n}\n\nvoid\nV2vControlClient::HandlePeerClose (Ptr<Socket> socket) {\n\tNS_LOG_FUNCTION (this << socket);\n}\n\nvoid\nV2vControlClient::HandlePeerError (Ptr<Socket> socket) {\n\tNS_LOG_FUNCTION (this << socket);\n}\n\n\n\nvoid\nV2vControlClient::ScheduleTransmit (Time dt)\n{\n  NS_LOG_FUNCTION (this << dt);\n  m_sendEvent = Simulator::Schedule (dt, &V2vControlClient::Send, this);\n  NS_LOG_DEBUG(\"[ScheduleTransmit] => NodeId:\" << m_currentMobility.imsi << \" EventInfo:\"\n               << m_sendEvent.GetTs() << \" status: \" << ToString(m_status));\n}\n\nvoid\nV2vControlClient::Send (void) {\n\tNS_LOG_FUNCTION (this);\n    NS_LOG_DEBUG(\"[Send] => NodeId:\" << m_currentMobility.imsi << \" EventInfo:\"\n                 << m_sendEvent.GetTs() << \" status: \" << ToString(m_status));\n\tNS_ASSERT(m_sendEvent.IsExpired());\n\n\tswitch (m_status) {\n        case V2vControlClient::CLUSTER_INITIALIZATION:{\n\n\t\t\tV2vClusterInfoHeader clusterInfo;\n            clusterInfo.SetSeq(m_sentCounter);\n            clusterInfo.SetMobilityInfo(m_currentMobility);\n\n            Ptr<Packet> packet = Create<Packet>(0);\n            packet->AddHeader(clusterInfo);\n\t\t\tm_txTrace(packet);\n\t\t\tm_socket->Send(packet);\n\t\t\t++ m_sentCounter;\n            m_formationCounter ++;\n\t\t\tif (InetSocketAddress::IsMatchingType(m_peer)) {\n                NS_LOG_INFO (\"[Send] CLUSTER_INITIALIZATION => At time \" << Simulator::Now ().GetSeconds ()\n                        << \"s node[IMSI] [\"<< m_currentMobility.imsi <<\"] sent \"\n\t\t\t\t\t\t<< packet->GetSize () << \" bytes to \"\n\t\t\t\t\t\t<< InetSocketAddress::ConvertFrom(m_peer).GetIpv4 ()\n\t\t\t\t\t\t<< \" port \" << InetSocketAddress::ConvertFrom (m_peer).GetPort ()\n                        << \" bytes.\"\n                        << \" position: \" << m_currentMobility.position\n                        << \" - Velocity: \" << m_currentMobility.velocity\n                        << \" - Direction: \" << m_currentMobility.direction);\n\t\t\t} else if (Inet6SocketAddress::IsMatchingType(m_peer)) {\n                NS_LOG_INFO (\"[Send] CLUSTER_INITIALIZATION => At time \" << Simulator::Now ().GetSeconds ()\n                        << \"s node[IMSI] [\"<< m_currentMobility.imsi <<\"] sent \"\n\t\t\t\t\t\t<< packet->GetSize () << \" bytes to \"\n\t\t\t\t\t\t<< Inet6SocketAddress::ConvertFrom(m_peer).GetIpv6 ()\n\t\t\t\t\t\t<< \" port \" << Inet6SocketAddress::ConvertFrom (m_peer).GetPort ()\n                        << \" bytes.\"\n\t\t\t\t\t\t<< \" position: \"\n                        << m_currentMobility.position << \" - Velocity: \" << m_currentMobility.velocity\n                        << \" - Direction: \" << m_currentMobility.direction);\n\t\t\t}\n            Simulator::Schedule (Seconds(m_minimumTdmaSlot*m_maxUes), &V2vControlClient::InitiateCluster, this);\n\t\t\tbreak;\n\t\t}\n        case V2vControlClient::CLUSTER_HEAD_ELECTION:{\n\n\t\t\tV2vInitiateClusterHeader initiateCluster;\n            initiateCluster.SetSeq(m_sentCounter);\n            initiateCluster.SetClusterId(m_currentMobility.imsi);\n\n            Ptr<Packet> packet = Create<Packet>(0);\n            packet->AddHeader(initiateCluster);\n            m_txTrace(packet);\n            m_socket->Send(packet);\n            ++ m_sentCounter;\n            m_formationCounter ++;\n\t\t\tif (InetSocketAddress::IsMatchingType(m_peer)) {\n                NS_LOG_INFO (\"[Send] CLUSTER_HEAD_ELECTION => At time \" << Simulator::Now ().GetSeconds ()\n                        << \"s node[IMSI] [\"<< m_currentMobility.imsi <<\"] sent \"\n\t\t\t\t\t\t<< packet->GetSize () << \" bytes to \"\n\t\t\t\t\t\t<< InetSocketAddress::ConvertFrom(m_peer).GetIpv4 ()\n\t\t\t\t\t\t<< \" port \" << InetSocketAddress::ConvertFrom (m_peer).GetPort ()\n\t\t\t\t\t\t<< \" as a COV\");\n\t\t\t} else if (Inet6SocketAddress::IsMatchingType(m_peer)) {\n                NS_LOG_INFO (\"[Send] CLUSTER_HEAD_ELECTION => At time \" << Simulator::Now ().GetSeconds ()\n                        << \"s node[IMSI] [\"<< m_currentMobility.imsi <<\"] sent \"\n\t\t\t\t\t\t<< packet->GetSize () << \" bytes to \"\n\t\t\t\t\t\t<< Inet6SocketAddress::ConvertFrom(m_peer).GetIpv6 ()\n\t\t\t\t\t\t<< \" port \" << Inet6SocketAddress::ConvertFrom (m_peer).GetPort ()\n\t\t\t\t\t\t<< \" as a COV\");\n\t\t\t}\n\n\t\t\tdouble waitingTime = SuitabilityCheck();\n            NS_LOG_UNCOND (\"[HandleRead] => NodeId: \" << m_currentMobility.imsi << \" WaitingTime is: \" << waitingTime);\n            m_chElectionEvent = Simulator::Schedule (Seconds(waitingTime), &V2vControlClient::FormCluster, this);\n\n            UniformVariable randomIncident ((int)waitingTime + 1, m_incidentWindow);\n            ScheduleIncidentEvent (Seconds (randomIncident.GetValue ()));\n\n            break;\n        }\n        case V2vControlClient::CLUSTER_FORMATION:\n        {\n            AcquireMobilityInfo();\n            m_currentMobility.degree = V2vClusterSap::CH;\n            m_currentMobility.clusterId = m_currentMobility.imsi;\n\n            V2vFormClusterHeader clusterInfo;\n            clusterInfo.SetSeq(m_sentCounter);\n            clusterInfo.SetMobilityInfo(m_currentMobility);\n\n            Ptr<Packet> packet = Create<Packet>(0);\n            packet->AddHeader(clusterInfo);\n            m_txTrace(packet);\n\t\t\tm_socket->Send(packet);\n            ++ m_sentCounter;\n            m_formationCounter ++;\n\t\t\tif (InetSocketAddress::IsMatchingType(m_peer)) {\n                NS_LOG_INFO (\"[Send] CLUSTER_FORMATION => At time \" << Simulator::Now ().GetSeconds ()\n                        << \"s node[IMSI] [\"<< m_currentMobility.imsi <<\"] sent \"\n\t\t\t\t\t\t<< packet->GetSize () << \" bytes to \"\n\t\t\t\t\t\t<< InetSocketAddress::ConvertFrom(m_peer).GetIpv4 ()\n\t\t\t\t\t\t<< \" port \" << InetSocketAddress::ConvertFrom (m_peer).GetPort ()\n                        << \" to become CH.\");\n\t\t\t} else if (Inet6SocketAddress::IsMatchingType(m_peer)) {\n                NS_LOG_INFO (\"[Send] CLUSTER_FORMATION => At time \" << Simulator::Now ().GetSeconds ()\n                        << \"s node[IMSI] [\"<< m_currentMobility.imsi <<\"] sent \"\n\t\t\t\t\t\t<< packet->GetSize () << \" bytes to \"\n\t\t\t\t\t\t<< Inet6SocketAddress::ConvertFrom(m_peer).GetIpv6 ()\n\t\t\t\t\t\t<< \" port \" << Inet6SocketAddress::ConvertFrom (m_peer).GetPort ()\n                        << \" to become CH.\");\n\t\t\t}\n\n            Simulator::Schedule (Seconds(0.), &V2vControlClient::UpdateNeighbors, this);\n\n            /// Schecule list updating\n            double updateTime = (int) Simulator::Now ().GetSeconds () + 1.5;\n            Simulator::Schedule(Seconds(updateTime-Simulator::Now ().GetSeconds ()), &V2vControlClient::UpdateNeighborList, this);\n\n\t\t\tbreak;\n        }\n        case V2vControlClient::CLUSTER_UPDATE:{\n\n            if(m_currentMobility.degree == V2vClusterSap::CH){\n                StatusReport ();\n            }\n\n            AcquireMobilityInfo();\n            V2vClusterInfoHeader clusterInfo;\n            clusterInfo.SetSeq(m_sentCounter);\n            clusterInfo.SetMobilityInfo(m_currentMobility);\n\n            Ptr<Packet> packet = Create<Packet>(0);\n            packet->AddHeader(clusterInfo);\n            m_txTrace(packet);\n            m_socket->Send(packet);\n            ++ m_sentCounter;\n            if (InetSocketAddress::IsMatchingType(m_peer)) {\n                NS_LOG_INFO (\"[Send] CLUSTER_UPDATE => Cluster Update At time: \" << Simulator::Now ().GetSeconds ()\n                        << \"s node[IMSI] [\"<< m_currentMobility.imsi <<\"] sent \"\n                        << packet->GetSize () << \" bytes to \"\n                        << InetSocketAddress::ConvertFrom(m_peer).GetIpv4 ()\n                        << \" port \" << InetSocketAddress::ConvertFrom (m_peer).GetPort ()\n                        << \" bytes.\"\n                        << \" position: \" << m_currentMobility.position\n                        << \" - Velocity: \" << m_currentMobility.velocity\n                        << \" - Direction: \" << m_currentMobility.direction);\n            } else if (Inet6SocketAddress::IsMatchingType(m_peer)) {\n                NS_LOG_INFO (\"[Send] CLUSTER_UPDATE => Cluster Update At time: \" << Simulator::Now ().GetSeconds ()\n                        << \"s node[IMSI] [\"<< m_currentMobility.imsi <<\"] sent \"\n                        << packet->GetSize () << \" bytes to \"\n                        << Inet6SocketAddress::ConvertFrom(m_peer).GetIpv6 ()\n                        << \" port \" << Inet6SocketAddress::ConvertFrom (m_peer).GetPort ()\n                        << \" bytes.\"\n                        << \" position: \" << m_currentMobility.position\n                        << \" - Velocity: \" << m_currentMobility.velocity\n                        << \" - Direction: \" << m_currentMobility.direction);\n            }\n            ScheduleTransmit (m_interval);\n            break;\n        }\n\t\tdefault:\n            NS_LOG_DEBUG (\"[Send] => Default Case NodeId [Transmit] \" << m_currentMobility.imsi\n                          << \" - Current Status: \" << ToString(m_status));\n\t\t\tbreak;\n\t}\n}\n\nvoid\nV2vControlClient::UpdateNeighbors (void){\n    m_status = V2vControlClient::CLUSTER_UPDATE;\n    ScheduleTransmit (m_interval);\n}\n\nvoid\nV2vControlClient::InitiateCluster (void){\n    if(IsSlowestNode()){\n        m_status = V2vControlClient::CLUSTER_HEAD_ELECTION;\n        ScheduleTransmit(Seconds(m_minimumTdmaSlot*m_maxUes));\n\t}\n}\n\n//!< Check if the neighbor is stable comparing the relative speed\nbool\nV2vControlClient::IsStable (Vector velocity){\n\n    Vector speed;\n    double vTh = 10;\n    speed.x = fabs(m_currentMobility.velocity.x - velocity.x);\n    speed.y = fabs(m_currentMobility.velocity.y - velocity.y);\n\n    NS_LOG_DEBUG(\"[IsStable] => vTh is:\" << vTh << \" - speed difference is:\" << speed.x + speed.y);\n    if(speed.x+speed.y > vTh){\n        return false;\n    }\n    return true;\n}\n\nbool\nV2vControlClient::IsSlowestNode (void){\n    NS_LOG_DEBUG(\"Node:\" << m_currentMobility.imsi << \"has \" << m_2rStableList.size() << \" list Size\");\n\n    //!< Simulate the 2r channel taking care only for distance/2 neighbors\n    double maxDistance;\n    for(std::map<uint64_t, V2vClusterSap::NeighborInfo>::iterator it = m_2rStableList.begin(); it != m_2rStableList.end(); ++it) {\n        V2vClusterSap::NeighborInfo value = it->second;\n        if((fabs( m_currentMobility.position.x - value.position.x) + fabs( m_currentMobility.position.y - value.position.y)) > maxDistance){\n            maxDistance = fabs( m_currentMobility.position.x - value.position.x) + fabs( m_currentMobility.position.y - value.position.y);\n        }\n    }\n\n    for(std::map<uint64_t, V2vClusterSap::NeighborInfo>::iterator it = m_2rStableList.begin(); it != m_2rStableList.end(); ++it) {\n        uint32_t key = it->first;\n        V2vClusterSap::NeighborInfo value = it->second;\n\n        if((fabs( m_currentMobility.position.x - value.position.x) + fabs( m_currentMobility.position.y - value.position.y)) < (maxDistance)/2){\n            NS_LOG_DEBUG(\"Found: \" <<  key << \" with speed: \" << value.velocity.x);\n\n            if(fabs(value.velocity.x + value.velocity.y) < fabs(m_currentMobility.velocity.x + m_currentMobility.velocity.y)){\n                return false;\n            }\n            if(fabs(value.velocity.x + value.velocity.y) == fabs(m_currentMobility.velocity.x + m_currentMobility.velocity.y)){\n                if(value.imsi < m_currentMobility.imsi){\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n\nvoid\nV2vControlClient::ConnectionSucceeded (Ptr<Socket> socket) {\n    NS_LOG_FUNCTION (this << socket);\n}\n\nvoid\nV2vControlClient::ConnectionFailed (Ptr<Socket> socket) {\n\tNS_LOG_FUNCTION (this << socket);\n}\n\nvoid V2vControlClient::UpdateNeighborList (void){\n\n    //!< Update Neighbor's List according to Timestamps\n    for(std::map<uint64_t, V2vClusterSap::NeighborInfo>::iterator it = m_2rStableList.begin(); it != m_2rStableList.end();){\n        uint64_t key = it->first;\n        V2vClusterSap::NeighborInfo value = it->second;\n        if(m_currentMobility.ts.GetSeconds() - value.ts.GetSeconds() > 1.2){\n            m_2rStableList.erase(it++);\n            NS_LOG_DEBUG (\"[UpdateNeighborList] => At: \" << Simulator::Now().GetSeconds() << \" Node::\"\n                          << m_currentMobility.imsi << \" - Removing Node:\" << value.imsi\n                          << \" with last sent time:\" << value.ts.GetSeconds());\n            if(value.imsi == m_currentMobility.clusterId){\n                NS_LOG_DEBUG (\"[UpdateNeighborList] => Node:\" << m_currentMobility.imsi\n                              << \" lost ClusterHead \" << value.imsi);\n\n                //!< go to STANDALONE State\n                m_currentMobility.clusterId = 0;\n                m_currentMobility.degree = V2vClusterSap::STANDALONE;\n\n                NS_LOG_DEBUG (\"[UpdateNeighborList] => Go to STANDALONE state: \" << m_currentMobility.imsi);\n            }\n\n            if(m_rStableList.find(key) != m_rStableList.end()){\n                NS_LOG_DEBUG (\"[UpdateNeighborList] => Node:\" << m_currentMobility.imsi << \" deletes CM from m_rStableList: \" << value.imsi);\n                m_rStableList.erase(key);\n            }\n\n            if(m_clusterList.find(key) != m_clusterList.end()){\n                NS_LOG_DEBUG (\"[UpdateNeighborList] => CH Node:\" << m_currentMobility.imsi << \" deletes CM from m_clusterList: \" << value.imsi);\n                m_clusterList.erase(key);\n            }\n\n            if( (m_rStableList.size() == 0) && (m_currentMobility.degree != V2vClusterSap::CH) ){\n                NS_LOG_DEBUG (\"[UpdateNeighborList] => To Become new CH: \" << m_currentMobility.imsi);\n                m_currentMobility.degree = V2vClusterSap::CH;\n                m_currentMobility.clusterId = m_currentMobility.imsi;\n                m_changesCounter ++;\n            }\n        }\n        else{\n            ++it;\n        }\n    }\n    Simulator::Schedule (m_interval, &V2vControlClient::UpdateNeighborList, this);\n}\n\nvoid\nV2vControlClient::ScheduleIncidentEvent (Time dt){\n    NS_LOG_FUNCTION (this << dt);\n    m_sendIncidentEvent = Simulator::Schedule (dt, &V2vControlClient::SendIncident, this);\n}\n\nvoid\nV2vControlClient::SendIncident (void){\n\n    V2vClusterSap::IncidentInfo incidentInfo;\n    incidentInfo.clusterId = m_currentMobility.clusterId;\n    incidentInfo.incidentType = V2vClusterSap::EMERGENCY_EVENT;\n\n    V2vIncidentEventHeader incidentHeader;\n    incidentHeader.SetIncidentInfo (incidentInfo);\n    m_incidentTimestamp = incidentHeader.GetTs();\n\n    Ptr<Packet> packet = Create<Packet>(0);\n    packet->AddHeader(incidentHeader);\n\n    if( (m_currentMobility.degree == V2vClusterSap::CH) || (m_currentMobility.degree == V2vClusterSap::STANDALONE)){\n\n        //!< Broadcast Incident to Cluster Members directly\n        m_socket->Send(packet);\n        if (InetSocketAddress::IsMatchingType(m_peer)) {\n            NS_LOG_UNCOND (\"[Send] Broadcast Incident Message from \" << m_currentMobility.imsi << \"=> At time \" << Simulator::Now ().GetSeconds ()\n                    <<\" sent \" << packet->GetSize () << \" bytes to \"\n                    << InetSocketAddress::ConvertFrom(m_peer).GetIpv4 ()\n                    << \" port \" << InetSocketAddress::ConvertFrom (m_peer).GetPort ()\n                    << \" - Event Type is:\" << ToString (incidentHeader.GetIncidentInfo ().incidentType));\n        } else if (Inet6SocketAddress::IsMatchingType(m_peer)) {\n            NS_LOG_UNCOND (\"[Send] Broadcast Incident Message from \" << m_currentMobility.imsi << \"=> At time \" << Simulator::Now ().GetSeconds ()\n                    <<\" sent \" << packet->GetSize () << \" bytes to \"\n                    << packet->GetSize () << \" bytes to \"\n                    << Inet6SocketAddress::ConvertFrom(m_peer).GetIpv6 ()\n                    << \" port \" << Inet6SocketAddress::ConvertFrom (m_peer).GetPort ()\n                    << \" - Event Type is:\" << ToString (incidentHeader.GetIncidentInfo ().incidentType));\n        }\n    }\n    else{\n\n        //!< Send Incident event to Cluster Head firstly\n        m_socketIncident->Send(packet);\n        m_incidentCounter ++;\n        if (InetSocketAddress::IsMatchingType(m_peerIncident)) {\n            NS_LOG_UNCOND (\"[Send] Incident Message => At time \" << Simulator::Now ().GetSeconds ()\n                    << \"s node[IMSI] [\"<< m_currentMobility.imsi <<\"] sent \"\n                    << packet->GetSize () << \" bytes to \"\n                    << InetSocketAddress::ConvertFrom(m_peerIncident).GetIpv4 ()\n                    << \" port \" << InetSocketAddress::ConvertFrom (m_peerIncident).GetPort ()\n                    << \" - Event Type is:\" << ToString (incidentInfo.incidentType));\n        } else if (Inet6SocketAddress::IsMatchingType(m_peerIncident)) {\n            NS_LOG_INFO (\"[Send] Incident Message => At time \" << Simulator::Now ().GetSeconds ()\n                    << \"s node[IMSI] [\"<< m_currentMobility.imsi <<\"] sent \"\n                    << packet->GetSize () << \" bytes to \"\n                    << Inet6SocketAddress::ConvertFrom(m_peerIncident).GetIpv6 ()\n                    << \" port \" << Inet6SocketAddress::ConvertFrom (m_peerIncident).GetPort ()\n                    << \" - Event Type is:\" << ToString (incidentInfo.incidentType));\n        }\n    }\n\n    //!< Schedule event generation in random time\n    ScheduleIncidentEvent (Seconds (m_incidentWindow));\n\n}\n\n} // Namespace ns3\n"
    },
    {
      "file_path": "model/v2v-mobility-model.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2015 University of Athens (UOA)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author:  - Lampros Katsikas <lkatsikas@di.uoa.gr>\n *          - Konstantinos Chatzikokolakis <kchatzi@di.uoa.gr>\n */\n\n#include \"v2v-mobility-model.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/double.h\"\n#include \"ns3/string.h\"\n#include \"ns3/pointer.h\"\n#include \"ns3/random-variable.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/log.h\"\n#include <math.h>\n\nNS_LOG_COMPONENT_DEFINE (\"V2vMobilityModel\");\n\nnamespace ns3 {\n\nNS_OBJECT_ENSURE_REGISTERED (V2vMobilityModel);\n\nTypeId\nV2vMobilityModel::GetTypeId (void)\n{\n  static TypeId tid = TypeId (\"ns3::V2vMobilityModel\")\n    .SetParent<MobilityModel> ()\n    .SetGroupName (\"Mobility\")\n    .AddConstructor<V2vMobilityModel> ()\n    .AddAttribute (\"Bounds\",\n                   \"Bounds of the area to cruise.\",\n                   RectangleValue (Rectangle (0.0, 0.0, 100.0, 100.0)),\n                   MakeRectangleAccessor (&V2vMobilityModel::m_bounds),\n                   MakeRectangleChecker ())\n    .AddAttribute (\"Time\",\n                   \"Change current direction and speed after moving for this delay.\",\n                   TimeValue (Seconds (1.0)),\n                   MakeTimeAccessor (&V2vMobilityModel::m_modeTime),\n                   MakeTimeChecker ())\n    .AddAttribute (\"Distance\",\n                   \"Change current direction and speed after moving for this distance.\",\n                   DoubleValue (1.0),\n                   MakeDoubleAccessor (&V2vMobilityModel::m_modeDistance),\n                   MakeDoubleChecker<double> ())\n    .AddAttribute (\"Mode\",\n                   \"The mode indicates the condition used to \"\n                   \"change the current speed and direction\",\n                   EnumValue (V2vMobilityModel::MODE_DISTANCE),\n                   MakeEnumAccessor (&V2vMobilityModel::m_mode),\n                   MakeEnumChecker (V2vMobilityModel::MODE_DISTANCE, \"Distance\",\n                                    V2vMobilityModel::MODE_TIME, \"Time\"))\n    .AddAttribute (\"Direction\",\n                   \"A random variable used to pick the direction (gradients).\",\n                   StringValue (\"ns3::UniformRandomVariable[Min=0.0|Max=6.283184]\"),\n                   MakePointerAccessor (&V2vMobilityModel::m_directionVariable),\n                   MakePointerChecker<RandomVariableStream> ())\n    .AddAttribute (\"Speed\",\n                   \"A random variable used to pick the speed (m/s).\",\n                   StringValue (\"ns3::UniformRandomVariable[Min=2.0|Max=4.0]\"),\n                   MakePointerAccessor (&V2vMobilityModel::m_speed),\n                   MakePointerChecker<RandomVariableStream> ())\n    .AddAttribute (\"SpeedVariation\",\n                    \"A random variable used to pick the speed variation (m/s).\",\n                    DoubleValue (1.0),\n                    MakeDoubleAccessor (&V2vMobilityModel::m_speedVariation),\n                    MakeDoubleChecker<double> ());\n  return tid;\n}\n\n\nvoid V2vMobilityModel::SetDirection(const Vector& direction){\n\t//m_direction\n}\n\nVector V2vMobilityModel::GetDirection(void) const{\n\tVector vector (std::cos (m_direction), std::sin (m_direction), 0.0);\n\n\treturn vector;\n}\n\nvoid\nV2vMobilityModel::SetSpeedVariation(double variation){\n    m_speedVariation = variation;\n}\n\nvoid\nV2vMobilityModel::DoInitialize (void)\n{\n  DoInitializePrivate ();\n  MobilityModel::DoInitialize ();\n}\n\nvoid\nV2vMobilityModel::DoInitializePrivate (void)\n{\n  m_helper.Update ();\n  double speed = m_speed->GetValue ();\n  m_direction = 1.0;\n\n  UniformVariable randomVariable (-m_speedVariation, m_speedVariation);\n  double s = std::ceil(randomVariable.GetValue() * 100 + 0.5)/100;\n\n  Vector vector (m_direction * (speed+s),\n                 0 ,\n                 0.0);\n  m_helper.SetVelocity (vector);\n  m_helper.Unpause ();\n\n  Time delayLeft;\n  if (m_mode == V2vMobilityModel::MODE_TIME)\n    {\n      delayLeft = m_modeTime;\n    }\n  else\n    {\n      delayLeft = Seconds (m_modeDistance / speed);\n    }\n  DoWalk (delayLeft);\n}\n\nvoid\nV2vMobilityModel::DoWalk (Time delayLeft)\n{\n  Vector position = m_helper.GetCurrentPosition ();\n  Vector speed = m_helper.GetVelocity ();\n  Vector nextPosition = position;\n  nextPosition.x += speed.x * delayLeft.GetSeconds ();\n  nextPosition.y += speed.y * delayLeft.GetSeconds ();\n  m_event.Cancel ();\n  if (m_bounds.IsInside (nextPosition))\n    {\n      m_event = Simulator::Schedule (delayLeft, &V2vMobilityModel::DoInitializePrivate, this);\n    }\n  else\n    {\n      nextPosition = m_bounds.CalculateIntersection (position, speed);\n      Time delay = Seconds ((nextPosition.x - position.x) / speed.x);\n      m_event = Simulator::Schedule (delay, &V2vMobilityModel::Rebound, this,\n                                     delayLeft - delay);\n    }\n  NotifyCourseChange ();\n}\n\nvoid\nV2vMobilityModel::Rebound (Time delayLeft)\n{\n  m_helper.UpdateWithBounds (m_bounds);\n  Vector position = m_helper.GetCurrentPosition ();\n  Vector speed = m_helper.GetVelocity ();\n  switch (m_bounds.GetClosestSide (position))\n    {\n    case Rectangle::RIGHT:\n    case Rectangle::LEFT:\n      speed.x = -speed.x;\n      break;\n    case Rectangle::TOP:\n    case Rectangle::BOTTOM:\n      speed.y = -speed.y;\n      break;\n    }\n  m_helper.SetVelocity (speed);\n  m_helper.Unpause ();\n  DoWalk (delayLeft);\n}\n\nvoid\nV2vMobilityModel::DoDispose (void)\n{\n  // chain up\n  MobilityModel::DoDispose ();\n}\nVector\nV2vMobilityModel::DoGetPosition (void) const\n{\n  m_helper.UpdateWithBounds (m_bounds);\n  return m_helper.GetCurrentPosition ();\n}\nvoid\nV2vMobilityModel::DoSetPosition (const Vector &position)\n{\n  NS_ASSERT (m_bounds.IsInside (position));\n  m_helper.SetPosition (position);\n  Simulator::Remove (m_event);\n  m_event = Simulator::ScheduleNow (&V2vMobilityModel::DoInitializePrivate, this);\n}\nVector\nV2vMobilityModel::DoGetVelocity (void) const\n{\n  return m_helper.GetVelocity ();\n}\nint64_t\nV2vMobilityModel::DoAssignStreams (int64_t stream)\n{\n  m_speed->SetStream (stream);\n  m_directionVariable->SetStream (stream + 1);\n  return 2;\n}\n\n\n} // namespace ns3\n"
    },
    {
      "file_path": "test/v2v-test-suite.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2015 University of Athens (UOA)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Author:  - Lampros Katsikas <lkatsikas@di.uoa.gr>\n *          - Konstantinos Chatzikokolakis <kchatzi@di.uoa.gr>\n */\n\n#include <fstream>\n#include \"ns3/log.h\"\n#include \"ns3/test.h\"\n#include \"ns3/abort.h\"\n#include \"ns3/config.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/simple-channel.h\"\n#include \"ns3/simple-net-device.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/inet-socket-address.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/v2v-cluster-header.h\"\n#include \"ns3/v2v-control-client.h\"\n\nusing namespace ns3;\n\n\n/*--------------------------- V2vControlClient Testing ---------------------------*/\nclass V2vControlClientTestCase: public TestCase {\npublic:\n    V2vControlClientTestCase();\n    virtual ~V2vControlClientTestCase();\n\nprivate:\n\tvirtual void DoRun(void);\n\n};\n\nV2vControlClientTestCase::V2vControlClientTestCase() :\n        TestCase(\"Verify the correct transmission of the packets.\"){\n}\n\nV2vControlClientTestCase::~V2vControlClientTestCase() {\n}\n\nvoid V2vControlClientTestCase::DoRun(void) {\n\n\tSimulator::Run();\n\tSimulator::Destroy();\n\n}\n\n\n/*--------------------------- V2vClusterInfoHeader Testing ---------------------------*/\nclass V2vClusterInfoHeaderTestCase: public TestCase {\npublic:\n    V2vClusterInfoHeaderTestCase();\n    virtual ~V2vClusterInfoHeaderTestCase();\n\nprivate:\n\tvirtual void DoRun(void);\n\n};\n\nV2vClusterInfoHeaderTestCase::V2vClusterInfoHeaderTestCase() :\n        TestCase(\"Check V2vClusterInfoHeader class serialization-deserialization\"){\n}\n\nV2vClusterInfoHeaderTestCase::~V2vClusterInfoHeaderTestCase() {\n}\n\nvoid V2vClusterInfoHeaderTestCase::DoRun(void) {\n\n    Simulator::Run();\n    Simulator::Destroy();\n}\n/*--------------------------------------------------------------------------*/\n\n/*--------------------------- V2vInitiateClusterHeader Testing ---------------------------*/\nclass V2vInitiateClusterHeaderTestCase: public TestCase {\npublic:\n    V2vInitiateClusterHeaderTestCase();\n    virtual ~V2vInitiateClusterHeaderTestCase();\n\nprivate:\n    virtual void DoRun(void);\n\n};\n\nV2vInitiateClusterHeaderTestCase::V2vInitiateClusterHeaderTestCase() :\n        TestCase(\"Check V2vInitiateClusterHeader class serialization-deserialization\"){\n}\n\nV2vInitiateClusterHeaderTestCase::~V2vInitiateClusterHeaderTestCase() {\n}\n\nvoid V2vInitiateClusterHeaderTestCase::DoRun(void) {\n\n    Simulator::Run();\n    Simulator::Destroy();\n}\n/*--------------------------------------------------------------------------*/\n\n/*--------------------------- V2vFormClusterHeader Testing ---------------------------*/\nclass V2vFormClusterHeaderTestCase: public TestCase {\npublic:\n    V2vFormClusterHeaderTestCase();\n    virtual ~V2vFormClusterHeaderTestCase();\n\nprivate:\n    virtual void DoRun(void);\n\n};\n\nV2vFormClusterHeaderTestCase::V2vFormClusterHeaderTestCase() :\n        TestCase(\"Check V2vFormClusterHeader class serialization-deserialization\"){\n}\n\nV2vFormClusterHeaderTestCase::~V2vFormClusterHeaderTestCase() {\n}\n\nvoid V2vFormClusterHeaderTestCase::DoRun(void) {\n\n    Simulator::Run();\n    Simulator::Destroy();\n}\n/*--------------------------------------------------------------------------*/\n\n/*--------------------------- V2vIncidentEventHeader Testing ---------------------------*/\nclass V2vIncidentEventHeaderTestCase: public TestCase {\npublic:\n    V2vIncidentEventHeaderTestCase();\n    virtual ~V2vIncidentEventHeaderTestCase();\n\nprivate:\n    virtual void DoRun(void);\n\n};\n\nV2vIncidentEventHeaderTestCase::V2vIncidentEventHeaderTestCase() :\n        TestCase(\"Check V2vIncidentEventHeader class serialization-deserialization\"){\n}\n\nV2vIncidentEventHeaderTestCase::~V2vIncidentEventHeaderTestCase() {\n}\n\nvoid V2vIncidentEventHeaderTestCase::DoRun(void) {\n\n    Simulator::Run();\n    Simulator::Destroy();\n}\n/*--------------------------------------------------------------------------*/\n\n/*--------------------------- End-to-end Testing ---------------------------*/\nclass V2vUdpEndToEndTestCase: public TestCase {\npublic:\n\tV2vUdpEndToEndTestCase();\n\tvirtual ~V2vUdpEndToEndTestCase();\n\nprivate:\n\tvirtual void DoRun(void);\n\n};\n\nV2vUdpEndToEndTestCase::V2vUdpEndToEndTestCase() :\n        TestCase(\"Test an end-to-end clustering scenario.\"){\n}\n\nV2vUdpEndToEndTestCase::~V2vUdpEndToEndTestCase() {\n}\n\nvoid V2vUdpEndToEndTestCase::DoRun(void) {\n\t// Todo:\n}\n/*--------------------------------------------------------------------------*/\n\n\n/*------------------------ TestSuite Initialization ------------------------*/\nclass V2vTestSuite: public TestSuite {\npublic:\n\tV2vTestSuite();\n};\n\nV2vTestSuite::V2vTestSuite() : TestSuite(\"v2v\", UNIT) {\n    AddTestCase(new V2vControlClientTestCase, TestCase::QUICK);\n    AddTestCase(new V2vClusterInfoHeaderTestCase, TestCase::QUICK);\n    AddTestCase(new V2vInitiateClusterHeaderTestCase, TestCase::QUICK);\n    AddTestCase(new V2vFormClusterHeaderTestCase, TestCase::QUICK);\n    AddTestCase(new V2vIncidentEventHeaderTestCase, TestCase::QUICK);\n\tAddTestCase(new V2vUdpEndToEndTestCase, TestCase::QUICK);\n}\n\n// Do not forget to allocate an instance of this TestSuite\nstatic V2vTestSuite v2vTestSuite;\n\n"
    }
  ]
}