{
  "repo_name": "ramisa2108/NS3-AODV-Optimized-Route-Discovery-Using-K-Means-Clustering",
  "github_url": "https://github.com/ramisa2108/NS3-AODV-Optimized-Route-Discovery-Using-K-Means-Clustering",
  "readme": "# NS3 AODV Optimized Route Discovery Using K-Means Clustering\n\nIn AODV routing, route discovery is done by the flooding method - which is broadcasting route request (RREQ) packtes to all the nodes in the transmission range of a sender. It often results in unnecessary re-transmissions of RREQ packets and the reply (RREP) packets generated in response, resulting in packet collisions and congestion in the network. In this project, I have proposed an optimized route discovering method for AODV. The key idea is to use K-Means clustering algorithm for selecting the best cluster of RREQ packet forwarders instead of broadcasting. The objective of this method is to reduce unnecessary control packet transmission in the network, thereby reducing congestion and end to end delay of the network.\n\nThe network is simulated using ns3.35.\n\n\n### Features used in K-Means clustering:  \n\n- distance to destination \n- number of transmission errors\n- free buffer space\n\nOptimal cluster is chosen based on these features of the neighbours.\n\n### Evaluation of clusters:\n\nEvaluation of the clusters are done by comparing to an ideal forwarder with features:\n\n- distance to destination = 0\n- number of transmission errors = 0\n- free buffer space = maximum buffer size\n\n### Modifications in the code base: \n\n- **`aodvKmeans-packet.h`**  \n    \n    new fields added to `RREPHeader` class : `m_txErrorCount`, `m_freeSpace`, `m_positionX`, `m_positionY`\n- **`aodvKmeans-rtable.h`**  \n    \n    new fields added to `RoutingTableEntry` class : `m_txErrorCount`, `m_freeSpace`, `m_positionX`, `m_positionY`\n- **`aodvKmeans-routing-protocol.h`**  \n    \n    - `m_position` :  \n     vector containing this node's position\n    - `m_lastKnowPosition` :  \n     map containing last known physical position of IP addresses\n    - `m_lastKnownCluster` :  \n     map containing last known clusters for forwarding to IP addresses (cleared periodically)\n\n- **`aodvKmeans-rtable.cc`**  \n    - `Kmeans` : \n    runs K-Means clustering algorithm on neighbouring nodes to find optimal cluster of forwarders for given destination\n\n\n- **`aodvKmeans-routing-protocol.cc`**  \n    \n    - `SendHello` :  \n        current node's position, free buffer space, transmission error count sent through `RREPHeader`\n    \n    - `RecvReply` :  \n        last known positions updated\n    \n    - Features in `RoutingTable` updated with incoming `RREPHeader` information \n    \n    - `NotifyTxError` :  \n        current node's tranmission error count incremented\n    \n    - `SendRequest` and `RecvRequest` :  \n     if `m_lastKnownPosition` contains the IP address for destination, then instead of broadcasting, `RREQ` is forwarded to optimal cluster obtained from `m_lastKnownClusters` or by running K-Means \n\n\n### Comparison with AODV\n\n![](/Results/nodes-del_ratio.png)\n![](/Results/pps-del_ratio.png)\n![](/Results/nodes-delay.png)\n![](/Results/pps-delay.png)\n\n\n- Number of nodes : 10, 20, 30, 40, 50  \n- Number of packets per second : 10, 20, 30, 40, 50\n\nFrom the figures, we can see that the **delivery ratio of the modified algorithm is slightly less than AODV**. But the difference in delivery ratio is not very significant considering the modified approach uses substantially less number of forwarders for route discovery. On the other hand, we can see that the **end to end delay in the modified approach is a lot lower than using only AODV**. This is due to using lower number of RREQ and RREP packets in the modified approach which makes the route discovery process much faster. So, even though the delivery ratio sufferes a little due to selective forwarding using K-Means clustering, the modified approach reduces the end to end delay of the network.\n\n\n### Steps for running the examples\n1. Download and install [ns3.35](https://www.nsnam.org/releases/ns-3-35/)\n2. Copy the folder ![aodvKmeans](/aodvKmeans) to **ns3/src** or **ns3/contrib**\n3. Build the new module **aodvKmeans** [Instructions](https://www.nsnam.org/docs/manual/html/new-modules.html)\n4. Add the examples from ![scratch](/scratch) to **ns3/scratch**\n\n",
  "examples": [
    {
      "file_path": "aodvKmeans/examples/aodvKmeans.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2009 IITP RAS\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * This is an example script for aodvKmeans manet routing protocol. \n *\n * Authors: Pavel Boyko <boyko@iitp.ru>\n */\n\n#include <iostream>\n#include <cmath>\n#include \"ns3/aodvKmeans-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/v4ping-helper.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\n/**\n * \\ingroup aodvKmeans-examples\n * \\ingroup examples\n * \\brief Test script.\n * \n * This script creates 1-dimensional grid topology and then ping last node from the first one:\n * \n * [10.0.0.1] <-- step --> [10.0.0.2] <-- step --> [10.0.0.3] <-- step --> [10.0.0.4]\n * \n * ping 10.0.0.4\n *\n * When 1/3 of simulation time has elapsed, one of the nodes is moved out of\n * range, thereby breaking the topology.  By default, this will result in\n * only 34 of 100 pings being received.  If the step size is reduced\n * to cover the gap, then all pings can be received.\n */\nclass aodvKmeansExample \n{\npublic:\n  aodvKmeansExample ();\n  /**\n   * \\brief Configure script parameters\n   * \\param argc is the command line argument count\n   * \\param argv is the command line arguments\n   * \\return true on successful configuration\n  */\n  bool Configure (int argc, char **argv);\n  /// Run simulation\n  void Run ();\n  /**\n   * Report results\n   * \\param os the output stream\n   */\n  void Report (std::ostream & os);\n\nprivate:\n\n  // parameters\n  /// Number of nodes\n  uint32_t size;\n  /// Distance between nodes, meters\n  double step;\n  /// Simulation time, seconds\n  double totalTime;\n  /// Write per-device PCAP traces if true\n  bool pcap;\n  /// Print routes if true\n  bool printRoutes;\n\n  // network\n  /// nodes used in the example\n  NodeContainer nodes;\n  /// devices used in the example\n  NetDeviceContainer devices;\n  /// interfaces used in the example\n  Ipv4InterfaceContainer interfaces;\n\nprivate:\n  /// Create the nodes\n  void CreateNodes ();\n  /// Create the devices\n  void CreateDevices ();\n  /// Create the network\n  void InstallInternetStack ();\n  /// Create the simulation applications\n  void InstallApplications ();\n};\n\nint main (int argc, char **argv)\n{\n  aodvKmeansExample test;\n  if (!test.Configure (argc, argv))\n    NS_FATAL_ERROR (\"Configuration failed. Aborted.\");\n\n  test.Run ();\n  test.Report (std::cout);\n  return 0;\n}\n\n//-----------------------------------------------------------------------------\naodvKmeansExample::aodvKmeansExample () :\n  size (10),\n  step (50),\n  totalTime (100),\n  pcap (false),\n  printRoutes (false)\n{\n}\n\nbool\naodvKmeansExample::Configure (int argc, char **argv)\n{\n  // Enable aodvKmeans logs by default. Comment this if too noisy\n  // LogComponentEnable(\"aodvKmeansRoutingProtocol\", LOG_LEVEL_ALL);\n\n  SeedManager::SetSeed (12345);\n  CommandLine cmd (__FILE__);\n\n  cmd.AddValue (\"pcap\", \"Write PCAP traces.\", pcap);\n  cmd.AddValue (\"printRoutes\", \"Print routing table dumps.\", printRoutes);\n  cmd.AddValue (\"size\", \"Number of nodes.\", size);\n  cmd.AddValue (\"time\", \"Simulation time, s.\", totalTime);\n  cmd.AddValue (\"step\", \"Grid step, m\", step);\n\n  cmd.Parse (argc, argv);\n  return true;\n}\n\nvoid\naodvKmeansExample::Run ()\n{\n//  Config::SetDefault (\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", UintegerValue (1)); // enable rts cts all the time.\n  CreateNodes ();\n  CreateDevices ();\n  InstallInternetStack ();\n  InstallApplications ();\n\n  std::cout << \"Starting simulation for \" << totalTime << \" s ...\\n\";\n\n  Simulator::Stop (Seconds (totalTime));\n  Simulator::Run ();\n  Simulator::Destroy ();\n}\n\nvoid\naodvKmeansExample::Report (std::ostream &)\n{ \n}\n\nvoid\naodvKmeansExample::CreateNodes ()\n{\n  std::cout << \"Creating \" << (unsigned)size << \" nodes \" << step << \" m apart.\\n\";\n  nodes.Create (size);\n  // Name nodes\n  for (uint32_t i = 0; i < size; ++i)\n    {\n      std::ostringstream os;\n      os << \"node-\" << i;\n      Names::Add (os.str (), nodes.Get (i));\n    }\n  // Create static grid\n  MobilityHelper mobility;\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0),\n                                 \"MinY\", DoubleValue (0.0),\n                                 \"DeltaX\", DoubleValue (step),\n                                 \"DeltaY\", DoubleValue (0),\n                                 \"GridWidth\", UintegerValue (size),\n                                 \"LayoutType\", StringValue (\"RowFirst\"));\n  mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install (nodes);\n}\n\nvoid\naodvKmeansExample::CreateDevices ()\n{\n  WifiMacHelper wifiMac;\n  wifiMac.SetType (\"ns3::AdhocWifiMac\"); \n  YansWifiPhyHelper wifiPhy;\n  YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default ();\n  wifiPhy.SetChannel (wifiChannel.Create ());\n  WifiHelper wifi;\n  \n  wifi.SetRemoteStationManager (\"ns3::ConstantRateWifiManager\", \"DataMode\", StringValue (\"OfdmRate6Mbps\"), \"RtsCtsThreshold\", UintegerValue (0));\n  devices = wifi.Install (wifiPhy, wifiMac, nodes); \n\n  if (pcap)\n    {\n      wifiPhy.EnablePcapAll (std::string (\"aodvKmeans\"));\n    }\n}\n\nvoid\naodvKmeansExample::InstallInternetStack ()\n{\n  aodvKmeansHelper aodvKmeans;\n  // you can configure aodvKmeans attributes here using aodvKmeans.Set(name, value)\n  InternetStackHelper stack;\n  stack.SetRoutingHelper (aodvKmeans); // has effect on the next Install ()\n  stack.Install (nodes);\n  Ipv4AddressHelper address;\n  address.SetBase (\"10.0.0.0\", \"255.0.0.0\");\n  interfaces = address.Assign (devices);\n\n  if (printRoutes)\n    {\n      Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper> (\"aodvKmeans.routes\", std::ios::out);\n      aodvKmeans.PrintRoutingTableAllAt (Seconds (8), routingStream);\n    }\n}\n\nvoid\naodvKmeansExample::InstallApplications ()\n{\n  V4PingHelper ping (interfaces.GetAddress (size - 1));\n  ping.SetAttribute (\"Verbose\", BooleanValue (true));\n\n  ApplicationContainer p = ping.Install (nodes.Get (0));\n  p.Start (Seconds (0));\n  p.Stop (Seconds (totalTime) - Seconds (0.001));\n\n  // move node away\n  Ptr<Node> node = nodes.Get (size/2);\n  Ptr<MobilityModel> mob = node->GetObject<MobilityModel> ();\n  Simulator::Schedule (Seconds (totalTime/3), &MobilityModel::SetPosition, mob, Vector (1e5, 1e5, 1e5));\n}\n\n"
    },
    {
      "file_path": "aodvKmeans/helper/aodvKmeans-helper.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2009 IITP RAS\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Authors: Pavel Boyko <boyko@iitp.ru>, written after OlsrHelper by Mathieu Lacage <mathieu.lacage@sophia.inria.fr>\n */\n#include \"aodvKmeans-helper.h\"\n#include \"ns3/aodvKmeans-routing-protocol.h\"\n#include \"ns3/node-list.h\"\n#include \"ns3/names.h\"\n#include \"ns3/ptr.h\"\n#include \"ns3/ipv4-list-routing.h\"\n\nnamespace ns3\n{\n\naodvKmeansHelper::aodvKmeansHelper() : \n  Ipv4RoutingHelper ()\n{\n  m_agentFactory.SetTypeId (\"ns3::aodvKmeans::RoutingProtocol\");\n}\n\naodvKmeansHelper* \naodvKmeansHelper::Copy (void) const \n{\n  return new aodvKmeansHelper (*this); \n}\n\nPtr<Ipv4RoutingProtocol> \naodvKmeansHelper::Create (Ptr<Node> node) const\n{\n  Ptr<aodvKmeans::RoutingProtocol> agent = m_agentFactory.Create<aodvKmeans::RoutingProtocol> ();\n  node->AggregateObject (agent);\n  return agent;\n}\n\nvoid \naodvKmeansHelper::Set (std::string name, const AttributeValue &value)\n{\n  m_agentFactory.Set (name, value);\n}\n\nint64_t\naodvKmeansHelper::AssignStreams (NodeContainer c, int64_t stream)\n{\n  int64_t currentStream = stream;\n  Ptr<Node> node;\n  for (NodeContainer::Iterator i = c.Begin (); i != c.End (); ++i)\n    {\n      node = (*i);\n      Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();\n      NS_ASSERT_MSG (ipv4, \"Ipv4 not installed on node\");\n      Ptr<Ipv4RoutingProtocol> proto = ipv4->GetRoutingProtocol ();\n      NS_ASSERT_MSG (proto, \"Ipv4 routing not installed on node\");\n      Ptr<aodvKmeans::RoutingProtocol> aodvKmeans = DynamicCast<aodvKmeans::RoutingProtocol> (proto);\n      if (aodvKmeans)\n        {\n          currentStream += aodvKmeans->AssignStreams (currentStream);\n          continue;\n        }\n      // aodvKmeans may also be in a list\n      Ptr<Ipv4ListRouting> list = DynamicCast<Ipv4ListRouting> (proto);\n      if (list)\n        {\n          int16_t priority;\n          Ptr<Ipv4RoutingProtocol> listProto;\n          Ptr<aodvKmeans::RoutingProtocol> listaodvKmeans;\n          for (uint32_t i = 0; i < list->GetNRoutingProtocols (); i++)\n            {\n              listProto = list->GetRoutingProtocol (i, priority);\n              listaodvKmeans = DynamicCast<aodvKmeans::RoutingProtocol> (listProto);\n              if (listaodvKmeans)\n                {\n                  currentStream += listaodvKmeans->AssignStreams (currentStream);\n                  break;\n                }\n            }\n        }\n    }\n  return (currentStream - stream);\n}\n\n}\n"
    },
    {
      "file_path": "aodvKmeans/model/aodvKmeans-neighbor.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2009 IITP RAS\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Based on\n *      NS-2 aodvKmeans model developed by the CMU/MONARCH group and optimized and\n *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;\n *\n *      aodvKmeans-UU implementation by Erik Nordstr\u00f6m of Uppsala University\n *      http://core.it.uu.se/core/index.php/aodvKmeans-UU\n *\n * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>\n *          Pavel Boyko <boyko@iitp.ru>\n */\n\n#include <algorithm>\n#include \"ns3/log.h\"\n#include \"ns3/wifi-mac-header.h\"\n#include \"aodvKmeans-neighbor.h\"\n\nnamespace ns3 {\n\nNS_LOG_COMPONENT_DEFINE (\"aodvKmeansNeighbors\");\n\nnamespace aodvKmeans {\nNeighbors::Neighbors (Time delay)\n  : m_ntimer (Timer::CANCEL_ON_DESTROY)\n{\n  m_ntimer.SetDelay (delay);\n  m_ntimer.SetFunction (&Neighbors::Purge, this);\n  m_txErrorCallback = MakeCallback (&Neighbors::ProcessTxError, this);\n}\n\nbool\nNeighbors::IsNeighbor (Ipv4Address addr)\n{\n  Purge ();\n  for (std::vector<Neighbor>::const_iterator i = m_nb.begin ();\n       i != m_nb.end (); ++i)\n    {\n      if (i->m_neighborAddress == addr)\n        {\n          return true;\n        }\n    }\n  return false;\n}\n\nTime\nNeighbors::GetExpireTime (Ipv4Address addr)\n{\n  Purge ();\n  for (std::vector<Neighbor>::const_iterator i = m_nb.begin (); i\n       != m_nb.end (); ++i)\n    {\n      if (i->m_neighborAddress == addr)\n        {\n          return (i->m_expireTime - Simulator::Now ());\n        }\n    }\n  return Seconds (0);\n}\n\nvoid\nNeighbors::Update (Ipv4Address addr, Time expire)\n{\n  for (std::vector<Neighbor>::iterator i = m_nb.begin (); i != m_nb.end (); ++i)\n    {\n      if (i->m_neighborAddress == addr)\n        {\n          i->m_expireTime\n            = std::max (expire + Simulator::Now (), i->m_expireTime);\n          if (i->m_hardwareAddress == Mac48Address ())\n            {\n              i->m_hardwareAddress = LookupMacAddress (i->m_neighborAddress);\n            }\n          return;\n        }\n    }\n\n  NS_LOG_LOGIC (\"Open link to \" << addr);\n  Neighbor neighbor (addr, LookupMacAddress (addr), expire + Simulator::Now ());\n  m_nb.push_back (neighbor);\n  Purge ();\n}\n\n\n\n\n\n\n\n/**\n * \\brief CloseNeighbor structure\n */\nstruct CloseNeighbor\n{\n  /**\n   * Check if the entry is expired\n   *\n   * \\param nb Neighbors::Neighbor entry\n   * \\return true if expired, false otherwise\n   */\n  bool operator() (const Neighbors::Neighbor & nb) const\n  {\n    return ((nb.m_expireTime < Simulator::Now ()) || nb.close);\n  }\n};\n\nvoid\nNeighbors::Purge ()\n{\n  if (m_nb.empty ())\n    {\n      return;\n    }\n\n  CloseNeighbor pred;\n  if (!m_handleLinkFailure.IsNull ())\n    {\n      for (std::vector<Neighbor>::iterator j = m_nb.begin (); j != m_nb.end (); ++j)\n        {\n          if (pred (*j))\n            {\n              NS_LOG_LOGIC (\"Close link to \" << j->m_neighborAddress);\n              m_handleLinkFailure (j->m_neighborAddress);\n            }\n        }\n    }\n  m_nb.erase (std::remove_if (m_nb.begin (), m_nb.end (), pred), m_nb.end ());\n  m_ntimer.Cancel ();\n  m_ntimer.Schedule ();\n}\n\nvoid\nNeighbors::ScheduleTimer ()\n{\n  m_ntimer.Cancel ();\n  m_ntimer.Schedule ();\n}\n\nvoid\nNeighbors::AddArpCache (Ptr<ArpCache> a)\n{\n  m_arp.push_back (a);\n}\n\nvoid\nNeighbors::DelArpCache (Ptr<ArpCache> a)\n{\n  m_arp.erase (std::remove (m_arp.begin (), m_arp.end (), a), m_arp.end ());\n}\n\nMac48Address\nNeighbors::LookupMacAddress (Ipv4Address addr)\n{\n  Mac48Address hwaddr;\n  for (std::vector<Ptr<ArpCache> >::const_iterator i = m_arp.begin ();\n       i != m_arp.end (); ++i)\n    {\n      ArpCache::Entry * entry = (*i)->Lookup (addr);\n      if (entry != 0 && (entry->IsAlive () || entry->IsPermanent ()) && !entry->IsExpired ())\n        {\n          hwaddr = Mac48Address::ConvertFrom (entry->GetMacAddress ());\n          break;\n        }\n    }\n  return hwaddr;\n}\n\n\n\nvoid\nNeighbors::ProcessTxError (WifiMacHeader const & hdr)\n{\n  Mac48Address addr = hdr.GetAddr1 ();\n\n  for (std::vector<Neighbor>::iterator i = m_nb.begin (); i != m_nb.end (); ++i)\n    {\n      if (i->m_hardwareAddress == addr)\n        {\n          i->close = true;\n        }\n    }\n  Purge ();\n}\n\n}  // namespace aodvKmeans\n}  // namespace ns3\n\n"
    },
    {
      "file_path": "aodvKmeans/model/aodvKmeans-packet.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2009 IITP RAS\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Based on\n *      NS-2 aodvKmeans model developed by the CMU/MONARCH group and optimized and\n *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;\n *\n *      aodvKmeans-UU implementation by Erik Nordstr\u00f6m of Uppsala University\n *      http://core.it.uu.se/core/index.php/aodvKmeans-UU\n *\n * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>\n *          Pavel Boyko <boyko@iitp.ru>\n */\n#include \"aodvKmeans-packet.h\"\n#include \"ns3/address-utils.h\"\n#include \"ns3/packet.h\"\n\nnamespace ns3 {\nnamespace aodvKmeans {\n\nNS_OBJECT_ENSURE_REGISTERED (TypeHeader);\n\nTypeHeader::TypeHeader (MessageType t)\n  : m_type (t),\n    m_valid (true)\n{\n}\n\nTypeId\nTypeHeader::GetTypeId ()\n{\n  static TypeId tid = TypeId (\"ns3::aodvKmeans::TypeHeader\")\n    .SetParent<Header> ()\n    .SetGroupName (\"aodvKmeans\")\n    .AddConstructor<TypeHeader> ()\n  ;\n  return tid;\n}\n\nTypeId\nTypeHeader::GetInstanceTypeId () const\n{\n  return GetTypeId ();\n}\n\nuint32_t\nTypeHeader::GetSerializedSize () const\n{\n  return 1;\n}\n\nvoid\nTypeHeader::Serialize (Buffer::Iterator i) const\n{\n  i.WriteU8 ((uint8_t) m_type);\n}\n\nuint32_t\nTypeHeader::Deserialize (Buffer::Iterator start)\n{\n  Buffer::Iterator i = start;\n  uint8_t type = i.ReadU8 ();\n  m_valid = true;\n  switch (type)\n    {\n    case aodvKmeansTYPE_RREQ:\n    case aodvKmeansTYPE_RREP:\n    case aodvKmeansTYPE_RERR:\n    case aodvKmeansTYPE_RREP_ACK:\n      {\n        m_type = (MessageType) type;\n        break;\n      }\n    default:\n      m_valid = false;\n    }\n  uint32_t dist = i.GetDistanceFrom (start);\n  NS_ASSERT (dist == GetSerializedSize ());\n  return dist;\n}\n\nvoid\nTypeHeader::Print (std::ostream &os) const\n{\n  switch (m_type)\n    {\n    case aodvKmeansTYPE_RREQ:\n      {\n        os << \"RREQ\";\n        break;\n      }\n    case aodvKmeansTYPE_RREP:\n      {\n        os << \"RREP\";\n        break;\n      }\n    case aodvKmeansTYPE_RERR:\n      {\n        os << \"RERR\";\n        break;\n      }\n    case aodvKmeansTYPE_RREP_ACK:\n      {\n        os << \"RREP_ACK\";\n        break;\n      }\n    default:\n      os << \"UNKNOWN_TYPE\";\n    }\n}\n\nbool\nTypeHeader::operator== (TypeHeader const & o) const\n{\n  return (m_type == o.m_type && m_valid == o.m_valid);\n}\n\nstd::ostream &\noperator<< (std::ostream & os, TypeHeader const & h)\n{\n  h.Print (os);\n  return os;\n}\n\n//-----------------------------------------------------------------------------\n// RREQ\n//-----------------------------------------------------------------------------\nRreqHeader::RreqHeader (uint8_t flags, uint8_t reserved, uint8_t hopCount, uint32_t requestID, Ipv4Address dst,\n                        uint32_t dstSeqNo, Ipv4Address origin, uint32_t originSeqNo)\n  : m_flags (flags),\n    m_reserved (reserved),\n    m_hopCount (hopCount),\n    m_requestID (requestID),\n    m_dst (dst),\n    m_dstSeqNo (dstSeqNo),\n    m_origin (origin),\n    m_originSeqNo (originSeqNo)\n{\n}\n\nNS_OBJECT_ENSURE_REGISTERED (RreqHeader);\n\nTypeId\nRreqHeader::GetTypeId ()\n{\n  static TypeId tid = TypeId (\"ns3::aodvKmeans::RreqHeader\")\n    .SetParent<Header> ()\n    .SetGroupName (\"aodvKmeans\")\n    .AddConstructor<RreqHeader> ()\n  ;\n  return tid;\n}\n\nTypeId\nRreqHeader::GetInstanceTypeId () const\n{\n  return GetTypeId ();\n}\n\nuint32_t\nRreqHeader::GetSerializedSize () const\n{\n  return 23;\n}\n\nvoid\nRreqHeader::Serialize (Buffer::Iterator i) const\n{\n  i.WriteU8 (m_flags);\n  i.WriteU8 (m_reserved);\n  i.WriteU8 (m_hopCount);\n  i.WriteHtonU32 (m_requestID);\n  WriteTo (i, m_dst);\n  i.WriteHtonU32 (m_dstSeqNo);\n  WriteTo (i, m_origin);\n  i.WriteHtonU32 (m_originSeqNo);\n}\n\nuint32_t\nRreqHeader::Deserialize (Buffer::Iterator start)\n{\n  Buffer::Iterator i = start;\n  m_flags = i.ReadU8 ();\n  m_reserved = i.ReadU8 ();\n  m_hopCount = i.ReadU8 ();\n  m_requestID = i.ReadNtohU32 ();\n  ReadFrom (i, m_dst);\n  m_dstSeqNo = i.ReadNtohU32 ();\n  ReadFrom (i, m_origin);\n  m_originSeqNo = i.ReadNtohU32 ();\n\n  uint32_t dist = i.GetDistanceFrom (start);\n  NS_ASSERT (dist == GetSerializedSize ());\n  return dist;\n}\n\nvoid\nRreqHeader::Print (std::ostream &os) const\n{\n  os << \"RREQ ID \" << m_requestID << \" destination: ipv4 \" << m_dst\n     << \" sequence number \" << m_dstSeqNo << \" source: ipv4 \"\n     << m_origin << \" sequence number \" << m_originSeqNo\n     << \" flags:\" << \" Gratuitous RREP \" << (*this).GetGratuitousRrep ()\n     << \" Destination only \" << (*this).GetDestinationOnly ()\n     << \" Unknown sequence number \" << (*this).GetUnknownSeqno ()\n     << \" Hop count \" <<  unsigned((*this).GetHopCount())\n     << \"\\n\";\n}\n\nstd::ostream &\noperator<< (std::ostream & os, RreqHeader const & h)\n{\n  h.Print (os);\n  return os;\n}\n\nvoid\nRreqHeader::SetGratuitousRrep (bool f)\n{\n  if (f)\n    {\n      m_flags |= (1 << 5);\n    }\n  else\n    {\n      m_flags &= ~(1 << 5);\n    }\n}\n\nbool\nRreqHeader::GetGratuitousRrep () const\n{\n  return (m_flags & (1 << 5));\n}\n\nvoid\nRreqHeader::SetDestinationOnly (bool f)\n{\n  if (f)\n    {\n      m_flags |= (1 << 4);\n    }\n  else\n    {\n      m_flags &= ~(1 << 4);\n    }\n}\n\nbool\nRreqHeader::GetDestinationOnly () const\n{\n  return (m_flags & (1 << 4));\n}\n\nvoid\nRreqHeader::SetUnknownSeqno (bool f)\n{\n  if (f)\n    {\n      m_flags |= (1 << 3);\n    }\n  else\n    {\n      m_flags &= ~(1 << 3);\n    }\n}\n\nbool\nRreqHeader::GetUnknownSeqno () const\n{\n  return (m_flags & (1 << 3));\n}\n\nbool\nRreqHeader::operator== (RreqHeader const & o) const\n{\n  return (m_flags == o.m_flags && m_reserved == o.m_reserved\n          && m_hopCount == o.m_hopCount && m_requestID == o.m_requestID\n          && m_dst == o.m_dst && m_dstSeqNo == o.m_dstSeqNo\n          && m_origin == o.m_origin && m_originSeqNo == o.m_originSeqNo);\n}\n\n//-----------------------------------------------------------------------------\n// RREP\n//-----------------------------------------------------------------------------\n\nRrepHeader::RrepHeader (uint8_t prefixSize, uint8_t hopCount, Ipv4Address dst,\n                        uint32_t dstSeqNo, Ipv4Address origin, Time lifeTime, \n                        uint32_t errorCount, uint32_t freeSpace,\n                        uint32_t positionX, uint32_t positionY)\n  : m_flags (0),\n    m_prefixSize (prefixSize),\n    m_hopCount (hopCount),\n    m_dst (dst),\n    m_dstSeqNo (dstSeqNo),\n    m_origin (origin),\n    m_txErrorCount(errorCount),\n    m_freeSpace(freeSpace),\n    m_positionX(positionX),\n    m_positionY(positionY)\n{\n  m_lifeTime = uint32_t (lifeTime.GetMilliSeconds ());\n}\n\nNS_OBJECT_ENSURE_REGISTERED (RrepHeader);\n\nTypeId\nRrepHeader::GetTypeId ()\n{\n  static TypeId tid = TypeId (\"ns3::aodvKmeans::RrepHeader\")\n    .SetParent<Header> ()\n    .SetGroupName (\"aodvKmeans\")\n    .AddConstructor<RrepHeader> ()\n  ;\n  return tid;\n}\n\nTypeId\nRrepHeader::GetInstanceTypeId () const\n{\n  return GetTypeId ();\n}\n\nuint32_t\nRrepHeader::GetSerializedSize () const\n{\n  return 19 + 4 * 4;\n}\nvoid\nRrepHeader::Serialize (Buffer::Iterator i) const\n{\n  i.WriteU8 (m_flags);\n  i.WriteU8 (m_prefixSize);\n  i.WriteU8 (m_hopCount);\n  WriteTo (i, m_dst);\n  i.WriteHtonU32 (m_dstSeqNo);\n  WriteTo (i, m_origin);\n  i.WriteHtonU32 (m_lifeTime);\n  i.WriteU32 (m_txErrorCount);\n  i.WriteU32 (m_freeSpace);\n  i.WriteU32 (m_positionX);\n  i.WriteU32 (m_positionY);\n}\nuint32_t\nRrepHeader::Deserialize (Buffer::Iterator start)\n{\n  Buffer::Iterator i = start;\n\n  m_flags = i.ReadU8 ();\n  m_prefixSize = i.ReadU8 (); \n  m_hopCount = i.ReadU8 ();\n  ReadFrom (i, m_dst);\n  m_dstSeqNo = i.ReadNtohU32 ();\n  ReadFrom (i, m_origin);\n  m_lifeTime = i.ReadNtohU32 ();\n  m_txErrorCount = i.ReadU32();\n  m_freeSpace = i.ReadU32();\n  m_positionX = i.ReadU32();\n  m_positionY = i.ReadU32();\n\n\n  uint32_t dist = i.GetDistanceFrom (start);\n  NS_ASSERT (dist == GetSerializedSize ());\n  return dist;\n}\n\nvoid\nRrepHeader::Print (std::ostream &os) const\n{\n  os << \"destination: ipv4 \" << m_dst << \" sequence number \" << m_dstSeqNo;\n  if (m_prefixSize != 0)\n    {\n      os << \" prefix size \" << m_prefixSize;\n    }\n  os << \" source ipv4 \" << m_origin << \" lifetime \" << m_lifeTime\n     << \" acknowledgment required flag \" << (*this).GetAckRequired ();\n}\n\nvoid\nRrepHeader::SetLifeTime (Time t)\n{\n  m_lifeTime = t.GetMilliSeconds ();\n}\n\nTime\nRrepHeader::GetLifeTime () const\n{\n  Time t (MilliSeconds (m_lifeTime));\n  return t;\n}\n\nvoid\nRrepHeader::SetAckRequired (bool f)\n{\n  if (f)\n    {\n      m_flags |= (1 << 6);\n    }\n  else\n    {\n      m_flags &= ~(1 << 6);\n    }\n}\n\nbool\nRrepHeader::GetAckRequired () const\n{\n  return (m_flags & (1 << 6));\n}\n\nvoid\nRrepHeader::SetPrefixSize (uint8_t sz)\n{\n  m_prefixSize = sz;\n}\n\nuint8_t\nRrepHeader::GetPrefixSize () const\n{\n  return m_prefixSize;\n}\n\nbool\nRrepHeader::operator== (RrepHeader const & o) const\n{\n  return (m_flags == o.m_flags && m_prefixSize == o.m_prefixSize\n          && m_hopCount == o.m_hopCount && m_dst == o.m_dst && m_dstSeqNo == o.m_dstSeqNo\n          && m_origin == o.m_origin && m_lifeTime == o.m_lifeTime \n          && m_txErrorCount == o.m_txErrorCount && m_freeSpace == o.m_freeSpace\n          && m_positionX == o.m_positionX && m_positionY == o.m_positionY);\n}\n\nvoid\nRrepHeader::SetHello (Ipv4Address origin, uint32_t srcSeqNo, Time lifetime)\n{\n  m_flags = 0;\n  m_prefixSize = 0;\n  m_hopCount = 0;\n  m_dst = origin;\n  m_dstSeqNo = srcSeqNo;\n  m_origin = origin;\n  m_lifeTime = lifetime.GetMilliSeconds ();\n  m_txErrorCount = 0;\n}\n\nstd::ostream &\noperator<< (std::ostream & os, RrepHeader const & h)\n{\n  h.Print (os);\n  return os;\n}\n\n//-----------------------------------------------------------------------------\n// RREP-ACK\n//-----------------------------------------------------------------------------\n\nRrepAckHeader::RrepAckHeader ()\n  : m_reserved (0)\n{\n}\n\nNS_OBJECT_ENSURE_REGISTERED (RrepAckHeader);\n\nTypeId\nRrepAckHeader::GetTypeId ()\n{\n  static TypeId tid = TypeId (\"ns3::aodvKmeans::RrepAckHeader\")\n    .SetParent<Header> ()\n    .SetGroupName (\"aodvKmeans\")\n    .AddConstructor<RrepAckHeader> ()\n  ;\n  return tid;\n}\n\nTypeId\nRrepAckHeader::GetInstanceTypeId () const\n{\n  return GetTypeId ();\n}\n\nuint32_t\nRrepAckHeader::GetSerializedSize () const\n{\n  return 1;\n}\n\nvoid\nRrepAckHeader::Serialize (Buffer::Iterator i ) const\n{\n  i.WriteU8 (m_reserved);\n}\n\nuint32_t\nRrepAckHeader::Deserialize (Buffer::Iterator start )\n{\n  Buffer::Iterator i = start;\n  m_reserved = i.ReadU8 ();\n  uint32_t dist = i.GetDistanceFrom (start);\n  NS_ASSERT (dist == GetSerializedSize ());\n  return dist;\n}\n\nvoid\nRrepAckHeader::Print (std::ostream &os ) const\n{\n}\n\nbool\nRrepAckHeader::operator== (RrepAckHeader const & o ) const\n{\n  return m_reserved == o.m_reserved;\n}\n\nstd::ostream &\noperator<< (std::ostream & os, RrepAckHeader const & h )\n{\n  h.Print (os);\n  return os;\n}\n\n//-----------------------------------------------------------------------------\n// RERR\n//-----------------------------------------------------------------------------\nRerrHeader::RerrHeader ()\n  : m_flag (0),\n    m_reserved (0)\n{\n}\n\nNS_OBJECT_ENSURE_REGISTERED (RerrHeader);\n\nTypeId\nRerrHeader::GetTypeId ()\n{\n  static TypeId tid = TypeId (\"ns3::aodvKmeans::RerrHeader\")\n    .SetParent<Header> ()\n    .SetGroupName (\"aodvKmeans\")\n    .AddConstructor<RerrHeader> ()\n  ;\n  return tid;\n}\n\nTypeId\nRerrHeader::GetInstanceTypeId () const\n{\n  return GetTypeId ();\n}\n\nuint32_t\nRerrHeader::GetSerializedSize () const\n{\n  return (3 + 8 * GetDestCount ());\n}\n\nvoid\nRerrHeader::Serialize (Buffer::Iterator i ) const\n{\n  i.WriteU8 (m_flag);\n  i.WriteU8 (m_reserved);\n  i.WriteU8 (GetDestCount ());\n  std::map<Ipv4Address, uint32_t>::const_iterator j;\n  for (j = m_unreachableDstSeqNo.begin (); j != m_unreachableDstSeqNo.end (); ++j)\n    {\n      WriteTo (i, (*j).first);\n      i.WriteHtonU32 ((*j).second);\n    }\n}\n\nuint32_t\nRerrHeader::Deserialize (Buffer::Iterator start )\n{\n  Buffer::Iterator i = start;\n  m_flag = i.ReadU8 ();\n  m_reserved = i.ReadU8 ();\n  uint8_t dest = i.ReadU8 ();\n  m_unreachableDstSeqNo.clear ();\n  Ipv4Address address;\n  uint32_t seqNo;\n  for (uint8_t k = 0; k < dest; ++k)\n    {\n      ReadFrom (i, address);\n      seqNo = i.ReadNtohU32 ();\n      m_unreachableDstSeqNo.insert (std::make_pair (address, seqNo));\n    }\n\n  uint32_t dist = i.GetDistanceFrom (start);\n  NS_ASSERT (dist == GetSerializedSize ());\n  return dist;\n}\n\nvoid\nRerrHeader::Print (std::ostream &os ) const\n{\n  os << \"Unreachable destination (ipv4 address, seq. number):\";\n  std::map<Ipv4Address, uint32_t>::const_iterator j;\n  for (j = m_unreachableDstSeqNo.begin (); j != m_unreachableDstSeqNo.end (); ++j)\n    {\n      os << (*j).first << \", \" << (*j).second;\n    }\n  os << \"No delete flag \" << (*this).GetNoDelete ();\n}\n\nvoid\nRerrHeader::SetNoDelete (bool f )\n{\n  if (f)\n    {\n      m_flag |= (1 << 0);\n    }\n  else\n    {\n      m_flag &= ~(1 << 0);\n    }\n}\n\nbool\nRerrHeader::GetNoDelete () const\n{\n  return (m_flag & (1 << 0));\n}\n\nbool\nRerrHeader::AddUnDestination (Ipv4Address dst, uint32_t seqNo )\n{\n  if (m_unreachableDstSeqNo.find (dst) != m_unreachableDstSeqNo.end ())\n    {\n      return true;\n    }\n\n  NS_ASSERT (GetDestCount () < 255); // can't support more than 255 destinations in single RERR\n  m_unreachableDstSeqNo.insert (std::make_pair (dst, seqNo));\n  return true;\n}\n\nbool\nRerrHeader::RemoveUnDestination (std::pair<Ipv4Address, uint32_t> & un )\n{\n  if (m_unreachableDstSeqNo.empty ())\n    {\n      return false;\n    }\n  std::map<Ipv4Address, uint32_t>::iterator i = m_unreachableDstSeqNo.begin ();\n  un = *i;\n  m_unreachableDstSeqNo.erase (i);\n  return true;\n}\n\nvoid\nRerrHeader::Clear ()\n{\n  m_unreachableDstSeqNo.clear ();\n  m_flag = 0;\n  m_reserved = 0;\n}\n\nbool\nRerrHeader::operator== (RerrHeader const & o ) const\n{\n  if (m_flag != o.m_flag || m_reserved != o.m_reserved || GetDestCount () != o.GetDestCount ())\n    {\n      return false;\n    }\n\n  std::map<Ipv4Address, uint32_t>::const_iterator j = m_unreachableDstSeqNo.begin ();\n  std::map<Ipv4Address, uint32_t>::const_iterator k = o.m_unreachableDstSeqNo.begin ();\n  for (uint8_t i = 0; i < GetDestCount (); ++i)\n    {\n      if ((j->first != k->first) || (j->second != k->second))\n        {\n          return false;\n        }\n\n      j++;\n      k++;\n    }\n  return true;\n}\n\nstd::ostream &\noperator<< (std::ostream & os, RerrHeader const & h )\n{\n  h.Print (os);\n  return os;\n}\n}\n}\n"
    },
    {
      "file_path": "aodvKmeans/model/aodvKmeans-routing-protocol.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2009 IITP RAS\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Based on\n *      NS-2 aodvKmeans model developed by the CMU/MONARCH group and optimized and\n *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;\n *\n *      aodvKmeans-UU implementation by Erik Nordstr\u00f6m of Uppsala University\n *      http://core.it.uu.se/core/index.php/aodvKmeans-UU\n *\n * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>\n *          Pavel Boyko <boyko@iitp.ru>\n */\n#define NS_LOG_APPEND_CONTEXT                                   \\\n  if (m_ipv4) { std::clog << \"[node \" << m_ipv4->GetObject<Node> ()->GetId () << \"] \"; }\n\n#include \"aodvKmeans-routing-protocol.h\"\n#include \"ns3/log.h\"\n#include \"ns3/boolean.h\"\n#include \"ns3/random-variable-stream.h\"\n#include \"ns3/inet-socket-address.h\"\n#include \"ns3/trace-source-accessor.h\"\n#include \"ns3/udp-socket-factory.h\"\n#include \"ns3/udp-l4-protocol.h\"\n#include \"ns3/udp-header.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/adhoc-wifi-mac.h\"\n#include \"ns3/wifi-mac-queue-item.h\"\n#include \"ns3/string.h\"\n#include \"ns3/pointer.h\"\n#include <algorithm>\n#include <limits>\n\nnamespace ns3 {\n\nNS_LOG_COMPONENT_DEFINE (\"aodvKmeansRoutingProtocol\");\n\nnamespace aodvKmeans {\nNS_OBJECT_ENSURE_REGISTERED (RoutingProtocol);\n\n/// UDP Port for aodvKmeans control traffic\nconst uint32_t RoutingProtocol::aodvKmeans_PORT = 654;\n\n/**\n* \\ingroup aodvKmeans\n* \\brief Tag used by aodvKmeans implementation\n*/\nclass DeferredRouteOutputTag : public Tag\n{\n\npublic:\n  /**\n   * \\brief Constructor\n   * \\param o the output interface\n   */\n  DeferredRouteOutputTag (int32_t o = -1) : Tag (),\n                                            m_oif (o)\n  {\n  }\n\n  /**\n   * \\brief Get the type ID.\n   * \\return the object TypeId\n   */\n  static TypeId GetTypeId ()\n  {\n    static TypeId tid = TypeId (\"ns3::aodvKmeans::DeferredRouteOutputTag\")\n      .SetParent<Tag> ()\n      .SetGroupName (\"aodvKmeans\")\n      .AddConstructor<DeferredRouteOutputTag> ()\n    ;\n    return tid;\n  }\n\n  TypeId  GetInstanceTypeId () const\n  {\n    return GetTypeId ();\n  }\n\n  /**\n   * \\brief Get the output interface\n   * \\return the output interface\n   */\n  int32_t GetInterface () const\n  {\n    return m_oif;\n  }\n\n  /**\n   * \\brief Set the output interface\n   * \\param oif the output interface\n   */\n  void SetInterface (int32_t oif)\n  {\n    m_oif = oif;\n  }\n\n  uint32_t GetSerializedSize () const\n  {\n    return sizeof(int32_t);\n  }\n\n  void  Serialize (TagBuffer i) const\n  {\n    i.WriteU32 (m_oif);\n  }\n\n  void  Deserialize (TagBuffer i)\n  {\n    m_oif = i.ReadU32 ();\n  }\n\n  void  Print (std::ostream &os) const\n  {\n    os << \"DeferredRouteOutputTag: output interface = \" << m_oif;\n  }\n\nprivate:\n  /// Positive if output device is fixed in RouteOutput\n  int32_t m_oif;\n};\n\nNS_OBJECT_ENSURE_REGISTERED (DeferredRouteOutputTag);\n\n\n//-----------------------------------------------------------------------------\nRoutingProtocol::RoutingProtocol ()\n  : m_rreqRetries (2),\n    m_ttlStart (1),\n    m_ttlIncrement (2),\n    m_ttlThreshold (7),\n    m_timeoutBuffer (2),\n    m_rreqRateLimit (10),\n    m_rerrRateLimit (10),\n    m_activeRouteTimeout (Seconds (3)),\n    m_netDiameter (35),\n    m_nodeTraversalTime (MilliSeconds (40)),\n    m_netTraversalTime (Time ((2 * m_netDiameter) * m_nodeTraversalTime)),\n    m_pathDiscoveryTime ( Time (2 * m_netTraversalTime)),\n    m_myRouteTimeout (Time (2 * std::max (m_pathDiscoveryTime, m_activeRouteTimeout))),\n    m_helloInterval (Seconds (1)),\n    m_allowedHelloLoss (2),\n    m_deletePeriod (Time (5 * std::max (m_activeRouteTimeout, m_helloInterval))),\n    m_nextHopWait (m_nodeTraversalTime + MilliSeconds (10)),\n    m_blackListTimeout (Time (m_rreqRetries * m_netTraversalTime)),\n    m_maxQueueLen (64),\n    m_maxQueueTime (Seconds (30)),\n    m_destinationOnly (false),\n    m_gratuitousReply (true),\n    m_enableHello (false),\n    m_routingTable (m_deletePeriod),\n    m_queue (m_maxQueueLen, m_maxQueueTime),\n    m_requestId (0),\n    m_seqNo (0),\n    m_rreqIdCache (m_pathDiscoveryTime),\n    m_dpd (m_pathDiscoveryTime),\n    m_nb (m_helloInterval * 2),\n    m_rreqCount (0),\n    m_rerrCount (0),\n    m_txerrorCount(0),\n    m_htimer (Timer::CANCEL_ON_DESTROY),\n    m_rreqRateLimitTimer (Timer::CANCEL_ON_DESTROY),\n    m_rerrRateLimitTimer (Timer::CANCEL_ON_DESTROY),\n    m_lastBcastTime (Seconds (0))\n    \n{\n  m_nb.SetCallback (MakeCallback (&RoutingProtocol::SendRerrWhenBreaksLinkToNextHop, this));\n}\n\nTypeId\nRoutingProtocol::GetTypeId (void)\n{\n  static TypeId tid = TypeId (\"ns3::aodvKmeans::RoutingProtocol\")\n    .SetParent<Ipv4RoutingProtocol> ()\n    .SetGroupName (\"aodvKmeans\")\n    .AddConstructor<RoutingProtocol> ()\n    .AddAttribute (\"HelloInterval\", \"HELLO messages emission interval.\",\n                   TimeValue (Seconds (1)),\n                   MakeTimeAccessor (&RoutingProtocol::m_helloInterval),\n                   MakeTimeChecker ())\n    .AddAttribute (\"TtlStart\", \"Initial TTL value for RREQ.\",\n                   UintegerValue (1),\n                   MakeUintegerAccessor (&RoutingProtocol::m_ttlStart),\n                   MakeUintegerChecker<uint16_t> ())\n    .AddAttribute (\"TtlIncrement\", \"TTL increment for each attempt using the expanding ring search for RREQ dissemination.\",\n                   UintegerValue (2),\n                   MakeUintegerAccessor (&RoutingProtocol::m_ttlIncrement),\n                   MakeUintegerChecker<uint16_t> ())\n    .AddAttribute (\"TtlThreshold\", \"Maximum TTL value for expanding ring search, TTL = NetDiameter is used beyond this value.\",\n                   UintegerValue (7),\n                   MakeUintegerAccessor (&RoutingProtocol::m_ttlThreshold),\n                   MakeUintegerChecker<uint16_t> ())\n    .AddAttribute (\"TimeoutBuffer\", \"Provide a buffer for the timeout.\",\n                   UintegerValue (2),\n                   MakeUintegerAccessor (&RoutingProtocol::m_timeoutBuffer),\n                   MakeUintegerChecker<uint16_t> ())\n    .AddAttribute (\"RreqRetries\", \"Maximum number of retransmissions of RREQ to discover a route\",\n                   UintegerValue (2),\n                   MakeUintegerAccessor (&RoutingProtocol::m_rreqRetries),\n                   MakeUintegerChecker<uint32_t> ())\n    .AddAttribute (\"RreqRateLimit\", \"Maximum number of RREQ per second.\",\n                   UintegerValue (10),\n                   MakeUintegerAccessor (&RoutingProtocol::m_rreqRateLimit),\n                   MakeUintegerChecker<uint32_t> ())\n    .AddAttribute (\"RerrRateLimit\", \"Maximum number of RERR per second.\",\n                   UintegerValue (10),\n                   MakeUintegerAccessor (&RoutingProtocol::m_rerrRateLimit),\n                   MakeUintegerChecker<uint32_t> ())\n    .AddAttribute (\"NodeTraversalTime\", \"Conservative estimate of the average one hop traversal time for packets and should include \"\n                   \"queuing delays, interrupt processing times and transfer times.\",\n                   TimeValue (MilliSeconds (40)),\n                   MakeTimeAccessor (&RoutingProtocol::m_nodeTraversalTime),\n                   MakeTimeChecker ())\n    .AddAttribute (\"NextHopWait\", \"Period of our waiting for the neighbour's RREP_ACK = 10 ms + NodeTraversalTime\",\n                   TimeValue (MilliSeconds (50)),\n                   MakeTimeAccessor (&RoutingProtocol::m_nextHopWait),\n                   MakeTimeChecker ())\n    .AddAttribute (\"ActiveRouteTimeout\", \"Period of time during which the route is considered to be valid\",\n                   TimeValue (Seconds (3)),\n                   MakeTimeAccessor (&RoutingProtocol::m_activeRouteTimeout),\n                   MakeTimeChecker ())\n    .AddAttribute (\"MyRouteTimeout\", \"Value of lifetime field in RREP generating by this node = 2 * max(ActiveRouteTimeout, PathDiscoveryTime)\",\n                   TimeValue (Seconds (11.2)),\n                   MakeTimeAccessor (&RoutingProtocol::m_myRouteTimeout),\n                   MakeTimeChecker ())\n    .AddAttribute (\"BlackListTimeout\", \"Time for which the node is put into the blacklist = RreqRetries * NetTraversalTime\",\n                   TimeValue (Seconds (5.6)),\n                   MakeTimeAccessor (&RoutingProtocol::m_blackListTimeout),\n                   MakeTimeChecker ())\n    .AddAttribute (\"DeletePeriod\", \"DeletePeriod is intended to provide an upper bound on the time for which an upstream node A \"\n                   \"can have a neighbor B as an active next hop for destination D, while B has invalidated the route to D.\"\n                   \" = 5 * max (HelloInterval, ActiveRouteTimeout)\",\n                   TimeValue (Seconds (15)),\n                   MakeTimeAccessor (&RoutingProtocol::m_deletePeriod),\n                   MakeTimeChecker ())\n    .AddAttribute (\"NetDiameter\", \"Net diameter measures the maximum possible number of hops between two nodes in the network\",\n                   UintegerValue (35),\n                   MakeUintegerAccessor (&RoutingProtocol::m_netDiameter),\n                   MakeUintegerChecker<uint32_t> ())\n    .AddAttribute (\"NetTraversalTime\", \"Estimate of the average net traversal time = 2 * NodeTraversalTime * NetDiameter\",\n                   TimeValue (Seconds (2.8)),\n                   MakeTimeAccessor (&RoutingProtocol::m_netTraversalTime),\n                   MakeTimeChecker ())\n    .AddAttribute (\"PathDiscoveryTime\", \"Estimate of maximum time needed to find route in network = 2 * NetTraversalTime\",\n                   TimeValue (Seconds (5.6)),\n                   MakeTimeAccessor (&RoutingProtocol::m_pathDiscoveryTime),\n                   MakeTimeChecker ())\n    .AddAttribute (\"MaxQueueLen\", \"Maximum number of packets that we allow a routing protocol to buffer.\",\n                   UintegerValue (64),\n                   MakeUintegerAccessor (&RoutingProtocol::SetMaxQueueLen,\n                                         &RoutingProtocol::GetMaxQueueLen),\n                   MakeUintegerChecker<uint32_t> ())\n    .AddAttribute (\"MaxQueueTime\", \"Maximum time packets can be queued (in seconds)\",\n                   TimeValue (Seconds (30)),\n                   MakeTimeAccessor (&RoutingProtocol::SetMaxQueueTime,\n                                     &RoutingProtocol::GetMaxQueueTime),\n                   MakeTimeChecker ())\n    .AddAttribute (\"AllowedHelloLoss\", \"Number of hello messages which may be loss for valid link.\",\n                   UintegerValue (2),\n                   MakeUintegerAccessor (&RoutingProtocol::m_allowedHelloLoss),\n                   MakeUintegerChecker<uint16_t> ())\n    .AddAttribute (\"GratuitousReply\", \"Indicates whether a gratuitous RREP should be unicast to the node originated route discovery.\",\n                   BooleanValue (true),\n                   MakeBooleanAccessor (&RoutingProtocol::SetGratuitousReplyFlag,\n                                        &RoutingProtocol::GetGratuitousReplyFlag),\n                   MakeBooleanChecker ())\n    .AddAttribute (\"DestinationOnly\", \"Indicates only the destination may respond to this RREQ.\",\n                   BooleanValue (false),\n                   MakeBooleanAccessor (&RoutingProtocol::SetDestinationOnlyFlag,\n                                        &RoutingProtocol::GetDestinationOnlyFlag),\n                   MakeBooleanChecker ())\n    .AddAttribute (\"EnableHello\", \"Indicates whether a hello messages enable.\",\n                   BooleanValue (true),\n                   MakeBooleanAccessor (&RoutingProtocol::SetHelloEnable,\n                                        &RoutingProtocol::GetHelloEnable),\n                   MakeBooleanChecker ())\n    .AddAttribute (\"EnableBroadcast\", \"Indicates whether a broadcast data packets forwarding enable.\",\n                   BooleanValue (true),\n                   MakeBooleanAccessor (&RoutingProtocol::SetBroadcastEnable,\n                                        &RoutingProtocol::GetBroadcastEnable),\n                   MakeBooleanChecker ())\n    .AddAttribute (\"UniformRv\",\n                   \"Access to the underlying UniformRandomVariable\",\n                   StringValue (\"ns3::UniformRandomVariable\"),\n                   MakePointerAccessor (&RoutingProtocol::m_uniformRandomVariable),\n                   MakePointerChecker<UniformRandomVariable> ())\n  ;\n  return tid;\n}\n\nvoid\nRoutingProtocol::SetMaxQueueLen (uint32_t len)\n{\n  m_maxQueueLen = len;\n  m_queue.SetMaxQueueLen (len);\n}\nvoid\nRoutingProtocol::SetMaxQueueTime (Time t)\n{\n  m_maxQueueTime = t;\n  m_queue.SetQueueTimeout (t);\n}\n\nRoutingProtocol::~RoutingProtocol ()\n{\n}\n\nvoid\nRoutingProtocol::DoDispose ()\n{\n  m_ipv4 = 0;\n  for (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::iterator iter =\n         m_socketAddresses.begin (); iter != m_socketAddresses.end (); iter++)\n    {\n      iter->first->Close ();\n    }\n  m_socketAddresses.clear ();\n  for (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::iterator iter =\n         m_socketSubnetBroadcastAddresses.begin (); iter != m_socketSubnetBroadcastAddresses.end (); iter++)\n    {\n      iter->first->Close ();\n    }\n  m_socketSubnetBroadcastAddresses.clear ();\n  Ipv4RoutingProtocol::DoDispose ();\n}\n\nvoid\nRoutingProtocol::PrintRoutingTable (Ptr<OutputStreamWrapper> stream, Time::Unit unit) const\n{\n  *stream->GetStream () << \"Node: \" << m_ipv4->GetObject<Node> ()->GetId ()\n                        << \"; Time: \" << Now ().As (unit)\n                        << \", Local time: \" << m_ipv4->GetObject<Node> ()->GetLocalTime ().As (unit)\n                        << \", aodvKmeans Routing table\" << std::endl;\n\n  m_routingTable.Print (stream, unit);\n  *stream->GetStream () << std::endl;\n}\n\nint64_t\nRoutingProtocol::AssignStreams (int64_t stream)\n{\n  NS_LOG_FUNCTION (this << stream);\n  m_uniformRandomVariable->SetStream (stream);\n  return 1;\n}\n\nvoid\nRoutingProtocol::Start ()\n{\n  NS_LOG_FUNCTION (this);\n  if (m_enableHello)\n    {\n      m_nb.ScheduleTimer ();\n    }\n  m_rreqRateLimitTimer.SetFunction (&RoutingProtocol::RreqRateLimitTimerExpire,\n                                    this);\n  m_rreqRateLimitTimer.Schedule (Seconds (1));\n\n  m_rerrRateLimitTimer.SetFunction (&RoutingProtocol::RerrRateLimitTimerExpire,\n                                    this);\n  m_rerrRateLimitTimer.Schedule (Seconds (1));\n\n}\n\nPtr<Ipv4Route>\nRoutingProtocol::RouteOutput (Ptr<Packet> p, const Ipv4Header &header,\n                              Ptr<NetDevice> oif, Socket::SocketErrno &sockerr)\n{\n  NS_LOG_FUNCTION (this << header << (oif ? oif->GetIfIndex () : 0));\n  if (!p)\n    {\n      NS_LOG_DEBUG (\"Packet is == 0\");\n      return LoopbackRoute (header, oif); // later\n    }\n  if (m_socketAddresses.empty ())\n    {\n      sockerr = Socket::ERROR_NOROUTETOHOST;\n      NS_LOG_LOGIC (\"No aodvKmeans interfaces\");\n      Ptr<Ipv4Route> route;\n      return route;\n    }\n  sockerr = Socket::ERROR_NOTERROR;\n  Ptr<Ipv4Route> route;\n  Ipv4Address dst = header.GetDestination ();\n  RoutingTableEntry rt;\n  if (m_routingTable.LookupValidRoute (dst, rt))\n    {\n      route = rt.GetRoute ();\n      NS_ASSERT (route != 0);\n      NS_LOG_DEBUG (\"Exist route to \" << route->GetDestination () << \" from interface \" << route->GetSource ());\n      if (oif != 0 && route->GetOutputDevice () != oif)\n        {\n          NS_LOG_DEBUG (\"Output device doesn't match. Dropped.\");\n          sockerr = Socket::ERROR_NOROUTETOHOST;\n          return Ptr<Ipv4Route> ();\n        }\n      UpdateRouteLifeTime (dst, m_activeRouteTimeout);\n      UpdateRouteLifeTime (route->GetGateway (), m_activeRouteTimeout);\n      return route;\n    }\n\n  // Valid route not found, in this case we return loopback.\n  // Actual route request will be deferred until packet will be fully formed,\n  // routed to loopback, received from loopback and passed to RouteInput (see below)\n  uint32_t iif = (oif ? m_ipv4->GetInterfaceForDevice (oif) : -1);\n  DeferredRouteOutputTag tag (iif);\n  NS_LOG_DEBUG (\"Valid Route not found\");\n  if (!p->PeekPacketTag (tag))\n    {\n      p->AddPacketTag (tag);\n    }\n  return LoopbackRoute (header, oif);\n}\n\nvoid\nRoutingProtocol::DeferredRouteOutput (Ptr<const Packet> p, const Ipv4Header & header,\n                                      UnicastForwardCallback ucb, ErrorCallback ecb)\n{\n  NS_LOG_FUNCTION (this << p << header);\n  NS_ASSERT (p != 0 && p != Ptr<Packet> ());\n\n  QueueEntry newEntry (p, header, ucb, ecb);\n  bool result = m_queue.Enqueue (newEntry);\n  //std::cout << \"my queue size = \" << m_queue.GetSize()  << \" after adding packet for \" << header.GetDestination() << \"\\n\";\n  if (result)\n    {\n      NS_LOG_LOGIC (\"Add packet \" << p->GetUid () << \" to queue. Protocol \" << (uint16_t) header.GetProtocol ());\n      RoutingTableEntry rt;\n      bool result = m_routingTable.LookupRoute (header.GetDestination (), rt);\n      if (!result || ((rt.GetFlag () != IN_SEARCH) && result))\n        {\n          NS_LOG_LOGIC (\"Send new RREQ for outbound packet to \" << header.GetDestination ());\n          SendRequest (header.GetDestination ());\n        }\n    }\n}\n\nbool\nRoutingProtocol::RouteInput (Ptr<const Packet> p, const Ipv4Header &header,\n                             Ptr<const NetDevice> idev, UnicastForwardCallback ucb,\n                             MulticastForwardCallback mcb, LocalDeliverCallback lcb, ErrorCallback ecb)\n{\n  NS_LOG_FUNCTION (this << p->GetUid () << header.GetDestination () << idev->GetAddress ());\n  if (m_socketAddresses.empty ())\n    {\n      NS_LOG_LOGIC (\"No aodvKmeans interfaces\");\n      return false;\n    }\n  NS_ASSERT (m_ipv4 != 0);\n  NS_ASSERT (p != 0);\n  // Check if input device supports IP\n  NS_ASSERT (m_ipv4->GetInterfaceForDevice (idev) >= 0);\n  int32_t iif = m_ipv4->GetInterfaceForDevice (idev);\n\n  Ipv4Address dst = header.GetDestination ();\n  Ipv4Address origin = header.GetSource ();\n\n  // Deferred route request\n  if (idev == m_lo)\n    {\n      DeferredRouteOutputTag tag;\n      if (p->PeekPacketTag (tag))\n        {\n          DeferredRouteOutput (p, header, ucb, ecb);\n          return true;\n        }\n    }\n\n  // Duplicate of own packet\n  if (IsMyOwnAddress (origin))\n    {\n      return true;\n    }\n\n  // aodvKmeans is not a multicast routing protocol\n  if (dst.IsMulticast ())\n    {\n      return false;\n    }\n\n  // Broadcast local delivery/forwarding\n  for (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const_iterator j =\n         m_socketAddresses.begin (); j != m_socketAddresses.end (); ++j)\n    {\n      Ipv4InterfaceAddress iface = j->second;\n      if (m_ipv4->GetInterfaceForAddress (iface.GetLocal ()) == iif)\n        {\n          if (dst == iface.GetBroadcast () || dst.IsBroadcast ())\n            {\n              if (m_dpd.IsDuplicate (p, header))\n                {\n                  NS_LOG_DEBUG (\"Duplicated packet \" << p->GetUid () << \" from \" << origin << \". Drop.\");\n                  return true;\n                }\n              UpdateRouteLifeTime (origin, m_activeRouteTimeout);\n              Ptr<Packet> packet = p->Copy ();\n              if (lcb.IsNull () == false)\n                {\n                  NS_LOG_LOGIC (\"Broadcast local delivery to \" << iface.GetLocal ());\n                  lcb (p, header, iif);\n                  // Fall through to additional processing\n                }\n              else\n                {\n                  NS_LOG_ERROR (\"Unable to deliver packet locally due to null callback \" << p->GetUid () << \" from \" << origin);\n                  ecb (p, header, Socket::ERROR_NOROUTETOHOST);\n                }\n              if (!m_enableBroadcast)\n                {\n                  return true;\n                }\n              if (header.GetProtocol () == UdpL4Protocol::PROT_NUMBER)\n                {\n                  UdpHeader udpHeader;\n                  p->PeekHeader (udpHeader);\n                  if (udpHeader.GetDestinationPort () == aodvKmeans_PORT)\n                    {\n                      // aodvKmeans packets sent in broadcast are already managed\n                      return true;\n                    }\n                }\n              if (header.GetTtl () > 1)\n                {\n                  NS_LOG_LOGIC (\"Forward broadcast. TTL \" << (uint16_t) header.GetTtl ());\n                  RoutingTableEntry toBroadcast;\n                  if (m_routingTable.LookupRoute (dst, toBroadcast))\n                    {\n                      Ptr<Ipv4Route> route = toBroadcast.GetRoute ();\n                      ucb (route, packet, header);\n                    }\n                  else\n                    {\n                      NS_LOG_DEBUG (\"No route to forward broadcast. Drop packet \" << p->GetUid ());\n                    }\n                }\n              else\n                {\n                  NS_LOG_DEBUG (\"TTL exceeded. Drop packet \" << p->GetUid ());\n                }\n              return true;\n            }\n        }\n    }\n\n  // Unicast local delivery\n  if (m_ipv4->IsDestinationAddress (dst, iif))\n    {\n      UpdateRouteLifeTime (origin, m_activeRouteTimeout);\n      RoutingTableEntry toOrigin;\n      if (m_routingTable.LookupValidRoute (origin, toOrigin))\n        {\n          UpdateRouteLifeTime (toOrigin.GetNextHop (), m_activeRouteTimeout);\n          m_nb.Update (toOrigin.GetNextHop (), m_activeRouteTimeout);\n        }\n      if (lcb.IsNull () == false)\n        {\n          NS_LOG_LOGIC (\"Unicast local delivery to \" << dst);\n          lcb (p, header, iif);\n        }\n      else\n        {\n          NS_LOG_ERROR (\"Unable to deliver packet locally due to null callback \" << p->GetUid () << \" from \" << origin);\n          ecb (p, header, Socket::ERROR_NOROUTETOHOST);\n        }\n      return true;\n    }\n\n  // Check if input device supports IP forwarding\n  if (m_ipv4->IsForwarding (iif) == false)\n    {\n      NS_LOG_LOGIC (\"Forwarding disabled for this interface\");\n      ecb (p, header, Socket::ERROR_NOROUTETOHOST);\n      return true;\n    }\n\n  // Forwarding\n  return Forwarding (p, header, ucb, ecb);\n}\n\nbool\nRoutingProtocol::Forwarding (Ptr<const Packet> p, const Ipv4Header & header,\n                             UnicastForwardCallback ucb, ErrorCallback ecb)\n{\n  NS_LOG_FUNCTION (this);\n  Ipv4Address dst = header.GetDestination ();\n  Ipv4Address origin = header.GetSource ();\n  m_routingTable.Purge ();\n  RoutingTableEntry toDst;\n  if (m_routingTable.LookupRoute (dst, toDst))\n    {\n      if (toDst.GetFlag () == VALID)\n        {\n          Ptr<Ipv4Route> route = toDst.GetRoute ();\n          NS_LOG_LOGIC (route->GetSource () << \" forwarding to \" << dst << \" from \" << origin << \" packet \" << p->GetUid ());\n\n          /*\n           *  Each time a route is used to forward a data packet, its Active Route\n           *  Lifetime field of the source, destination and the next hop on the\n           *  path to the destination is updated to be no less than the current\n           *  time plus ActiveRouteTimeout.\n           */\n          UpdateRouteLifeTime (origin, m_activeRouteTimeout);\n          UpdateRouteLifeTime (dst, m_activeRouteTimeout);\n          UpdateRouteLifeTime (route->GetGateway (), m_activeRouteTimeout);\n          /*\n           *  Since the route between each originator and destination pair is expected to be symmetric, the\n           *  Active Route Lifetime for the previous hop, along the reverse path back to the IP source, is also updated\n           *  to be no less than the current time plus ActiveRouteTimeout\n           */\n          RoutingTableEntry toOrigin;\n          m_routingTable.LookupRoute (origin, toOrigin);\n          UpdateRouteLifeTime (toOrigin.GetNextHop (), m_activeRouteTimeout);\n\n          m_nb.Update (route->GetGateway (), m_activeRouteTimeout);\n          m_nb.Update (toOrigin.GetNextHop (), m_activeRouteTimeout);\n\n          ucb (route, p, header);\n          return true;\n        }\n      else\n        {\n          if (toDst.GetValidSeqNo ())\n            {\n              SendRerrWhenNoRouteToForward (dst, toDst.GetSeqNo (), origin);\n              NS_LOG_DEBUG (\"Drop packet \" << p->GetUid () << \" because no route to forward it.\");\n              return false;\n            }\n        }\n    }\n  NS_LOG_LOGIC (\"route not found to \" << dst << \". Send RERR message.\");\n  NS_LOG_DEBUG (\"Drop packet \" << p->GetUid () << \" because no route to forward it.\");\n  SendRerrWhenNoRouteToForward (dst, 0, origin);\n  return false;\n}\n\nvoid\nRoutingProtocol::SetIpv4 (Ptr<Ipv4> ipv4)\n{\n  NS_ASSERT (ipv4 != 0);\n  NS_ASSERT (m_ipv4 == 0);\n\n  m_ipv4 = ipv4;\n\n  // Create lo route. It is asserted that the only one interface up for now is loopback\n  NS_ASSERT (m_ipv4->GetNInterfaces () == 1 && m_ipv4->GetAddress (0, 0).GetLocal () == Ipv4Address (\"127.0.0.1\"));\n  m_lo = m_ipv4->GetNetDevice (0);\n  NS_ASSERT (m_lo != 0);\n  // Remember lo route\n  RoutingTableEntry rt (/*device=*/ m_lo, /*dst=*/ Ipv4Address::GetLoopback (), /*know seqno=*/ true, /*seqno=*/ 0,\n                                    /*iface=*/ Ipv4InterfaceAddress (Ipv4Address::GetLoopback (), Ipv4Mask (\"255.0.0.0\")),\n                                    /*hops=*/ 1, /*next hop=*/ Ipv4Address::GetLoopback (),\n                                    /*lifetime=*/ Simulator::GetMaximumSimulationTime ());\n  m_routingTable.AddRoute (rt);\n\n  Simulator::ScheduleNow (&RoutingProtocol::Start, this);\n}\n\nvoid\nRoutingProtocol::NotifyInterfaceUp (uint32_t i)\n{\n  NS_LOG_FUNCTION (this << m_ipv4->GetAddress (i, 0).GetLocal ());\n  Ptr<Ipv4L3Protocol> l3 = m_ipv4->GetObject<Ipv4L3Protocol> ();\n  if (l3->GetNAddresses (i) > 1)\n    {\n      NS_LOG_WARN (\"aodvKmeans does not work with more then one address per each interface.\");\n    }\n  Ipv4InterfaceAddress iface = l3->GetAddress (i, 0);\n  if (iface.GetLocal () == Ipv4Address (\"127.0.0.1\"))\n    {\n      return;\n    }\n\n  // Create a socket to listen only on this interface\n  Ptr<Socket> socket = Socket::CreateSocket (GetObject<Node> (),\n                                             UdpSocketFactory::GetTypeId ());\n  NS_ASSERT (socket != 0);\n  socket->SetRecvCallback (MakeCallback (&RoutingProtocol::RecvaodvKmeans, this));\n  socket->BindToNetDevice (l3->GetNetDevice (i));\n  socket->Bind (InetSocketAddress (iface.GetLocal (), aodvKmeans_PORT));\n  socket->SetAllowBroadcast (true);\n  socket->SetIpRecvTtl (true);\n  m_socketAddresses.insert (std::make_pair (socket, iface));\n\n  // create also a subnet broadcast socket\n  socket = Socket::CreateSocket (GetObject<Node> (),\n                                 UdpSocketFactory::GetTypeId ());\n  NS_ASSERT (socket != 0);\n  socket->SetRecvCallback (MakeCallback (&RoutingProtocol::RecvaodvKmeans, this));\n  socket->BindToNetDevice (l3->GetNetDevice (i));\n  socket->Bind (InetSocketAddress (iface.GetBroadcast (), aodvKmeans_PORT));\n  socket->SetAllowBroadcast (true);\n  socket->SetIpRecvTtl (true);\n  m_socketSubnetBroadcastAddresses.insert (std::make_pair (socket, iface));\n\n  // Add local broadcast record to the routing table\n  Ptr<NetDevice> dev = m_ipv4->GetNetDevice (m_ipv4->GetInterfaceForAddress (iface.GetLocal ()));\n  RoutingTableEntry rt (/*device=*/ dev, /*dst=*/ iface.GetBroadcast (), /*know seqno=*/ true, /*seqno=*/ 0, /*iface=*/ iface,\n                                    /*hops=*/ 1, /*next hop=*/ iface.GetBroadcast (), /*lifetime=*/ Simulator::GetMaximumSimulationTime ());\n  m_routingTable.AddRoute (rt);\n\n  if (l3->GetInterface (i)->GetArpCache ())\n    {\n      m_nb.AddArpCache (l3->GetInterface (i)->GetArpCache ());\n    }\n\n  // Allow neighbor manager use this interface for layer 2 feedback if possible\n  Ptr<WifiNetDevice> wifi = dev->GetObject<WifiNetDevice> ();\n  if (wifi == 0)\n    {\n      return;\n    }\n  Ptr<WifiMac> mac = wifi->GetMac ();\n  if (mac == 0)\n    {\n      return;\n    }\n\n  mac->TraceConnectWithoutContext (\"DroppedMpdu\", MakeCallback (&RoutingProtocol::NotifyTxError, this));\n}\n\nvoid\nRoutingProtocol::NotifyTxError (WifiMacDropReason reason, Ptr<const WifiMacQueueItem> mpdu)\n{\n  m_txerrorCount++;\n  m_nb.GetTxErrorCallback ()(mpdu->GetHeader ());\n}\n\nvoid\nRoutingProtocol::NotifyInterfaceDown (uint32_t i)\n{\n  NS_LOG_FUNCTION (this << m_ipv4->GetAddress (i, 0).GetLocal ());\n\n  // Disable layer 2 link state monitoring (if possible)\n  Ptr<Ipv4L3Protocol> l3 = m_ipv4->GetObject<Ipv4L3Protocol> ();\n  Ptr<NetDevice> dev = l3->GetNetDevice (i);\n  Ptr<WifiNetDevice> wifi = dev->GetObject<WifiNetDevice> ();\n  if (wifi != 0)\n    {\n      Ptr<WifiMac> mac = wifi->GetMac ()->GetObject<AdhocWifiMac> ();\n      if (mac != 0)\n        {\n          mac->TraceDisconnectWithoutContext (\"DroppedMpdu\",\n                                              MakeCallback (&RoutingProtocol::NotifyTxError, this));\n          m_nb.DelArpCache (l3->GetInterface (i)->GetArpCache ());\n        }\n    }\n\n  // Close socket\n  Ptr<Socket> socket = FindSocketWithInterfaceAddress (m_ipv4->GetAddress (i, 0));\n  NS_ASSERT (socket);\n  socket->Close ();\n  m_socketAddresses.erase (socket);\n\n  // Close socket\n  socket = FindSubnetBroadcastSocketWithInterfaceAddress (m_ipv4->GetAddress (i, 0));\n  NS_ASSERT (socket);\n  socket->Close ();\n  m_socketSubnetBroadcastAddresses.erase (socket);\n\n  if (m_socketAddresses.empty ())\n    {\n      NS_LOG_LOGIC (\"No aodvKmeans interfaces\");\n      m_htimer.Cancel ();\n      m_nb.Clear ();\n      m_routingTable.Clear ();\n      return;\n    }\n  m_routingTable.DeleteAllRoutesFromInterface (m_ipv4->GetAddress (i, 0));\n}\n\nvoid\nRoutingProtocol::NotifyAddAddress (uint32_t i, Ipv4InterfaceAddress address)\n{\n  NS_LOG_FUNCTION (this << \" interface \" << i << \" address \" << address);\n  Ptr<Ipv4L3Protocol> l3 = m_ipv4->GetObject<Ipv4L3Protocol> ();\n  if (!l3->IsUp (i))\n    {\n      return;\n    }\n  if (l3->GetNAddresses (i) == 1)\n    {\n      Ipv4InterfaceAddress iface = l3->GetAddress (i, 0);\n      Ptr<Socket> socket = FindSocketWithInterfaceAddress (iface);\n      if (!socket)\n        {\n          if (iface.GetLocal () == Ipv4Address (\"127.0.0.1\"))\n            {\n              return;\n            }\n          // Create a socket to listen only on this interface\n          Ptr<Socket> socket = Socket::CreateSocket (GetObject<Node> (),\n                                                     UdpSocketFactory::GetTypeId ());\n          NS_ASSERT (socket != 0);\n          socket->SetRecvCallback (MakeCallback (&RoutingProtocol::RecvaodvKmeans,this));\n          socket->BindToNetDevice (l3->GetNetDevice (i));\n          socket->Bind (InetSocketAddress (iface.GetLocal (), aodvKmeans_PORT));\n          socket->SetAllowBroadcast (true);\n          m_socketAddresses.insert (std::make_pair (socket, iface));\n\n          // create also a subnet directed broadcast socket\n          socket = Socket::CreateSocket (GetObject<Node> (),\n                                         UdpSocketFactory::GetTypeId ());\n          NS_ASSERT (socket != 0);\n          socket->SetRecvCallback (MakeCallback (&RoutingProtocol::RecvaodvKmeans, this));\n          socket->BindToNetDevice (l3->GetNetDevice (i));\n          socket->Bind (InetSocketAddress (iface.GetBroadcast (), aodvKmeans_PORT));\n          socket->SetAllowBroadcast (true);\n          socket->SetIpRecvTtl (true);\n          m_socketSubnetBroadcastAddresses.insert (std::make_pair (socket, iface));\n\n          // Add local broadcast record to the routing table\n          Ptr<NetDevice> dev = m_ipv4->GetNetDevice (\n              m_ipv4->GetInterfaceForAddress (iface.GetLocal ()));\n          RoutingTableEntry rt (/*device=*/ dev, /*dst=*/ iface.GetBroadcast (), /*know seqno=*/ true,\n                                            /*seqno=*/ 0, /*iface=*/ iface, /*hops=*/ 1,\n                                            /*next hop=*/ iface.GetBroadcast (), /*lifetime=*/ Simulator::GetMaximumSimulationTime ());\n          m_routingTable.AddRoute (rt);\n        }\n    }\n  else\n    {\n      NS_LOG_LOGIC (\"aodvKmeans does not work with more then one address per each interface. Ignore added address\");\n    }\n}\n\nvoid\nRoutingProtocol::NotifyRemoveAddress (uint32_t i, Ipv4InterfaceAddress address)\n{\n  NS_LOG_FUNCTION (this);\n  Ptr<Socket> socket = FindSocketWithInterfaceAddress (address);\n  if (socket)\n    {\n      m_routingTable.DeleteAllRoutesFromInterface (address);\n      socket->Close ();\n      m_socketAddresses.erase (socket);\n\n      Ptr<Socket> unicastSocket = FindSubnetBroadcastSocketWithInterfaceAddress (address);\n      if (unicastSocket)\n        {\n          unicastSocket->Close ();\n          m_socketAddresses.erase (unicastSocket);\n        }\n\n      Ptr<Ipv4L3Protocol> l3 = m_ipv4->GetObject<Ipv4L3Protocol> ();\n      if (l3->GetNAddresses (i))\n        {\n          Ipv4InterfaceAddress iface = l3->GetAddress (i, 0);\n          // Create a socket to listen only on this interface\n          Ptr<Socket> socket = Socket::CreateSocket (GetObject<Node> (),\n                                                     UdpSocketFactory::GetTypeId ());\n          NS_ASSERT (socket != 0);\n          socket->SetRecvCallback (MakeCallback (&RoutingProtocol::RecvaodvKmeans, this));\n          // Bind to any IP address so that broadcasts can be received\n          socket->BindToNetDevice (l3->GetNetDevice (i));\n          socket->Bind (InetSocketAddress (iface.GetLocal (), aodvKmeans_PORT));\n          socket->SetAllowBroadcast (true);\n          socket->SetIpRecvTtl (true);\n          m_socketAddresses.insert (std::make_pair (socket, iface));\n\n          // create also a unicast socket\n          socket = Socket::CreateSocket (GetObject<Node> (),\n                                         UdpSocketFactory::GetTypeId ());\n          NS_ASSERT (socket != 0);\n          socket->SetRecvCallback (MakeCallback (&RoutingProtocol::RecvaodvKmeans, this));\n          socket->BindToNetDevice (l3->GetNetDevice (i));\n          socket->Bind (InetSocketAddress (iface.GetBroadcast (), aodvKmeans_PORT));\n          socket->SetAllowBroadcast (true);\n          socket->SetIpRecvTtl (true);\n          m_socketSubnetBroadcastAddresses.insert (std::make_pair (socket, iface));\n\n          // Add local broadcast record to the routing table\n          Ptr<NetDevice> dev = m_ipv4->GetNetDevice (m_ipv4->GetInterfaceForAddress (iface.GetLocal ()));\n          RoutingTableEntry rt (/*device=*/ dev, /*dst=*/ iface.GetBroadcast (), /*know seqno=*/ true, /*seqno=*/ 0, /*iface=*/ iface,\n                                            /*hops=*/ 1, /*next hop=*/ iface.GetBroadcast (), /*lifetime=*/ Simulator::GetMaximumSimulationTime ());\n          m_routingTable.AddRoute (rt);\n        }\n      if (m_socketAddresses.empty ())\n        {\n          NS_LOG_LOGIC (\"No aodvKmeans interfaces\");\n          m_htimer.Cancel ();\n          m_nb.Clear ();\n          m_routingTable.Clear ();\n          return;\n        }\n    }\n  else\n    {\n      NS_LOG_LOGIC (\"Remove address not participating in aodvKmeans operation\");\n    }\n}\n\nbool\nRoutingProtocol::IsMyOwnAddress (Ipv4Address src)\n{\n  NS_LOG_FUNCTION (this << src);\n  for (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const_iterator j =\n         m_socketAddresses.begin (); j != m_socketAddresses.end (); ++j)\n    {\n      Ipv4InterfaceAddress iface = j->second;\n      if (src == iface.GetLocal ())\n        {\n          return true;\n        }\n    }\n  return false;\n}\n\nPtr<Ipv4Route>\nRoutingProtocol::LoopbackRoute (const Ipv4Header & hdr, Ptr<NetDevice> oif) const\n{\n  NS_LOG_FUNCTION (this << hdr);\n  NS_ASSERT (m_lo != 0);\n  Ptr<Ipv4Route> rt = Create<Ipv4Route> ();\n  rt->SetDestination (hdr.GetDestination ());\n  //\n  // Source address selection here is tricky.  The loopback route is\n  // returned when aodvKmeans does not have a route; this causes the packet\n  // to be looped back and handled (cached) in RouteInput() method\n  // while a route is found. However, connection-oriented protocols\n  // like TCP need to create an endpoint four-tuple (src, src port,\n  // dst, dst port) and create a pseudo-header for checksumming.  So,\n  // aodvKmeans needs to guess correctly what the eventual source address\n  // will be.\n  //\n  // For single interface, single address nodes, this is not a problem.\n  // When there are possibly multiple outgoing interfaces, the policy\n  // implemented here is to pick the first available aodvKmeans interface.\n  // If RouteOutput() caller specified an outgoing interface, that\n  // further constrains the selection of source address\n  //\n  std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const_iterator j = m_socketAddresses.begin ();\n  if (oif)\n    {\n      // Iterate to find an address on the oif device\n      for (j = m_socketAddresses.begin (); j != m_socketAddresses.end (); ++j)\n        {\n          Ipv4Address addr = j->second.GetLocal ();\n          int32_t interface = m_ipv4->GetInterfaceForAddress (addr);\n          if (oif == m_ipv4->GetNetDevice (static_cast<uint32_t> (interface)))\n            {\n              rt->SetSource (addr);\n              break;\n            }\n        }\n    }\n  else\n    {\n      rt->SetSource (j->second.GetLocal ());\n    }\n  NS_ASSERT_MSG (rt->GetSource () != Ipv4Address (), \"Valid aodvKmeans source address not found\");\n  rt->SetGateway (Ipv4Address (\"127.0.0.1\"));\n  rt->SetOutputDevice (m_lo);\n  return rt;\n}\n\nvoid\nRoutingProtocol::SendRequest (Ipv4Address dst)\n{\n  NS_LOG_FUNCTION ( this << dst);\n  // A node SHOULD NOT originate more than RREQ_RATELIMIT RREQ messages per second.\n  if (m_rreqCount == m_rreqRateLimit)\n    {\n      Simulator::Schedule (m_rreqRateLimitTimer.GetDelayLeft () + MicroSeconds (100),\n                           &RoutingProtocol::SendRequest, this, dst);\n      return;\n    }\n  else\n    {\n      m_rreqCount++;\n    }\n  // Create RREQ header\n  RreqHeader rreqHeader;\n  rreqHeader.SetDst (dst);\n\n  RoutingTableEntry rt;\n  // Using the Hop field in Routing Table to manage the expanding ring search\n  uint16_t ttl = m_ttlStart;\n  if (m_routingTable.LookupRoute (dst, rt))\n    {\n      if (rt.GetFlag () != IN_SEARCH)\n        {\n          ttl = std::min<uint16_t> (rt.GetHop () + m_ttlIncrement, m_netDiameter);\n        }\n      else\n        {\n          ttl = rt.GetHop () + m_ttlIncrement;\n          if (ttl > m_ttlThreshold)\n            {\n              ttl = m_netDiameter;\n            }\n        }\n      if (ttl == m_netDiameter)\n        {\n          rt.IncrementRreqCnt ();\n\n        }\n      if (rt.GetValidSeqNo ())\n        {\n          rreqHeader.SetDstSeqno (rt.GetSeqNo ());\n        }\n      else\n        {\n          rreqHeader.SetUnknownSeqno (true);\n        }\n      rt.SetHop (ttl);\n      rt.SetFlag (IN_SEARCH);\n      rt.SetLifeTime (m_pathDiscoveryTime);\n      m_routingTable.Update (rt);\n    }\n  else\n    {\n      rreqHeader.SetUnknownSeqno (true);\n      Ptr<NetDevice> dev = 0;\n      RoutingTableEntry newEntry (/*device=*/ dev, /*dst=*/ dst, /*validSeqNo=*/ false, /*seqno=*/ 0,\n                                              /*iface=*/ Ipv4InterfaceAddress (),/*hop=*/ ttl,\n                                              /*nextHop=*/ Ipv4Address (), /*lifeTime=*/ m_pathDiscoveryTime);\n      // Check if TtlStart == NetDiameter\n      if (ttl == m_netDiameter)\n        {\n          newEntry.IncrementRreqCnt ();\n        }\n      newEntry.SetFlag (IN_SEARCH);\n      m_routingTable.AddRoute (newEntry);\n    }\n\n  if (m_gratuitousReply)\n    {\n      rreqHeader.SetGratuitousRrep (true);\n    }\n  if (m_destinationOnly)\n    {\n      rreqHeader.SetDestinationOnly (true);\n    }\n\n  m_seqNo++;\n  rreqHeader.SetOriginSeqno (m_seqNo);\n  m_requestId++;\n  rreqHeader.SetId (m_requestId);\n\n  //std::cout << \"Sending...\\n\";\n  // Send RREQ as subnet directed broadcast from each interface used by aodvKmeans\n  for (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const_iterator j =\n         m_socketAddresses.begin (); j != m_socketAddresses.end (); ++j)\n    {\n\n      \n      Ptr<Socket> socket = j->first;\n      Ipv4InterfaceAddress iface = j->second;\n\n      //std::cout << iface.GetLocal() << \" --> \" <<dst << \"\\n\";\n      rreqHeader.SetOrigin (iface.GetLocal ());\n      m_rreqIdCache.IsDuplicate (iface.GetLocal (), m_requestId);\n\n      Ptr<Packet> packet = Create<Packet> ();\n      SocketIpTtlTag tag;\n      tag.SetTtl (ttl);\n      packet->AddPacketTag (tag);\n      packet->AddHeader (rreqHeader);\n      TypeHeader tHeader (aodvKmeansTYPE_RREQ);\n      packet->AddHeader (tHeader);\n      // Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise\n      Ipv4Address destination;\n      if (iface.GetMask () == Ipv4Mask::GetOnes ())\n          {\n            std::cout << \"Broadcast\\n\";\n            destination = Ipv4Address (\"255.255.255.255\");\n            NS_LOG_DEBUG (\"Send RREQ with id \" << rreqHeader.GetId () << \" to socket\");\n            m_lastBcastTime = Simulator::Now ();\n          Simulator::Schedule (Time (MilliSeconds (m_uniformRandomVariable->GetInteger (0, 10))), &RoutingProtocol::SendTo, this, socket, packet, destination);\n            \n          }\n        else if(m_lastKnownPosition.find(dst) == m_lastKnownPosition.end())\n          {\n            destination = iface.GetBroadcast ();\n            m_lastBcastTime = Simulator::Now ();\n            Simulator::Schedule (Time (MilliSeconds (m_uniformRandomVariable->GetInteger (0, 10))), &RoutingProtocol::SendTo, this, socket, packet, destination);\n            \n   \n           \n          }\n        \n      \n      else \n      {\n        std::vector<Ipv4Address>selectedCluster;\n        if(m_lastKnonwCluster.find(dst) != m_lastKnonwCluster.end())\n        {\n            //std::cout << rreqHeader.GetId() << \" \" << dst << \" used from list\\n\";\n            selectedCluster = m_lastKnonwCluster[dst];\n        }\n        else\n        {\n            std::pair<uint32_t, uint32_t> posDst = m_lastKnownPosition.find(dst)->second;\n          \n            selectedCluster = m_routingTable.Kmeans(dst, posDst.first, posDst.second);\n        \n        }\n         \n        int interval = m_uniformRandomVariable->GetInteger (0, 10);\n        int neighbours = selectedCluster.size();\n        if(neighbours == 0)\n        {\n            destination = iface.GetBroadcast ();\n            m_lastBcastTime = Simulator::Now ();\n            Simulator::Schedule (Time (MilliSeconds (m_uniformRandomVariable->GetInteger (0, 10))), &RoutingProtocol::SendTo, this, socket, packet, destination);\n            continue;\n   \n        }\n        for(int i=0;i<neighbours;i++)\n        {\n          destination = selectedCluster[i];\n          NS_LOG_DEBUG (\"Send RREQ with id \" << rreqHeader.GetId () << \" to socket\");\n          Simulator::Schedule (Time (MilliSeconds ((i+1) * interval)), &RoutingProtocol::SendTo, this, socket, packet, destination);\n        }\n        m_lastBcastTime = Simulator::Now () + Time(MilliSeconds(neighbours * interval));\n        m_lastKnonwCluster[dst] = selectedCluster;\n        \n        Simulator::Schedule(Time(Seconds(1)), &RoutingProtocol::ClusterTimerExpire, this, dst);\n      }\n      \n    }\n  ScheduleRreqRetry (dst);\n}\n\nvoid\nRoutingProtocol::SendTo (Ptr<Socket> socket, Ptr<Packet> packet, Ipv4Address destination)\n{\n  socket->SendTo (packet, 0, InetSocketAddress (destination, aodvKmeans_PORT));\n\n}\nvoid\nRoutingProtocol::ScheduleRreqRetry (Ipv4Address dst)\n{\n  NS_LOG_FUNCTION (this << dst);\n  if (m_addressReqTimer.find (dst) == m_addressReqTimer.end ())\n    {\n      Timer timer (Timer::CANCEL_ON_DESTROY);\n      m_addressReqTimer[dst] = timer;\n    }\n  m_addressReqTimer[dst].SetFunction (&RoutingProtocol::RouteRequestTimerExpire, this);\n  m_addressReqTimer[dst].Cancel ();\n  m_addressReqTimer[dst].SetArguments (dst);\n  RoutingTableEntry rt;\n  m_routingTable.LookupRoute (dst, rt);\n  Time retry;\n  if (rt.GetHop () < m_netDiameter)\n    {\n      retry = 2 * m_nodeTraversalTime * (rt.GetHop () + m_timeoutBuffer);\n    }\n  else\n    {\n      NS_ABORT_MSG_UNLESS (rt.GetRreqCnt () > 0, \"Unexpected value for GetRreqCount ()\");\n      uint16_t backoffFactor = rt.GetRreqCnt () - 1;\n      NS_LOG_LOGIC (\"Applying binary exponential backoff factor \" << backoffFactor);\n      retry = m_netTraversalTime * (1 << backoffFactor);\n    }\n  m_addressReqTimer[dst].Schedule (retry);\n  NS_LOG_LOGIC (\"Scheduled RREQ retry in \" << retry.As (Time::S));\n}\n\nvoid\nRoutingProtocol::RecvaodvKmeans (Ptr<Socket> socket)\n{\n  NS_LOG_FUNCTION (this << socket);\n  Address sourceAddress;\n  Ptr<Packet> packet = socket->RecvFrom (sourceAddress);\n  InetSocketAddress inetSourceAddr = InetSocketAddress::ConvertFrom (sourceAddress);\n  Ipv4Address sender = inetSourceAddr.GetIpv4 ();\n  Ipv4Address receiver;\n\n  if (m_socketAddresses.find (socket) != m_socketAddresses.end ())\n    {\n      receiver = m_socketAddresses[socket].GetLocal ();\n    }\n  else if (m_socketSubnetBroadcastAddresses.find (socket) != m_socketSubnetBroadcastAddresses.end ())\n    {\n      receiver = m_socketSubnetBroadcastAddresses[socket].GetLocal ();\n    }\n  else\n    {\n      NS_ASSERT_MSG (false, \"Received a packet from an unknown socket\");\n    }\n  NS_LOG_DEBUG (\"aodvKmeans node \" << this << \" received a aodvKmeans packet from \" << sender << \" to \" << receiver);\n\n  UpdateRouteToNeighbor (sender, receiver);\n  TypeHeader tHeader (aodvKmeansTYPE_RREQ);\n  packet->RemoveHeader (tHeader);\n  if (!tHeader.IsValid ())\n    {\n      NS_LOG_DEBUG (\"aodvKmeans message \" << packet->GetUid () << \" with unknown type received: \" << tHeader.Get () << \". Drop\");\n      return; // drop\n    }\n  switch (tHeader.Get ())\n    {\n    case aodvKmeansTYPE_RREQ:\n      {\n        RecvRequest (packet, receiver, sender);\n        break;\n      }\n    case aodvKmeansTYPE_RREP:\n      {\n        RecvReply (packet, receiver, sender);\n        break;\n      }\n    case aodvKmeansTYPE_RERR:\n      {\n        RecvError (packet, sender);\n        break;\n      }\n    case aodvKmeansTYPE_RREP_ACK:\n      {\n        RecvReplyAck (sender);\n        break;\n      }\n    }\n}\n\nbool\nRoutingProtocol::UpdateRouteLifeTime (Ipv4Address addr, Time lifetime)\n{\n  NS_LOG_FUNCTION (this << addr << lifetime);\n  RoutingTableEntry rt;\n  if (m_routingTable.LookupRoute (addr, rt))\n    {\n      if (rt.GetFlag () == VALID)\n        {\n          NS_LOG_DEBUG (\"Updating VALID route\");\n          rt.SetRreqCnt (0);\n          rt.SetLifeTime (std::max (lifetime, rt.GetLifeTime ()));\n          m_routingTable.Update (rt);\n          return true;\n        }\n    }\n  return false;\n}\n\nvoid\nRoutingProtocol::UpdateRouteToNeighbor (Ipv4Address sender, Ipv4Address receiver)\n{\n  NS_LOG_FUNCTION (this << \"sender \" << sender << \" receiver \" << receiver);\n  RoutingTableEntry toNeighbor;\n  if (!m_routingTable.LookupRoute (sender, toNeighbor))\n    {\n      Ptr<NetDevice> dev = m_ipv4->GetNetDevice (m_ipv4->GetInterfaceForAddress (receiver));\n      RoutingTableEntry newEntry (/*device=*/ dev, /*dst=*/ sender, /*know seqno=*/ false, /*seqno=*/ 0,\n                                              /*iface=*/ m_ipv4->GetAddress (m_ipv4->GetInterfaceForAddress (receiver), 0),\n                                              /*hops=*/ 1, /*next hop=*/ sender, /*lifetime=*/ m_activeRouteTimeout);\n      m_routingTable.AddRoute (newEntry);\n    }\n  else\n    {\n      Ptr<NetDevice> dev = m_ipv4->GetNetDevice (m_ipv4->GetInterfaceForAddress (receiver));\n      if (toNeighbor.GetValidSeqNo () && (toNeighbor.GetHop () == 1) && (toNeighbor.GetOutputDevice () == dev))\n        {\n          toNeighbor.SetLifeTime (std::max (m_activeRouteTimeout, toNeighbor.GetLifeTime ()));\n          \n        }\n      else\n        {\n          RoutingTableEntry newEntry (/*device=*/ dev, /*dst=*/ sender, /*know seqno=*/ false, /*seqno=*/ 0,\n                                                  /*iface=*/ m_ipv4->GetAddress (m_ipv4->GetInterfaceForAddress (receiver), 0),\n                                                  /*hops=*/ 1, /*next hop=*/ sender, /*lifetime=*/ std::max (m_activeRouteTimeout, toNeighbor.GetLifeTime ())\n                                                  );\n          m_routingTable.Update (newEntry);\n\n        }\n    }\n\n}\n\nvoid\nRoutingProtocol::RecvRequest (Ptr<Packet> p, Ipv4Address receiver, Ipv4Address src)\n{\n  NS_LOG_FUNCTION (this);\n  RreqHeader rreqHeader;\n  p->RemoveHeader (rreqHeader);\n\n  // A node ignores all RREQs received from any node in its blacklist\n  RoutingTableEntry toPrev;\n  if (m_routingTable.LookupRoute (src, toPrev))\n    {\n      if (toPrev.IsUnidirectional ())\n        {\n          NS_LOG_DEBUG (\"Ignoring RREQ from node in blacklist\");\n          return;\n        }\n    }\n\n  uint32_t id = rreqHeader.GetId ();\n  Ipv4Address origin = rreqHeader.GetOrigin ();\n  \n  \n  \n  /*\n   *  Node checks to determine whether it has received a RREQ with the same Originator IP Address and RREQ ID.\n   *  If such a RREQ has been received, the node silently discards the newly received RREQ.\n   */\n  if (m_rreqIdCache.IsDuplicate (origin, id))\n    {\n      NS_LOG_DEBUG (\"Ignoring RREQ due to duplicate\");\n      return;\n    }\n\n  // Increment RREQ hop count\n  uint8_t hop = rreqHeader.GetHopCount () + 1;\n  rreqHeader.SetHopCount (hop);\n  \n  \n\n  /*\n   *  When the reverse route is created or updated, the following actions on the route are also carried out:\n   *  1. the Originator Sequence Number from the RREQ is compared to the corresponding destination sequence number\n   *     in the route table entry and copied if greater than the existing value there\n   *  2. the valid sequence number field is set to true;\n   *  3. the next hop in the routing table becomes the node from which the  RREQ was received\n   *  4. the hop count is copied from the Hop Count in the RREQ message;\n   *  5. the Lifetime is set to be the maximum of (ExistingLifetime, MinimalLifetime), where\n   *     MinimalLifetime = current time + 2*NetTraversalTime - 2*HopCount*NodeTraversalTime\n   */\n  RoutingTableEntry toOrigin;\n  if (!m_routingTable.LookupRoute (origin, toOrigin))\n    {\n      Ptr<NetDevice> dev = m_ipv4->GetNetDevice (m_ipv4->GetInterfaceForAddress (receiver));\n      RoutingTableEntry newEntry (/*device=*/ dev, /*dst=*/ origin, /*validSeno=*/ true, /*seqNo=*/ rreqHeader.GetOriginSeqno (),\n                                              /*iface=*/ m_ipv4->GetAddress (m_ipv4->GetInterfaceForAddress (receiver), 0), /*hops=*/ hop,\n                                              /*nextHop*/ src, /*timeLife=*/ Time ((2 * m_netTraversalTime - 2 * hop * m_nodeTraversalTime)));\n      m_routingTable.AddRoute (newEntry);\n    }\n  else\n    {\n      if (toOrigin.GetValidSeqNo ())\n        {\n          if (int32_t (rreqHeader.GetOriginSeqno ()) - int32_t (toOrigin.GetSeqNo ()) > 0)\n            {\n              toOrigin.SetSeqNo (rreqHeader.GetOriginSeqno ());\n            }\n        }\n      else\n        {\n          toOrigin.SetSeqNo (rreqHeader.GetOriginSeqno ());\n        }\n      toOrigin.SetValidSeqNo (true);\n      toOrigin.SetNextHop (src);\n      toOrigin.SetOutputDevice (m_ipv4->GetNetDevice (m_ipv4->GetInterfaceForAddress (receiver)));\n      toOrigin.SetInterface (m_ipv4->GetAddress (m_ipv4->GetInterfaceForAddress (receiver), 0));\n      toOrigin.SetHop (hop);\n      toOrigin.SetLifeTime (std::max (Time (2 * m_netTraversalTime - 2 * hop * m_nodeTraversalTime),\n                                      toOrigin.GetLifeTime ()));\n      m_routingTable.Update (toOrigin);\n      //m_nb.Update (src, Time (AllowedHelloLoss * HelloInterval));\n    }\n\n\n  RoutingTableEntry toNeighbor;\n  if (!m_routingTable.LookupRoute (src, toNeighbor))\n    {\n      NS_LOG_DEBUG (\"Neighbor:\" << src << \" not found in routing table. Creating an entry\");\n      Ptr<NetDevice> dev = m_ipv4->GetNetDevice (m_ipv4->GetInterfaceForAddress (receiver));\n      RoutingTableEntry newEntry (dev, src, false, rreqHeader.GetOriginSeqno (),\n                                  m_ipv4->GetAddress (m_ipv4->GetInterfaceForAddress (receiver), 0),\n                                  1, src, m_activeRouteTimeout);\n      m_routingTable.AddRoute (newEntry);\n    }\n  else\n    {\n      toNeighbor.SetLifeTime (m_activeRouteTimeout);\n      toNeighbor.SetValidSeqNo (false);\n      toNeighbor.SetSeqNo (rreqHeader.GetOriginSeqno ());\n      toNeighbor.SetFlag (VALID);\n      toNeighbor.SetOutputDevice (m_ipv4->GetNetDevice (m_ipv4->GetInterfaceForAddress (receiver)));\n      toNeighbor.SetInterface (m_ipv4->GetAddress (m_ipv4->GetInterfaceForAddress (receiver), 0));\n      toNeighbor.SetHop (1);\n      toNeighbor.SetNextHop (src);\n      m_routingTable.Update (toNeighbor);\n    }\n  m_nb.Update (src, Time (m_allowedHelloLoss * m_helloInterval));\n\n  NS_LOG_LOGIC (receiver << \" receive RREQ with hop count \" << static_cast<uint32_t> (rreqHeader.GetHopCount ())\n                         << \" ID \" << rreqHeader.GetId ()\n                         << \" to destination \" << rreqHeader.GetDst ());\n\n  //  A node generates a RREP if either:\n  //  (i)  it is itself the destination,\n  if (IsMyOwnAddress (rreqHeader.GetDst ()))\n    {\n      m_routingTable.LookupRoute (origin, toOrigin);\n      NS_LOG_DEBUG (\"Send reply since I am the destination\");\n      SendReply (rreqHeader, toOrigin);\n      return;\n    }\n  /*\n   * (ii) or it has an active route to the destination, the destination sequence number in the node's existing route table entry for the destination\n   *      is valid and greater than or equal to the Destination Sequence Number of the RREQ, and the \"destination only\" flag is NOT set.\n   */\n  RoutingTableEntry toDst;\n  Ipv4Address dst = rreqHeader.GetDst ();\n  if (m_routingTable.LookupRoute (dst, toDst))\n    {\n      /*\n       * Drop RREQ, This node RREP will make a loop.\n       */\n      if (toDst.GetNextHop () == src)\n        {\n          NS_LOG_DEBUG (\"Drop RREQ from \" << src << \", dest next hop \" << toDst.GetNextHop ());\n          return;\n        }\n      /*\n       * The Destination Sequence number for the requested destination is set to the maximum of the corresponding value\n       * received in the RREQ message, and the destination sequence value currently maintained by the node for the requested destination.\n       * However, the forwarding node MUST NOT modify its maintained value for the destination sequence number, even if the value\n       * received in the incoming RREQ is larger than the value currently maintained by the forwarding node.\n       */\n      if ((rreqHeader.GetUnknownSeqno () || (int32_t (toDst.GetSeqNo ()) - int32_t (rreqHeader.GetDstSeqno ()) >= 0))\n          && toDst.GetValidSeqNo () )\n        {\n          if (!rreqHeader.GetDestinationOnly () && toDst.GetFlag () == VALID)\n            {\n              m_routingTable.LookupRoute (origin, toOrigin);\n              SendReplyByIntermediateNode (toDst, toOrigin, rreqHeader.GetGratuitousRrep ());\n              return;\n            }\n          rreqHeader.SetDstSeqno (toDst.GetSeqNo ());\n          rreqHeader.SetUnknownSeqno (false);\n        }\n    }\n\n  SocketIpTtlTag tag;\n  p->RemovePacketTag (tag);\n  if (tag.GetTtl () < 2)\n    {\n      NS_LOG_DEBUG (\"TTL exceeded. Drop RREQ origin \" << src << \" destination \" << dst );\n      return;\n    }\n\n  for (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const_iterator j =\n         m_socketAddresses.begin (); j != m_socketAddresses.end (); ++j)\n    {\n      Ptr<Socket> socket = j->first;\n      Ipv4InterfaceAddress iface = j->second;\n      Ptr<Packet> packet = Create<Packet> ();\n      SocketIpTtlTag ttl;\n      ttl.SetTtl (tag.GetTtl () - 1);\n      packet->AddPacketTag (ttl);\n      packet->AddHeader (rreqHeader);\n      TypeHeader tHeader (aodvKmeansTYPE_RREQ);\n      packet->AddHeader (tHeader);\n      // Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise\n      Ipv4Address destination;\n      \n      \n        if (iface.GetMask () == Ipv4Mask::GetOnes ())\n        {\n          destination = Ipv4Address (\"255.255.255.255\");\n           m_lastBcastTime = Simulator::Now ();\n          Simulator::Schedule (Time (MilliSeconds (m_uniformRandomVariable->GetInteger (0, 10))), &RoutingProtocol::SendTo, this, socket, packet, destination);\n\n          \n        }\n        else if(m_lastKnownPosition.find(dst) == m_lastKnownPosition.end() || m_routingTable.isEmpty()) \n        { \n          \n            destination = iface.GetBroadcast ();\n            m_lastBcastTime = Simulator::Now ();\n           Simulator::Schedule (Time (MilliSeconds (m_uniformRandomVariable->GetInteger (0, 10))), &RoutingProtocol::SendTo, this, socket, packet, destination);\n\n        }\n         \n       \n      else \n      {\n        std::vector<Ipv4Address>selectedCluster;\n        if(m_lastKnonwCluster.find(dst) != m_lastKnonwCluster.end())\n        {\n            //std::cout << rreqHeader.GetId() << \" \" << dst << \" used from list\\n\";\n            selectedCluster = m_lastKnonwCluster[dst];\n        }\n        else\n        {\n            std::pair<uint32_t, uint32_t> posDst = m_lastKnownPosition.find(dst)->second;\n          \n            selectedCluster = m_routingTable.Kmeans(dst, posDst.first, posDst.second);\n        \n        }\n        int interval = m_uniformRandomVariable->GetInteger (0, 10);\n        int neighbours = selectedCluster.size();\n        if(neighbours == 0)\n        {\n            destination = iface.GetBroadcast ();\n            m_lastBcastTime = Simulator::Now ();\n            Simulator::Schedule (Time (MilliSeconds (m_uniformRandomVariable->GetInteger (0, 10))), &RoutingProtocol::SendTo, this, socket, packet, destination);\n            continue;\n   \n        }\n        for(int i=0;i<neighbours;i++)\n        {\n          destination = selectedCluster[i];\n          NS_LOG_DEBUG (\"Send RREQ with id \" << rreqHeader.GetId () << \" to socket\");\n          Simulator::Schedule (Time (MilliSeconds ((i+1) * interval)), &RoutingProtocol::SendTo, this, socket, packet, destination);\n        }\n        m_lastBcastTime = Simulator::Now () + Time(MilliSeconds(neighbours * interval));\n        m_lastKnonwCluster[dst] = selectedCluster;\n        \n\n        Simulator::Schedule(Time(Seconds(1)), &RoutingProtocol::ClusterTimerExpire, this, dst);    \n      }\n      \n    }\n}\n\nvoid\nRoutingProtocol::SendReply (RreqHeader const & rreqHeader, RoutingTableEntry const & toOrigin)\n{\n  NS_LOG_FUNCTION (this << toOrigin.GetDestination ());\n  /*\n   * Destination node MUST increment its own sequence number by one if the sequence number in the RREQ packet is equal to that\n   * incremented value. Otherwise, the destination does not change its sequence number before generating the  RREP message.\n   */\n  if (!rreqHeader.GetUnknownSeqno () && (rreqHeader.GetDstSeqno () == m_seqNo + 1))\n    {\n      m_seqNo++;\n    }\n  \n  \n\n  \n\n  m_position = m_ipv4->GetObject<Node>()->GetObject<MobilityModel> ()->GetPosition();\n  \n  RrepHeader rrepHeader ( /*prefixSize=*/ 0, /*hops=*/ 0, /*dst=*/ rreqHeader.GetDst (),\n                                          /*dstSeqNo=*/ m_seqNo, /*origin=*/ toOrigin.GetDestination (), /*lifeTime=*/ m_myRouteTimeout,\n                                          /*txerrors=*/m_txerrorCount, /*freeSpace=*/ m_queue.GetFreeQueueLen(),\n                                          /*positionX=*/(uint32_t) m_position.x, /*positionY=*/(uint32_t) m_position.y);\n  Ptr<Packet> packet = Create<Packet> ();\n  SocketIpTtlTag tag;\n  tag.SetTtl (toOrigin.GetHop ());\n  packet->AddPacketTag (tag);\n  packet->AddHeader (rrepHeader);\n  TypeHeader tHeader (aodvKmeansTYPE_RREP);\n  packet->AddHeader (tHeader);\n  Ptr<Socket> socket = FindSocketWithInterfaceAddress (toOrigin.GetInterface ());\n  NS_ASSERT (socket);\n  socket->SendTo (packet, 0, InetSocketAddress (toOrigin.GetNextHop (), aodvKmeans_PORT));\n}\n\nvoid\nRoutingProtocol::SendReplyByIntermediateNode (RoutingTableEntry & toDst, RoutingTableEntry & toOrigin, bool gratRep)\n{\n  NS_LOG_FUNCTION (this);\n\n  \n\n  \n  RrepHeader rrepHeader (/*prefix size=*/ 0, /*hops=*/ toDst.GetHop (), /*dst=*/ toDst.GetDestination (), /*dst seqno=*/ toDst.GetSeqNo (),\n                                          /*origin=*/ toOrigin.GetDestination (), /*lifetime=*/ toDst.GetLifeTime (),\n                                          /*txerrors=*/ toDst.GetTxErrorCount(), /*freeSpace=*/toDst.GetFreeSpace(),\n                                          /*positionX=*/toDst.GetPositionX(), /*positionY*/toDst.GetPositionY());\n  /* If the node we received a RREQ for is a neighbor we are\n   * probably facing a unidirectional link... Better request a RREP-ack\n   */\n  if (toDst.GetHop () == 1)\n    {\n      rrepHeader.SetAckRequired (true);\n      RoutingTableEntry toNextHop;\n      m_routingTable.LookupRoute (toOrigin.GetNextHop (), toNextHop);\n      toNextHop.m_ackTimer.SetFunction (&RoutingProtocol::AckTimerExpire, this);\n      toNextHop.m_ackTimer.SetArguments (toNextHop.GetDestination (), m_blackListTimeout);\n      toNextHop.m_ackTimer.SetDelay (m_nextHopWait);\n    }\n  toDst.InsertPrecursor (toOrigin.GetNextHop ());\n  toOrigin.InsertPrecursor (toDst.GetNextHop ());\n  m_routingTable.Update (toDst);\n  m_routingTable.Update (toOrigin);\n\n  Ptr<Packet> packet = Create<Packet> ();\n  SocketIpTtlTag tag;\n  tag.SetTtl (toOrigin.GetHop ());\n  packet->AddPacketTag (tag);\n  packet->AddHeader (rrepHeader);\n  TypeHeader tHeader (aodvKmeansTYPE_RREP);\n  packet->AddHeader (tHeader);\n  Ptr<Socket> socket = FindSocketWithInterfaceAddress (toOrigin.GetInterface ());\n  NS_ASSERT (socket);\n  socket->SendTo (packet, 0, InetSocketAddress (toOrigin.GetNextHop (), aodvKmeans_PORT));\n\n  // Generating gratuitous RREPs\n  if (gratRep)\n    {\n     \n      \n      RrepHeader gratRepHeader (/*prefix size=*/ 0, /*hops=*/ toOrigin.GetHop (), /*dst=*/ toOrigin.GetDestination (),\n                                                 /*dst seqno=*/ toOrigin.GetSeqNo (), /*origin=*/ toDst.GetDestination (),\n                                                 /*lifetime=*/ toOrigin.GetLifeTime (), \n                                                 /*txerrors=*/toOrigin.GetTxErrorCount(), /*freeSpace=*/toOrigin.GetFreeSpace(),\n                                                 /*positionX*/ toOrigin.GetPositionX(), /*positiony=*/toOrigin.GetPositionY());\n      Ptr<Packet> packetToDst = Create<Packet> ();\n      SocketIpTtlTag gratTag;\n      gratTag.SetTtl (toDst.GetHop ());\n      packetToDst->AddPacketTag (gratTag);\n      packetToDst->AddHeader (gratRepHeader);\n      TypeHeader type (aodvKmeansTYPE_RREP);\n      packetToDst->AddHeader (type);\n      Ptr<Socket> socket = FindSocketWithInterfaceAddress (toDst.GetInterface ());\n      NS_ASSERT (socket);\n      NS_LOG_LOGIC (\"Send gratuitous RREP \" << packet->GetUid ());\n      socket->SendTo (packetToDst, 0, InetSocketAddress (toDst.GetNextHop (), aodvKmeans_PORT));\n    }\n}\n\nvoid\nRoutingProtocol::SendReplyAck (Ipv4Address neighbor)\n{\n  NS_LOG_FUNCTION (this << \" to \" << neighbor);\n  RrepAckHeader h;\n  TypeHeader typeHeader (aodvKmeansTYPE_RREP_ACK);\n  Ptr<Packet> packet = Create<Packet> ();\n  SocketIpTtlTag tag;\n  tag.SetTtl (1);\n  packet->AddPacketTag (tag);\n  packet->AddHeader (h);\n  packet->AddHeader (typeHeader);\n  RoutingTableEntry toNeighbor;\n  m_routingTable.LookupRoute (neighbor, toNeighbor);\n  Ptr<Socket> socket = FindSocketWithInterfaceAddress (toNeighbor.GetInterface ());\n  NS_ASSERT (socket);\n  socket->SendTo (packet, 0, InetSocketAddress (neighbor, aodvKmeans_PORT));\n}\n\nvoid\nRoutingProtocol::RecvReply (Ptr<Packet> p, Ipv4Address receiver, Ipv4Address sender)\n{\n  NS_LOG_FUNCTION (this << \" src \" << sender);\n  RrepHeader rrepHeader;\n  p->RemoveHeader (rrepHeader);\n  Ipv4Address dst = rrepHeader.GetDst ();\n  NS_LOG_LOGIC (\"RREP destination \" << dst << \" RREP origin \" << rrepHeader.GetOrigin ());\n\n  uint8_t hop = rrepHeader.GetHopCount () + 1;\n  rrepHeader.SetHopCount (hop);\n\n  if(m_lastKnownPosition.find(rrepHeader.GetDst()) != m_lastKnownPosition.end())\n  {\n    m_lastKnownPosition[rrepHeader.GetDst()] = rrepHeader.GetPosition();\n  }\n  else \n  {\n    m_lastKnownPosition[rrepHeader.GetDst()] = rrepHeader.GetPosition();\n  }\n\n\n  \n\n  \n\n  // If RREP is Hello message\n  if (dst == rrepHeader.GetOrigin ())\n    {\n      ProcessHello (rrepHeader, receiver);\n      return;\n    }\n\n  /*\n   * If the route table entry to the destination is created or updated, then the following actions occur:\n   * -  the route is marked as active,\n   * -  the destination sequence number is marked as valid,\n   * -  the next hop in the route entry is assigned to be the node from which the RREP is received,\n   *    which is indicated by the source IP address field in the IP header,\n   * -  the hop count is set to the value of the hop count from RREP message + 1\n   * -  the expiry time is set to the current time plus the value of the Lifetime in the RREP message,\n   * -  and the destination sequence number is the Destination Sequence Number in the RREP message.\n   */\n  Ptr<NetDevice> dev = m_ipv4->GetNetDevice (m_ipv4->GetInterfaceForAddress (receiver));\n  RoutingTableEntry newEntry (/*device=*/ dev, /*dst=*/ dst, /*validSeqNo=*/ true, /*seqno=*/ rrepHeader.GetDstSeqno (),\n                                          /*iface=*/ m_ipv4->GetAddress (m_ipv4->GetInterfaceForAddress (receiver), 0),/*hop=*/ hop,\n                                          /*nextHop=*/ sender, /*lifeTime=*/ rrepHeader.GetLifeTime (), \n                                          /*txError=*/rrepHeader.GetTxErrorCount(), /*positionX=*/rrepHeader.GetPosition().first, /*positionY=*/rrepHeader.GetPosition().second);\n  RoutingTableEntry toDst;\n  if (m_routingTable.LookupRoute (dst, toDst))\n    {\n      /*\n       * The existing entry is updated only in the following circumstances:\n       * (i) the sequence number in the routing table is marked as invalid in route table entry.\n       */\n      if (!toDst.GetValidSeqNo ())\n        {\n\n          m_routingTable.Update (newEntry);\n        }\n      // (ii)the Destination Sequence Number in the RREP is greater than the node's copy of the destination sequence number and the known value is valid,\n      else if ((int32_t (rrepHeader.GetDstSeqno ()) - int32_t (toDst.GetSeqNo ())) > 0)\n        {\n          m_routingTable.Update (newEntry);\n        }\n      else\n        {\n          // (iii) the sequence numbers are the same, but the route is marked as inactive.\n          if ((rrepHeader.GetDstSeqno () == toDst.GetSeqNo ()) && (toDst.GetFlag () != VALID))\n            {\n              m_routingTable.Update (newEntry);\n            }\n          // (iv)  the sequence numbers are the same, and the New Hop Count is smaller than the hop count in route table entry.\n          else if ((rrepHeader.GetDstSeqno () == toDst.GetSeqNo ()) && (hop < toDst.GetHop ()))\n            {\n              m_routingTable.Update (newEntry);\n            }\n          \n          \n        }\n    }\n  else\n    {\n      // The forward route for this destination is created if it does not already exist.\n      NS_LOG_LOGIC (\"add new route\");\n      m_routingTable.AddRoute (newEntry);\n    }\n  // Acknowledge receipt of the RREP by sending a RREP-ACK message back\n  if (rrepHeader.GetAckRequired ())\n    {\n      SendReplyAck (sender);\n      rrepHeader.SetAckRequired (false);\n    }\n  NS_LOG_LOGIC (\"receiver \" << receiver << \" origin \" << rrepHeader.GetOrigin ());\n  if (IsMyOwnAddress (rrepHeader.GetOrigin ()))\n    {\n      if (toDst.GetFlag () == IN_SEARCH)\n        {\n          m_routingTable.Update (newEntry);\n          m_addressReqTimer[dst].Cancel ();\n          m_addressReqTimer.erase (dst);\n        }\n      m_routingTable.LookupRoute (dst, toDst);\n      //std::cout << \"SendPacketFromQueue: \" << sender << \"\\n\";\n      SendPacketFromQueue (dst, toDst.GetRoute ());\n      return;\n    }\n\n  RoutingTableEntry toOrigin;\n  if (!m_routingTable.LookupRoute (rrepHeader.GetOrigin (), toOrigin) || toOrigin.GetFlag () == IN_SEARCH)\n    {\n      return; // Impossible! drop.\n    }\n  toOrigin.SetLifeTime (std::max (m_activeRouteTimeout, toOrigin.GetLifeTime ()));\n  m_routingTable.Update (toOrigin);\n\n  // Update information about precursors\n  if (m_routingTable.LookupValidRoute (rrepHeader.GetDst (), toDst))\n    {\n      toDst.InsertPrecursor (toOrigin.GetNextHop ());\n      m_routingTable.Update (toDst);\n\n      RoutingTableEntry toNextHopToDst;\n      m_routingTable.LookupRoute (toDst.GetNextHop (), toNextHopToDst);\n      toNextHopToDst.InsertPrecursor (toOrigin.GetNextHop ());\n      m_routingTable.Update (toNextHopToDst);\n\n      toOrigin.InsertPrecursor (toDst.GetNextHop ());\n      m_routingTable.Update (toOrigin);\n\n      RoutingTableEntry toNextHopToOrigin;\n      m_routingTable.LookupRoute (toOrigin.GetNextHop (), toNextHopToOrigin);\n      toNextHopToOrigin.InsertPrecursor (toDst.GetNextHop ());\n      m_routingTable.Update (toNextHopToOrigin);\n    }\n  SocketIpTtlTag tag;\n  p->RemovePacketTag (tag);\n  if (tag.GetTtl () < 2)\n    {\n      NS_LOG_DEBUG (\"TTL exceeded. Drop RREP destination \" << dst << \" origin \" << rrepHeader.GetOrigin ());\n      return;\n    }\n\n  \n  Ptr<Packet> packet = Create<Packet> ();\n  SocketIpTtlTag ttl;\n  ttl.SetTtl (tag.GetTtl () - 1);\n  packet->AddPacketTag (ttl);\n  packet->AddHeader (rrepHeader);\n  TypeHeader tHeader (aodvKmeansTYPE_RREP);\n  packet->AddHeader (tHeader);\n  Ptr<Socket> socket = FindSocketWithInterfaceAddress (toOrigin.GetInterface ());\n  NS_ASSERT (socket);\n  socket->SendTo (packet, 0, InetSocketAddress (toOrigin.GetNextHop (), aodvKmeans_PORT));\n}\n\nvoid\nRoutingProtocol::RecvReplyAck (Ipv4Address neighbor)\n{\n  NS_LOG_FUNCTION (this);\n  RoutingTableEntry rt;\n  if (m_routingTable.LookupRoute (neighbor, rt))\n    {\n      rt.m_ackTimer.Cancel ();\n      rt.SetFlag (VALID);\n      m_routingTable.Update (rt);\n    }\n}\n\nvoid\nRoutingProtocol::ProcessHello (RrepHeader const & rrepHeader, Ipv4Address receiver )\n{\n  NS_LOG_FUNCTION (this << \"from \" << rrepHeader.GetDst ());\n  \n  \n  \n  /*\n   *  Whenever a node receives a Hello message from a neighbor, the node\n   * SHOULD make sure that it has an active route to the neighbor, and\n   * create one if necessary.\n   */\n\n  \n  RoutingTableEntry toNeighbor;\n  if (!m_routingTable.LookupRoute (rrepHeader.GetDst (), toNeighbor))\n    {\n      Ptr<NetDevice> dev = m_ipv4->GetNetDevice (m_ipv4->GetInterfaceForAddress (receiver));\n      RoutingTableEntry newEntry (/*device=*/ dev, /*dst=*/ rrepHeader.GetDst (), /*validSeqNo=*/ true, /*seqno=*/ rrepHeader.GetDstSeqno (),\n                                              /*iface=*/ m_ipv4->GetAddress (m_ipv4->GetInterfaceForAddress (receiver), 0),\n                                              /*hop=*/ 1, /*nextHop=*/ rrepHeader.GetDst (), /*lifeTime=*/ rrepHeader.GetLifeTime (), \n                                              /*txError=*/rrepHeader.GetTxErrorCount(), /*positionX=*/rrepHeader.GetPosition().first, \n                                              /*positiony=*/rrepHeader.GetPosition().second, /*freespace*/rrepHeader.GetFreeSpace());\n      m_routingTable.AddRoute (newEntry);\n    }\n  else\n    {\n      toNeighbor.SetLifeTime (std::max (Time (m_allowedHelloLoss * m_helloInterval), toNeighbor.GetLifeTime ()));\n      toNeighbor.SetSeqNo (rrepHeader.GetDstSeqno ());\n      toNeighbor.SetValidSeqNo (true);\n      toNeighbor.SetFlag (VALID);\n      toNeighbor.SetOutputDevice (m_ipv4->GetNetDevice (m_ipv4->GetInterfaceForAddress (receiver)));\n      toNeighbor.SetInterface (m_ipv4->GetAddress (m_ipv4->GetInterfaceForAddress (receiver), 0));\n      toNeighbor.SetHop (1);\n      toNeighbor.SetNextHop (rrepHeader.GetDst ());\n      toNeighbor.SetTxErrorCount(rrepHeader.GetTxErrorCount());\n      toNeighbor.SetFreeSpace(rrepHeader.GetFreeSpace());\n      toNeighbor.SetPositionX(rrepHeader.GetPosition().first);\n      toNeighbor.SetPositionY(rrepHeader.GetPosition().second);\n      m_routingTable.Update (toNeighbor);\n    }\n  if (m_enableHello)\n    {\n      m_nb.Update (rrepHeader.GetDst (), Time (m_allowedHelloLoss * m_helloInterval));\n    }\n}\n\nvoid\nRoutingProtocol::RecvError (Ptr<Packet> p, Ipv4Address src )\n{\n  NS_LOG_FUNCTION (this << \" from \" << src);\n  RerrHeader rerrHeader;\n  p->RemoveHeader (rerrHeader);\n  std::map<Ipv4Address, uint32_t> dstWithNextHopSrc;\n  std::map<Ipv4Address, uint32_t> unreachable;\n  m_routingTable.GetListOfDestinationWithNextHop (src, dstWithNextHopSrc);\n  std::pair<Ipv4Address, uint32_t> un;\n  while (rerrHeader.RemoveUnDestination (un))\n    {\n      for (std::map<Ipv4Address, uint32_t>::const_iterator i =\n             dstWithNextHopSrc.begin (); i != dstWithNextHopSrc.end (); ++i)\n        {\n          if (i->first == un.first)\n            {\n              unreachable.insert (un);\n            }\n        }\n    }\n\n  std::vector<Ipv4Address> precursors;\n  for (std::map<Ipv4Address, uint32_t>::const_iterator i = unreachable.begin ();\n       i != unreachable.end (); )\n    {\n      if (!rerrHeader.AddUnDestination (i->first, i->second))\n        {\n          TypeHeader typeHeader (aodvKmeansTYPE_RERR);\n          Ptr<Packet> packet = Create<Packet> ();\n          SocketIpTtlTag tag;\n          tag.SetTtl (1);\n          packet->AddPacketTag (tag);\n          packet->AddHeader (rerrHeader);\n          packet->AddHeader (typeHeader);\n          SendRerrMessage (packet, precursors);\n          rerrHeader.Clear ();\n        }\n      else\n        {\n          RoutingTableEntry toDst;\n          m_routingTable.LookupRoute (i->first, toDst);\n          toDst.GetPrecursors (precursors);\n          ++i;\n        }\n    }\n  if (rerrHeader.GetDestCount () != 0)\n    {\n      TypeHeader typeHeader (aodvKmeansTYPE_RERR);\n      Ptr<Packet> packet = Create<Packet> ();\n      SocketIpTtlTag tag;\n      tag.SetTtl (1);\n      packet->AddPacketTag (tag);\n      packet->AddHeader (rerrHeader);\n      packet->AddHeader (typeHeader);\n      SendRerrMessage (packet, precursors);\n    }\n  m_routingTable.InvalidateRoutesWithDst (unreachable);\n}\nvoid\nRoutingProtocol::ClusterTimerExpire(Ipv4Address dst)\n{\n  //std::cout << \"dst cleaned\\n\";\n  if(m_lastKnonwCluster.find(dst) != m_lastKnonwCluster.end())\n  {\n    m_lastKnonwCluster.erase(dst);\n  }\n}\nvoid\nRoutingProtocol::RouteRequestTimerExpire (Ipv4Address dst)\n{\n  NS_LOG_LOGIC (this);\n  RoutingTableEntry toDst;\n  if (m_routingTable.LookupValidRoute (dst, toDst))\n    {\n      SendPacketFromQueue (dst, toDst.GetRoute ());\n      NS_LOG_LOGIC (\"route to \" << dst << \" found\");\n      return;\n    }\n  /*\n   *  If a route discovery has been attempted RreqRetries times at the maximum TTL without\n   *  receiving any RREP, all data packets destined for the corresponding destination SHOULD be\n   *  dropped from the buffer and a Destination Unreachable message SHOULD be delivered to the application.\n   */\n  if (toDst.GetRreqCnt () == m_rreqRetries)\n    {\n      NS_LOG_LOGIC (\"route discovery to \" << dst << \" has been attempted RreqRetries (\" << m_rreqRetries << \") times with ttl \" << m_netDiameter);\n      m_addressReqTimer.erase (dst);\n      m_routingTable.DeleteRoute (dst);\n      NS_LOG_DEBUG (\"Route not found. Drop all packets with dst \" << dst);\n      m_queue.DropPacketWithDst (dst);\n      return;\n    }\n\n  if (toDst.GetFlag () == IN_SEARCH)\n    {\n      NS_LOG_LOGIC (\"Resend RREQ to \" << dst << \" previous ttl \" << toDst.GetHop ());\n      SendRequest (dst);\n    }\n  else\n    {\n      NS_LOG_DEBUG (\"Route down. Stop search. Drop packet with destination \" << dst);\n      m_addressReqTimer.erase (dst);\n      m_routingTable.DeleteRoute (dst);\n      m_queue.DropPacketWithDst (dst);\n    }\n}\n\nvoid\nRoutingProtocol::HelloTimerExpire ()\n{\n  NS_LOG_FUNCTION (this);\n  Time offset = Time (Seconds (0));\n  if (m_lastBcastTime > Time (Seconds (0)))\n    {\n      offset = Simulator::Now () - m_lastBcastTime;\n      NS_LOG_DEBUG (\"Hello deferred due to last bcast at:\" << m_lastBcastTime);\n    }\n  else\n    {\n      SendHello ();\n    }\n  m_htimer.Cancel ();\n  Time diff = m_helloInterval - offset;\n  m_htimer.Schedule (std::max (Time (Seconds (0)), diff));\n  m_lastBcastTime = Time (Seconds (0));\n}\n\nvoid\nRoutingProtocol::RreqRateLimitTimerExpire ()\n{\n  NS_LOG_FUNCTION (this);\n  m_rreqCount = 0;\n  m_rreqRateLimitTimer.Schedule (Seconds (1));\n}\n\nvoid\nRoutingProtocol::RerrRateLimitTimerExpire ()\n{\n  NS_LOG_FUNCTION (this);\n  m_rerrCount = 0;\n  m_rerrRateLimitTimer.Schedule (Seconds (1));\n}\n\nvoid\nRoutingProtocol::AckTimerExpire (Ipv4Address neighbor, Time blacklistTimeout)\n{\n  NS_LOG_FUNCTION (this);\n  m_routingTable.MarkLinkAsUnidirectional (neighbor, blacklistTimeout);\n}\n\nvoid\nRoutingProtocol::SendHello ()\n{\n  NS_LOG_FUNCTION (this);\n  /* Broadcast a RREP with TTL = 1 with the RREP message fields set as follows:\n   *   Destination IP Address         The node's IP address.\n   *   Destination Sequence Number    The node's latest sequence number.\n   *   Hop Count                      0\n   *   Lifetime                       AllowedHelloLoss * HelloInterval\n   */\n\n  m_position = m_ipv4->GetObject<Node>()->GetObject<MobilityModel> ()->GetPosition();\n    \n  for (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const_iterator j = m_socketAddresses.begin (); j != m_socketAddresses.end (); ++j)\n    {\n      Ptr<Socket> socket = j->first;\n      Ipv4InterfaceAddress iface = j->second;\n      \n      RrepHeader helloHeader (/*prefix size=*/ 0, /*hops=*/ 0, /*dst=*/ iface.GetLocal (), /*dst seqno=*/ m_seqNo,\n                                               /*origin=*/ iface.GetLocal (),/*lifetime=*/ Time (m_allowedHelloLoss * m_helloInterval),\n                                               /*txError=*/ m_txerrorCount, /*freespace=*/ m_queue.GetFreeQueueLen(), /*positionx=*/ (uint32_t)m_position.x, /*positiony*/(uint32_t) m_position.y);\n      Ptr<Packet> packet = Create<Packet> ();\n      SocketIpTtlTag tag;\n      tag.SetTtl (1);\n      packet->AddPacketTag (tag);\n      packet->AddHeader (helloHeader);\n      TypeHeader tHeader (aodvKmeansTYPE_RREP);\n      packet->AddHeader (tHeader);\n      // Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise\n      Ipv4Address destination;\n      if (iface.GetMask () == Ipv4Mask::GetOnes ())\n        {\n          destination = Ipv4Address (\"255.255.255.255\");\n        }\n      else\n        {\n          destination = iface.GetBroadcast ();\n        }\n      Time jitter = Time (MilliSeconds (m_uniformRandomVariable->GetInteger (0, 10)));\n      Simulator::Schedule (jitter, &RoutingProtocol::SendTo, this, socket, packet, destination);\n    }\n}\n\nvoid\nRoutingProtocol::SendPacketFromQueue (Ipv4Address dst, Ptr<Ipv4Route> route)\n{\n\n      // Ptr<Node> node = ;\n      // Ptr<MobilityModel> mobility = ;\n      // Vector position = mobility->GetPosition();\n      // std::cout << position.x << ' ' << position.y << \"\\n\";\n\n      //Vector position = m_ipv4->GetObject<Node>()->GetObject<MobilityModel> ()->GetPosition();\n      \n  // Ipv4Address bestForwarder = m_nb.Kmeans(dst);\n  \n  // std::cout << \"Best forwarder by aodvKmeans = \" << bestForwarder << \"\\n\";\n  // std::cout << \"Selected next hop = \" << route->GetGateway() << \"\\n\";\n\n  // RoutingTableEntry bestForwarderEntry;\n  // m_routingTable.LookupRoute(bestForwarder, bestForwarderEntry);\n\n\n  // route->SetGateway(bestForwarderEntry.GetNextHop());\n  // route->SetOutputDevice(bestForwarderEntry.GetOutputDevice());\n\n\n  NS_LOG_FUNCTION (this);\n  QueueEntry queueEntry;\n  while (m_queue.Dequeue (dst, queueEntry))\n    {\n      DeferredRouteOutputTag tag;\n      Ptr<Packet> p = ConstCast<Packet> (queueEntry.GetPacket ());\n      if (p->RemovePacketTag (tag)\n          && tag.GetInterface () != -1\n          && tag.GetInterface () != m_ipv4->GetInterfaceForDevice (route->GetOutputDevice ()))\n        {\n          NS_LOG_DEBUG (\"Output device doesn't match. Dropped.\");\n          return;\n        }\n      UnicastForwardCallback ucb = queueEntry.GetUnicastForwardCallback ();\n      Ipv4Header header = queueEntry.GetIpv4Header ();\n      header.SetSource (route->GetSource ());\n      header.SetTtl (header.GetTtl () + 1); // compensate extra TTL decrement by fake loopback routing\n      ucb (route, p, header);\n    }\n\n    \n}\n\nvoid\nRoutingProtocol::SendRerrWhenBreaksLinkToNextHop (Ipv4Address nextHop)\n{\n  NS_LOG_FUNCTION (this << nextHop);\n  RerrHeader rerrHeader;\n  std::vector<Ipv4Address> precursors;\n  std::map<Ipv4Address, uint32_t> unreachable;\n\n  RoutingTableEntry toNextHop;\n  if (!m_routingTable.LookupRoute (nextHop, toNextHop))\n    {\n      return;\n    }\n  toNextHop.GetPrecursors (precursors);\n  rerrHeader.AddUnDestination (nextHop, toNextHop.GetSeqNo ());\n  m_routingTable.GetListOfDestinationWithNextHop (nextHop, unreachable);\n  for (std::map<Ipv4Address, uint32_t>::const_iterator i = unreachable.begin (); i\n       != unreachable.end (); )\n    {\n      if (!rerrHeader.AddUnDestination (i->first, i->second))\n        {\n          NS_LOG_LOGIC (\"Send RERR message with maximum size.\");\n          TypeHeader typeHeader (aodvKmeansTYPE_RERR);\n          Ptr<Packet> packet = Create<Packet> ();\n          SocketIpTtlTag tag;\n          tag.SetTtl (1);\n          packet->AddPacketTag (tag);\n          packet->AddHeader (rerrHeader);\n          packet->AddHeader (typeHeader);\n          SendRerrMessage (packet, precursors);\n          rerrHeader.Clear ();\n        }\n      else\n        {\n          RoutingTableEntry toDst;\n          m_routingTable.LookupRoute (i->first, toDst);\n          toDst.GetPrecursors (precursors);\n          ++i;\n        }\n    }\n  if (rerrHeader.GetDestCount () != 0)\n    {\n      TypeHeader typeHeader (aodvKmeansTYPE_RERR);\n      Ptr<Packet> packet = Create<Packet> ();\n      SocketIpTtlTag tag;\n      tag.SetTtl (1);\n      packet->AddPacketTag (tag);\n      packet->AddHeader (rerrHeader);\n      packet->AddHeader (typeHeader);\n      SendRerrMessage (packet, precursors);\n    }\n  unreachable.insert (std::make_pair (nextHop, toNextHop.GetSeqNo ()));\n  m_routingTable.InvalidateRoutesWithDst (unreachable);\n}\n\nvoid\nRoutingProtocol::SendRerrWhenNoRouteToForward (Ipv4Address dst,\n                                               uint32_t dstSeqNo, Ipv4Address origin)\n{\n  NS_LOG_FUNCTION (this);\n  // A node SHOULD NOT originate more than RERR_RATELIMIT RERR messages per second.\n  if (m_rerrCount == m_rerrRateLimit)\n    {\n      // Just make sure that the RerrRateLimit timer is running and will expire\n      NS_ASSERT (m_rerrRateLimitTimer.IsRunning ());\n      // discard the packet and return\n      NS_LOG_LOGIC (\"RerrRateLimit reached at \" << Simulator::Now ().As (Time::S) << \" with timer delay left \"\n                                                << m_rerrRateLimitTimer.GetDelayLeft ().As (Time::S)\n                                                << \"; suppressing RERR\");\n      return;\n    }\n  RerrHeader rerrHeader;\n  rerrHeader.AddUnDestination (dst, dstSeqNo);\n  RoutingTableEntry toOrigin;\n  Ptr<Packet> packet = Create<Packet> ();\n  SocketIpTtlTag tag;\n  tag.SetTtl (1);\n  packet->AddPacketTag (tag);\n  packet->AddHeader (rerrHeader);\n  packet->AddHeader (TypeHeader (aodvKmeansTYPE_RERR));\n  if (m_routingTable.LookupValidRoute (origin, toOrigin))\n    {\n      Ptr<Socket> socket = FindSocketWithInterfaceAddress (\n          toOrigin.GetInterface ());\n      NS_ASSERT (socket);\n      NS_LOG_LOGIC (\"Unicast RERR to the source of the data transmission\");\n      socket->SendTo (packet, 0, InetSocketAddress (toOrigin.GetNextHop (), aodvKmeans_PORT));\n    }\n  else\n    {\n      for (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const_iterator i =\n             m_socketAddresses.begin (); i != m_socketAddresses.end (); ++i)\n        {\n          Ptr<Socket> socket = i->first;\n          Ipv4InterfaceAddress iface = i->second;\n          NS_ASSERT (socket);\n          NS_LOG_LOGIC (\"Broadcast RERR message from interface \" << iface.GetLocal ());\n          // Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise\n          Ipv4Address destination;\n          if (iface.GetMask () == Ipv4Mask::GetOnes ())\n            {\n              destination = Ipv4Address (\"255.255.255.255\");\n            }\n          else\n            {\n              destination = iface.GetBroadcast ();\n            }\n          socket->SendTo (packet->Copy (), 0, InetSocketAddress (destination, aodvKmeans_PORT));\n        }\n    }\n}\n\nvoid\nRoutingProtocol::SendRerrMessage (Ptr<Packet> packet, std::vector<Ipv4Address> precursors)\n{\n  NS_LOG_FUNCTION (this);\n\n  if (precursors.empty ())\n    {\n      NS_LOG_LOGIC (\"No precursors\");\n      return;\n    }\n  // A node SHOULD NOT originate more than RERR_RATELIMIT RERR messages per second.\n  if (m_rerrCount == m_rerrRateLimit)\n    {\n      // Just make sure that the RerrRateLimit timer is running and will expire\n      NS_ASSERT (m_rerrRateLimitTimer.IsRunning ());\n      // discard the packet and return\n      NS_LOG_LOGIC (\"RerrRateLimit reached at \" << Simulator::Now ().As (Time::S) << \" with timer delay left \"\n                                                << m_rerrRateLimitTimer.GetDelayLeft ().As (Time::S)\n                                                << \"; suppressing RERR\");\n      return;\n    }\n  // If there is only one precursor, RERR SHOULD be unicast toward that precursor\n  if (precursors.size () == 1)\n    {\n      RoutingTableEntry toPrecursor;\n      if (m_routingTable.LookupValidRoute (precursors.front (), toPrecursor))\n        {\n          Ptr<Socket> socket = FindSocketWithInterfaceAddress (toPrecursor.GetInterface ());\n          NS_ASSERT (socket);\n          NS_LOG_LOGIC (\"one precursor => unicast RERR to \" << toPrecursor.GetDestination () << \" from \" << toPrecursor.GetInterface ().GetLocal ());\n          Simulator::Schedule (Time (MilliSeconds (m_uniformRandomVariable->GetInteger (0, 10))), &RoutingProtocol::SendTo, this, socket, packet, precursors.front ());\n          m_rerrCount++;\n        }\n      return;\n    }\n\n  //  Should only transmit RERR on those interfaces which have precursor nodes for the broken route\n  std::vector<Ipv4InterfaceAddress> ifaces;\n  RoutingTableEntry toPrecursor;\n  for (std::vector<Ipv4Address>::const_iterator i = precursors.begin (); i != precursors.end (); ++i)\n    {\n      if (m_routingTable.LookupValidRoute (*i, toPrecursor)\n          && std::find (ifaces.begin (), ifaces.end (), toPrecursor.GetInterface ()) == ifaces.end ())\n        {\n          ifaces.push_back (toPrecursor.GetInterface ());\n        }\n    }\n\n  for (std::vector<Ipv4InterfaceAddress>::const_iterator i = ifaces.begin (); i != ifaces.end (); ++i)\n    {\n      Ptr<Socket> socket = FindSocketWithInterfaceAddress (*i);\n      NS_ASSERT (socket);\n      NS_LOG_LOGIC (\"Broadcast RERR message from interface \" << i->GetLocal ());\n      // std::cout << \"Broadcast RERR message from interface \" << i->GetLocal () << std::endl;\n      // Send to all-hosts broadcast if on /32 addr, subnet-directed otherwise\n      Ptr<Packet> p = packet->Copy ();\n      Ipv4Address destination;\n      if (i->GetMask () == Ipv4Mask::GetOnes ())\n        {\n          destination = Ipv4Address (\"255.255.255.255\");\n        }\n      else\n        {\n          destination = i->GetBroadcast ();\n        }\n      Simulator::Schedule (Time (MilliSeconds (m_uniformRandomVariable->GetInteger (0, 10))), &RoutingProtocol::SendTo, this, socket, p, destination);\n    }\n}\n\nPtr<Socket>\nRoutingProtocol::FindSocketWithInterfaceAddress (Ipv4InterfaceAddress addr ) const\n{\n  NS_LOG_FUNCTION (this << addr);\n  for (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const_iterator j =\n         m_socketAddresses.begin (); j != m_socketAddresses.end (); ++j)\n    {\n      Ptr<Socket> socket = j->first;\n      Ipv4InterfaceAddress iface = j->second;\n      if (iface == addr)\n        {\n          return socket;\n        }\n    }\n  Ptr<Socket> socket;\n  return socket;\n}\n\nPtr<Socket>\nRoutingProtocol::FindSubnetBroadcastSocketWithInterfaceAddress (Ipv4InterfaceAddress addr ) const\n{\n  NS_LOG_FUNCTION (this << addr);\n  for (std::map<Ptr<Socket>, Ipv4InterfaceAddress>::const_iterator j =\n         m_socketSubnetBroadcastAddresses.begin (); j != m_socketSubnetBroadcastAddresses.end (); ++j)\n    {\n      Ptr<Socket> socket = j->first;\n      Ipv4InterfaceAddress iface = j->second;\n      if (iface == addr)\n        {\n          return socket;\n        }\n    }\n  Ptr<Socket> socket;\n  return socket;\n}\n\nvoid\nRoutingProtocol::DoInitialize (void)\n{\n  NS_LOG_FUNCTION (this);\n  uint32_t startTime;\n  if (m_enableHello)\n    {\n      m_htimer.SetFunction (&RoutingProtocol::HelloTimerExpire, this);\n      startTime = m_uniformRandomVariable->GetInteger (0, 100);\n      NS_LOG_DEBUG (\"Starting at time \" << startTime << \"ms\");\n      m_htimer.Schedule (MilliSeconds (startTime));\n    }\n  Ipv4RoutingProtocol::DoInitialize ();\n}\n\n} //namespace aodvKmeans\n} //namespace ns3\n"
    },
    {
      "file_path": "aodvKmeans/model/aodvKmeans-rqueue.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2009 IITP RAS\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Based on\n *      NS-2 aodvKmeans model developed by the CMU/MONARCH group and optimized and\n *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;\n *\n *      aodvKmeans-UU implementation by Erik Nordstr\u00f6m of Uppsala University\n *      http://core.it.uu.se/core/index.php/aodvKmeans-UU\n *\n * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>\n *          Pavel Boyko <boyko@iitp.ru>\n */\n#include \"aodvKmeans-rqueue.h\"\n#include <algorithm>\n#include <functional>\n#include \"ns3/ipv4-route.h\"\n#include \"ns3/socket.h\"\n#include \"ns3/log.h\"\n\nnamespace ns3 {\n\nNS_LOG_COMPONENT_DEFINE (\"aodvKmeansRequestQueue\");\n\nnamespace aodvKmeans {\nuint32_t\nRequestQueue::GetSize ()\n{\n  Purge ();\n  return m_queue.size ();\n}\n\nbool\nRequestQueue::Enqueue (QueueEntry & entry)\n{\n  Purge ();\n  for (std::vector<QueueEntry>::const_iterator i = m_queue.begin (); i\n       != m_queue.end (); ++i)\n    {\n      if ((i->GetPacket ()->GetUid () == entry.GetPacket ()->GetUid ())\n          && (i->GetIpv4Header ().GetDestination ()\n              == entry.GetIpv4Header ().GetDestination ()))\n        {\n          return false;\n        }\n    }\n  entry.SetExpireTime (m_queueTimeout);\n  if (m_queue.size () == m_maxLen)\n    {\n      Drop (m_queue.front (), \"Drop the most aged packet\"); // Drop the most aged packet\n      m_queue.erase (m_queue.begin ());\n    }\n  m_queue.push_back (entry);\n  \n  return true;\n}\n\nvoid\nRequestQueue::DropPacketWithDst (Ipv4Address dst)\n{\n  NS_LOG_FUNCTION (this << dst);\n  Purge ();\n  for (std::vector<QueueEntry>::iterator i = m_queue.begin (); i\n       != m_queue.end (); ++i)\n    {\n      if (i->GetIpv4Header ().GetDestination () == dst)\n        {\n          Drop (*i, \"DropPacketWithDst \");\n        }\n    }\n  auto new_end = std::remove_if (m_queue.begin (), m_queue.end (),\n                                 [&](const QueueEntry& en) { return en.GetIpv4Header ().GetDestination () == dst; });\n  m_queue.erase (new_end, m_queue.end ());\n}\n\nbool\nRequestQueue::Dequeue (Ipv4Address dst, QueueEntry & entry)\n{\n  Purge ();\n  for (std::vector<QueueEntry>::iterator i = m_queue.begin (); i != m_queue.end (); ++i)\n    {\n      if (i->GetIpv4Header ().GetDestination () == dst)\n        {\n          entry = *i;\n          m_queue.erase (i);\n          return true;\n        }\n    }\n  return false;\n}\n\nbool\nRequestQueue::Find (Ipv4Address dst)\n{\n  for (std::vector<QueueEntry>::const_iterator i = m_queue.begin (); i\n       != m_queue.end (); ++i)\n    {\n      if (i->GetIpv4Header ().GetDestination () == dst)\n        {\n          return true;\n        }\n    }\n  return false;\n}\n\n/**\n * \\brief IsExpired structure\n */\nstruct IsExpired\n{\n  \n  /**\n   * Check if the entry is expired\n   *\n   * \\param e QueueEntry entry\n   * \\return true if expired, false otherwise\n   */\n   bool\n  operator() (QueueEntry const & e) const\n  {\n    return (e.GetExpireTime () < Seconds (0));\n  }\n};\n\nvoid\nRequestQueue::Purge ()\n{\n  IsExpired pred;\n  for (std::vector<QueueEntry>::iterator i = m_queue.begin (); i\n       != m_queue.end (); ++i)\n    {\n      if (pred (*i))\n        {\n          Drop (*i, \"Drop outdated packet \");\n        }\n    }\n  m_queue.erase (std::remove_if (m_queue.begin (), m_queue.end (), pred),\n                 m_queue.end ());\n}\n\nvoid\nRequestQueue::Drop (QueueEntry en, std::string reason)\n{\n  NS_LOG_LOGIC (reason << en.GetPacket ()->GetUid () << \" \" << en.GetIpv4Header ().GetDestination ());\n  en.GetErrorCallback () (en.GetPacket (), en.GetIpv4Header (),\n                          Socket::ERROR_NOROUTETOHOST);\n  return;\n}\n\n}  // namespace aodvKmeans\n}  // namespace ns3\n"
    },
    {
      "file_path": "aodvKmeans/model/aodvKmeans-rtable.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2009 IITP RAS\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Based on\n *      NS-2 aodvKmeans model developed by the CMU/MONARCH group and optimized and\n *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;\n *\n *      aodvKmeans-UU implementation by Erik Nordstr\u00f6m of Uppsala University\n *      http://core.it.uu.se/core/index.php/aodvKmeans-UU\n *\n * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>\n *          Pavel Boyko <boyko@iitp.ru>\n */\n\n#include \"aodvKmeans-rtable.h\"\n#include <algorithm>\n#include <iomanip>\n#include \"ns3/simulator.h\"\n#include \"ns3/log.h\"\n\nnamespace ns3 {\n\nNS_LOG_COMPONENT_DEFINE (\"aodvKmeansRoutingTable\");\n\nnamespace aodvKmeans {\n\n/*\n The Routing Table\n */\n\nRoutingTableEntry::RoutingTableEntry (Ptr<NetDevice> dev, Ipv4Address dst, bool vSeqNo, uint32_t seqNo,\n                                      Ipv4InterfaceAddress iface, uint16_t hops, Ipv4Address nextHop, Time lifetime,\n                                      uint32_t txError, uint32_t positionX, uint32_t positionY, uint32_t freeSpace)\n  : m_ackTimer (Timer::CANCEL_ON_DESTROY),\n    m_validSeqNo (vSeqNo),\n    m_seqNo (seqNo),\n    m_hops (hops),\n    m_lifeTime (lifetime + Simulator::Now ()),\n    m_iface (iface),\n    m_flag (VALID),\n    m_reqCount (0),\n    m_blackListState (false),\n    m_blackListTimeout (Simulator::Now ()),\n    m_txerrorCount(txError),\n    m_positionX(positionX),\n    m_positionY(positionY),\n    m_freeSpace(freeSpace)\n{\n  m_ipv4Route = Create<Ipv4Route> ();\n  m_ipv4Route->SetDestination (dst);\n  m_ipv4Route->SetGateway (nextHop);\n  m_ipv4Route->SetSource (m_iface.GetLocal ());\n  m_ipv4Route->SetOutputDevice (dev);\n}\n\nRoutingTableEntry::~RoutingTableEntry ()\n{\n}\n\nbool\nRoutingTableEntry::InsertPrecursor (Ipv4Address id)\n{\n  NS_LOG_FUNCTION (this << id);\n  if (!LookupPrecursor (id))\n    {\n      m_precursorList.push_back (id);\n      return true;\n    }\n  else\n    {\n      return false;\n    }\n}\n\nbool\nRoutingTableEntry::LookupPrecursor (Ipv4Address id)\n{\n  NS_LOG_FUNCTION (this << id);\n  for (std::vector<Ipv4Address>::const_iterator i = m_precursorList.begin (); i\n       != m_precursorList.end (); ++i)\n    {\n      if (*i == id)\n        {\n          NS_LOG_LOGIC (\"Precursor \" << id << \" found\");\n          return true;\n        }\n    }\n  NS_LOG_LOGIC (\"Precursor \" << id << \" not found\");\n  return false;\n}\n\nbool\nRoutingTableEntry::DeletePrecursor (Ipv4Address id)\n{\n  NS_LOG_FUNCTION (this << id);\n  std::vector<Ipv4Address>::iterator i = std::remove (m_precursorList.begin (),\n                                                      m_precursorList.end (), id);\n  if (i == m_precursorList.end ())\n    {\n      NS_LOG_LOGIC (\"Precursor \" << id << \" not found\");\n      return false;\n    }\n  else\n    {\n      NS_LOG_LOGIC (\"Precursor \" << id << \" found\");\n      m_precursorList.erase (i, m_precursorList.end ());\n    }\n  return true;\n}\n\nvoid\nRoutingTableEntry::DeleteAllPrecursors ()\n{\n  NS_LOG_FUNCTION (this);\n  m_precursorList.clear ();\n}\n\nbool\nRoutingTableEntry::IsPrecursorListEmpty () const\n{\n  return m_precursorList.empty ();\n}\n\nvoid\nRoutingTableEntry::GetPrecursors (std::vector<Ipv4Address> & prec) const\n{\n  NS_LOG_FUNCTION (this);\n  if (IsPrecursorListEmpty ())\n    {\n      return;\n    }\n  for (std::vector<Ipv4Address>::const_iterator i = m_precursorList.begin (); i\n       != m_precursorList.end (); ++i)\n    {\n      bool result = true;\n      for (std::vector<Ipv4Address>::const_iterator j = prec.begin (); j\n           != prec.end (); ++j)\n        {\n          if (*j == *i)\n            {\n              result = false;\n            }\n        }\n      if (result)\n        {\n          prec.push_back (*i);\n        }\n    }\n}\n\nvoid\nRoutingTableEntry::Invalidate (Time badLinkLifetime)\n{\n  NS_LOG_FUNCTION (this << badLinkLifetime.As (Time::S));\n  if (m_flag == INVALID)\n    {\n      return;\n    }\n  m_flag = INVALID;\n  m_reqCount = 0;\n  m_lifeTime = badLinkLifetime + Simulator::Now ();\n}\n\nvoid\nRoutingTableEntry::Print (Ptr<OutputStreamWrapper> stream, Time::Unit unit /* = Time::S */) const\n{\n  std::ostream* os = stream->GetStream ();\n  // Copy the current ostream state\n  std::ios oldState (nullptr);\n  oldState.copyfmt (*os);\n\n  *os << std::resetiosflags (std::ios::adjustfield) << std::setiosflags (std::ios::left);\n\n  std::ostringstream dest, gw, iface, expire;\n  dest << m_ipv4Route->GetDestination ();\n  gw << m_ipv4Route->GetGateway ();\n  iface << m_iface.GetLocal ();\n  expire << std::setprecision (2) << (m_lifeTime - Simulator::Now ()).As (unit);\n  *os << std::setw (16) << dest.str();\n  *os << std::setw (16) << gw.str();\n  *os << std::setw (16) << iface.str();\n  *os << std::setw (16);\n  switch (m_flag)\n    {\n    case VALID:\n      {\n        *os << \"UP\";\n        break;\n      }\n    case INVALID:\n      {\n        *os << \"DOWN\";\n        break;\n      }\n    case IN_SEARCH:\n      {\n        *os << \"IN_SEARCH\";\n        break;\n      }\n    }\n\n  *os << std::setw (16) << expire.str();\n  *os << m_hops << std::endl;\n  // Restore the previous ostream state\n  (*os).copyfmt (oldState);\n}\n\n/*\n The Routing Table\n */\n\nRoutingTable::RoutingTable (Time t)\n  : m_badLinkLifetime (t)\n{\n}\n\nbool\nRoutingTable::LookupRoute (Ipv4Address id, RoutingTableEntry & rt)\n{\n  NS_LOG_FUNCTION (this << id);\n  Purge ();\n  if (m_ipv4AddressEntry.empty ())\n    {\n      NS_LOG_LOGIC (\"Route to \" << id << \" not found; m_ipv4AddressEntry is empty\");\n      return false;\n    }\n  std::map<Ipv4Address, RoutingTableEntry>::const_iterator i =\n    m_ipv4AddressEntry.find (id);\n  if (i == m_ipv4AddressEntry.end ())\n    {\n      NS_LOG_LOGIC (\"Route to \" << id << \" not found\");\n      return false;\n    }\n  rt = i->second;\n  NS_LOG_LOGIC (\"Route to \" << id << \" found\");\n  return true;\n}\n\nbool\nRoutingTable::LookupValidRoute (Ipv4Address id, RoutingTableEntry & rt)\n{\n  NS_LOG_FUNCTION (this << id);\n  if (!LookupRoute (id, rt))\n    {\n      NS_LOG_LOGIC (\"Route to \" << id << \" not found\");\n      return false;\n    }\n  NS_LOG_LOGIC (\"Route to \" << id << \" flag is \" << ((rt.GetFlag () == VALID) ? \"valid\" : \"not valid\"));\n  return (rt.GetFlag () == VALID);\n}\n\nbool\nRoutingTable::DeleteRoute (Ipv4Address dst)\n{\n  NS_LOG_FUNCTION (this << dst);\n  Purge ();\n  if (m_ipv4AddressEntry.erase (dst) != 0)\n    {\n      NS_LOG_LOGIC (\"Route deletion to \" << dst << \" successful\");\n      return true;\n    }\n  NS_LOG_LOGIC (\"Route deletion to \" << dst << \" not successful\");\n  return false;\n}\n\nbool\nRoutingTable::AddRoute (RoutingTableEntry & rt)\n{\n  NS_LOG_FUNCTION (this);\n  Purge ();\n  if (rt.GetFlag () != IN_SEARCH)\n    {\n      rt.SetRreqCnt (0);\n    }\n  std::pair<std::map<Ipv4Address, RoutingTableEntry>::iterator, bool> result =\n    m_ipv4AddressEntry.insert (std::make_pair (rt.GetDestination (), rt));\n  return result.second;\n}\n\nbool\nRoutingTable::Update (RoutingTableEntry & rt)\n{\n  NS_LOG_FUNCTION (this);\n  std::map<Ipv4Address, RoutingTableEntry>::iterator i =\n    m_ipv4AddressEntry.find (rt.GetDestination ());\n  if (i == m_ipv4AddressEntry.end ())\n    {\n      NS_LOG_LOGIC (\"Route update to \" << rt.GetDestination () << \" fails; not found\");\n      return false;\n    }\n  i->second = rt;\n  if (i->second.GetFlag () != IN_SEARCH)\n    {\n      NS_LOG_LOGIC (\"Route update to \" << rt.GetDestination () << \" set RreqCnt to 0\");\n      i->second.SetRreqCnt (0);\n    }\n  return true;\n}\n\nbool\nRoutingTable::SetEntryState (Ipv4Address id, RouteFlags state)\n{\n  NS_LOG_FUNCTION (this);\n  std::map<Ipv4Address, RoutingTableEntry>::iterator i =\n    m_ipv4AddressEntry.find (id);\n  if (i == m_ipv4AddressEntry.end ())\n    {\n      NS_LOG_LOGIC (\"Route set entry state to \" << id << \" fails; not found\");\n      return false;\n    }\n  i->second.SetFlag (state);\n  i->second.SetRreqCnt (0);\n  NS_LOG_LOGIC (\"Route set entry state to \" << id << \": new state is \" << state);\n  return true;\n}\n\nvoid\nRoutingTable::GetListOfDestinationWithNextHop (Ipv4Address nextHop, std::map<Ipv4Address, uint32_t> & unreachable )\n{\n  NS_LOG_FUNCTION (this);\n  Purge ();\n  unreachable.clear ();\n  for (std::map<Ipv4Address, RoutingTableEntry>::const_iterator i =\n         m_ipv4AddressEntry.begin (); i != m_ipv4AddressEntry.end (); ++i)\n    {\n      if (i->second.GetNextHop () == nextHop)\n        {\n          NS_LOG_LOGIC (\"Unreachable insert \" << i->first << \" \" << i->second.GetSeqNo ());\n          unreachable.insert (std::make_pair (i->first, i->second.GetSeqNo ()));\n        }\n    }\n}\n\nvoid\nRoutingTable::InvalidateRoutesWithDst (const std::map<Ipv4Address, uint32_t> & unreachable)\n{\n  NS_LOG_FUNCTION (this);\n  Purge ();\n  for (std::map<Ipv4Address, RoutingTableEntry>::iterator i =\n         m_ipv4AddressEntry.begin (); i != m_ipv4AddressEntry.end (); ++i)\n    {\n      for (std::map<Ipv4Address, uint32_t>::const_iterator j =\n             unreachable.begin (); j != unreachable.end (); ++j)\n        {\n          if ((i->first == j->first) && (i->second.GetFlag () == VALID))\n            {\n              NS_LOG_LOGIC (\"Invalidate route with destination address \" << i->first);\n              i->second.Invalidate (m_badLinkLifetime);\n            }\n        }\n    }\n}\n\nvoid\nRoutingTable::DeleteAllRoutesFromInterface (Ipv4InterfaceAddress iface)\n{\n  NS_LOG_FUNCTION (this);\n  if (m_ipv4AddressEntry.empty ())\n    {\n      return;\n    }\n  for (std::map<Ipv4Address, RoutingTableEntry>::iterator i =\n         m_ipv4AddressEntry.begin (); i != m_ipv4AddressEntry.end (); )\n    {\n      if (i->second.GetInterface () == iface)\n        {\n          std::map<Ipv4Address, RoutingTableEntry>::iterator tmp = i;\n          ++i;\n          m_ipv4AddressEntry.erase (tmp);\n        }\n      else\n        {\n          ++i;\n        }\n    }\n}\nstd::vector<Ipv4Address> \nRoutingTable::Kmeans (Ipv4Address dst, uint32_t positionX, uint32_t positionY)\n{\n    Purge();\n  \n    /// features list\n    int n = m_ipv4AddressEntry.size();\n    double features[n][3];\n    int k = 2;\n    double cluster_center[k][3];\n    int cluster_assignments[n];\n\n  \n    int i = 0;\n    \n    for (std::map<Ipv4Address, RoutingTableEntry>::iterator it = m_ipv4AddressEntry.begin (); it != m_ipv4AddressEntry.end (); ++it)\n    {\n      if(it->first.IsBroadcast() || it->first.IsLocalhost() || it->first.IsMulticast() || \n      it->first.IsSubnetDirectedBroadcast(Ipv4Mask((char *)\"255.255.255.0\")) || it->second.GetFlag() == INVALID || it->second.GetHop() > 2)\n      {\n        continue;\n      }\n      features[i][0] = 1.0 * (positionX - it->second.GetPositionX()) * (positionX - it->second.GetPositionX()) + \n                      1.0 * (positionY - it->second.GetPositionY()) * (positionY - it->second.GetPositionY());\n                    \n      features[i][1] = 1.0 * it->second.GetTxErrorCount();\n      features[i][2] = 1.0 * it->second.GetFreeSpace();\n      i++;\n    }\n    \n    n = i;\n\n    double mini[3], maxi[3];\n\n    // normalize the features\n    for(int j=0;j<3;j++)\n    {\n      mini[j] = features[0][j];\n      maxi[j] = features[0][j];\n      for(int i=1;i<n;i++)\n      {\n        mini[j] = std::min(mini[j], features[i][j]);\n        maxi[j]= std::max(maxi[j], features[i][j]);\n      }\n\n      for(int i=0;i<n;i++)\n      {\n        features[i][j] = (features[i][j] - mini[j]);\n        if(mini[j] != maxi[j]) features[i][j]/= (maxi[j] - mini[j]);\n      }\n\n    }\n    \n\n    // define an idea feature list\n    double ideal[3];\n    ideal[0] = 0.0; // minimum possible distance\n    ideal[1] = 0.0; // minimum possible error\n    ideal[2] = maxi[2]; // buffer empty\n    \n\n    // randomly pick k cluster heads\n    srand(time(0));\n    for(int i=0;i<k;i++)\n    {\n      int p = rand() % n;\n      for(int j=0;j<3;j++)\n      {\n        cluster_center[i][j] = features[p][j];\n      }\n    }\n\n    int num_iterations = 3;\n    // run iterations\n    for(int iteration=0;iteration<=num_iterations;iteration++)\n    {\n      \n      // assign clusters\n\n      for(int i=0;i<n;i++)\n      {\n          double mini_dist = -1.0;\n          for(int j=0;j<k;j++)\n          {\n            double dist = 0.0;\n            for(int d=0; d<3; d++)\n            {\n              dist += (features[i][d] - cluster_center[j][d]) * (features[i][d] - cluster_center[j][d]);\n               \n            }\n            if(mini_dist == -1.0 || dist < mini_dist)\n            {\n              mini_dist = dist;\n              cluster_assignments[i] = j;\n            }\n          }\n          \n      }\n\n      if(iteration == num_iterations) \n      {\n        break;\n      }\n\n      // re-position cluster centers\n      \n      for(int j=0;j<k;j++)\n      {\n        int cnt = 0;\n        for(int d=0;d<3;d++)\n        {\n          cluster_center[j][d] = 0.0;\n        }\n\n\n        for(int i=0;i<n;i++)\n        {\n          if(cluster_assignments[i] == j)\n          {\n            for(int d=0;d<3;d++)\n            {\n              cluster_center[j][d] += features[i][d];\n              \n            }\n            \n            cnt++;\n          }\n          \n        }\n        if(cnt)\n        {\n          for(int d=0;d<3;d++)\n          {\n            cluster_center[j][d] /= cnt;\n          }\n        }\n        else \n        {\n          int p = rand() % n;\n          for(int d=0;d<3;d++)\n          {\n            cluster_center[j][d] = features[p][d];\n          }\n        }\n\n        \n      }\n      \n\n    }\n\n\n    // de-normalize cluster centers\n    \n    for(int j=0;j<k;j++)\n    {\n      for(int d=0;d<3;d++)\n      {\n        cluster_center[j][d] *= (maxi[d] - mini[d]);\n        cluster_center[j][d] += mini[d];\n      }\n    }\n    for(int i=0;i<n;i++)\n    {\n      for(int d=0;d<3;d++)\n      {\n        features[i][d] *= (maxi[d] - mini[d]);\n        features[i][d] += mini[d];\n      }\n    }\n\n    // select optimal cluster\n    int optimal_cluster = -1;\n    double mini_dist = -1.0;\n    for(int j=0;j<k;j++)\n    {\n      double dist = 0;\n      for(int d=0; d<3; d++)\n      {\n          dist += (cluster_center[j][d] - ideal[d]) * (cluster_center[j][d] - ideal[d]); \n      }\n      if(mini_dist == -1.0 || dist < mini_dist)\n      {\n        mini_dist = dist;\n        optimal_cluster = j;\n      }\n\n    }\n\n    std::vector<Ipv4Address>selectedCluster;\n    i=0;\n    for (std::map<Ipv4Address, RoutingTableEntry>::iterator it = m_ipv4AddressEntry.begin (); it != m_ipv4AddressEntry.end (); ++it)\n    {\n      if(it->first.IsBroadcast() || it->first.IsLocalhost() || it->first.IsMulticast() || \n      it->first.IsSubnetDirectedBroadcast(Ipv4Mask((char *)\"255.255.255.0\")) || it->second.GetFlag() == INVALID || it->second.GetHop() > 2)\n      {\n        continue;\n      }\n      if(cluster_assignments[i] == optimal_cluster)\n      {\n        selectedCluster.push_back(it->first);\n      }\n      i++;\n    }\n    \n    return selectedCluster;\n\n}\n\n\nvoid\nRoutingTable::Purge ()\n{\n  NS_LOG_FUNCTION (this);\n  if (m_ipv4AddressEntry.empty ())\n    {\n      return;\n    }\n  for (std::map<Ipv4Address, RoutingTableEntry>::iterator i =\n         m_ipv4AddressEntry.begin (); i != m_ipv4AddressEntry.end (); )\n    {\n      if (i->second.GetLifeTime () < Seconds (0))\n        {\n          if (i->second.GetFlag () == INVALID)\n            {\n              std::map<Ipv4Address, RoutingTableEntry>::iterator tmp = i;\n              ++i;\n              m_ipv4AddressEntry.erase (tmp);\n            }\n          else if (i->second.GetFlag () == VALID)\n            {\n              NS_LOG_LOGIC (\"Invalidate route with destination address \" << i->first);\n              i->second.Invalidate (m_badLinkLifetime);\n              ++i;\n            }\n          else\n            {\n              ++i;\n            }\n        }\n      else\n        {\n          ++i;\n        }\n    }\n}\n\nvoid\nRoutingTable::Purge (std::map<Ipv4Address, RoutingTableEntry> &table) const\n{\n  NS_LOG_FUNCTION (this);\n  if (table.empty ())\n    {\n      return;\n    }\n  for (std::map<Ipv4Address, RoutingTableEntry>::iterator i =\n         table.begin (); i != table.end (); )\n    {\n      if (i->second.GetLifeTime () < Seconds (0))\n        {\n          if (i->second.GetFlag () == INVALID)\n            {\n              std::map<Ipv4Address, RoutingTableEntry>::iterator tmp = i;\n              ++i;\n              table.erase (tmp);\n            }\n          else if (i->second.GetFlag () == VALID)\n            {\n              NS_LOG_LOGIC (\"Invalidate route with destination address \" << i->first);\n              i->second.Invalidate (m_badLinkLifetime);\n              ++i;\n            }\n          else\n            {\n              ++i;\n            }\n        }\n      else\n        {\n          ++i;\n        }\n    }\n}\n\nbool\nRoutingTable::MarkLinkAsUnidirectional (Ipv4Address neighbor, Time blacklistTimeout)\n{\n  NS_LOG_FUNCTION (this << neighbor << blacklistTimeout.As (Time::S));\n  std::map<Ipv4Address, RoutingTableEntry>::iterator i =\n    m_ipv4AddressEntry.find (neighbor);\n  if (i == m_ipv4AddressEntry.end ())\n    {\n      NS_LOG_LOGIC (\"Mark link unidirectional to  \" << neighbor << \" fails; not found\");\n      return false;\n    }\n  i->second.SetUnidirectional (true);\n  i->second.SetBlacklistTimeout (blacklistTimeout);\n  i->second.SetRreqCnt (0);\n  NS_LOG_LOGIC (\"Set link to \" << neighbor << \" to unidirectional\");\n  return true;\n}\n\nvoid\nRoutingTable::Print (Ptr<OutputStreamWrapper> stream, Time::Unit unit /* = Time::S */) const\n{\n  std::map<Ipv4Address, RoutingTableEntry> table = m_ipv4AddressEntry;\n  Purge (table);\n  std::ostream* os = stream->GetStream ();\n  // Copy the current ostream state\n  std::ios oldState (nullptr);\n  oldState.copyfmt (*os);\n\n  *os << std::resetiosflags (std::ios::adjustfield) << std::setiosflags (std::ios::left);\n  *os << \"\\nAODV Routing table\\n\";\n  *os << std::setw (16) << \"Destination\";\n  *os << std::setw (16) << \"Gateway\";\n  *os << std::setw (16) << \"Interface\";\n  *os << std::setw (16) << \"Flag\";\n  *os << std::setw (16) << \"Expire\";\n  *os << \"Hops\" << std::endl;\n  for (std::map<Ipv4Address, RoutingTableEntry>::const_iterator i =\n         table.begin (); i != table.end (); ++i)\n    {\n      i->second.Print (stream, unit);\n    }\n  *stream->GetStream () << \"\\n\";\n}\n\n}\n}\n"
    },
    {
      "file_path": "aodvKmeans/test/aodvKmeans-id-cache-test-suite.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2009 IITP RAS\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Based on\n *      NS-2 aodvKmeans model developed by the CMU/MONARCH group and optimized and\n *      tuned by Samir Das and Mahesh Marina, University of Cincinnati;\n *\n *      aodvKmeans-UU implementation by Erik Nordstr\u00f6m of Uppsala University\n *      http://core.it.uu.se/core/index.php/aodvKmeans-UU\n *\n * Authors: Elena Buchatskaia <borovkovaes@iitp.ru>\n *          Pavel Boyko <boyko@iitp.ru>\n */\n#include \"ns3/aodvKmeans-id-cache.h\"\n#include \"ns3/test.h\"\n\nnamespace ns3 {\nnamespace aodvKmeans {\n\n/**\n * \\ingroup aodvKmeans\n * \\defgroup aodvKmeans-test aodvKmeans module tests\n */\n\n\n/**\n * \\ingroup aodvKmeans-test\n * \\ingroup tests\n *\n * \\brief Unit test for id cache\n */\nclass IdCacheTest : public TestCase\n{\npublic:\n  IdCacheTest () : TestCase (\"Id Cache\"),\n                   cache (Seconds (10))\n  {\n  }\n  virtual void DoRun ();\n\nprivate:\n  /// Timeout test function #1\n  void CheckTimeout1 ();\n  /// Timeout test function #2\n  void CheckTimeout2 ();\n  /// Timeout test function #3\n  void CheckTimeout3 ();\n\n  /// ID cache\n  IdCache cache;\n};\n\nvoid\nIdCacheTest::DoRun ()\n{\n  NS_TEST_EXPECT_MSG_EQ (cache.GetLifeTime (), Seconds (10), \"Lifetime\");\n  NS_TEST_EXPECT_MSG_EQ (cache.IsDuplicate (Ipv4Address (\"1.2.3.4\"), 3), false, \"Unknown ID & address\");\n  NS_TEST_EXPECT_MSG_EQ (cache.IsDuplicate (Ipv4Address (\"1.2.3.4\"), 4), false, \"Unknown ID\");\n  NS_TEST_EXPECT_MSG_EQ (cache.IsDuplicate (Ipv4Address (\"4.3.2.1\"), 3), false, \"Unknown address\");\n  NS_TEST_EXPECT_MSG_EQ (cache.IsDuplicate (Ipv4Address (\"1.2.3.4\"), 3), true, \"Known address & ID\");\n  cache.SetLifetime (Seconds (15));\n  NS_TEST_EXPECT_MSG_EQ (cache.GetLifeTime (), Seconds (15), \"New lifetime\");\n  cache.IsDuplicate (Ipv4Address (\"1.1.1.1\"), 4);\n  cache.IsDuplicate (Ipv4Address (\"1.1.1.1\"), 4);\n  cache.IsDuplicate (Ipv4Address (\"2.2.2.2\"), 5);\n  cache.IsDuplicate (Ipv4Address (\"3.3.3.3\"), 6);\n  NS_TEST_EXPECT_MSG_EQ (cache.GetSize (), 6, \"trivial\");\n\n  Simulator::Schedule (Seconds (5), &IdCacheTest::CheckTimeout1, this);\n  Simulator::Schedule (Seconds (11), &IdCacheTest::CheckTimeout2, this);\n  Simulator::Schedule (Seconds (30), &IdCacheTest::CheckTimeout3, this);\n  Simulator::Run ();\n  Simulator::Destroy ();\n}\n\nvoid\nIdCacheTest::CheckTimeout1 ()\n{\n  NS_TEST_EXPECT_MSG_EQ (cache.GetSize (), 6, \"Nothing expire\");\n}\n\nvoid\nIdCacheTest::CheckTimeout2 ()\n{\n  NS_TEST_EXPECT_MSG_EQ (cache.GetSize (), 3, \"3 records left\");\n}\n\nvoid\nIdCacheTest::CheckTimeout3 ()\n{\n  NS_TEST_EXPECT_MSG_EQ (cache.GetSize (), 0, \"All records expire\");\n}\n\n/**\n * \\ingroup aodvKmeans-test\n * \\ingroup tests\n *\n * \\brief Id Cache Test Suite\n */\nclass IdCacheTestSuite : public TestSuite\n{\npublic:\n  IdCacheTestSuite () : TestSuite (\"aodvKmeans-routing-id-cache\", UNIT)\n  {\n    AddTestCase (new IdCacheTest, TestCase::QUICK);\n  }\n} g_idCacheTestSuite; ///< the test suite\n\n}  // namespace aodvKmeans\n}  // namespace ns3\n"
    },
    {
      "file_path": "aodvKmeans/test/aodvKmeans-regression.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2009 IITP RAS\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Authors: Pavel Boyko <boyko@iitp.ru>\n */\n\n#include \"aodvKmeans-regression.h\"\n#include \"bug-772.h\"\n\n#include \"ns3/simulator.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/double.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/string.h\"\n#include \"ns3/boolean.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/abort.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/pcap-file.h\"\n#include \"ns3/aodvKmeans-helper.h\"\n#include \"ns3/config.h\"\n#include \"ns3/pcap-test.h\"\n#include \"ns3/rng-seed-manager.h\"\n#include \"ns3/icmpv4.h\"\n#include <sstream>\n\nusing namespace ns3;\n\n/**\n * \\ingroup aodvKmeans-test\n * \\ingroup tests\n *\n * \\brief aodvKmeans regression test suite\n */\nclass aodvKmeansRegressionTestSuite : public TestSuite\n{\npublic:\n  aodvKmeansRegressionTestSuite () : TestSuite (\"routing-aodvKmeans-regression\", SYSTEM)\n  {\n    SetDataDir (NS_TEST_SOURCEDIR);\n    // General RREQ-RREP-RRER test case\n    AddTestCase (new ChainRegressionTest (\"aodvKmeans-chain-regression-test\"), TestCase::QUICK);\n    // \\bugid{606} test case, should crash if bug is not fixed\n    AddTestCase (new ChainRegressionTest (\"bug-606-test\", Seconds (10), 3, Seconds (1)), TestCase::QUICK);\n    // \\bugid{772} UDP test case\n    AddTestCase (new Bug772ChainTest (\"udp-chain-test\", \"ns3::UdpSocketFactory\", Seconds (3), 10), TestCase::QUICK);\n  }\n} g_aodvKmeansRegressionTestSuite; ///< the test suite\n\n\n/**\n * \\ingroup aodvKmeans-test\n * \\ingroup tests\n *\n * \\brief Chain Regression Test\n */\nChainRegressionTest::ChainRegressionTest (const char * const prefix, Time t, uint32_t size, Time arpAliveTimeout)\n  : TestCase (\"aodvKmeans chain regression test\"),\n    m_nodes (0),\n    m_prefix (prefix),\n    m_time (t),\n    m_size (size),\n    m_step (120),\n    m_arpAliveTimeout (arpAliveTimeout),\n    m_seq (0)\n{\n}\n\nChainRegressionTest::~ChainRegressionTest ()\n{\n  delete m_nodes;\n}\n\nvoid\nChainRegressionTest::SendPing ()\n{\n  if (Simulator::Now () >= m_time)\n    {\n      return;\n    }\n\n  Ptr<Packet> p = Create<Packet> ();\n  Icmpv4Echo echo;\n  echo.SetSequenceNumber (m_seq);\n  m_seq++;\n  echo.SetIdentifier (0);\n\n  Ptr<Packet> dataPacket = Create<Packet> (56);\n  echo.SetData (dataPacket);\n  p->AddHeader (echo);\n  Icmpv4Header header;\n  header.SetType (Icmpv4Header::ICMPV4_ECHO);\n  header.SetCode (0);\n  if (Node::ChecksumEnabled ())\n    {\n      header.EnableChecksum ();\n    }\n  p->AddHeader (header);\n  m_socket->Send (p, 0);\n  Simulator::Schedule (Seconds (1), &ChainRegressionTest::SendPing, this);\n}\n\nvoid\nChainRegressionTest::DoRun ()\n{\n  RngSeedManager::SetSeed (12345);\n  RngSeedManager::SetRun (7);\n  Config::SetDefault (\"ns3::ArpCache::AliveTimeout\", TimeValue (m_arpAliveTimeout));\n\n  CreateNodes ();\n  CreateDevices ();\n\n  // At m_time / 3 move central node away and see what will happen\n  Ptr<Node> node = m_nodes->Get (m_size / 2);\n  Ptr<MobilityModel> mob = node->GetObject<MobilityModel> ();\n  Simulator::Schedule (Time (m_time / 3), &MobilityModel::SetPosition, mob, Vector (1e5, 1e5, 1e5));\n\n  Simulator::Stop (m_time);\n  Simulator::Run ();\n  Simulator::Destroy ();\n\n  CheckResults ();\n\n  delete m_nodes, m_nodes = 0;\n}\n\nvoid\nChainRegressionTest::CreateNodes ()\n{\n  m_nodes = new NodeContainer;\n  m_nodes->Create (m_size);\n  MobilityHelper mobility;\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0),\n                                 \"MinY\", DoubleValue (0.0),\n                                 \"DeltaX\", DoubleValue (m_step),\n                                 \"DeltaY\", DoubleValue (0),\n                                 \"GridWidth\", UintegerValue (m_size),\n                                 \"LayoutType\", StringValue (\"RowFirst\"));\n  mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install (*m_nodes);\n}\n\nvoid\nChainRegressionTest::CreateDevices ()\n{\n  // 1. Setup WiFi\n  int64_t streamsUsed = 0;\n  WifiMacHelper wifiMac;\n  wifiMac.SetType (\"ns3::AdhocWifiMac\");\n  YansWifiPhyHelper wifiPhy;\n  wifiPhy.DisablePreambleDetectionModel ();\n  YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default ();\n  Ptr<YansWifiChannel> chan = wifiChannel.Create ();\n  wifiPhy.SetChannel (chan);\n\n  // This test suite output was originally based on YansErrorRateModel\n  wifiPhy.SetErrorRateModel (\"ns3::YansErrorRateModel\");\n  WifiHelper wifi;\n  wifi.SetRemoteStationManager (\"ns3::ConstantRateWifiManager\", \"DataMode\", StringValue (\"OfdmRate6Mbps\"), \"RtsCtsThreshold\", StringValue (\"2200\"));\n  NetDeviceContainer devices = wifi.Install (wifiPhy, wifiMac, *m_nodes);\n\n  // Assign fixed stream numbers to wifi and channel random variables\n  streamsUsed += wifi.AssignStreams (devices, streamsUsed);\n  // Assign 6 streams per device\n  NS_TEST_ASSERT_MSG_EQ (streamsUsed, (devices.GetN () * 6), \"Stream assignment mismatch\");\n  streamsUsed += wifiChannel.AssignStreams (chan, streamsUsed);\n  // Assign 0 streams per channel for this configuration\n  NS_TEST_ASSERT_MSG_EQ (streamsUsed, (devices.GetN () * 6), \"Stream assignment mismatch\");\n\n  // 2. Setup TCP/IP & aodvKmeans\n  aodvKmeansHelper aodvKmeans; // Use default parameters here\n  InternetStackHelper internetStack;\n  internetStack.SetRoutingHelper (aodvKmeans);\n  internetStack.Install (*m_nodes);\n  streamsUsed += internetStack.AssignStreams (*m_nodes, streamsUsed);\n  // InternetStack uses m_size more streams\n  NS_TEST_ASSERT_MSG_EQ (streamsUsed, (devices.GetN () * 8) + m_size, \"Stream assignment mismatch\");\n  streamsUsed += aodvKmeans.AssignStreams (*m_nodes, streamsUsed);\n  // aodvKmeans uses m_size more streams\n  NS_TEST_ASSERT_MSG_EQ (streamsUsed, ((devices.GetN () * 8) + (2 * m_size)), \"Stream assignment mismatch\");\n\n  Ipv4AddressHelper address;\n  address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  // 3. Setup ping\n  m_socket = Socket::CreateSocket (m_nodes->Get (0), TypeId::LookupByName (\"ns3::Ipv4RawSocketFactory\"));\n  m_socket->SetAttribute (\"Protocol\", UintegerValue (1)); // icmp\n  InetSocketAddress src = InetSocketAddress (Ipv4Address::GetAny (), 0);\n  m_socket->Bind (src);\n  InetSocketAddress dst = InetSocketAddress (interfaces.GetAddress (m_size - 1), 0);\n  m_socket->Connect (dst);\n\n  SendPing ();\n\n  // 4. write PCAP\n  wifiPhy.EnablePcapAll (CreateTempDirFilename (m_prefix));\n}\n\nvoid\nChainRegressionTest::CheckResults ()\n{\n  for (uint32_t i = 0; i < m_size; ++i)\n    {\n      NS_PCAP_TEST_EXPECT_EQ (m_prefix << \"-\" << i << \"-0.pcap\");\n    }\n}\n"
    },
    {
      "file_path": "aodvKmeans/test/aodvKmeans-test-suite.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2009 IITP RAS\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Authors: Pavel Boyko <boyko@iitp.ru>\n */\n#include \"ns3/test.h\"\n#include \"ns3/aodvKmeans-neighbor.h\"\n#include \"ns3/aodvKmeans-packet.h\"\n#include \"ns3/aodvKmeans-rqueue.h\"\n#include \"ns3/aodvKmeans-rtable.h\"\n#include \"ns3/ipv4-route.h\"\n\nnamespace ns3 {\nnamespace aodvKmeans {\n\n/**\n * \\ingroup aodvKmeans-test\n * \\ingroup tests\n *\n * \\brief Unit test for neighbors\n */\nstruct NeighborTest : public TestCase\n{\n  NeighborTest () : TestCase (\"Neighbor\"),\n                    neighbor (0)\n  {\n  }\n  virtual void DoRun ();\n  /**\n   * Handler test function\n   * \\param addr the IPv4 address of the neighbor\n   */\n  void Handler (Ipv4Address addr);\n  /// Check timeout function 1\n  void CheckTimeout1 ();\n  /// Check timeout function 2\n  void CheckTimeout2 ();\n  /// Check timeout function 3\n  void CheckTimeout3 ();\n  /// The Neighbors\n  Neighbors * neighbor;\n};\n\nvoid\nNeighborTest::Handler (Ipv4Address addr)\n{\n}\n\nvoid\nNeighborTest::CheckTimeout1 ()\n{\n  NS_TEST_EXPECT_MSG_EQ (neighbor->IsNeighbor (Ipv4Address (\"1.2.3.4\")), true, \"Neighbor exists\");\n  NS_TEST_EXPECT_MSG_EQ (neighbor->IsNeighbor (Ipv4Address (\"1.1.1.1\")), true, \"Neighbor exists\");\n  NS_TEST_EXPECT_MSG_EQ (neighbor->IsNeighbor (Ipv4Address (\"2.2.2.2\")), true, \"Neighbor exists\");\n  NS_TEST_EXPECT_MSG_EQ (neighbor->IsNeighbor (Ipv4Address (\"3.3.3.3\")), true, \"Neighbor exists\");\n}\nvoid\nNeighborTest::CheckTimeout2 ()\n{\n  NS_TEST_EXPECT_MSG_EQ (neighbor->IsNeighbor (Ipv4Address (\"1.2.3.4\")), false, \"Neighbor doesn't exist\");\n  NS_TEST_EXPECT_MSG_EQ (neighbor->IsNeighbor (Ipv4Address (\"1.1.1.1\")), false, \"Neighbor doesn't exist\");\n  NS_TEST_EXPECT_MSG_EQ (neighbor->IsNeighbor (Ipv4Address (\"2.2.2.2\")), false, \"Neighbor doesn't exist\");\n  NS_TEST_EXPECT_MSG_EQ (neighbor->IsNeighbor (Ipv4Address (\"3.3.3.3\")), true, \"Neighbor exists\");\n}\nvoid\nNeighborTest::CheckTimeout3 ()\n{\n  NS_TEST_EXPECT_MSG_EQ (neighbor->IsNeighbor (Ipv4Address (\"1.2.3.4\")), false, \"Neighbor doesn't exist\");\n  NS_TEST_EXPECT_MSG_EQ (neighbor->IsNeighbor (Ipv4Address (\"1.1.1.1\")), false, \"Neighbor doesn't exist\");\n  NS_TEST_EXPECT_MSG_EQ (neighbor->IsNeighbor (Ipv4Address (\"2.2.2.2\")), false, \"Neighbor doesn't exist\");\n  NS_TEST_EXPECT_MSG_EQ (neighbor->IsNeighbor (Ipv4Address (\"3.3.3.3\")), false, \"Neighbor doesn't exist\");\n}\n\nvoid\nNeighborTest::DoRun ()\n{\n  Neighbors nb (Seconds (1));\n  neighbor = &nb;\n  neighbor->SetCallback (MakeCallback (&NeighborTest::Handler, this));\n  neighbor->Update (Ipv4Address (\"1.2.3.4\"), Seconds (1));\n  NS_TEST_EXPECT_MSG_EQ (neighbor->IsNeighbor (Ipv4Address (\"1.2.3.4\")), true, \"Neighbor exists\");\n  NS_TEST_EXPECT_MSG_EQ (neighbor->IsNeighbor (Ipv4Address (\"4.3.2.1\")), false, \"Neighbor doesn't exist\");\n  neighbor->Update (Ipv4Address (\"1.2.3.4\"), Seconds (10));\n  NS_TEST_EXPECT_MSG_EQ (neighbor->IsNeighbor (Ipv4Address (\"1.2.3.4\")), true, \"Neighbor exists\");\n  NS_TEST_EXPECT_MSG_EQ (neighbor->GetExpireTime (Ipv4Address (\"1.2.3.4\")), Seconds (10), \"Known expire time\");\n  NS_TEST_EXPECT_MSG_EQ (neighbor->GetExpireTime (Ipv4Address (\"4.3.2.1\")), Seconds (0), \"Known expire time\");\n  neighbor->Update (Ipv4Address (\"1.1.1.1\"), Seconds (5));\n  neighbor->Update (Ipv4Address (\"2.2.2.2\"), Seconds (10));\n  neighbor->Update (Ipv4Address (\"3.3.3.3\"), Seconds (20));\n\n  Simulator::Schedule (Seconds (2), &NeighborTest::CheckTimeout1, this);\n  Simulator::Schedule (Seconds (15), &NeighborTest::CheckTimeout2, this);\n  Simulator::Schedule (Seconds (30), &NeighborTest::CheckTimeout3, this);\n  Simulator::Run ();\n  Simulator::Destroy ();\n}\n\n/**\n * \\ingroup aodvKmeans-test\n * \\ingroup tests\n *\n * \\brief Type header test case\n */\nstruct TypeHeaderTest : public TestCase\n{\n  TypeHeaderTest () : TestCase (\"aodvKmeans TypeHeader\")\n  {\n  }\n  virtual void DoRun ()\n  {\n    TypeHeader h (aodvKmeansTYPE_RREQ);\n    NS_TEST_EXPECT_MSG_EQ (h.IsValid (), true, \"Default header is valid\");\n    NS_TEST_EXPECT_MSG_EQ (h.Get (), aodvKmeansTYPE_RREQ, \"Default header is RREQ\");\n\n    Ptr<Packet> p = Create<Packet> ();\n    p->AddHeader (h);\n    TypeHeader h2 (aodvKmeansTYPE_RREP);\n    uint32_t bytes = p->RemoveHeader (h2);\n    NS_TEST_EXPECT_MSG_EQ (bytes, 1, \"Type header is 1 byte long\");\n    NS_TEST_EXPECT_MSG_EQ (h, h2, \"Round trip serialization works\");\n  }\n};\n\n/**\n * \\ingroup aodvKmeans-test\n * \\ingroup tests\n *\n * \\brief Unit test for RREQ\n */\nstruct RreqHeaderTest : public TestCase\n{\n  RreqHeaderTest () : TestCase (\"aodvKmeans RREQ\")\n  {\n  }\n  virtual void DoRun ()\n  {\n    RreqHeader h (/*flags*/ 0, /*reserved*/ 0, /*hopCount*/ 6, /*requestID*/ 1, /*dst*/ Ipv4Address (\"1.2.3.4\"),\n                            /*dstSeqNo*/ 40, /*origin*/ Ipv4Address (\"4.3.2.1\"), /*originSeqNo*/ 10);\n    NS_TEST_EXPECT_MSG_EQ (h.GetGratuitousRrep (), false, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetDestinationOnly (), false, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetHopCount (), 6, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetId (), 1, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetDst (), Ipv4Address (\"1.2.3.4\"), \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetDstSeqno (), 40, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetOrigin (), Ipv4Address (\"4.3.2.1\"), \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetOriginSeqno (), 10, \"trivial\");\n\n    h.SetGratuitousRrep (true);\n    NS_TEST_EXPECT_MSG_EQ (h.GetGratuitousRrep (), true, \"trivial\");\n    h.SetDestinationOnly (true);\n    NS_TEST_EXPECT_MSG_EQ (h.GetDestinationOnly (), true, \"trivial\");\n    h.SetUnknownSeqno (true);\n    NS_TEST_EXPECT_MSG_EQ (h.GetUnknownSeqno (), true, \"trivial\");\n    h.SetDst (Ipv4Address (\"1.1.1.1\"));\n    NS_TEST_EXPECT_MSG_EQ (h.GetDst (), Ipv4Address (\"1.1.1.1\"), \"trivial\");\n    h.SetDstSeqno (5);\n    NS_TEST_EXPECT_MSG_EQ (h.GetDstSeqno (), 5, \"trivial\");\n    h.SetHopCount (7);\n    NS_TEST_EXPECT_MSG_EQ (h.GetHopCount (), 7, \"trivial\");\n    h.SetId (55);\n    NS_TEST_EXPECT_MSG_EQ (h.GetId (), 55, \"trivial\");\n    h.SetOrigin (Ipv4Address (\"4.4.4.4\"));\n    NS_TEST_EXPECT_MSG_EQ (h.GetOrigin (), Ipv4Address (\"4.4.4.4\"), \"trivial\");\n    h.SetOriginSeqno (23);\n    NS_TEST_EXPECT_MSG_EQ (h.GetOriginSeqno (), 23, \"trivial\");\n\n    Ptr<Packet> p = Create<Packet> ();\n    p->AddHeader (h);\n    RreqHeader h2;\n    uint32_t bytes = p->RemoveHeader (h2);\n    NS_TEST_EXPECT_MSG_EQ (bytes, 23, \"RREP is 23 bytes long\");\n    NS_TEST_EXPECT_MSG_EQ (h, h2, \"Round trip serialization works\");\n\n  }\n};\n\n/**\n * \\ingroup aodvKmeans-test\n * \\ingroup tests\n *\n * \\brief Unit test for RREP\n */\nstruct RrepHeaderTest : public TestCase\n{\n  RrepHeaderTest () : TestCase (\"aodvKmeans RREP\")\n  {\n  }\n  virtual void DoRun ()\n  {\n    RrepHeader h (/*prefixSize*/ 0, /*hopCount*/ 12, /*dst*/ Ipv4Address (\"1.2.3.4\"), /*dstSeqNo*/ 2,\n                                 /*origin*/ Ipv4Address (\"4.3.2.1\"), /*lifetime*/ Seconds (3));\n    NS_TEST_EXPECT_MSG_EQ (h.GetPrefixSize (), 0, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetHopCount (), 12, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetDst (), Ipv4Address (\"1.2.3.4\"), \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetDstSeqno (), 2, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetOrigin (), Ipv4Address (\"4.3.2.1\"), \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetLifeTime (), Seconds (3), \"trivial\");\n    h.SetDst (Ipv4Address (\"1.1.1.1\"));\n    NS_TEST_EXPECT_MSG_EQ (h.GetDst (), Ipv4Address (\"1.1.1.1\"), \"trivial\");\n    h.SetDstSeqno (123);\n    NS_TEST_EXPECT_MSG_EQ (h.GetDstSeqno (), 123, \"trivial\");\n    h.SetOrigin (Ipv4Address (\"4.4.4.4\"));\n    NS_TEST_EXPECT_MSG_EQ (h.GetOrigin (), Ipv4Address (\"4.4.4.4\"), \"trivial\");\n    h.SetLifeTime (MilliSeconds (1200));\n    NS_TEST_EXPECT_MSG_EQ (h.GetLifeTime (), MilliSeconds (1200), \"trivial\");\n    h.SetAckRequired (true);\n    NS_TEST_EXPECT_MSG_EQ (h.GetAckRequired (), true, \"trivial\");\n    h.SetAckRequired (false);\n    NS_TEST_EXPECT_MSG_EQ (h.GetAckRequired (), false, \"trivial\");\n    h.SetPrefixSize (2);\n    NS_TEST_EXPECT_MSG_EQ (h.GetPrefixSize (), 2, \"trivial\");\n    h.SetHopCount (15);\n    NS_TEST_EXPECT_MSG_EQ (h.GetHopCount (), 15, \"trivial\");\n\n    h.SetHello (Ipv4Address (\"10.0.0.2\"), 9, Seconds (15));\n    NS_TEST_EXPECT_MSG_EQ (h.GetDst (), h.GetOrigin (), \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetDstSeqno (), 9, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetLifeTime (), Seconds (15), \"trivial\");\n\n    Ptr<Packet> p = Create<Packet> ();\n    p->AddHeader (h);\n    RrepHeader h2;\n    uint32_t bytes = p->RemoveHeader (h2);\n    NS_TEST_EXPECT_MSG_EQ (bytes, 19, \"RREP is 19 bytes long\");\n    NS_TEST_EXPECT_MSG_EQ (h, h2, \"Round trip serialization works\");\n  }\n};\n\n/**\n * \\ingroup aodvKmeans-test\n * \\ingroup tests\n *\n * \\brief Unit test for RREP-ACK\n */\nstruct RrepAckHeaderTest : public TestCase\n{\n  RrepAckHeaderTest () : TestCase (\"aodvKmeans RREP-ACK\")\n  {\n  }\n  virtual void DoRun ()\n  {\n    RrepAckHeader h;\n    Ptr<Packet> p = Create<Packet> ();\n    p->AddHeader (h);\n    RrepAckHeader h2;\n    uint32_t bytes = p->RemoveHeader (h2);\n    NS_TEST_EXPECT_MSG_EQ (bytes, 1, \"ACK is 1 byte long\");\n    NS_TEST_EXPECT_MSG_EQ (h, h2, \"Round trip serialization works\");\n  }\n};\n\n/**\n * \\ingroup aodvKmeans-test\n * \\ingroup tests\n *\n * \\brief Unit test for RERR\n */\nstruct RerrHeaderTest : public TestCase\n{\n  RerrHeaderTest () : TestCase (\"aodvKmeans RERR\")\n  {\n  }\n  virtual void DoRun ()\n  {\n    RerrHeader h;\n    h.SetNoDelete (true);\n    NS_TEST_EXPECT_MSG_EQ (h.GetNoDelete (), true, \"trivial\");\n    Ipv4Address dst = Ipv4Address (\"1.2.3.4\");\n    NS_TEST_EXPECT_MSG_EQ (h.AddUnDestination (dst, 12), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetDestCount (), 1, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.AddUnDestination (dst, 13), true, \"trivial\");\n    Ipv4Address dst2 = Ipv4Address (\"4.3.2.1\");\n    NS_TEST_EXPECT_MSG_EQ (h.AddUnDestination (dst2, 12), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetDestCount (), 2, \"trivial\");\n\n    Ptr<Packet> p = Create<Packet> ();\n    p->AddHeader (h);\n    RerrHeader h2;\n    uint32_t bytes = p->RemoveHeader (h2);\n    NS_TEST_EXPECT_MSG_EQ (bytes, h.GetSerializedSize (), \"(De)Serialized size match\");\n    NS_TEST_EXPECT_MSG_EQ (h, h2, \"Round trip serialization works\");\n  }\n};\n\n/**\n * \\ingroup aodvKmeans-test\n * \\ingroup tests\n *\n * \\brief Unit test for aodvKmeans routing table entry\n */\nstruct QueueEntryTest : public TestCase\n{\n  QueueEntryTest () : TestCase (\"QueueEntry\")\n  {\n  }\n  /**\n   * Unicast test function\n   * \\param route the IPv4 route\n   * \\param packet the packet\n   * \\param header the IPv4 header\n   */\n  void Unicast (Ptr<Ipv4Route> route, Ptr<const Packet> packet, const Ipv4Header & header)\n  {\n  }\n  /**\n   * Error test function\n   * \\param p The packet\n   * \\param h The header\n   * \\param e the socket error\n   */\n  void Error (Ptr<const Packet> p, const Ipv4Header & h, Socket::SocketErrno e)\n  {\n  }\n  /**\n   * Unicast 2 testfunction\n   * \\param route The IPv4 route\n   * \\param packet The packet\n   * \\param header The header\n   */\n  void Unicast2 (Ptr<Ipv4Route> route, Ptr<const Packet> packet, const Ipv4Header & header)\n  {\n  }\n  /**\n   * Error2 test function\n   * \\param p The packet\n   * \\param h The header\n   * \\param e the socket error\n   */\n  void Error2 (Ptr<const Packet> p, const Ipv4Header & h, Socket::SocketErrno e)\n  {\n  }\n  virtual void DoRun ()\n  {\n    Ptr<const Packet> packet = Create<Packet> ();\n    Ipv4Header h;\n    h.SetDestination (Ipv4Address (\"1.2.3.4\"));\n    h.SetSource (Ipv4Address (\"4.3.2.1\"));\n    Ipv4RoutingProtocol::UnicastForwardCallback ucb = MakeCallback (&QueueEntryTest::Unicast, this);\n    Ipv4RoutingProtocol::ErrorCallback ecb = MakeCallback (&QueueEntryTest::Error, this);\n    QueueEntry entry (packet, h, ucb, ecb, Seconds (1));\n    NS_TEST_EXPECT_MSG_EQ (h.GetDestination (),  entry.GetIpv4Header ().GetDestination (), \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (h.GetSource (),  entry.GetIpv4Header ().GetSource (), \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (ucb.IsEqual (entry.GetUnicastForwardCallback ()), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (ecb.IsEqual (entry.GetErrorCallback ()), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (entry.GetExpireTime (), Seconds (1), \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (entry.GetPacket (), packet, \"trivial\");\n    entry.SetExpireTime (Seconds (3));\n    NS_TEST_EXPECT_MSG_EQ (entry.GetExpireTime (), Seconds (3), \"trivial\");\n    Ipv4Header h2;\n    h2.SetDestination (Ipv4Address (\"1.1.1.1\"));\n    entry.SetIpv4Header (h2);\n    NS_TEST_EXPECT_MSG_EQ (entry.GetIpv4Header ().GetDestination (), Ipv4Address (\"1.1.1.1\"), \"trivial\");\n    Ipv4RoutingProtocol::UnicastForwardCallback ucb2 = MakeCallback (&QueueEntryTest::Unicast2, this);\n    Ipv4RoutingProtocol::ErrorCallback ecb2 = MakeCallback (&QueueEntryTest::Error2, this);\n    entry.SetErrorCallback (ecb2);\n    NS_TEST_EXPECT_MSG_EQ (ecb2.IsEqual (entry.GetErrorCallback ()), true, \"trivial\");\n    entry.SetUnicastForwardCallback (ucb2);\n    NS_TEST_EXPECT_MSG_EQ (ucb2.IsEqual (entry.GetUnicastForwardCallback ()), true, \"trivial\");\n  }\n};\n//-----------------------------------------------------------------------------\n/// Unit test for RequestQueue\nstruct aodvKmeansRqueueTest : public TestCase\n{\n  aodvKmeansRqueueTest () : TestCase (\"Rqueue\"),\n                      q (64, Seconds (30))\n  {\n  }\n  virtual void DoRun ();\n  /**\n   * Unicast test function\n   * \\param route the IPv4 route\n   * \\param packet the packet\n   * \\param header the IPv4 header\n   */\n  void Unicast (Ptr<Ipv4Route> route, Ptr<const Packet> packet, const Ipv4Header & header)\n  {\n  }\n  /**\n   * Error test function\n   * \\param p The packet\n   * \\param h The header\n   * \\param e the socket error\n   */\n  void Error (Ptr<const Packet> p, const Ipv4Header & h, Socket::SocketErrno e)\n  {\n  }\n  /// Check size limit function\n  void CheckSizeLimit ();\n  /// Check timeout function\n  void CheckTimeout ();\n\n  /// Request queue\n  RequestQueue q;\n};\n\nvoid\naodvKmeansRqueueTest::DoRun ()\n{\n  NS_TEST_EXPECT_MSG_EQ (q.GetMaxQueueLen (), 64, \"trivial\");\n  q.SetMaxQueueLen (32);\n  NS_TEST_EXPECT_MSG_EQ (q.GetMaxQueueLen (), 32, \"trivial\");\n  NS_TEST_EXPECT_MSG_EQ (q.GetQueueTimeout (), Seconds (30), \"trivial\");\n  q.SetQueueTimeout (Seconds (10));\n  NS_TEST_EXPECT_MSG_EQ (q.GetQueueTimeout (), Seconds (10), \"trivial\");\n\n  Ptr<const Packet> packet = Create<Packet> ();\n  Ipv4Header h;\n  h.SetDestination (Ipv4Address (\"1.2.3.4\"));\n  h.SetSource (Ipv4Address (\"4.3.2.1\"));\n  Ipv4RoutingProtocol::UnicastForwardCallback ucb = MakeCallback (&aodvKmeansRqueueTest::Unicast, this);\n  Ipv4RoutingProtocol::ErrorCallback ecb = MakeCallback (&aodvKmeansRqueueTest::Error, this);\n  QueueEntry e1 (packet, h, ucb, ecb, Seconds (1));\n  q.Enqueue (e1);\n  q.Enqueue (e1);\n  q.Enqueue (e1);\n  NS_TEST_EXPECT_MSG_EQ (q.Find (Ipv4Address (\"1.2.3.4\")), true, \"trivial\");\n  NS_TEST_EXPECT_MSG_EQ (q.Find (Ipv4Address (\"1.1.1.1\")), false, \"trivial\");\n  NS_TEST_EXPECT_MSG_EQ (q.GetSize (), 1, \"trivial\");\n  q.DropPacketWithDst (Ipv4Address (\"1.2.3.4\"));\n  NS_TEST_EXPECT_MSG_EQ (q.Find (Ipv4Address (\"1.2.3.4\")), false, \"trivial\");\n  NS_TEST_EXPECT_MSG_EQ (q.GetSize (), 0, \"trivial\");\n\n  h.SetDestination (Ipv4Address (\"2.2.2.2\"));\n  QueueEntry e2 (packet, h, ucb, ecb, Seconds (1));\n  q.Enqueue (e1);\n  q.Enqueue (e2);\n  Ptr<Packet> packet2 = Create<Packet> ();\n  QueueEntry e3 (packet2, h, ucb, ecb, Seconds (1));\n  NS_TEST_EXPECT_MSG_EQ (q.Dequeue (Ipv4Address (\"3.3.3.3\"), e3), false, \"trivial\");\n  NS_TEST_EXPECT_MSG_EQ (q.Dequeue (Ipv4Address (\"2.2.2.2\"), e3), true, \"trivial\");\n  NS_TEST_EXPECT_MSG_EQ (q.Find (Ipv4Address (\"2.2.2.2\")), false, \"trivial\");\n  q.Enqueue (e2);\n  q.Enqueue (e3);\n  NS_TEST_EXPECT_MSG_EQ (q.GetSize (), 2, \"trivial\");\n  Ptr<Packet> packet4 = Create<Packet> ();\n  h.SetDestination (Ipv4Address (\"1.2.3.4\"));\n  QueueEntry e4 (packet4, h, ucb, ecb, Seconds (20));\n  q.Enqueue (e4);\n  NS_TEST_EXPECT_MSG_EQ (q.GetSize (), 3, \"trivial\");\n  q.DropPacketWithDst (Ipv4Address (\"1.2.3.4\"));\n  NS_TEST_EXPECT_MSG_EQ (q.GetSize (), 1, \"trivial\");\n\n  CheckSizeLimit ();\n\n  Ipv4Header header2;\n  Ipv4Address dst2 (\"1.2.3.4\");\n  header2.SetDestination (dst2);\n\n  Simulator::Schedule (q.GetQueueTimeout () + Seconds (1), &aodvKmeansRqueueTest::CheckTimeout, this);\n\n  Simulator::Run ();\n  Simulator::Destroy ();\n}\n\nvoid\naodvKmeansRqueueTest::CheckSizeLimit ()\n{\n  Ptr<Packet> packet = Create<Packet> ();\n  Ipv4Header header;\n  Ipv4RoutingProtocol::UnicastForwardCallback ucb = MakeCallback (&aodvKmeansRqueueTest::Unicast, this);\n  Ipv4RoutingProtocol::ErrorCallback ecb = MakeCallback (&aodvKmeansRqueueTest::Error, this);\n  QueueEntry e1 (packet, header, ucb, ecb, Seconds (1));\n\n  for (uint32_t i = 0; i < q.GetMaxQueueLen (); ++i)\n    {\n      q.Enqueue (e1);\n    }\n  NS_TEST_EXPECT_MSG_EQ (q.GetSize (), 2, \"trivial\");\n\n  for (uint32_t i = 0; i < q.GetMaxQueueLen (); ++i)\n    {\n      q.Enqueue (e1);\n    }\n  NS_TEST_EXPECT_MSG_EQ (q.GetSize (), 2, \"trivial\");\n}\n\nvoid\naodvKmeansRqueueTest::CheckTimeout ()\n{\n  NS_TEST_EXPECT_MSG_EQ (q.GetSize (), 0, \"Must be empty now\");\n}\n\n/**\n * \\ingroup aodvKmeans-test\n * \\ingroup tests\n *\n * \\brief Unit test for aodvKmeans routing table entry\n */\nstruct aodvKmeansRtableEntryTest : public TestCase\n{\n  aodvKmeansRtableEntryTest () : TestCase (\"RtableEntry\")\n  {\n  }\n  virtual void DoRun ()\n  {\n    Ptr<NetDevice> dev;\n    Ipv4InterfaceAddress iface;\n    RoutingTableEntry rt (/*output device*/ dev, /*dst*/ Ipv4Address (\"1.2.3.4\"), /*validSeqNo*/ true, /*seqNo*/ 10,\n                                            /*interface*/ iface, /*hop*/ 5, /*next hop*/ Ipv4Address (\"3.3.3.3\"), /*lifetime*/ Seconds (10));\n    NS_TEST_EXPECT_MSG_EQ (rt.GetOutputDevice (), dev, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.GetDestination (), Ipv4Address (\"1.2.3.4\"), \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.GetValidSeqNo (), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.GetSeqNo (), 10, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.GetInterface (), iface, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.GetHop (), 5, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.GetNextHop (), Ipv4Address (\"3.3.3.3\"), \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.GetLifeTime (), Seconds (10), \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.GetFlag (), VALID, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.GetRreqCnt (), 0, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.IsPrecursorListEmpty (), true, \"trivial\");\n\n    Ptr<NetDevice> dev2;\n    Ipv4InterfaceAddress iface2;\n    rt.SetOutputDevice (dev2);\n    NS_TEST_EXPECT_MSG_EQ (rt.GetOutputDevice (), dev2, \"trivial\");\n    rt.SetInterface (iface2);\n    NS_TEST_EXPECT_MSG_EQ (rt.GetInterface (), iface2, \"trivial\");\n    rt.SetValidSeqNo (false);\n    NS_TEST_EXPECT_MSG_EQ (rt.GetValidSeqNo (), false, \"trivial\");\n    rt.SetFlag (INVALID);\n    NS_TEST_EXPECT_MSG_EQ (rt.GetFlag (), INVALID, \"trivial\");\n    rt.SetFlag (IN_SEARCH);\n    NS_TEST_EXPECT_MSG_EQ (rt.GetFlag (), IN_SEARCH, \"trivial\");\n    rt.SetHop (12);\n    NS_TEST_EXPECT_MSG_EQ (rt.GetHop (), 12, \"trivial\");\n    rt.SetLifeTime (Seconds (1));\n    NS_TEST_EXPECT_MSG_EQ (rt.GetLifeTime (), Seconds (1), \"trivial\");\n    rt.SetNextHop (Ipv4Address (\"1.1.1.1\"));\n    NS_TEST_EXPECT_MSG_EQ (rt.GetNextHop (), Ipv4Address (\"1.1.1.1\"), \"trivial\");\n    rt.SetUnidirectional (true);\n    NS_TEST_EXPECT_MSG_EQ (rt.IsUnidirectional (), true, \"trivial\");\n    rt.SetBlacklistTimeout (Seconds (7));\n    NS_TEST_EXPECT_MSG_EQ (rt.GetBlacklistTimeout (), Seconds (7), \"trivial\");\n    rt.SetRreqCnt (2);\n    NS_TEST_EXPECT_MSG_EQ (rt.GetRreqCnt (), 2, \"trivial\");\n    rt.IncrementRreqCnt ();\n    NS_TEST_EXPECT_MSG_EQ (rt.GetRreqCnt (), 3, \"trivial\");\n    rt.Invalidate (Seconds (13));\n    NS_TEST_EXPECT_MSG_EQ (rt.GetFlag (), INVALID, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.GetLifeTime (), Seconds (13), \"trivial\");\n    rt.SetLifeTime (MilliSeconds (100));\n    NS_TEST_EXPECT_MSG_EQ (rt.GetLifeTime (), MilliSeconds (100), \"trivial\");\n    Ptr<Ipv4Route> route = rt.GetRoute ();\n    NS_TEST_EXPECT_MSG_EQ (route->GetDestination (), Ipv4Address (\"1.2.3.4\"), \"trivial\");\n\n    NS_TEST_EXPECT_MSG_EQ (rt.InsertPrecursor (Ipv4Address (\"10.0.0.1\")), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.IsPrecursorListEmpty (), false, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.InsertPrecursor (Ipv4Address (\"10.0.0.2\")), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.InsertPrecursor (Ipv4Address (\"10.0.0.2\")), false, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.LookupPrecursor (Ipv4Address (\"10.0.0.3\")), false, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.LookupPrecursor (Ipv4Address (\"10.0.0.1\")), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.DeletePrecursor (Ipv4Address (\"10.0.0.2\")), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.LookupPrecursor (Ipv4Address (\"10.0.0.2\")), false, \"trivial\");\n    std::vector<Ipv4Address> prec;\n    rt.GetPrecursors (prec);\n    NS_TEST_EXPECT_MSG_EQ (prec.size (), 1, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.InsertPrecursor (Ipv4Address (\"10.0.0.4\")), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.DeletePrecursor (Ipv4Address (\"10.0.0.5\")), false, \"trivial\");\n    rt.GetPrecursors (prec);\n    NS_TEST_EXPECT_MSG_EQ (prec.size (), 2, \"trivial\");\n    rt.DeleteAllPrecursors ();\n    NS_TEST_EXPECT_MSG_EQ (rt.IsPrecursorListEmpty (), true, \"trivial\");\n    rt.GetPrecursors (prec);\n    NS_TEST_EXPECT_MSG_EQ (prec.size (), 2, \"trivial\");\n    Simulator::Destroy ();\n  }\n};\n\n/**\n * \\ingroup aodvKmeans-test\n * \\ingroup tests\n *\n * \\brief Unit test for aodvKmeans routing table\n */\nstruct aodvKmeansRtableTest : public TestCase\n{\n  aodvKmeansRtableTest () : TestCase (\"Rtable\")\n  {\n  }\n  virtual void DoRun ()\n  {\n    RoutingTable rtable (Seconds (2));\n    NS_TEST_EXPECT_MSG_EQ (rtable.GetBadLinkLifetime (), Seconds (2), \"trivial\");\n    rtable.SetBadLinkLifetime (Seconds (1));\n    NS_TEST_EXPECT_MSG_EQ (rtable.GetBadLinkLifetime (), Seconds (1), \"trivial\");\n    Ptr<NetDevice> dev;\n    Ipv4InterfaceAddress iface;\n    RoutingTableEntry rt (/*output device*/ dev, /*dst*/ Ipv4Address (\"1.2.3.4\"), /*validSeqNo*/ true, /*seqNo*/ 10,\n                                            /*interface*/ iface, /*hop*/ 5, /*next hop*/ Ipv4Address (\"1.1.1.1\"), /*lifetime*/ Seconds (10));\n    NS_TEST_EXPECT_MSG_EQ (rtable.AddRoute (rt), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rtable.AddRoute (rt), false, \"trivial\");\n    RoutingTableEntry rt2 (/*output device*/ dev, /*dst*/ Ipv4Address (\"4.3.2.1\"), /*validSeqNo*/ false, /*seqNo*/ 0,\n                                             /*interface*/ iface, /*hop*/ 15, /*next hop*/ Ipv4Address (\"1.1.1.1\"), /*lifetime*/ Seconds (1));\n    NS_TEST_EXPECT_MSG_EQ (rtable.AddRoute (rt2), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rtable.LookupRoute (rt2.GetDestination (), rt), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt2.GetDestination (), rt.GetDestination (), \"trivial\");\n    rt.SetHop (20);\n    rt.InsertPrecursor (Ipv4Address (\"10.0.0.3\"));\n    NS_TEST_EXPECT_MSG_EQ (rtable.Update (rt), true, \"trivial\");\n    RoutingTableEntry rt3;\n    NS_TEST_EXPECT_MSG_EQ (rtable.LookupRoute (Ipv4Address (\"10.0.0.1\"), rt), false, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rtable.Update (rt3), false, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rtable.SetEntryState (Ipv4Address (\"10.0.0.1\"), INVALID), false, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rtable.SetEntryState (Ipv4Address (\"1.2.3.4\"), IN_SEARCH), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rtable.DeleteRoute (Ipv4Address (\"5.5.5.5\")), false, \"trivial\");\n    RoutingTableEntry rt4 (/*output device*/ dev, /*dst*/ Ipv4Address (\"5.5.5.5\"), /*validSeqNo*/ false, /*seqNo*/ 0,\n                                             /*interface*/ iface, /*hop*/ 15, /*next hop*/ Ipv4Address (\"1.1.1.1\"), /*lifetime*/ Seconds (-10));\n    NS_TEST_EXPECT_MSG_EQ (rtable.AddRoute (rt4), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rtable.SetEntryState (Ipv4Address (\"5.5.5.5\"), INVALID), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rtable.LookupRoute (Ipv4Address (\"5.5.5.5\"), rt), false, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rtable.MarkLinkAsUnidirectional (Ipv4Address (\"1.2.3.4\"), Seconds (2)), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rtable.LookupRoute (Ipv4Address (\"1.2.3.4\"), rt), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.IsUnidirectional (), true, \"trivial\");\n    rt.SetLifeTime (Seconds (-5));\n    NS_TEST_EXPECT_MSG_EQ (rtable.Update (rt), true, \"trivial\");\n    std::map<Ipv4Address, uint32_t> unreachable;\n    rtable.GetListOfDestinationWithNextHop (Ipv4Address (\"1.1.1.1\"), unreachable);\n    NS_TEST_EXPECT_MSG_EQ (unreachable.size (), 2, \"trivial\");\n    unreachable.insert (std::make_pair (Ipv4Address (\"4.3.2.1\"), 3));\n    rtable.InvalidateRoutesWithDst (unreachable);\n    NS_TEST_EXPECT_MSG_EQ (rtable.LookupRoute (Ipv4Address (\"4.3.2.1\"), rt), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rt.GetFlag (), INVALID, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rtable.DeleteRoute (Ipv4Address (\"1.2.3.4\")), true, \"trivial\");\n    NS_TEST_EXPECT_MSG_EQ (rtable.DeleteRoute (Ipv4Address (\"1.2.3.4\")), false, \"trivial\");\n    Simulator::Destroy ();\n  }\n};\n\n/**\n * \\ingroup aodvKmeans-test\n * \\ingroup tests\n *\n * \\brief aodvKmeans test suite\n */\nclass aodvKmeansTestSuite : public TestSuite\n{\npublic:\n  aodvKmeansTestSuite () : TestSuite (\"routing-aodvKmeans\", UNIT)\n  {\n    AddTestCase (new NeighborTest, TestCase::QUICK);\n    AddTestCase (new TypeHeaderTest, TestCase::QUICK);\n    AddTestCase (new RreqHeaderTest, TestCase::QUICK);\n    AddTestCase (new RrepHeaderTest, TestCase::QUICK);\n    AddTestCase (new RrepAckHeaderTest, TestCase::QUICK);\n    AddTestCase (new RerrHeaderTest, TestCase::QUICK);\n    AddTestCase (new QueueEntryTest, TestCase::QUICK);\n    AddTestCase (new aodvKmeansRqueueTest, TestCase::QUICK);\n    AddTestCase (new aodvKmeansRtableEntryTest, TestCase::QUICK);\n    AddTestCase (new aodvKmeansRtableTest, TestCase::QUICK);\n  }\n} g_aodvKmeansTestSuite; ///< the test suite\n\n}  // namespace aodvKmeans\n}  // namespace ns3\n"
    },
    {
      "file_path": "aodvKmeans/test/bug-772.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2009 IITP RAS\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Authors: Pavel Boyko <boyko@iitp.ru>\n */\n\n#include \"bug-772.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/random-variable-stream.h\"\n#include \"ns3/rng-seed-manager.h\"\n#include \"ns3/string.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/double.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/boolean.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/abort.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/pcap-file.h\"\n#include \"ns3/aodvKmeans-helper.h\"\n#include \"ns3/v4ping-helper.h\"\n#include \"ns3/config.h\"\n#include \"ns3/inet-socket-address.h\"\n#include \"ns3/data-rate.h\"\n#include \"ns3/pcap-test.h\"\n#include <sstream>\n\nusing namespace ns3;\n\n//-----------------------------------------------------------------------------\n// UdpChainTest\n//-----------------------------------------------------------------------------\nBug772ChainTest::Bug772ChainTest (const char * const prefix, const char * const proto, Time t, uint32_t size)\n  : TestCase (\"Bug 772 UDP and TCP chain regression test\"),\n    m_nodes (0),\n    m_prefix (prefix),\n    m_proto (proto),\n    m_time (t),\n    m_size (size),\n    m_step (120),\n    m_port (9),\n    m_receivedPackets (0)\n{\n}\n\nBug772ChainTest::~Bug772ChainTest ()\n{\n  delete m_nodes;\n}\n\nvoid\nBug772ChainTest::SendData (Ptr<Socket> socket)\n{\n  if (Simulator::Now () < m_time)\n    {\n      socket->Send (Create<Packet> (1000));\n      Simulator::ScheduleWithContext (socket->GetNode ()->GetId (), Seconds (0.25),\n                                      &Bug772ChainTest::SendData, this, socket);\n    }\n}\n\nvoid\nBug772ChainTest::HandleRead (Ptr<Socket> socket)\n{\n  m_receivedPackets++;\n}\n\nvoid\nBug772ChainTest::DoRun ()\n{\n  RngSeedManager::SetSeed (12345);\n  RngSeedManager::SetRun (7);\n\n  // Default of 3 will cause packet loss\n  Config::SetDefault (\"ns3::ArpCache::PendingQueueSize\", UintegerValue (10));\n\n  CreateNodes ();\n  CreateDevices ();\n\n  Simulator::Stop (m_time + Seconds (1));  // Allow buffered packets to clear\n  Simulator::Run ();\n  Simulator::Destroy ();\n\n  CheckResults ();\n\n  delete m_nodes, m_nodes = 0;\n}\n\nvoid\nBug772ChainTest::CreateNodes ()\n{\n  m_nodes = new NodeContainer;\n  m_nodes->Create (m_size);\n  MobilityHelper mobility;\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0),\n                                 \"MinY\", DoubleValue (0.0),\n                                 \"DeltaX\", DoubleValue (m_step),\n                                 \"DeltaY\", DoubleValue (0),\n                                 \"GridWidth\", UintegerValue (m_size),\n                                 \"LayoutType\", StringValue (\"RowFirst\"));\n  mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install (*m_nodes);\n}\n\nvoid\nBug772ChainTest::CreateDevices ()\n{\n  int64_t streamsUsed = 0;\n  // 1. Setup WiFi\n  WifiMacHelper wifiMac;\n  wifiMac.SetType (\"ns3::AdhocWifiMac\");\n  YansWifiPhyHelper wifiPhy;\n  wifiPhy.DisablePreambleDetectionModel ();\n  // This test suite output was originally based on YansErrorRateModel\n  wifiPhy.SetErrorRateModel (\"ns3::YansErrorRateModel\");\n  YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default ();\n  Ptr<YansWifiChannel> chan = wifiChannel.Create ();\n  wifiPhy.SetChannel (chan);\n  wifiPhy.Set (\"TxGain\", DoubleValue (1.0)); //this configuration should go away in future revision to the test\n  wifiPhy.Set (\"RxGain\", DoubleValue (1.0)); //this configuration should go away in future revision to the test\n  WifiHelper wifi;\n  wifi.SetRemoteStationManager (\"ns3::ConstantRateWifiManager\", \"DataMode\", StringValue (\"OfdmRate6Mbps\"), \"RtsCtsThreshold\", StringValue (\"2200\"), \"MaxSlrc\", UintegerValue (7));\n  NetDeviceContainer devices = wifi.Install (wifiPhy, wifiMac, *m_nodes);\n\n  // Assign fixed stream numbers to wifi and channel random variables\n  streamsUsed += wifi.AssignStreams (devices, streamsUsed);\n  // Assign 6 streams per device\n  NS_TEST_ASSERT_MSG_EQ (streamsUsed, (devices.GetN () * 6), \"Stream assignment mismatch\");\n  streamsUsed += wifiChannel.AssignStreams (chan, streamsUsed);\n  // Assign 0 streams per channel for this configuration\n  NS_TEST_ASSERT_MSG_EQ (streamsUsed, (devices.GetN () * 6), \"Stream assignment mismatch\");\n\n  // 2. Setup TCP/IP & aodvKmeans\n  aodvKmeansHelper aodvKmeans; // Use default parameters here\n  InternetStackHelper internetStack;\n  internetStack.SetRoutingHelper (aodvKmeans);\n  internetStack.Install (*m_nodes);\n  streamsUsed += internetStack.AssignStreams (*m_nodes, streamsUsed);\n  // Expect to use (3*m_size) more streams for internet stack random variables\n  NS_TEST_ASSERT_MSG_EQ (streamsUsed, ((devices.GetN () * 6) + (3 * m_size)), \"Stream assignment mismatch\");\n  streamsUsed += aodvKmeans.AssignStreams (*m_nodes, streamsUsed);\n  // Expect to use m_size more streams for aodvKmeans\n  NS_TEST_ASSERT_MSG_EQ (streamsUsed, ((devices.GetN () * 6) + (3 * m_size) + m_size), \"Stream assignment mismatch\");\n  Ipv4AddressHelper address;\n  address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  // 3. Setup UDP source and sink\n  m_sendSocket = Socket::CreateSocket (m_nodes->Get (0), TypeId::LookupByName (m_proto));\n  m_sendSocket->Bind ();\n  m_sendSocket->Connect (InetSocketAddress (interfaces.GetAddress (m_size - 1), m_port));\n  m_sendSocket->SetAllowBroadcast (true);\n  Simulator::ScheduleWithContext (m_sendSocket->GetNode ()->GetId (), Seconds (1.0),\n                                  &Bug772ChainTest::SendData, this, m_sendSocket);\n\n  m_recvSocket = Socket::CreateSocket (m_nodes->Get (m_size - 1), TypeId::LookupByName (m_proto));\n  m_recvSocket->Bind (InetSocketAddress (Ipv4Address::GetAny (), m_port));\n  m_recvSocket->Listen ();\n  m_recvSocket->ShutdownSend ();\n  m_recvSocket->SetRecvCallback (MakeCallback (&Bug772ChainTest::HandleRead, this));\n\n}\n\nvoid\nBug772ChainTest::CheckResults ()\n{\n  // We should have sent 8 packets (every 0.25 seconds from time 1 to time 3)\n  // Check that the received packet count is 8\n  NS_TEST_EXPECT_MSG_EQ (m_receivedPackets, 8, \"Did not receive expected 8 packets\");\n}\n"
    },
    {
      "file_path": "aodvKmeans/test/loopback.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2010 IITP RAS\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * Authors: Pavel Boyko <boyko@iitp.ru>\n */\n\n#include \"ns3/test.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/socket-factory.h\"\n#include \"ns3/udp-socket-factory.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/double.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/string.h\"\n#include \"ns3/boolean.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/abort.h\"\n#include \"ns3/udp-echo-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/pcap-file.h\"\n#include \"ns3/aodvKmeans-helper.h\"\n#include \"ns3/v4ping.h\"\n#include \"ns3/config.h\"\n#include \"ns3/constant-position-mobility-model.h\"\n#include \"ns3/names.h\"\n#include <sstream>\n\nnamespace ns3 {\nnamespace aodvKmeans {\n\n/**\n * \\ingroup aodvKmeans\n *\n * \\brief aodvKmeans loopback UDP echo test case\n */\nclass LoopbackTestCase : public TestCase\n{\n  uint32_t m_count; //!< number of packet received;\n  Ptr<Socket> m_txSocket; //!< transmit socket;\n  Ptr<Socket> m_echoSocket; //!< echo socket;\n  Ptr<Socket> m_rxSocket; //!< receive socket;\n  uint16_t m_echoSendPort; //!< echo send port;\n  uint16_t m_echoReplyPort; //!< echo reply port;\n\n  /**\n   * Send data function\n   * \\param socket The socket to send data\n   */\n  void SendData (Ptr<Socket> socket);\n  /**\n   * Receive packet function\n   * \\param socket The socket to receive data\n   */\n  void ReceivePkt (Ptr<Socket> socket);\n  /**\n   * Echo data function\n   * \\param socket The socket to echo data\n   */\n  void EchoData (Ptr<Socket> socket);\n\npublic:\n  LoopbackTestCase ();\n  void DoRun ();\n};\n\nLoopbackTestCase::LoopbackTestCase ()\n  : TestCase (\"UDP Echo 127.0.0.1 test\"),\n    m_count (0)\n{\n  m_echoSendPort = 1233;\n  m_echoReplyPort = 1234;\n}\n\nvoid LoopbackTestCase::ReceivePkt (Ptr<Socket> socket)\n{\n  Ptr<Packet> receivedPacket = socket->Recv (std::numeric_limits<uint32_t>::max (), 0);\n\n  m_count++;\n}\n\nvoid\nLoopbackTestCase::EchoData (Ptr<Socket> socket)\n{\n  Address from;\n  Ptr<Packet> receivedPacket = socket->RecvFrom (std::numeric_limits<uint32_t>::max (), 0, from);\n\n  Ipv4Address src = InetSocketAddress::ConvertFrom (from).GetIpv4 ();\n  Address to = InetSocketAddress (src, m_echoReplyPort);\n\n  receivedPacket->RemoveAllPacketTags ();\n  receivedPacket->RemoveAllByteTags ();\n\n  socket->SendTo (receivedPacket, 0, to);\n}\n\nvoid\nLoopbackTestCase::SendData (Ptr<Socket> socket)\n{\n  Address realTo = InetSocketAddress (Ipv4Address::GetLoopback (), m_echoSendPort);\n  socket->SendTo (Create<Packet> (123), 0, realTo);\n\n  Simulator::ScheduleWithContext (socket->GetNode ()->GetId (), Seconds (1.0),\n                                  &LoopbackTestCase::SendData, this, socket);\n}\n\nvoid\nLoopbackTestCase::DoRun ()\n{\n  NodeContainer nodes;\n  nodes.Create (1);\n  Ptr<MobilityModel> m = CreateObject<ConstantPositionMobilityModel> ();\n  m->SetPosition (Vector (0, 0, 0));\n  nodes.Get (0)->AggregateObject (m);\n  // Setup WiFi\n  WifiMacHelper wifiMac;\n  wifiMac.SetType (\"ns3::AdhocWifiMac\");\n  YansWifiPhyHelper wifiPhy;\n  YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default ();\n  wifiPhy.SetChannel (wifiChannel.Create ());\n  WifiHelper wifi;\n  wifi.SetRemoteStationManager (\"ns3::ConstantRateWifiManager\", \"DataMode\", StringValue (\"OfdmRate6Mbps\"), \"RtsCtsThreshold\", StringValue (\"2200\"));\n  NetDeviceContainer devices = wifi.Install (wifiPhy, wifiMac, nodes);\n\n  // Setup TCP/IP & aodvKmeans\n  aodvKmeansHelper aodvKmeans; // Use default parameters here\n  InternetStackHelper internetStack;\n  internetStack.SetRoutingHelper (aodvKmeans);\n  internetStack.Install (nodes);\n  Ipv4AddressHelper address;\n  address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  // Setup echos\n  Ptr<SocketFactory> socketFactory = nodes.Get (0)->GetObject<UdpSocketFactory> ();\n  m_rxSocket = socketFactory->CreateSocket ();\n  m_rxSocket->Bind (InetSocketAddress (Ipv4Address::GetLoopback (), m_echoReplyPort));\n  m_rxSocket->SetRecvCallback (MakeCallback (&LoopbackTestCase::ReceivePkt, this));\n\n  m_echoSocket = socketFactory->CreateSocket ();\n  m_echoSocket->Bind (InetSocketAddress (Ipv4Address::GetLoopback (), m_echoSendPort));\n  m_echoSocket->SetRecvCallback (MakeCallback (&LoopbackTestCase::EchoData, this));\n\n  m_txSocket = socketFactory->CreateSocket ();\n\n  Simulator::ScheduleWithContext (m_txSocket->GetNode ()->GetId (), Seconds (1.0),\n                                  &LoopbackTestCase::SendData, this, m_txSocket);\n\n  // Run\n  Simulator::Stop (Seconds (5));\n  Simulator::Run ();\n\n  m_txSocket->Close ();\n  m_echoSocket->Close ();\n  m_rxSocket->Close ();\n\n  Simulator::Destroy ();\n\n  // Check that 4 packets delivered\n  NS_TEST_ASSERT_MSG_EQ (m_count, 4, \"Exactly 4 echo replies must be delivered.\");\n}\n\n/**\n * \\ingroup aodvKmeans-test\n * \\ingroup tests\n *\n * \\brief aodvKmeans Loopback test suite\n */\nclass aodvKmeansLoopbackTestSuite : public TestSuite\n{\npublic:\n  aodvKmeansLoopbackTestSuite () : TestSuite (\"routing-aodvKmeans-loopback\", SYSTEM)\n  {\n    SetDataDir (NS_TEST_SOURCEDIR);\n    // UDP Echo loopback test case\n    AddTestCase (new LoopbackTestCase (), TestCase::QUICK);\n  }\n} g_aodvKmeansLoopbackTestSuite; ///< the test suite\n\n\n}  // namespace aodvKmeans\n}  // namespace ns3\n"
    },
    {
      "file_path": "scratch/aodvKmeansExample.cc",
      "code": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n/*\n * Copyright (c) 2009 IITP RAS\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation;\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n * This is an example script for AODV manet routing protocol. \n *\n * Authors: Pavel Boyko <boyko@iitp.ru>\n */\n\n#include<iostream>\n#include<fstream>\n#include \"ns3/core-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/olsr-module.h\"\n#include \"ns3/dsdv-module.h\"\n#include \"ns3/aodvKmeans-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AODV-Kmeans-Example\");\n\nclass AODVExample\n{\n\npublic:\n    AODVExample();\n    // run this experiment\n    void Run();\n    // configure script parameters\n    void CommandSetUp(int argc, char * argv[]);\n    // print arguments\n    void PrintArguments();\n    // print node positions\n    void PrintPositions();\n\nprivate:\n\n// parameters\n\n    // number of nodes in the network\n    int m_nodes;\n    // node movement speed in m/s\n    int m_speed;\n    // node pause time in s\n    int m_pause;\n    // total simulation time\n    double m_totalTime;\n    // total bytes transmitted\n    uint32_t m_totalBytes;\n    // total packets received \n    uint32_t m_totalPackets;\n    // number of flows\n    int m_nflows;\n    // total transmission power\n    double m_txp;\n    // trace mobility if true\n    bool m_traceMobility;\n    // print routies if true\n    bool m_printRoutes;\n    // move clients away after 1/2 of simulation\n    bool m_moveClients;\n    \n    // total sent packets\n    int m_packetsSent;\n    // total received packets\n    int m_packetsReceived;\n    // total dropped packets \n    int m_packetsDropped;\n\n\n    // nodes used in this example\n    NodeContainer nodes;\n    // netdevices used in this example\n    NetDeviceContainer devices;\n    // interfaces used in this example\n    Ipv4InterfaceContainer interfaces;\n\n    // client nodes\n    std::vector<int>m_clients;\n    // server nodes\n    std::vector<int>m_servers;\n\n    // prefix for filenames\n    std::string m_prefix;\n    // int packets per second\n    int m_packets_per_second;\n    // intervals\n    double m_interval;\n    // protocol 1: aodv with kmeans, 2: aodv\n    int m_protocol;\n\n\n    \n   \n\n// functions\n    // create the nodes\n    void CreateNodes();\n    // create the devices\n    void CreateDevices();\n    // create network\n    void CreateInternetStacks();\n    // create application\n    void InstallApplications();\n    \n    \n    // callback function for packet send\n    void SendPkt (Ptr< const Packet > packet, Ptr< Ipv4 > ipv4, uint32_t interface);\n    // callback function for packet send\n    void ReceivePkt (Ptr< const Packet > packet, Ptr< Ipv4 > ipv4, uint32_t interface);\n\n\n    // check if the address is a servr\n    bool MatchServerClient(Ipv4Address address, Ipv4Address address2);\n\n    void ReceivePacket (Ptr<Socket> socket);\n    \n\n};\n\n\nAODVExample::AODVExample():\n    m_nodes(15),\n    m_speed(20),\n    m_pause(0),\n    m_totalTime(10),\n    m_totalBytes(0),\n    m_totalPackets(0),\n    m_nflows(6),\n    m_txp(7.5),\n    m_traceMobility(false),\n    m_printRoutes(false),\n    m_moveClients(false),\n    m_packetsSent(0),\n    m_packetsReceived(0),\n    m_packetsDropped(0),\n    m_prefix(\"project-baseline\"),\n    m_packets_per_second(1),\n    m_protocol(1)\n    \n{\n   \n}\nvoid\nAODVExample::CommandSetUp(int argc, char *argv[])\n{\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nodes\", \"Total number of nodes in the network\", m_nodes);\n    cmd.AddValue(\"speed\", \"Speed of nodes moving\", m_speed);\n    cmd.AddValue(\"pause\", \"Pause time for nodes movement\", m_pause);\n    cmd.AddValue(\"time\", \"Total time the simulation will run\", m_totalTime);\n    cmd.AddValue(\"flows\", \"Number of flows\", m_nflows);\n    cmd.AddValue(\"txp\", \"Transmission power\", m_txp);\n    cmd.AddValue(\"traceMobility\", \"Enable mobility tracing\", m_traceMobility);\n    cmd.AddValue(\"printRoute\", \"Enable printing routes\", m_printRoutes);\n    cmd.AddValue(\"moveclient\", \"Move clients away after some time\", m_moveClients);\n    cmd.AddValue(\"prefix\", \"Prefix of all generated file names\\n\", m_prefix);\n    cmd.AddValue(\"packetsPerSecond\", \"Packets Sent per second\", m_packets_per_second);\n    cmd.AddValue(\"protocol\", \"Protocol to use 1: AODV With KMeans 2: Only AODV\", m_protocol);\n    \n    cmd.Parse (argc, argv);\n    return;\n}\n\nvoid\nAODVExample::PrintArguments()\n{\n    std::cout << \"Simulation arguments:\\n\";\n    std::cout << \"nodes: \" << m_nodes << \"\\n\";\n    std::cout << \"flows: \" << m_nflows << \"\\n\";\n    std::cout << \"speed: \" << m_speed << \"\\n\";\n    std::cout << \"time: \" << m_totalTime << \"\\n\";\n    std::cout << \"pps: \" << m_packets_per_second << \"\\n\";\n    std::cout << \"--------------------------\\n\";\n}\n\nvoid \nAODVExample::PrintPositions()\n{\n    std::cout << \"Time: \" << Simulator::Now().GetSeconds() << \"\\n\";\n    Simulator::Schedule(Seconds(1.0), &AODVExample::PrintPositions, this);\n\n}\n\nvoid \nAODVExample::Run()\n{\n\n    PrintArguments();\n\n    \n    Packet::EnablePrinting();\n\n    \n    //Set Non-unicastMode rate to unicast mode\n    Config::SetDefault (\"ns3::WifiRemoteStationManager::NonUnicastMode\",StringValue (\"DsssRate11Mbps\"));\n\n    std::cout << \"Setting networks...\\n\";\n    CreateNodes();\n    CreateDevices();\n    CreateInternetStacks();\n    InstallApplications();\n\n    \n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll ();\n\n    NS_LOG_INFO(\"Running simulations...\");\n    \n    Simulator::Stop(Seconds(m_totalTime));\n\n    std::ofstream positionPrint(\"project-baseline-node-positions.txt\");\n    positionPrint.close();\n    Simulator::Schedule(Seconds(1.0), &AODVExample::PrintPositions, this);\n\n    \n    \n    // setup animation\n    // AnimationInterface anim (m_prefix + \"-animation.xml\");\n    // anim.SetMaxPktsPerTraceFile(1000000);\n    \n    \n\n    Simulator::Run();\n\n    // this must be added after simulator::run()  \n    \n    int j=0;\n    float AvgThroughput = 0;\n    Time Jitter;\n    Time Delay;\n\n    // variables for output measurement\n    uint32_t SentPackets = 0;\n    uint32_t ReceivedPackets = 0;\n    uint32_t DroppedPackets = 0;\n\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowmon.GetClassifier ());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats ();\n\n    \n    std::ofstream flowOut(\"TaskB/\"+ m_prefix+\"-flowstats\");\n    bool printConsole = true;\n\n    for (auto iter = stats.begin (); iter != stats.end (); ++iter) {\n            SentPackets = SentPackets +(iter->second.txPackets);\n            ReceivedPackets = ReceivedPackets + (iter->second.rxPackets);\n            DroppedPackets += iter->second.txPackets - iter->second.rxPackets;\n            AvgThroughput = AvgThroughput + iter->second.rxBytes;\n            \n            Delay = Delay + (iter->second.delaySum);\n            \n            \n            j = j + 1;\n\n        \n\n    }\n\n    //AvgThroughput = AvgThroughput/j;\n    AvgThroughput = AvgThroughput * 8.0 / ((m_totalTime-1.0) * 1024.0);\n    Delay = Delay / ReceivedPackets;\n    \n    flowOut << \"--------Total Results of the simulation----------\"<<std::endl << \"\\n\";\n    flowOut << \"Nodes: \" << m_nodes << \"\\n\";\n    flowOut << \"Flows: \" << m_nflows << \"\\n\";\n    flowOut << \"pps: \" << m_packets_per_second << \"\\n\";\n    flowOut << \"speed: \" << m_speed << \"\\n\";\n    flowOut << \"Total Received Packets = \" << ReceivedPackets << \"\\n\";\n    flowOut << \"Total sent packets  = \" << SentPackets << \"\\n\";\n    flowOut << \"Total Lost Packets = \" << DroppedPackets << \"\\n\";\n    flowOut << \"Packet Loss ratio = \" << ((DroppedPackets*100.00)/SentPackets)<< \" %\" << \"\\n\";\n    flowOut << \"Packet delivery ratio = \" << ((ReceivedPackets*100.00)/SentPackets)<< \" %\" << \"\\n\";\n    flowOut << \"Average Throughput = \" << AvgThroughput<< \" Kbps\" << \"\\n\";\n    flowOut << \"End to End Delay = \" << Delay << \"\\n\";\n    flowOut << \"Total Flow id \" << j << \"\\n\";\n\n    if(printConsole)\n    {\n        std::cout << \"\\n--------Total Results of the simulation from flow monitor----------\\n\";\n        std::cout << \"Total Flow id \" << j << \"\\n\";\n        std::cout << \"Total sent packets  = \" << SentPackets << \"\\n\";\n        std::cout << \"Total Received Packets = \" << ReceivedPackets << \"\\n\";\n        std::cout << \"End to End Delay = \" << Delay << \"\\n\";\n        std::cout << \"Packet delivery ratio = \" << ReceivedPackets << \" / \" << SentPackets << \" = \" << ((ReceivedPackets*100.00)/SentPackets)<< \"%\" << \"\\n\";\n        std::cout << \"Packet Loss ratio = \" << ((DroppedPackets*100.00)/SentPackets)<< \" %\" << \"\\n\";\n        std::cout << \"Average Throughput = \" << AvgThroughput<< \"Kbps\" << \"\\n\\n\";\n    }\n\n\n    flowOut.close();\n    Simulator::Destroy();\n\n    \n    \n\n}\n\nvoid \nAODVExample::CreateNodes()\n{\n\n    nodes.Create(m_nodes);\n    \n    // Name the nodes\n    for(int j=0;j<m_nodes;j++){\n        std::ostringstream os;\n        os << \"node-\" << j;\n        Names::Add(os.str(), nodes.Get(j));\n    }\n\n    // create mobility model\n    MobilityHelper mobilityHelper;\n    int64_t streamIndex = 0; // used to get consistent mobility across scenarios\n\n    ObjectFactory pos;\n    pos.SetTypeId(\"ns3::RandomRectanglePositionAllocator\");\n    pos.Set(\"X\", StringValue(\"ns3::UniformRandomVariable[Min=0|Max=300]\"));\n    pos.Set(\"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0|Max=300]\"));\n\n    Ptr<PositionAllocator> positionAlloc = pos.Create()->GetObject<PositionAllocator>();\n    streamIndex += positionAlloc->AssignStreams(streamIndex);\n\n    std::stringstream ssSpeed;\n    ssSpeed << \"ns3::UniformRandomVariable[Min=0.0|Max=\" << m_speed << \"]\";\n    std::stringstream ssPause;\n    ssPause << \"ns3::ConstantRandomVariable[Constant=\" << m_pause << \"]\";\n\n    mobilityHelper.SetMobilityModel(\n        \"ns3::RandomWaypointMobilityModel\",\n        \"Speed\", StringValue(ssSpeed.str()),\n        \"Pause\", StringValue(ssPause.str()),\n        \"PositionAllocator\", PointerValue(positionAlloc)\n    );\n    mobilityHelper.SetPositionAllocator(positionAlloc);\n    mobilityHelper.Install(nodes);\n    streamIndex += mobilityHelper.AssignStreams(nodes, streamIndex);\n\n    \n    NS_UNUSED(streamIndex);\n\n    \n    std::cout << \"nodes created\\n\";\n\n    \n}\nvoid \nAODVExample::CreateDevices()\n{\n\n    // setting up wifi phy and channel using helpers\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\");\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Add a mac and disable rate control\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\n        \"ns3::ConstantRateWifiManager\",\n        \"DataMode\", StringValue(\"DsssRate11Mbps\"),\n        \"ControlMode\", StringValue(\"DsssRate11Mbps\")\n    );\n\n    wifiPhy.Set(\"TxPowerStart\", DoubleValue(m_txp));\n    wifiPhy.Set(\"TxPowerEnd\", DoubleValue(m_txp));\n\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n            \n\n    AsciiTraceHelper ascii;\n    wifiPhy.EnableAsciiAll(ascii.CreateFileStream(m_prefix + \"-phy.tr\"));\n  \n    std::cout << \"devices created\\n\"; \n\n\n\n}\nvoid \nAODVExample::CreateInternetStacks()\n{\n\n    InternetStackHelper internet;\n    AodvHelper aodv;\n    aodvKmeansHelper aodvKmeans;\n    if(m_protocol == 1)\n    {\n        internet.SetRoutingHelper(aodvKmeans);\n    }\n    else \n    {\n        internet.SetRoutingHelper(aodv);\n    }\n    //\n    \n    internet.Install(nodes);\n    NS_LOG_INFO (\"assigning ip address\");\n\n    Ipv4AddressHelper addressHelper;\n    \n    addressHelper.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n\n    interfaces = addressHelper.Assign(devices);\n\n\n    AsciiTraceHelper ascii;\n    internet.EnableAsciiIpv4All(ascii.CreateFileStream(m_prefix + \"-ipv4.tr\"));\n    \n\n\n}\n\nvoid \nAODVExample::InstallApplications()\n{\n    UdpEchoServerHelper echoServer(9);\n\n\n    \n    m_clients.reserve(m_nflows / 2);\n    m_servers.reserve(m_nflows / 2);\n    std::ofstream serverClient(\"TaskB/\"+ m_prefix + \"-server-client.txt\");\n    \n    for(int i=0;i<m_nflows/2;i++)\n    {\n        m_clients[i] = m_nodes-i*2-1;\n        m_servers[i] = i*2;\n        serverClient << interfaces.GetAddress(m_servers[i]) << \"\\n\";\n        serverClient << interfaces.GetAddress(m_clients[i]) << \"\\n\";\n        \n    }\n\n    serverClient.close();\n\n    m_interval = 1.0 / m_packets_per_second;\n    \n    std::cout << \"Setting up flows \" << std::endl;\n    for(int i=0; i<m_nflows/2; i++){\n\n        ApplicationContainer serverApps = echoServer.Install(nodes.Get(m_servers[i]));\n        serverApps.Start(Seconds(0.1));\n        serverApps.Stop(Seconds(m_totalTime));\n\n        UdpEchoClientHelper echoClient(interfaces.GetAddress(m_servers[i]), 9);\n        echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10000));\n        echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(m_interval)));\n        echoClient.SetAttribute(\"PacketSize\", UintegerValue(64));\n\n\n\n        ApplicationContainer clientApps = echoClient.Install(nodes.Get(m_clients[i]));\n        clientApps.Start(Seconds(1.0));\n        clientApps.Stop(Seconds(m_totalTime));\n  \n        std::cout << interfaces.GetAddress(m_clients[i]) << \" ---> \" << interfaces.GetAddress(m_servers[i]) << std::endl;\n    \n\n    }\n\n\n}\n\n\n\nint\nmain (int argc, char *argv[])\n{\n    AODVExample aodv;\n    aodv.CommandSetUp(argc, argv);\n    aodv.Run();\n    return 0;\n}\n"
    }
  ]
}